[
	{
		"original_code": "// Md5Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an MD5 Hash (RFC 1321) from a given input <tt>source</tt> with an optional <tt>salt</tt> and\n * hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Md5Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"MD5\";\n\n    public Md5Hash() {\n    }\n\n    public Md5Hash(Object source) {\n        super(source);\n    }\n\n    public Md5Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Md5Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Md5Hash fromHexString(String hex) {\n        Md5Hash hash = new Md5Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Md5Hash fromBase64String(String base64) {\n        Md5Hash hash = new Md5Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Md5HashTest0.java",
		"test_prompt": "// Md5HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Md5Hash}.\n* It contains ten unit test cases for the {@link Md5Hash#fromHexString(String)} method.\n*/\nclass Md5HashTest0 {"
	},
	{
		"original_code": "// Md5Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an MD5 Hash (RFC 1321) from a given input <tt>source</tt> with an optional <tt>salt</tt> and\n * hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Md5Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"MD5\";\n\n    public Md5Hash() {\n    }\n\n    public Md5Hash(Object source) {\n        super(source);\n    }\n\n    public Md5Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Md5Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Md5Hash fromHexString(String hex) {\n        Md5Hash hash = new Md5Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Md5Hash fromBase64String(String base64) {\n        Md5Hash hash = new Md5Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Md5HashTest1.java",
		"test_prompt": "// Md5HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Md5Hash}.\n* It contains ten unit test cases for the {@link Md5Hash#fromBase64String(String)} method.\n*/\nclass Md5HashTest1 {"
	},
	{
		"original_code": "// Sha256Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-256 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha256Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-256\";\n\n    public Sha256Hash() {\n    }\n\n    public Sha256Hash(Object source) {\n        super(source);\n    }\n\n    public Sha256Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha256Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha256Hash fromHexString(String hex) {\n        Sha256Hash hash = new Sha256Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha256Hash fromBase64String(String base64) {\n        Sha256Hash hash = new Sha256Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha256HashTest0.java",
		"test_prompt": "// Sha256HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha256Hash}.\n* It contains ten unit test cases for the {@link Sha256Hash#fromHexString(String)} method.\n*/\nclass Sha256HashTest0 {"
	},
	{
		"original_code": "// Sha256Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-256 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha256Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-256\";\n\n    public Sha256Hash() {\n    }\n\n    public Sha256Hash(Object source) {\n        super(source);\n    }\n\n    public Sha256Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha256Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha256Hash fromHexString(String hex) {\n        Sha256Hash hash = new Sha256Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha256Hash fromBase64String(String base64) {\n        Sha256Hash hash = new Sha256Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha256HashTest1.java",
		"test_prompt": "// Sha256HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha256Hash}.\n* It contains ten unit test cases for the {@link Sha256Hash#fromBase64String(String)} method.\n*/\nclass Sha256HashTest1 {"
	},
	{
		"original_code": "// Sha384Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-384 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha384Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-384\";\n\n    public Sha384Hash() {\n    }\n\n    public Sha384Hash(Object source) {\n        super(source);\n    }\n\n    public Sha384Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha384Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha384Hash fromHexString(String hex) {\n        Sha384Hash hash = new Sha384Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha384Hash fromBase64String(String base64) {\n        Sha384Hash hash = new Sha384Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha384HashTest0.java",
		"test_prompt": "// Sha384HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha384Hash}.\n* It contains ten unit test cases for the {@link Sha384Hash#fromHexString(String)} method.\n*/\nclass Sha384HashTest0 {"
	},
	{
		"original_code": "// Sha384Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-384 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha384Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-384\";\n\n    public Sha384Hash() {\n    }\n\n    public Sha384Hash(Object source) {\n        super(source);\n    }\n\n    public Sha384Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha384Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha384Hash fromHexString(String hex) {\n        Sha384Hash hash = new Sha384Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha384Hash fromBase64String(String base64) {\n        Sha384Hash hash = new Sha384Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha384HashTest1.java",
		"test_prompt": "// Sha384HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha384Hash}.\n* It contains ten unit test cases for the {@link Sha384Hash#fromBase64String(String)} method.\n*/\nclass Sha384HashTest1 {"
	},
	{
		"original_code": "// Sha512Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-512 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha512Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-512\";\n\n    public Sha512Hash() {\n    }\n\n    public Sha512Hash(Object source) {\n        super(source);\n    }\n\n    public Sha512Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha512Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha512Hash fromHexString(String hex) {\n        Sha512Hash hash = new Sha512Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha512Hash fromBase64String(String base64) {\n        Sha512Hash hash = new Sha512Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha512HashTest0.java",
		"test_prompt": "// Sha512HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha512Hash}.\n* It contains ten unit test cases for the {@link Sha512Hash#fromHexString(String)} method.\n*/\nclass Sha512HashTest0 {"
	},
	{
		"original_code": "// Sha512Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-512 Hash from a given input <tt>source</tt> with an optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * <p><b>JDK Version Note</b> - Attempting to instantiate this class on JREs prior to version 1.4.0 will throw\n * an {@link IllegalStateException IllegalStateException}\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha512Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-512\";\n\n    public Sha512Hash() {\n    }\n\n    public Sha512Hash(Object source) {\n        super(source);\n    }\n\n    public Sha512Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha512Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha512Hash fromHexString(String hex) {\n        Sha512Hash hash = new Sha512Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha512Hash fromBase64String(String base64) {\n        Sha512Hash hash = new Sha512Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha512HashTest1.java",
		"test_prompt": "// Sha512HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha512Hash}.\n* It contains ten unit test cases for the {@link Sha512Hash#fromBase64String(String)} method.\n*/\nclass Sha512HashTest1 {"
	},
	{
		"original_code": "// Md2Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an MD2 Hash (RFC 1319) from a given input <tt>source</tt> with an optional <tt>salt</tt> and\n * hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Md2Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"MD2\";\n\n    public Md2Hash() {\n    }\n\n    public Md2Hash(Object source) {\n        super(source);\n    }\n\n    public Md2Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Md2Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Md2Hash fromHexString(String hex) {\n        Md2Hash hash = new Md2Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Md2Hash fromBase64String(String base64) {\n        Md2Hash hash = new Md2Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Md2HashTest0.java",
		"test_prompt": "// Md2HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Md2Hash}.\n* It contains ten unit test cases for the {@link Md2Hash#fromHexString(String)} method.\n*/\nclass Md2HashTest0 {"
	},
	{
		"original_code": "// Md2Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an MD2 Hash (RFC 1319) from a given input <tt>source</tt> with an optional <tt>salt</tt> and\n * hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Md2Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"MD2\";\n\n    public Md2Hash() {\n    }\n\n    public Md2Hash(Object source) {\n        super(source);\n    }\n\n    public Md2Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Md2Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Md2Hash fromHexString(String hex) {\n        Md2Hash hash = new Md2Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Md2Hash fromBase64String(String base64) {\n        Md2Hash hash = new Md2Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Md2HashTest1.java",
		"test_prompt": "// Md2HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Md2Hash}.\n* It contains ten unit test cases for the {@link Md2Hash#fromBase64String(String)} method.\n*/\nclass Md2HashTest1 {"
	},
	{
		"original_code": "// AbstractHash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * Provides a base for all JSecurity Hash algorithms with support for salts and multiple hash iterations.\n *\n * <p>Read <a href=\"http://www.owasp.org/index.php/Hashing_Java\" target=\"blank\">http://www.owasp.org/index.php/Hashing_Java</a> for a\n * good article on the benefits of hashing, including what a 'salt' is as well as why it and multiple hash iterations\n * can be useful.\n *\n * <p>This class and its subclasses support hashing with additional capabilities of salting and multiple iterations via\n * overloaded constructors</p>.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    /**\n     * The hashed data\n     */\n    private byte[] bytes = null;\n\n    /**\n     * Cached value of the {@link #toHex() toHex()} call so multiple calls won't incur repeated overhead.\n     */\n    private String hexEncoded = null;\n\n    /**\n     * Cached value of the {@link #toBase64() toBase64()} call so multiple calls won't incur repeated overhead.\n     */\n    private String base64Encoded = null;\n\n    /**\n     * Creates an new instance without any of its properties set (no hashing is performed).\n     *\n     * <p>Because all constructors in this class\n     * (except this one) hash the <tt>source</tt> constructor argument, this default, no-arg constructor is useful in\n     * scenarios whenyou have a byte array that you know is already hashed and just want to set the bytes in their\n     * raw form directly on an instance.  After instantiating the instance with this default, no-arg constructor, you\n     * can then immediately call {@link #setBytes setBytes} to have a fully-initiallized instance.\n     */\n    public AbstractHash() {\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> with no <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, null, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the object to be hashed.\n     * @throws CodecException if the specified <tt>source</tt> cannot be converted into a byte array (byte[]).\n     */\n    public AbstractHash(Object source) throws CodecException {\n        this(source, null, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, salt, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the source object to be hashed.\n     * @param salt   the salt to use for the hash\n     * @throws CodecException if either constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt) throws CodecException {\n        this(source, salt, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> a total of\n     * <tt>hashIterations</tt> times.\n     *\n     * <p>By default, this class only supports Object method arguments of\n     * type <tt>byte[]</tt>, <tt>char[]</tt> and <tt>String</tt>.  If either argument is anything other than these\n     * types a {@link org.jsecurity.codec.CodecException CodecException} will be thrown.\n     *\n     * <p>If you want to be able to hash other object types, or use other salt types, you need to override the\n     * {@link #toBytes(Object) toBytes(Object)} method to support those specific types.  Your other option is to\n     * convert your arguments to one of the default three supported types first before passing them in to this\n     * constructor</tt>.\n     *\n     * @param source         the source object to be hashed.\n     * @param salt           the salt to use for the hash\n     * @param hashIterations the number of times the <tt>source</tt> argument hashed for attack resiliency.\n     * @throws CodecException if either Object constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt, int hashIterations) throws CodecException {\n        byte[] sourceBytes = toBytes(source);\n        byte[] saltBytes = null;\n        if (salt != null) {\n            saltBytes = toBytes(salt);\n        }\n        byte[] hashedBytes = hash(sourceBytes, saltBytes, hashIterations);\n        setBytes(hashedBytes);\n    }\n\n    /**\n     * Implemented by subclasses, this specifies the name of the {@link MessageDigest MessageDigest} algorithm\n     * to use when performing the hash.\n     *\n     * @return the {@link MessageDigest MessageDigest} algorithm to use when performing the hash.\n     */\n    protected abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    /**\n     * Sets the raw bytes stored by this hash instance.\n     *\n     * <p>The bytes are kept in raw form - they will not be hashed/changed.  This is primarily a utility method for\n     * constructing a Hash instance when the hashed value is already known.\n     *\n     * @param alreadyHashedBytes the raw already-hashed bytes to store in this instance.\n     */\n    public void setBytes(byte[] alreadyHashedBytes) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    /**\n     * Returns the JDK MessageDigest instance to use for executing the hash.\n     *\n     * @param algorithmName the algorithm to use for the hash, provided by subclasses.\n     * @return the MessageDigest object for the specfied <tt>algorithm</tt>.\n     */\n    protected MessageDigest getDigest(String algorithmName) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Hashes the specified byte array without a salt for a single iteration.\n     *\n     * @param bytes the bytes to hash.\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes) {\n        return hash(bytes, null, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for a single iteration.\n     *\n     * @param bytes the bytes to hash\n     * @param salt  the salt to use for the initial hash\n     * @return the hashed bytes\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt) {\n        return hash(bytes, salt, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for the specified number of iterations.\n     *\n     * @param bytes          the bytes to hash\n     * @param salt           the salt to use for the initial hash\n     * @param hashIterations the number of times the the <tt>bytes</tt> will be hashed (for attack resiliency).\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) {\n        MessageDigest md = getDigest(getAlgorithmName());\n        if (salt != null) {\n            md.reset();\n            md.update(salt);\n        }\n        byte[] hashed = md.digest(bytes);\n        //already hashed once above\n        int iterations = hashIterations - 1;\n        //iterate remaining number:\n        for (int i = 0; i < iterations; i++) {\n            md.reset();\n            hashed = md.digest(hashed);\n        }\n        return hashed;\n    }\n\n    /**\n     * Returns a hex-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting hex string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a hex-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toHex() {\n        if (this.hexEncoded == null) {\n            this.hexEncoded = Hex.encodeToString(getBytes());\n        }\n        return this.hexEncoded;\n    }\n\n    /**\n     * Returns a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting Base64 string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeToString(getBytes());\n        }\n        return this.base64Encoded;\n    }\n\n    /**\n     * Simple implementation that merely returns {@link #toHex() toHex()}.\n     *\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    /**\n     * Returns <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     * this Hash's byte array, <tt>false</tt> otherwise.\n     *\n     * @param o the object (Hash) to check for equality.\n     * @return <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     *         this Hash's byte array, <tt>false</tt> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o instanceof Hash) {\n            Hash other = (Hash) o;\n            return Arrays.equals(getBytes(), other.getBytes());\n        }\n        return false;\n    }\n\n    /**\n     * Simply returns toHex().hashCode();\n     *\n     * @return toHex().hashCode()\n     */\n    public int hashCode() {\n        return toHex().hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/AbstractHashTest0.java",
		"test_prompt": "// AbstractHashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractHash}.\n* It contains ten unit test cases for the {@link AbstractHash#toHex()} method.\n*/\nclass AbstractHashTest0 {"
	},
	{
		"original_code": "// AbstractHash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * Provides a base for all JSecurity Hash algorithms with support for salts and multiple hash iterations.\n *\n * <p>Read <a href=\"http://www.owasp.org/index.php/Hashing_Java\" target=\"blank\">http://www.owasp.org/index.php/Hashing_Java</a> for a\n * good article on the benefits of hashing, including what a 'salt' is as well as why it and multiple hash iterations\n * can be useful.\n *\n * <p>This class and its subclasses support hashing with additional capabilities of salting and multiple iterations via\n * overloaded constructors</p>.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    /**\n     * The hashed data\n     */\n    private byte[] bytes = null;\n\n    /**\n     * Cached value of the {@link #toHex() toHex()} call so multiple calls won't incur repeated overhead.\n     */\n    private String hexEncoded = null;\n\n    /**\n     * Cached value of the {@link #toBase64() toBase64()} call so multiple calls won't incur repeated overhead.\n     */\n    private String base64Encoded = null;\n\n    /**\n     * Creates an new instance without any of its properties set (no hashing is performed).\n     *\n     * <p>Because all constructors in this class\n     * (except this one) hash the <tt>source</tt> constructor argument, this default, no-arg constructor is useful in\n     * scenarios whenyou have a byte array that you know is already hashed and just want to set the bytes in their\n     * raw form directly on an instance.  After instantiating the instance with this default, no-arg constructor, you\n     * can then immediately call {@link #setBytes setBytes} to have a fully-initiallized instance.\n     */\n    public AbstractHash() {\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> with no <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, null, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the object to be hashed.\n     * @throws CodecException if the specified <tt>source</tt> cannot be converted into a byte array (byte[]).\n     */\n    public AbstractHash(Object source) throws CodecException {\n        this(source, null, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, salt, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the source object to be hashed.\n     * @param salt   the salt to use for the hash\n     * @throws CodecException if either constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt) throws CodecException {\n        this(source, salt, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> a total of\n     * <tt>hashIterations</tt> times.\n     *\n     * <p>By default, this class only supports Object method arguments of\n     * type <tt>byte[]</tt>, <tt>char[]</tt> and <tt>String</tt>.  If either argument is anything other than these\n     * types a {@link org.jsecurity.codec.CodecException CodecException} will be thrown.\n     *\n     * <p>If you want to be able to hash other object types, or use other salt types, you need to override the\n     * {@link #toBytes(Object) toBytes(Object)} method to support those specific types.  Your other option is to\n     * convert your arguments to one of the default three supported types first before passing them in to this\n     * constructor</tt>.\n     *\n     * @param source         the source object to be hashed.\n     * @param salt           the salt to use for the hash\n     * @param hashIterations the number of times the <tt>source</tt> argument hashed for attack resiliency.\n     * @throws CodecException if either Object constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt, int hashIterations) throws CodecException {\n        byte[] sourceBytes = toBytes(source);\n        byte[] saltBytes = null;\n        if (salt != null) {\n            saltBytes = toBytes(salt);\n        }\n        byte[] hashedBytes = hash(sourceBytes, saltBytes, hashIterations);\n        setBytes(hashedBytes);\n    }\n\n    /**\n     * Implemented by subclasses, this specifies the name of the {@link MessageDigest MessageDigest} algorithm\n     * to use when performing the hash.\n     *\n     * @return the {@link MessageDigest MessageDigest} algorithm to use when performing the hash.\n     */\n    protected abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    /**\n     * Sets the raw bytes stored by this hash instance.\n     *\n     * <p>The bytes are kept in raw form - they will not be hashed/changed.  This is primarily a utility method for\n     * constructing a Hash instance when the hashed value is already known.\n     *\n     * @param alreadyHashedBytes the raw already-hashed bytes to store in this instance.\n     */\n    public void setBytes(byte[] alreadyHashedBytes) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    /**\n     * Returns the JDK MessageDigest instance to use for executing the hash.\n     *\n     * @param algorithmName the algorithm to use for the hash, provided by subclasses.\n     * @return the MessageDigest object for the specfied <tt>algorithm</tt>.\n     */\n    protected MessageDigest getDigest(String algorithmName) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Hashes the specified byte array without a salt for a single iteration.\n     *\n     * @param bytes the bytes to hash.\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes) {\n        return hash(bytes, null, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for a single iteration.\n     *\n     * @param bytes the bytes to hash\n     * @param salt  the salt to use for the initial hash\n     * @return the hashed bytes\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt) {\n        return hash(bytes, salt, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for the specified number of iterations.\n     *\n     * @param bytes          the bytes to hash\n     * @param salt           the salt to use for the initial hash\n     * @param hashIterations the number of times the the <tt>bytes</tt> will be hashed (for attack resiliency).\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) {\n        MessageDigest md = getDigest(getAlgorithmName());\n        if (salt != null) {\n            md.reset();\n            md.update(salt);\n        }\n        byte[] hashed = md.digest(bytes);\n        //already hashed once above\n        int iterations = hashIterations - 1;\n        //iterate remaining number:\n        for (int i = 0; i < iterations; i++) {\n            md.reset();\n            hashed = md.digest(hashed);\n        }\n        return hashed;\n    }\n\n    /**\n     * Returns a hex-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting hex string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a hex-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toHex() {\n        if (this.hexEncoded == null) {\n            this.hexEncoded = Hex.encodeToString(getBytes());\n        }\n        return this.hexEncoded;\n    }\n\n    /**\n     * Returns a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting Base64 string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeToString(getBytes());\n        }\n        return this.base64Encoded;\n    }\n\n    /**\n     * Simple implementation that merely returns {@link #toHex() toHex()}.\n     *\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    /**\n     * Returns <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     * this Hash's byte array, <tt>false</tt> otherwise.\n     *\n     * @param o the object (Hash) to check for equality.\n     * @return <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     *         this Hash's byte array, <tt>false</tt> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o instanceof Hash) {\n            Hash other = (Hash) o;\n            return Arrays.equals(getBytes(), other.getBytes());\n        }\n        return false;\n    }\n\n    /**\n     * Simply returns toHex().hashCode();\n     *\n     * @return toHex().hashCode()\n     */\n    public int hashCode() {\n        return toHex().hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/AbstractHashTest1.java",
		"test_prompt": "// AbstractHashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractHash}.\n* It contains ten unit test cases for the {@link AbstractHash#toBase64()} method.\n*/\nclass AbstractHashTest1 {"
	},
	{
		"original_code": "// AbstractHash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * Provides a base for all JSecurity Hash algorithms with support for salts and multiple hash iterations.\n *\n * <p>Read <a href=\"http://www.owasp.org/index.php/Hashing_Java\" target=\"blank\">http://www.owasp.org/index.php/Hashing_Java</a> for a\n * good article on the benefits of hashing, including what a 'salt' is as well as why it and multiple hash iterations\n * can be useful.\n *\n * <p>This class and its subclasses support hashing with additional capabilities of salting and multiple iterations via\n * overloaded constructors</p>.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    /**\n     * The hashed data\n     */\n    private byte[] bytes = null;\n\n    /**\n     * Cached value of the {@link #toHex() toHex()} call so multiple calls won't incur repeated overhead.\n     */\n    private String hexEncoded = null;\n\n    /**\n     * Cached value of the {@link #toBase64() toBase64()} call so multiple calls won't incur repeated overhead.\n     */\n    private String base64Encoded = null;\n\n    /**\n     * Creates an new instance without any of its properties set (no hashing is performed).\n     *\n     * <p>Because all constructors in this class\n     * (except this one) hash the <tt>source</tt> constructor argument, this default, no-arg constructor is useful in\n     * scenarios whenyou have a byte array that you know is already hashed and just want to set the bytes in their\n     * raw form directly on an instance.  After instantiating the instance with this default, no-arg constructor, you\n     * can then immediately call {@link #setBytes setBytes} to have a fully-initiallized instance.\n     */\n    public AbstractHash() {\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> with no <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, null, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the object to be hashed.\n     * @throws CodecException if the specified <tt>source</tt> cannot be converted into a byte array (byte[]).\n     */\n    public AbstractHash(Object source) throws CodecException {\n        this(source, null, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, salt, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the source object to be hashed.\n     * @param salt   the salt to use for the hash\n     * @throws CodecException if either constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt) throws CodecException {\n        this(source, salt, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> a total of\n     * <tt>hashIterations</tt> times.\n     *\n     * <p>By default, this class only supports Object method arguments of\n     * type <tt>byte[]</tt>, <tt>char[]</tt> and <tt>String</tt>.  If either argument is anything other than these\n     * types a {@link org.jsecurity.codec.CodecException CodecException} will be thrown.\n     *\n     * <p>If you want to be able to hash other object types, or use other salt types, you need to override the\n     * {@link #toBytes(Object) toBytes(Object)} method to support those specific types.  Your other option is to\n     * convert your arguments to one of the default three supported types first before passing them in to this\n     * constructor</tt>.\n     *\n     * @param source         the source object to be hashed.\n     * @param salt           the salt to use for the hash\n     * @param hashIterations the number of times the <tt>source</tt> argument hashed for attack resiliency.\n     * @throws CodecException if either Object constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt, int hashIterations) throws CodecException {\n        byte[] sourceBytes = toBytes(source);\n        byte[] saltBytes = null;\n        if (salt != null) {\n            saltBytes = toBytes(salt);\n        }\n        byte[] hashedBytes = hash(sourceBytes, saltBytes, hashIterations);\n        setBytes(hashedBytes);\n    }\n\n    /**\n     * Implemented by subclasses, this specifies the name of the {@link MessageDigest MessageDigest} algorithm\n     * to use when performing the hash.\n     *\n     * @return the {@link MessageDigest MessageDigest} algorithm to use when performing the hash.\n     */\n    protected abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    /**\n     * Sets the raw bytes stored by this hash instance.\n     *\n     * <p>The bytes are kept in raw form - they will not be hashed/changed.  This is primarily a utility method for\n     * constructing a Hash instance when the hashed value is already known.\n     *\n     * @param alreadyHashedBytes the raw already-hashed bytes to store in this instance.\n     */\n    public void setBytes(byte[] alreadyHashedBytes) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    /**\n     * Returns the JDK MessageDigest instance to use for executing the hash.\n     *\n     * @param algorithmName the algorithm to use for the hash, provided by subclasses.\n     * @return the MessageDigest object for the specfied <tt>algorithm</tt>.\n     */\n    protected MessageDigest getDigest(String algorithmName) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Hashes the specified byte array without a salt for a single iteration.\n     *\n     * @param bytes the bytes to hash.\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes) {\n        return hash(bytes, null, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for a single iteration.\n     *\n     * @param bytes the bytes to hash\n     * @param salt  the salt to use for the initial hash\n     * @return the hashed bytes\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt) {\n        return hash(bytes, salt, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for the specified number of iterations.\n     *\n     * @param bytes          the bytes to hash\n     * @param salt           the salt to use for the initial hash\n     * @param hashIterations the number of times the the <tt>bytes</tt> will be hashed (for attack resiliency).\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) {\n        MessageDigest md = getDigest(getAlgorithmName());\n        if (salt != null) {\n            md.reset();\n            md.update(salt);\n        }\n        byte[] hashed = md.digest(bytes);\n        //already hashed once above\n        int iterations = hashIterations - 1;\n        //iterate remaining number:\n        for (int i = 0; i < iterations; i++) {\n            md.reset();\n            hashed = md.digest(hashed);\n        }\n        return hashed;\n    }\n\n    /**\n     * Returns a hex-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting hex string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a hex-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toHex() {\n        if (this.hexEncoded == null) {\n            this.hexEncoded = Hex.encodeToString(getBytes());\n        }\n        return this.hexEncoded;\n    }\n\n    /**\n     * Returns a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting Base64 string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeToString(getBytes());\n        }\n        return this.base64Encoded;\n    }\n\n    /**\n     * Simple implementation that merely returns {@link #toHex() toHex()}.\n     *\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    /**\n     * Returns <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     * this Hash's byte array, <tt>false</tt> otherwise.\n     *\n     * @param o the object (Hash) to check for equality.\n     * @return <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     *         this Hash's byte array, <tt>false</tt> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o instanceof Hash) {\n            Hash other = (Hash) o;\n            return Arrays.equals(getBytes(), other.getBytes());\n        }\n        return false;\n    }\n\n    /**\n     * Simply returns toHex().hashCode();\n     *\n     * @return toHex().hashCode()\n     */\n    public int hashCode() {\n        return toHex().hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/AbstractHashTest2.java",
		"test_prompt": "// AbstractHashTest2.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractHash}.\n* It contains ten unit test cases for the {@link AbstractHash#equals(Object)} method.\n*/\nclass AbstractHashTest2 {"
	},
	{
		"original_code": "// AbstractHash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * Provides a base for all JSecurity Hash algorithms with support for salts and multiple hash iterations.\n *\n * <p>Read <a href=\"http://www.owasp.org/index.php/Hashing_Java\" target=\"blank\">http://www.owasp.org/index.php/Hashing_Java</a> for a\n * good article on the benefits of hashing, including what a 'salt' is as well as why it and multiple hash iterations\n * can be useful.\n *\n * <p>This class and its subclasses support hashing with additional capabilities of salting and multiple iterations via\n * overloaded constructors</p>.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractHash extends CodecSupport implements Hash {\n\n    /**\n     * The hashed data\n     */\n    private byte[] bytes = null;\n\n    /**\n     * Cached value of the {@link #toHex() toHex()} call so multiple calls won't incur repeated overhead.\n     */\n    private String hexEncoded = null;\n\n    /**\n     * Cached value of the {@link #toBase64() toBase64()} call so multiple calls won't incur repeated overhead.\n     */\n    private String base64Encoded = null;\n\n    /**\n     * Creates an new instance without any of its properties set (no hashing is performed).\n     *\n     * <p>Because all constructors in this class\n     * (except this one) hash the <tt>source</tt> constructor argument, this default, no-arg constructor is useful in\n     * scenarios whenyou have a byte array that you know is already hashed and just want to set the bytes in their\n     * raw form directly on an instance.  After instantiating the instance with this default, no-arg constructor, you\n     * can then immediately call {@link #setBytes setBytes} to have a fully-initiallized instance.\n     */\n    public AbstractHash() {\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> with no <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, null, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the object to be hashed.\n     * @throws CodecException if the specified <tt>source</tt> cannot be converted into a byte array (byte[]).\n     */\n    public AbstractHash(Object source) throws CodecException {\n        this(source, null, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> using a single hash iteration.\n     *\n     * <p>It is a convenience constructor that merely executes <code>this( source, salt, 1);</code>.\n     *\n     * <p>Please see the\n     * {@link #AbstractHash(Object source, Object salt, int numIterations) AbstractHash(Object,Object,int)}\n     * constructor for the types of Objects that may be passed into this constructor, as well as how to support further\n     * types.\n     *\n     * @param source the source object to be hashed.\n     * @param salt   the salt to use for the hash\n     * @throws CodecException if either constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt) throws CodecException {\n        this(source, salt, 1);\n    }\n\n    /**\n     * Creates a hash of the specified <tt>source</tt> using the given <tt>salt</tt> a total of\n     * <tt>hashIterations</tt> times.\n     *\n     * <p>By default, this class only supports Object method arguments of\n     * type <tt>byte[]</tt>, <tt>char[]</tt> and <tt>String</tt>.  If either argument is anything other than these\n     * types a {@link org.jsecurity.codec.CodecException CodecException} will be thrown.\n     *\n     * <p>If you want to be able to hash other object types, or use other salt types, you need to override the\n     * {@link #toBytes(Object) toBytes(Object)} method to support those specific types.  Your other option is to\n     * convert your arguments to one of the default three supported types first before passing them in to this\n     * constructor</tt>.\n     *\n     * @param source         the source object to be hashed.\n     * @param salt           the salt to use for the hash\n     * @param hashIterations the number of times the <tt>source</tt> argument hashed for attack resiliency.\n     * @throws CodecException if either Object constructor argument cannot be converted into a byte array.\n     */\n    public AbstractHash(Object source, Object salt, int hashIterations) throws CodecException {\n        byte[] sourceBytes = toBytes(source);\n        byte[] saltBytes = null;\n        if (salt != null) {\n            saltBytes = toBytes(salt);\n        }\n        byte[] hashedBytes = hash(sourceBytes, saltBytes, hashIterations);\n        setBytes(hashedBytes);\n    }\n\n    /**\n     * Implemented by subclasses, this specifies the name of the {@link MessageDigest MessageDigest} algorithm\n     * to use when performing the hash.\n     *\n     * @return the {@link MessageDigest MessageDigest} algorithm to use when performing the hash.\n     */\n    protected abstract String getAlgorithmName();\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    /**\n     * Sets the raw bytes stored by this hash instance.\n     *\n     * <p>The bytes are kept in raw form - they will not be hashed/changed.  This is primarily a utility method for\n     * constructing a Hash instance when the hashed value is already known.\n     *\n     * @param alreadyHashedBytes the raw already-hashed bytes to store in this instance.\n     */\n    public void setBytes(byte[] alreadyHashedBytes) {\n        this.bytes = alreadyHashedBytes;\n        this.hexEncoded = null;\n        this.base64Encoded = null;\n    }\n\n    /**\n     * Returns the JDK MessageDigest instance to use for executing the hash.\n     *\n     * @param algorithmName the algorithm to use for the hash, provided by subclasses.\n     * @return the MessageDigest object for the specfied <tt>algorithm</tt>.\n     */\n    protected MessageDigest getDigest(String algorithmName) {\n        try {\n            return MessageDigest.getInstance(algorithmName);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"No native '\" + algorithmName + \"' MessageDigest instance available on the current JVM.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Hashes the specified byte array without a salt for a single iteration.\n     *\n     * @param bytes the bytes to hash.\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes) {\n        return hash(bytes, null, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for a single iteration.\n     *\n     * @param bytes the bytes to hash\n     * @param salt  the salt to use for the initial hash\n     * @return the hashed bytes\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt) {\n        return hash(bytes, salt, 1);\n    }\n\n    /**\n     * Hashes the specified byte array using the given <tt>salt</tt> for the specified number of iterations.\n     *\n     * @param bytes          the bytes to hash\n     * @param salt           the salt to use for the initial hash\n     * @param hashIterations the number of times the the <tt>bytes</tt> will be hashed (for attack resiliency).\n     * @return the hashed bytes.\n     */\n    protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) {\n        MessageDigest md = getDigest(getAlgorithmName());\n        if (salt != null) {\n            md.reset();\n            md.update(salt);\n        }\n        byte[] hashed = md.digest(bytes);\n        //already hashed once above\n        int iterations = hashIterations - 1;\n        //iterate remaining number:\n        for (int i = 0; i < iterations; i++) {\n            md.reset();\n            hashed = md.digest(hashed);\n        }\n        return hashed;\n    }\n\n    /**\n     * Returns a hex-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting hex string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a hex-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toHex() {\n        if (this.hexEncoded == null) {\n            this.hexEncoded = Hex.encodeToString(getBytes());\n        }\n        return this.hexEncoded;\n    }\n\n    /**\n     * Returns a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     *\n     * <p>This implementation caches the resulting Base64 string so multiple calls to this method remain performant.\n     * However, calling {@link #setBytes setBytes} will null the cached value, forcing it to be recalculated the\n     * next time this method is called.\n     *\n     * @return a Base64-encoded string of the underlying {@link #getBytes byte array}.\n     */\n    public String toBase64() {\n        if (this.base64Encoded == null) {\n            //cache result in case this method is called multiple times.\n            this.base64Encoded = Base64.encodeToString(getBytes());\n        }\n        return this.base64Encoded;\n    }\n\n    /**\n     * Simple implementation that merely returns {@link #toHex() toHex()}.\n     *\n     * @return the {@link #toHex() toHex()} value.\n     */\n    public String toString() {\n        return toHex();\n    }\n\n    /**\n     * Returns <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     * this Hash's byte array, <tt>false</tt> otherwise.\n     *\n     * @param o the object (Hash) to check for equality.\n     * @return <tt>true</tt> if the specified object is a Hash and its {@link #getBytes byte array} is identical to\n     *         this Hash's byte array, <tt>false</tt> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o instanceof Hash) {\n            Hash other = (Hash) o;\n            return Arrays.equals(getBytes(), other.getBytes());\n        }\n        return false;\n    }\n\n    /**\n     * Simply returns toHex().hashCode();\n     *\n     * @return toHex().hashCode()\n     */\n    public int hashCode() {\n        return toHex().hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/AbstractHashTest3.java",
		"test_prompt": "// AbstractHashTest3.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecException;\nimport org.jsecurity.codec.CodecSupport;\nimport org.jsecurity.codec.Hex;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractHash}.\n* It contains ten unit test cases for the {@link AbstractHash#hashCode()} method.\n*/\nclass AbstractHashTest3 {"
	},
	{
		"original_code": "// Sha1Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-1 Hash (Secure Hash Standard, NIST FIPS 180-1) from a given input <tt>source</tt> with an\n * optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha1Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-1\";\n\n    public Sha1Hash() {\n    }\n\n    public Sha1Hash(Object source) {\n        super(source);\n    }\n\n    public Sha1Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha1Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha1Hash fromHexString(String hex) {\n        Sha1Hash hash = new Sha1Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha1Hash fromBase64String(String base64) {\n        Sha1Hash hash = new Sha1Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha1HashTest0.java",
		"test_prompt": "// Sha1HashTest0.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha1Hash}.\n* It contains ten unit test cases for the {@link Sha1Hash#fromHexString(String)} method.\n*/\nclass Sha1HashTest0 {"
	},
	{
		"original_code": "// Sha1Hash.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\n\n/**\n * Generates an SHA-1 Hash (Secure Hash Standard, NIST FIPS 180-1) from a given input <tt>source</tt> with an\n * optional <tt>salt</tt> and hash iterations.\n *\n * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing\n * techniques and how the overloaded constructors function.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Sha1Hash extends AbstractHash {\n\n    //TODO - complete JavaDoc\n    public static final String ALGORITHM_NAME = \"SHA-1\";\n\n    public Sha1Hash() {\n    }\n\n    public Sha1Hash(Object source) {\n        super(source);\n    }\n\n    public Sha1Hash(Object source, Object salt) {\n        super(source, salt);\n    }\n\n    public Sha1Hash(Object source, Object salt, int hashIterations) {\n        super(source, salt, hashIterations);\n    }\n\n    protected String getAlgorithmName() {\n        return ALGORITHM_NAME;\n    }\n\n    public static Sha1Hash fromHexString(String hex) {\n        Sha1Hash hash = new Sha1Hash();\n        hash.setBytes(Hex.decode(hex));\n        return hash;\n    }\n\n    public static Sha1Hash fromBase64String(String base64) {\n        Sha1Hash hash = new Sha1Hash();\n        hash.setBytes(Base64.decode(base64));\n        return hash;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/hash/Sha1HashTest1.java",
		"test_prompt": "// Sha1HashTest1.java\npackage org.jsecurity.crypto.hash;\n\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sha1Hash}.\n* It contains ten unit test cases for the {@link Sha1Hash#fromBase64String(String)} method.\n*/\nclass Sha1HashTest1 {"
	},
	{
		"original_code": "// BlowfishCipher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * JSecurity's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n * same <tt>Key</tt> to both encrypt and decrypt data.  If one is not provided via the {@link #setKey setKey} method,\n * a default one will be used, BUT NOTE:\n *\n * <p>Because JSecurity is an open-source project, if anyone knew that you were using JSecurity's default\n * <code>Key</code>, they could download/view the source, and with enough effort, reconstruct the <code>Key</code>\n * and decode encrypted data at will.\n *\n * <p>JSecurity only really uses Ciphers to encrypt user ids and session ids, so if that information is not critical\n * to you and you think the default key still makes things 'sufficiently difficult', then you can ignore this issue.\n *\n * <p>However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n * <tt>Key</tt> via the {@link #setKey setKey} method to a Key known only to your application,\n * guaranteeing that no third party can decrypt your data.  If you want to know how to do this, you can browse this\n * class's source code for the {@link #generateNewKey()} method to see how we created our default.  Then you can\n * duplicate the same in your environment and set the result on an instance of this class via the\n * <code>setKey</code> method.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class BlowfishCipher implements Cipher {\n\n    /**\n     * The JDK Crypto Cipher algorithm to use for this class, equal to &quot;Blowfish&quot;.\n     */\n    private static final String ALGORITHM = \"Blowfish\";\n\n    /**\n     * The JDK Crypto Transformation string to use for this class, equal to {@link #ALGORITHM ALGORITHM} + &quot;/ECB/PKCS5Padding&quot;;\n     */\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //The following KEY_BYTES String was created by running\n    //System.out.println( Base64.encode( generateNewKey().getEncoded() ) ); and copying-n-pasting the output here.\n    //You should run the same and set the resulting output as a property of this class instead of using\n    //JSecurity's default Key for proper security.\n    private static final byte[] KEY_BYTES = Base64.decode(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n\n    private static final Key DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n\n    /**\n     * Internal private log instance.\n     */\n    private static final Log log = LogFactory.getLog(BlowfishCipher.class);\n\n    /**\n     * The key to use by default, can be overridden by calling {@link #setKey(java.security.Key)}.\n     */\n    private Key key = DEFAULT_CIPHER_KEY;\n\n    /**\n     * Default no argument constructor that uses an internal default {@link #getKey() key} to use during\n     * encryption and decryption.  For propery security, you should definitely supply your own key by using the\n     * {@link #setKey(java.security.Key) setKey(Key)} method.\n     */\n    public BlowfishCipher() {\n    }\n\n    /**\n     * Returns the default {@link Key Key} to use for symmetric encryption and decryption if one is not specified during\n     * encryption/decryption.  For truly secure applications,\n     * you should always specify your own key via the {@link #setKey(java.security.Key) setKey} method.\n     * @return the {@link Key Key} to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public Key getKey() {\n        return key;\n    }\n\n    /**\n     * Sets the internal default {@link Key Key} to use for symmetric encryption and decryption if one is not\n     * specified during encryption/decryption.   For truly secure applications, you should always specify your own\n     * key via this method.\n     * @param key the key to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public void setKey(Key key) {\n        this.key = key;\n    }\n\n    /**\n     * Encrypts the specified raw byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] encrypt(byte[] raw, byte[] key) {\n        byte[] encrypted = crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Incoming byte array of size \" + (raw != null ? raw.length : 0) + \".  Encrypted \" + \"byte array is size \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return encrypted;\n    }\n\n    /**\n     * Decrypts the specified already-encrypted byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] decrypt(byte[] encrypted, byte[] key) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to decrypt incoming byte array of length \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    /**\n     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations, based on\n     * the {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     * @return a new Cipher instance.\n     * @throws IllegalStateException if a new Cipher instance cannot be constructed based on the\n     * {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     */\n    protected javax.crypto.Cipher newCipherInstance() throws IllegalStateException {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" + javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" + \"Blowfish under this configuration is required for the \" + getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n     * potential {@link InvalidKeyException InvalidKeyException} that might arise.\n     *\n     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n     * @param mode the Cipher mode\n     * @param key the Cipher's Key\n     */\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n     * might arise in an {@link IllegalStateException IllegalStateException}\n     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n     * @param bytes the bytes to crypt\n     * @return the resulting crypted byte array.\n     */\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link #init(javax.crypto.Cipher, int, java.security.Key)} and then\n     * {@link #crypt(javax.crypto.Cipher, byte[])}.  Ensures that the key is never null by using the\n     * {@link #getKey() default key} if the method argument key is <code>null</code>.\n     * @param bytes the bytes to crypt\n     * @param mode the JDK Cipher mode\n     * @param key the key to use to do the cryption.  If <code>null</code> the {@link #getKey() default key} will be used.\n     * @return the resulting crypted byte array\n     */\n    protected byte[] crypt(byte[] bytes, int mode, byte[] key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        java.security.Key jdkKey;\n        if (key == null) {\n            jdkKey = getKey();\n        } else {\n            jdkKey = new SecretKeySpec(key, ALGORITHM);\n        }\n        init(cipher, mode, jdkKey);\n        return crypt(cipher, bytes);\n    }\n\n    /**\n     * Generates a new {@link Key Key} suitable for this Cipher by calling\n     * {@link #generateNewKey() generateNewKey(128)} (uses a 128 bit size by default).\n     * @return a new {@link Key Key}, 128 bits in length.\n     */\n    public static Key generateNewKey() {\n        return generateNewKey(128);\n    }\n\n    /**\n     * Generates a new {@link Key Key} of the specified size suitable for this Cipher\n     * (based on the {@link #ALGORITHM ALGORITHM} using the JDK {@link KeyGenerator KeyGenerator}.\n     * @param keyBitSize the bit size of the key to create\n     * @return the created key suitable for use with this Cipher.\n     */\n    public static Key generateNewKey(int keyBitSize) {\n        KeyGenerator kg;\n        try {\n            kg = KeyGenerator.getInstance(ALGORITHM);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Unable to acquire \" + ALGORITHM + \" algorithm.  This is required to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n        kg.init(keyBitSize);\n        return kg.generateKey();\n    }\n\n    /**\n     * Simple test main method to ensure functionality is correct.  Should really be moved to a proper test case.\n     * @param unused ignored\n     * @throws Exception if anything unexpected happens.\n     */\n    public static void main(String[] unused) throws Exception {\n        Cipher cipher = new BlowfishCipher();\n        String[] cleartext = new String[] { \"Hello, this is a test.\", \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" };\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeToString(cleartextBytes) + \"]\");\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeToString(encrypted);\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n            byte[] decrypted = cipher.decrypt(Base64.decode(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeToString(decrypted) + \"]\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/BlowfishCipherTest0.java",
		"test_prompt": "// BlowfishCipherTest0.java\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BlowfishCipher}.\n* It contains ten unit test cases for the {@link BlowfishCipher#encrypt(byte[], byte[])} method.\n*/\nclass BlowfishCipherTest0 {"
	},
	{
		"original_code": "// BlowfishCipher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * JSecurity's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n * same <tt>Key</tt> to both encrypt and decrypt data.  If one is not provided via the {@link #setKey setKey} method,\n * a default one will be used, BUT NOTE:\n *\n * <p>Because JSecurity is an open-source project, if anyone knew that you were using JSecurity's default\n * <code>Key</code>, they could download/view the source, and with enough effort, reconstruct the <code>Key</code>\n * and decode encrypted data at will.\n *\n * <p>JSecurity only really uses Ciphers to encrypt user ids and session ids, so if that information is not critical\n * to you and you think the default key still makes things 'sufficiently difficult', then you can ignore this issue.\n *\n * <p>However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n * <tt>Key</tt> via the {@link #setKey setKey} method to a Key known only to your application,\n * guaranteeing that no third party can decrypt your data.  If you want to know how to do this, you can browse this\n * class's source code for the {@link #generateNewKey()} method to see how we created our default.  Then you can\n * duplicate the same in your environment and set the result on an instance of this class via the\n * <code>setKey</code> method.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class BlowfishCipher implements Cipher {\n\n    /**\n     * The JDK Crypto Cipher algorithm to use for this class, equal to &quot;Blowfish&quot;.\n     */\n    private static final String ALGORITHM = \"Blowfish\";\n\n    /**\n     * The JDK Crypto Transformation string to use for this class, equal to {@link #ALGORITHM ALGORITHM} + &quot;/ECB/PKCS5Padding&quot;;\n     */\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //The following KEY_BYTES String was created by running\n    //System.out.println( Base64.encode( generateNewKey().getEncoded() ) ); and copying-n-pasting the output here.\n    //You should run the same and set the resulting output as a property of this class instead of using\n    //JSecurity's default Key for proper security.\n    private static final byte[] KEY_BYTES = Base64.decode(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n\n    private static final Key DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n\n    /**\n     * Internal private log instance.\n     */\n    private static final Log log = LogFactory.getLog(BlowfishCipher.class);\n\n    /**\n     * The key to use by default, can be overridden by calling {@link #setKey(java.security.Key)}.\n     */\n    private Key key = DEFAULT_CIPHER_KEY;\n\n    /**\n     * Default no argument constructor that uses an internal default {@link #getKey() key} to use during\n     * encryption and decryption.  For propery security, you should definitely supply your own key by using the\n     * {@link #setKey(java.security.Key) setKey(Key)} method.\n     */\n    public BlowfishCipher() {\n    }\n\n    /**\n     * Returns the default {@link Key Key} to use for symmetric encryption and decryption if one is not specified during\n     * encryption/decryption.  For truly secure applications,\n     * you should always specify your own key via the {@link #setKey(java.security.Key) setKey} method.\n     * @return the {@link Key Key} to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public Key getKey() {\n        return key;\n    }\n\n    /**\n     * Sets the internal default {@link Key Key} to use for symmetric encryption and decryption if one is not\n     * specified during encryption/decryption.   For truly secure applications, you should always specify your own\n     * key via this method.\n     * @param key the key to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public void setKey(Key key) {\n        this.key = key;\n    }\n\n    /**\n     * Encrypts the specified raw byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] encrypt(byte[] raw, byte[] key) {\n        byte[] encrypted = crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Incoming byte array of size \" + (raw != null ? raw.length : 0) + \".  Encrypted \" + \"byte array is size \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return encrypted;\n    }\n\n    /**\n     * Decrypts the specified already-encrypted byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] decrypt(byte[] encrypted, byte[] key) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to decrypt incoming byte array of length \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    /**\n     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations, based on\n     * the {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     * @return a new Cipher instance.\n     * @throws IllegalStateException if a new Cipher instance cannot be constructed based on the\n     * {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     */\n    protected javax.crypto.Cipher newCipherInstance() throws IllegalStateException {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" + javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" + \"Blowfish under this configuration is required for the \" + getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n     * potential {@link InvalidKeyException InvalidKeyException} that might arise.\n     *\n     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n     * @param mode the Cipher mode\n     * @param key the Cipher's Key\n     */\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n     * might arise in an {@link IllegalStateException IllegalStateException}\n     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n     * @param bytes the bytes to crypt\n     * @return the resulting crypted byte array.\n     */\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link #init(javax.crypto.Cipher, int, java.security.Key)} and then\n     * {@link #crypt(javax.crypto.Cipher, byte[])}.  Ensures that the key is never null by using the\n     * {@link #getKey() default key} if the method argument key is <code>null</code>.\n     * @param bytes the bytes to crypt\n     * @param mode the JDK Cipher mode\n     * @param key the key to use to do the cryption.  If <code>null</code> the {@link #getKey() default key} will be used.\n     * @return the resulting crypted byte array\n     */\n    protected byte[] crypt(byte[] bytes, int mode, byte[] key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        java.security.Key jdkKey;\n        if (key == null) {\n            jdkKey = getKey();\n        } else {\n            jdkKey = new SecretKeySpec(key, ALGORITHM);\n        }\n        init(cipher, mode, jdkKey);\n        return crypt(cipher, bytes);\n    }\n\n    /**\n     * Generates a new {@link Key Key} suitable for this Cipher by calling\n     * {@link #generateNewKey() generateNewKey(128)} (uses a 128 bit size by default).\n     * @return a new {@link Key Key}, 128 bits in length.\n     */\n    public static Key generateNewKey() {\n        return generateNewKey(128);\n    }\n\n    /**\n     * Generates a new {@link Key Key} of the specified size suitable for this Cipher\n     * (based on the {@link #ALGORITHM ALGORITHM} using the JDK {@link KeyGenerator KeyGenerator}.\n     * @param keyBitSize the bit size of the key to create\n     * @return the created key suitable for use with this Cipher.\n     */\n    public static Key generateNewKey(int keyBitSize) {\n        KeyGenerator kg;\n        try {\n            kg = KeyGenerator.getInstance(ALGORITHM);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Unable to acquire \" + ALGORITHM + \" algorithm.  This is required to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n        kg.init(keyBitSize);\n        return kg.generateKey();\n    }\n\n    /**\n     * Simple test main method to ensure functionality is correct.  Should really be moved to a proper test case.\n     * @param unused ignored\n     * @throws Exception if anything unexpected happens.\n     */\n    public static void main(String[] unused) throws Exception {\n        Cipher cipher = new BlowfishCipher();\n        String[] cleartext = new String[] { \"Hello, this is a test.\", \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" };\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeToString(cleartextBytes) + \"]\");\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeToString(encrypted);\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n            byte[] decrypted = cipher.decrypt(Base64.decode(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeToString(decrypted) + \"]\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/BlowfishCipherTest1.java",
		"test_prompt": "// BlowfishCipherTest1.java\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BlowfishCipher}.\n* It contains ten unit test cases for the {@link BlowfishCipher#decrypt(byte[], byte[])} method.\n*/\nclass BlowfishCipherTest1 {"
	},
	{
		"original_code": "// BlowfishCipher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * JSecurity's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n * same <tt>Key</tt> to both encrypt and decrypt data.  If one is not provided via the {@link #setKey setKey} method,\n * a default one will be used, BUT NOTE:\n *\n * <p>Because JSecurity is an open-source project, if anyone knew that you were using JSecurity's default\n * <code>Key</code>, they could download/view the source, and with enough effort, reconstruct the <code>Key</code>\n * and decode encrypted data at will.\n *\n * <p>JSecurity only really uses Ciphers to encrypt user ids and session ids, so if that information is not critical\n * to you and you think the default key still makes things 'sufficiently difficult', then you can ignore this issue.\n *\n * <p>However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n * <tt>Key</tt> via the {@link #setKey setKey} method to a Key known only to your application,\n * guaranteeing that no third party can decrypt your data.  If you want to know how to do this, you can browse this\n * class's source code for the {@link #generateNewKey()} method to see how we created our default.  Then you can\n * duplicate the same in your environment and set the result on an instance of this class via the\n * <code>setKey</code> method.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class BlowfishCipher implements Cipher {\n\n    /**\n     * The JDK Crypto Cipher algorithm to use for this class, equal to &quot;Blowfish&quot;.\n     */\n    private static final String ALGORITHM = \"Blowfish\";\n\n    /**\n     * The JDK Crypto Transformation string to use for this class, equal to {@link #ALGORITHM ALGORITHM} + &quot;/ECB/PKCS5Padding&quot;;\n     */\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //The following KEY_BYTES String was created by running\n    //System.out.println( Base64.encode( generateNewKey().getEncoded() ) ); and copying-n-pasting the output here.\n    //You should run the same and set the resulting output as a property of this class instead of using\n    //JSecurity's default Key for proper security.\n    private static final byte[] KEY_BYTES = Base64.decode(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n\n    private static final Key DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n\n    /**\n     * Internal private log instance.\n     */\n    private static final Log log = LogFactory.getLog(BlowfishCipher.class);\n\n    /**\n     * The key to use by default, can be overridden by calling {@link #setKey(java.security.Key)}.\n     */\n    private Key key = DEFAULT_CIPHER_KEY;\n\n    /**\n     * Default no argument constructor that uses an internal default {@link #getKey() key} to use during\n     * encryption and decryption.  For propery security, you should definitely supply your own key by using the\n     * {@link #setKey(java.security.Key) setKey(Key)} method.\n     */\n    public BlowfishCipher() {\n    }\n\n    /**\n     * Returns the default {@link Key Key} to use for symmetric encryption and decryption if one is not specified during\n     * encryption/decryption.  For truly secure applications,\n     * you should always specify your own key via the {@link #setKey(java.security.Key) setKey} method.\n     * @return the {@link Key Key} to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public Key getKey() {\n        return key;\n    }\n\n    /**\n     * Sets the internal default {@link Key Key} to use for symmetric encryption and decryption if one is not\n     * specified during encryption/decryption.   For truly secure applications, you should always specify your own\n     * key via this method.\n     * @param key the key to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public void setKey(Key key) {\n        this.key = key;\n    }\n\n    /**\n     * Encrypts the specified raw byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] encrypt(byte[] raw, byte[] key) {\n        byte[] encrypted = crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Incoming byte array of size \" + (raw != null ? raw.length : 0) + \".  Encrypted \" + \"byte array is size \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return encrypted;\n    }\n\n    /**\n     * Decrypts the specified already-encrypted byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] decrypt(byte[] encrypted, byte[] key) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to decrypt incoming byte array of length \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    /**\n     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations, based on\n     * the {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     * @return a new Cipher instance.\n     * @throws IllegalStateException if a new Cipher instance cannot be constructed based on the\n     * {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     */\n    protected javax.crypto.Cipher newCipherInstance() throws IllegalStateException {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" + javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" + \"Blowfish under this configuration is required for the \" + getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n     * potential {@link InvalidKeyException InvalidKeyException} that might arise.\n     *\n     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n     * @param mode the Cipher mode\n     * @param key the Cipher's Key\n     */\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n     * might arise in an {@link IllegalStateException IllegalStateException}\n     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n     * @param bytes the bytes to crypt\n     * @return the resulting crypted byte array.\n     */\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link #init(javax.crypto.Cipher, int, java.security.Key)} and then\n     * {@link #crypt(javax.crypto.Cipher, byte[])}.  Ensures that the key is never null by using the\n     * {@link #getKey() default key} if the method argument key is <code>null</code>.\n     * @param bytes the bytes to crypt\n     * @param mode the JDK Cipher mode\n     * @param key the key to use to do the cryption.  If <code>null</code> the {@link #getKey() default key} will be used.\n     * @return the resulting crypted byte array\n     */\n    protected byte[] crypt(byte[] bytes, int mode, byte[] key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        java.security.Key jdkKey;\n        if (key == null) {\n            jdkKey = getKey();\n        } else {\n            jdkKey = new SecretKeySpec(key, ALGORITHM);\n        }\n        init(cipher, mode, jdkKey);\n        return crypt(cipher, bytes);\n    }\n\n    /**\n     * Generates a new {@link Key Key} suitable for this Cipher by calling\n     * {@link #generateNewKey() generateNewKey(128)} (uses a 128 bit size by default).\n     * @return a new {@link Key Key}, 128 bits in length.\n     */\n    public static Key generateNewKey() {\n        return generateNewKey(128);\n    }\n\n    /**\n     * Generates a new {@link Key Key} of the specified size suitable for this Cipher\n     * (based on the {@link #ALGORITHM ALGORITHM} using the JDK {@link KeyGenerator KeyGenerator}.\n     * @param keyBitSize the bit size of the key to create\n     * @return the created key suitable for use with this Cipher.\n     */\n    public static Key generateNewKey(int keyBitSize) {\n        KeyGenerator kg;\n        try {\n            kg = KeyGenerator.getInstance(ALGORITHM);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Unable to acquire \" + ALGORITHM + \" algorithm.  This is required to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n        kg.init(keyBitSize);\n        return kg.generateKey();\n    }\n\n    /**\n     * Simple test main method to ensure functionality is correct.  Should really be moved to a proper test case.\n     * @param unused ignored\n     * @throws Exception if anything unexpected happens.\n     */\n    public static void main(String[] unused) throws Exception {\n        Cipher cipher = new BlowfishCipher();\n        String[] cleartext = new String[] { \"Hello, this is a test.\", \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" };\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeToString(cleartextBytes) + \"]\");\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeToString(encrypted);\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n            byte[] decrypted = cipher.decrypt(Base64.decode(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeToString(decrypted) + \"]\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/BlowfishCipherTest2.java",
		"test_prompt": "// BlowfishCipherTest2.java\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BlowfishCipher}.\n* It contains ten unit test cases for the {@link BlowfishCipher#generateNewKey()} method.\n*/\nclass BlowfishCipherTest2 {"
	},
	{
		"original_code": "// BlowfishCipher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\n/**\n * JSecurity's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n * same <tt>Key</tt> to both encrypt and decrypt data.  If one is not provided via the {@link #setKey setKey} method,\n * a default one will be used, BUT NOTE:\n *\n * <p>Because JSecurity is an open-source project, if anyone knew that you were using JSecurity's default\n * <code>Key</code>, they could download/view the source, and with enough effort, reconstruct the <code>Key</code>\n * and decode encrypted data at will.\n *\n * <p>JSecurity only really uses Ciphers to encrypt user ids and session ids, so if that information is not critical\n * to you and you think the default key still makes things 'sufficiently difficult', then you can ignore this issue.\n *\n * <p>However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n * <tt>Key</tt> via the {@link #setKey setKey} method to a Key known only to your application,\n * guaranteeing that no third party can decrypt your data.  If you want to know how to do this, you can browse this\n * class's source code for the {@link #generateNewKey()} method to see how we created our default.  Then you can\n * duplicate the same in your environment and set the result on an instance of this class via the\n * <code>setKey</code> method.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class BlowfishCipher implements Cipher {\n\n    /**\n     * The JDK Crypto Cipher algorithm to use for this class, equal to &quot;Blowfish&quot;.\n     */\n    private static final String ALGORITHM = \"Blowfish\";\n\n    /**\n     * The JDK Crypto Transformation string to use for this class, equal to {@link #ALGORITHM ALGORITHM} + &quot;/ECB/PKCS5Padding&quot;;\n     */\n    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n\n    //The following KEY_BYTES String was created by running\n    //System.out.println( Base64.encode( generateNewKey().getEncoded() ) ); and copying-n-pasting the output here.\n    //You should run the same and set the resulting output as a property of this class instead of using\n    //JSecurity's default Key for proper security.\n    private static final byte[] KEY_BYTES = Base64.decode(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n\n    private static final Key DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n\n    /**\n     * Internal private log instance.\n     */\n    private static final Log log = LogFactory.getLog(BlowfishCipher.class);\n\n    /**\n     * The key to use by default, can be overridden by calling {@link #setKey(java.security.Key)}.\n     */\n    private Key key = DEFAULT_CIPHER_KEY;\n\n    /**\n     * Default no argument constructor that uses an internal default {@link #getKey() key} to use during\n     * encryption and decryption.  For propery security, you should definitely supply your own key by using the\n     * {@link #setKey(java.security.Key) setKey(Key)} method.\n     */\n    public BlowfishCipher() {\n    }\n\n    /**\n     * Returns the default {@link Key Key} to use for symmetric encryption and decryption if one is not specified during\n     * encryption/decryption.  For truly secure applications,\n     * you should always specify your own key via the {@link #setKey(java.security.Key) setKey} method.\n     * @return the {@link Key Key} to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public Key getKey() {\n        return key;\n    }\n\n    /**\n     * Sets the internal default {@link Key Key} to use for symmetric encryption and decryption if one is not\n     * specified during encryption/decryption.   For truly secure applications, you should always specify your own\n     * key via this method.\n     * @param key the key to use for symmetric encryption and decryption.\n     * @see #encrypt(byte[], byte[])\n     * @see #decrypt(byte[], byte[])\n     */\n    public void setKey(Key key) {\n        this.key = key;\n    }\n\n    /**\n     * Encrypts the specified raw byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] encrypt(byte[] raw, byte[] key) {\n        byte[] encrypted = crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Incoming byte array of size \" + (raw != null ? raw.length : 0) + \".  Encrypted \" + \"byte array is size \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return encrypted;\n    }\n\n    /**\n     * Decrypts the specified already-encrypted byte array.  If the <code>key</code> argument is null, the internal default\n     * {@link #getKey() key} will be used to encrypt the byte array.\n     */\n    public byte[] decrypt(byte[] encrypted, byte[] key) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to decrypt incoming byte array of length \" + (encrypted != null ? encrypted.length : 0));\n        }\n        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n    }\n\n    /**\n     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations, based on\n     * the {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     * @return a new Cipher instance.\n     * @throws IllegalStateException if a new Cipher instance cannot be constructed based on the\n     * {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n     */\n    protected javax.crypto.Cipher newCipherInstance() throws IllegalStateException {\n        try {\n            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n        } catch (Exception e) {\n            String msg = \"Unable to acquire a Java JCE Cipher instance using \" + javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" + \"Blowfish under this configuration is required for the \" + getClass().getName() + \" instance to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n     * potential {@link InvalidKeyException InvalidKeyException} that might arise.\n     *\n     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n     * @param mode the Cipher mode\n     * @param key the Cipher's Key\n     */\n    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n        try {\n            cipher.init(mode, key);\n        } catch (InvalidKeyException e) {\n            String msg = \"Unable to init cipher.\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n     * might arise in an {@link IllegalStateException IllegalStateException}\n     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n     * @param bytes the bytes to crypt\n     * @return the resulting crypted byte array.\n     */\n    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n        try {\n            return cipher.doFinal(bytes);\n        } catch (Exception e) {\n            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n            throw new IllegalStateException(msg, e);\n        }\n    }\n\n    /**\n     * Calls the {@link #init(javax.crypto.Cipher, int, java.security.Key)} and then\n     * {@link #crypt(javax.crypto.Cipher, byte[])}.  Ensures that the key is never null by using the\n     * {@link #getKey() default key} if the method argument key is <code>null</code>.\n     * @param bytes the bytes to crypt\n     * @param mode the JDK Cipher mode\n     * @param key the key to use to do the cryption.  If <code>null</code> the {@link #getKey() default key} will be used.\n     * @return the resulting crypted byte array\n     */\n    protected byte[] crypt(byte[] bytes, int mode, byte[] key) {\n        javax.crypto.Cipher cipher = newCipherInstance();\n        java.security.Key jdkKey;\n        if (key == null) {\n            jdkKey = getKey();\n        } else {\n            jdkKey = new SecretKeySpec(key, ALGORITHM);\n        }\n        init(cipher, mode, jdkKey);\n        return crypt(cipher, bytes);\n    }\n\n    /**\n     * Generates a new {@link Key Key} suitable for this Cipher by calling\n     * {@link #generateNewKey() generateNewKey(128)} (uses a 128 bit size by default).\n     * @return a new {@link Key Key}, 128 bits in length.\n     */\n    public static Key generateNewKey() {\n        return generateNewKey(128);\n    }\n\n    /**\n     * Generates a new {@link Key Key} of the specified size suitable for this Cipher\n     * (based on the {@link #ALGORITHM ALGORITHM} using the JDK {@link KeyGenerator KeyGenerator}.\n     * @param keyBitSize the bit size of the key to create\n     * @return the created key suitable for use with this Cipher.\n     */\n    public static Key generateNewKey(int keyBitSize) {\n        KeyGenerator kg;\n        try {\n            kg = KeyGenerator.getInstance(ALGORITHM);\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Unable to acquire \" + ALGORITHM + \" algorithm.  This is required to function.\";\n            throw new IllegalStateException(msg, e);\n        }\n        kg.init(keyBitSize);\n        return kg.generateKey();\n    }\n\n    /**\n     * Simple test main method to ensure functionality is correct.  Should really be moved to a proper test case.\n     * @param unused ignored\n     * @throws Exception if anything unexpected happens.\n     */\n    public static void main(String[] unused) throws Exception {\n        Cipher cipher = new BlowfishCipher();\n        String[] cleartext = new String[] { \"Hello, this is a test.\", \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" };\n        for (String clear : cleartext) {\n            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n            System.out.println(\"Clear text: [\" + clear + \"]\");\n            System.out.println(\"Clear text base64: [\" + Base64.encodeToString(cleartextBytes) + \"]\");\n            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n            String encryptedBase64 = Base64.encodeToString(encrypted);\n            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n            byte[] decrypted = cipher.decrypt(Base64.decode(encryptedBase64), null);\n            String decryptedString = CodecSupport.toString(decrypted);\n            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n            System.out.println(\"Decrypted text base64: [\" + Base64.encodeToString(decrypted) + \"]\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/crypto/BlowfishCipherTest3.java",
		"test_prompt": "// BlowfishCipherTest3.java\npackage org.jsecurity.crypto;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.CodecSupport;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BlowfishCipher}.\n* It contains ten unit test cases for the {@link BlowfishCipher#generateNewKey(int)} method.\n*/\nclass BlowfishCipherTest3 {"
	},
	{
		"original_code": "// HashtableCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the JSecurity {@link Cache} interface that uses a\r\n * {@link Hashtable} to store cached objects.  This implementation is only suitable for\r\n * development/testing use.  A more robust caching solution should be used for production\r\n * systems such as the {@link org.jsecurity.cache.ehcache.EhCacheManager}\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class HashtableCache implements Cache {\r\n\r\n    /**\r\n     * The underlying hashtable.\r\n     */\r\n    private final Map hashtable = new Hashtable();\r\n\r\n    /**\r\n     * The name of this cache.\r\n     */\r\n    private final String name;\r\n\r\n    /**\r\n     * Creates a new cache with the given name.\r\n     *\r\n     * @param name the name of this cache.\r\n     */\r\n    public HashtableCache(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Object get(Object key) throws CacheException {\r\n        return hashtable.get(key);\r\n    }\r\n\r\n    public void put(Object key, Object value) throws CacheException {\r\n        hashtable.put(key, value);\r\n    }\r\n\r\n    public void remove(Object key) throws CacheException {\r\n        hashtable.remove(key);\r\n    }\r\n\r\n    public void clear() throws CacheException {\r\n        hashtable.clear();\r\n    }\r\n\r\n    public int size() {\r\n        return hashtable.size();\r\n    }\r\n\r\n    public Set keys() {\r\n        if (!hashtable.isEmpty()) {\r\n            return Collections.unmodifiableSet(hashtable.keySet());\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        if (!hashtable.isEmpty()) {\r\n            Collection values = hashtable.values();\r\n            if (values instanceof Set) {\r\n                return Collections.unmodifiableSet((Set) values);\r\n            } else {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(values));\r\n            }\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"HashtableCache [\" + name + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/HashtableCacheTest0.java",
		"test_prompt": "// HashtableCacheTest0.java\npackage org.jsecurity.cache;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HashtableCache}.\n* It contains ten unit test cases for the {@link HashtableCache#size()} method.\n*/\nclass HashtableCacheTest0 {"
	},
	{
		"original_code": "// HashtableCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the JSecurity {@link Cache} interface that uses a\r\n * {@link Hashtable} to store cached objects.  This implementation is only suitable for\r\n * development/testing use.  A more robust caching solution should be used for production\r\n * systems such as the {@link org.jsecurity.cache.ehcache.EhCacheManager}\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class HashtableCache implements Cache {\r\n\r\n    /**\r\n     * The underlying hashtable.\r\n     */\r\n    private final Map hashtable = new Hashtable();\r\n\r\n    /**\r\n     * The name of this cache.\r\n     */\r\n    private final String name;\r\n\r\n    /**\r\n     * Creates a new cache with the given name.\r\n     *\r\n     * @param name the name of this cache.\r\n     */\r\n    public HashtableCache(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Object get(Object key) throws CacheException {\r\n        return hashtable.get(key);\r\n    }\r\n\r\n    public void put(Object key, Object value) throws CacheException {\r\n        hashtable.put(key, value);\r\n    }\r\n\r\n    public void remove(Object key) throws CacheException {\r\n        hashtable.remove(key);\r\n    }\r\n\r\n    public void clear() throws CacheException {\r\n        hashtable.clear();\r\n    }\r\n\r\n    public int size() {\r\n        return hashtable.size();\r\n    }\r\n\r\n    public Set keys() {\r\n        if (!hashtable.isEmpty()) {\r\n            return Collections.unmodifiableSet(hashtable.keySet());\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        if (!hashtable.isEmpty()) {\r\n            Collection values = hashtable.values();\r\n            if (values instanceof Set) {\r\n                return Collections.unmodifiableSet((Set) values);\r\n            } else {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(values));\r\n            }\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"HashtableCache [\" + name + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/HashtableCacheTest1.java",
		"test_prompt": "// HashtableCacheTest1.java\npackage org.jsecurity.cache;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HashtableCache}.\n* It contains ten unit test cases for the {@link HashtableCache#keys()} method.\n*/\nclass HashtableCacheTest1 {"
	},
	{
		"original_code": "// HashtableCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the JSecurity {@link Cache} interface that uses a\r\n * {@link Hashtable} to store cached objects.  This implementation is only suitable for\r\n * development/testing use.  A more robust caching solution should be used for production\r\n * systems such as the {@link org.jsecurity.cache.ehcache.EhCacheManager}\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class HashtableCache implements Cache {\r\n\r\n    /**\r\n     * The underlying hashtable.\r\n     */\r\n    private final Map hashtable = new Hashtable();\r\n\r\n    /**\r\n     * The name of this cache.\r\n     */\r\n    private final String name;\r\n\r\n    /**\r\n     * Creates a new cache with the given name.\r\n     *\r\n     * @param name the name of this cache.\r\n     */\r\n    public HashtableCache(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Object get(Object key) throws CacheException {\r\n        return hashtable.get(key);\r\n    }\r\n\r\n    public void put(Object key, Object value) throws CacheException {\r\n        hashtable.put(key, value);\r\n    }\r\n\r\n    public void remove(Object key) throws CacheException {\r\n        hashtable.remove(key);\r\n    }\r\n\r\n    public void clear() throws CacheException {\r\n        hashtable.clear();\r\n    }\r\n\r\n    public int size() {\r\n        return hashtable.size();\r\n    }\r\n\r\n    public Set keys() {\r\n        if (!hashtable.isEmpty()) {\r\n            return Collections.unmodifiableSet(hashtable.keySet());\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        if (!hashtable.isEmpty()) {\r\n            Collection values = hashtable.values();\r\n            if (values instanceof Set) {\r\n                return Collections.unmodifiableSet((Set) values);\r\n            } else {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(values));\r\n            }\r\n        } else {\r\n            return Collections.EMPTY_SET;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"HashtableCache [\" + name + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/HashtableCacheTest2.java",
		"test_prompt": "// HashtableCacheTest2.java\npackage org.jsecurity.cache;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HashtableCache}.\n* It contains ten unit test cases for the {@link HashtableCache#values()} method.\n*/\nclass HashtableCacheTest2 {"
	},
	{
		"original_code": "// EhCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache.ehcache;\r\n\r\nimport net.sf.ehcache.Element;\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.cache.Cache;\r\nimport org.jsecurity.cache.CacheException;\r\nimport java.util.Collections;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n/**\r\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an {@link net.sf.ehcache.Ehcache} instance.\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class EhCache implements Cache {\r\n\r\n    /**\r\n     * Private internal log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(EhCache.class);\r\n\r\n    /**\r\n     * The wrapped Ehcache instance.\r\n     */\r\n    private net.sf.ehcache.Ehcache cache;\r\n\r\n    /**\r\n     * Constructs a new EhCache instance with the given cache.\r\n     *\r\n     * @param cache - delegate EhCache instance this JSecurity cache instance will wrap.\r\n     */\r\n    public EhCache(net.sf.ehcache.Cache cache) {\r\n        if (cache == null) {\r\n            throw new IllegalArgumentException(\"Cache argument cannot be null.\");\r\n        }\r\n        this.cache = cache;\r\n    }\r\n\r\n    /**\r\n     * Gets a value of an element which matches the given key.\r\n     *\r\n     * @param key the key of the element to return.\r\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\r\n     */\r\n    public Object get(Object key) throws CacheException {\r\n        try {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Getting object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n            }\r\n            if (key == null) {\r\n                return null;\r\n            } else {\r\n                Element element = cache.get(key);\r\n                if (element == null) {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"Element for [\" + key + \"] is null.\");\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    return element.getObjectValue();\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Puts an object into the cache.\r\n     *\r\n     * @param key   the key.\r\n     * @param value the value.\r\n     */\r\n    public void put(Object key, Object value) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Putting object in cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            Element element = new Element(key, value);\r\n            cache.put(element);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the element which matches the key.\r\n     *\r\n     * <p>If no element matches, nothing is removed and no Exception is thrown.</p>\r\n     *\r\n     * @param key the key of the element to remove\r\n     */\r\n    public void remove(Object key) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Removing object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            cache.remove(key);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all elements in the cache, but leaves the cache in a useable state.\r\n     */\r\n    public void clear() throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Clearing all objects from cache [\" + cache.getName() + \"]\");\r\n        }\r\n        try {\r\n            cache.removeAll();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return cache.getSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set keys() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(keys));\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                Set values = new LinkedHashSet(keys.size());\r\n                for (Object key : keys) {\r\n                    values.add(cache.get(key));\r\n                }\r\n                return Collections.unmodifiableSet(values);\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     * number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     *         number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryUsage() {\r\n        try {\r\n            return cache.calculateInMemorySize();\r\n        } catch (Throwable t) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryStoreSize() {\r\n        try {\r\n            return cache.getMemoryStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getDiskStoreSize() {\r\n        try {\r\n            return cache.getDiskStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     *\r\n     * @return &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     */\r\n    public String toString() {\r\n        return \"EhCache [\" + cache.getName() + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/ehcache/EhCacheTest0.java",
		"test_prompt": "// EhCacheTest0.java\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EhCache}.\n* It contains ten unit test cases for the {@link EhCache#size()} method.\n*/\nclass EhCacheTest0 {"
	},
	{
		"original_code": "// EhCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache.ehcache;\r\n\r\nimport net.sf.ehcache.Element;\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.cache.Cache;\r\nimport org.jsecurity.cache.CacheException;\r\nimport java.util.Collections;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n/**\r\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an {@link net.sf.ehcache.Ehcache} instance.\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class EhCache implements Cache {\r\n\r\n    /**\r\n     * Private internal log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(EhCache.class);\r\n\r\n    /**\r\n     * The wrapped Ehcache instance.\r\n     */\r\n    private net.sf.ehcache.Ehcache cache;\r\n\r\n    /**\r\n     * Constructs a new EhCache instance with the given cache.\r\n     *\r\n     * @param cache - delegate EhCache instance this JSecurity cache instance will wrap.\r\n     */\r\n    public EhCache(net.sf.ehcache.Cache cache) {\r\n        if (cache == null) {\r\n            throw new IllegalArgumentException(\"Cache argument cannot be null.\");\r\n        }\r\n        this.cache = cache;\r\n    }\r\n\r\n    /**\r\n     * Gets a value of an element which matches the given key.\r\n     *\r\n     * @param key the key of the element to return.\r\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\r\n     */\r\n    public Object get(Object key) throws CacheException {\r\n        try {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Getting object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n            }\r\n            if (key == null) {\r\n                return null;\r\n            } else {\r\n                Element element = cache.get(key);\r\n                if (element == null) {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"Element for [\" + key + \"] is null.\");\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    return element.getObjectValue();\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Puts an object into the cache.\r\n     *\r\n     * @param key   the key.\r\n     * @param value the value.\r\n     */\r\n    public void put(Object key, Object value) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Putting object in cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            Element element = new Element(key, value);\r\n            cache.put(element);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the element which matches the key.\r\n     *\r\n     * <p>If no element matches, nothing is removed and no Exception is thrown.</p>\r\n     *\r\n     * @param key the key of the element to remove\r\n     */\r\n    public void remove(Object key) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Removing object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            cache.remove(key);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all elements in the cache, but leaves the cache in a useable state.\r\n     */\r\n    public void clear() throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Clearing all objects from cache [\" + cache.getName() + \"]\");\r\n        }\r\n        try {\r\n            cache.removeAll();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return cache.getSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set keys() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(keys));\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                Set values = new LinkedHashSet(keys.size());\r\n                for (Object key : keys) {\r\n                    values.add(cache.get(key));\r\n                }\r\n                return Collections.unmodifiableSet(values);\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     * number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     *         number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryUsage() {\r\n        try {\r\n            return cache.calculateInMemorySize();\r\n        } catch (Throwable t) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryStoreSize() {\r\n        try {\r\n            return cache.getMemoryStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getDiskStoreSize() {\r\n        try {\r\n            return cache.getDiskStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     *\r\n     * @return &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     */\r\n    public String toString() {\r\n        return \"EhCache [\" + cache.getName() + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/ehcache/EhCacheTest1.java",
		"test_prompt": "// EhCacheTest1.java\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EhCache}.\n* It contains ten unit test cases for the {@link EhCache#keys()} method.\n*/\nclass EhCacheTest1 {"
	},
	{
		"original_code": "// EhCache.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.cache.ehcache;\r\n\r\nimport net.sf.ehcache.Element;\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.cache.Cache;\r\nimport org.jsecurity.cache.CacheException;\r\nimport java.util.Collections;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n/**\r\n * JSecurity {@link org.jsecurity.cache.Cache} implementation that wraps an {@link net.sf.ehcache.Ehcache} instance.\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class EhCache implements Cache {\r\n\r\n    /**\r\n     * Private internal log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(EhCache.class);\r\n\r\n    /**\r\n     * The wrapped Ehcache instance.\r\n     */\r\n    private net.sf.ehcache.Ehcache cache;\r\n\r\n    /**\r\n     * Constructs a new EhCache instance with the given cache.\r\n     *\r\n     * @param cache - delegate EhCache instance this JSecurity cache instance will wrap.\r\n     */\r\n    public EhCache(net.sf.ehcache.Cache cache) {\r\n        if (cache == null) {\r\n            throw new IllegalArgumentException(\"Cache argument cannot be null.\");\r\n        }\r\n        this.cache = cache;\r\n    }\r\n\r\n    /**\r\n     * Gets a value of an element which matches the given key.\r\n     *\r\n     * @param key the key of the element to return.\r\n     * @return The value placed into the cache with an earlier put, or null if not found or expired\r\n     */\r\n    public Object get(Object key) throws CacheException {\r\n        try {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Getting object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n            }\r\n            if (key == null) {\r\n                return null;\r\n            } else {\r\n                Element element = cache.get(key);\r\n                if (element == null) {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"Element for [\" + key + \"] is null.\");\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    return element.getObjectValue();\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Puts an object into the cache.\r\n     *\r\n     * @param key   the key.\r\n     * @param value the value.\r\n     */\r\n    public void put(Object key, Object value) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Putting object in cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            Element element = new Element(key, value);\r\n            cache.put(element);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the element which matches the key.\r\n     *\r\n     * <p>If no element matches, nothing is removed and no Exception is thrown.</p>\r\n     *\r\n     * @param key the key of the element to remove\r\n     */\r\n    public void remove(Object key) throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Removing object from cache [\" + cache.getName() + \"] for key [\" + key + \"]\");\r\n        }\r\n        try {\r\n            cache.remove(key);\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all elements in the cache, but leaves the cache in a useable state.\r\n     */\r\n    public void clear() throws CacheException {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Clearing all objects from cache [\" + cache.getName() + \"]\");\r\n        }\r\n        try {\r\n            cache.removeAll();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return cache.getSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set keys() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                return Collections.unmodifiableSet(new LinkedHashSet(keys));\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    public Set values() {\r\n        try {\r\n            List keys = cache.getKeys();\r\n            if (keys != null && !keys.isEmpty()) {\r\n                Set values = new LinkedHashSet(keys.size());\r\n                for (Object key : keys) {\r\n                    values.add(cache.get(key));\r\n                }\r\n                return Collections.unmodifiableSet(values);\r\n            } else {\r\n                return Collections.EMPTY_SET;\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     * number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache is using in memory (RAM), or <code>-1</code> if that\r\n     *         number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryUsage() {\r\n        try {\r\n            return cache.calculateInMemorySize();\r\n        } catch (Throwable t) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's memory store is using (RAM), or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getMemoryStoreSize() {\r\n        try {\r\n            return cache.getMemoryStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     * that number is unknown or cannot be calculated.\r\n     *\r\n     * @return the size (in bytes) that this EhCache's disk store is consuming or <code>-1</code> if\r\n     *         that number is unknown or cannot be calculated.\r\n     */\r\n    public long getDiskStoreSize() {\r\n        try {\r\n            return cache.getDiskStoreSize();\r\n        } catch (Throwable t) {\r\n            throw new CacheException(t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     *\r\n     * @return &quot;EhCache [&quot; + cache.getName() + &quot;]&quot;\r\n     */\r\n    public String toString() {\r\n        return \"EhCache [\" + cache.getName() + \"]\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/cache/ehcache/EhCacheTest2.java",
		"test_prompt": "// EhCacheTest2.java\npackage org.jsecurity.cache.ehcache;\n\nimport net.sf.ehcache.Element;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheException;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EhCache}.\n* It contains ten unit test cases for the {@link EhCache#values()} method.\n*/\nclass EhCacheTest2 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest0.java",
		"test_prompt": "// StringUtilsTest0.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#hasText(String)} method.\n*/\nclass StringUtilsTest0 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest1.java",
		"test_prompt": "// StringUtilsTest1.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#hasLength(String)} method.\n*/\nclass StringUtilsTest1 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest2.java",
		"test_prompt": "// StringUtilsTest2.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#startsWithIgnoreCase(String, String)} method.\n*/\nclass StringUtilsTest2 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest3.java",
		"test_prompt": "// StringUtilsTest3.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#clean(String)} method.\n*/\nclass StringUtilsTest3 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest4.java",
		"test_prompt": "// StringUtilsTest4.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#tokenizeToStringArray(String, String)} method.\n*/\nclass StringUtilsTest4 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest5.java",
		"test_prompt": "// StringUtilsTest5.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#tokenizeToStringArray(String, String, boolean, boolean)} method.\n*/\nclass StringUtilsTest5 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest6.java",
		"test_prompt": "// StringUtilsTest6.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#toStringArray(Collection)} method.\n*/\nclass StringUtilsTest6 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest7.java",
		"test_prompt": "// StringUtilsTest7.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#splitKeyValue(String)} method.\n*/\nclass StringUtilsTest7 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest8.java",
		"test_prompt": "// StringUtilsTest8.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#split(String)} method.\n*/\nclass StringUtilsTest8 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest9.java",
		"test_prompt": "// StringUtilsTest9.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#split(String, char)} method.\n*/\nclass StringUtilsTest9 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest10.java",
		"test_prompt": "// StringUtilsTest10.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#split(String, char, char)} method.\n*/\nclass StringUtilsTest10 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest11.java",
		"test_prompt": "// StringUtilsTest11.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#split(String, char, char, char)} method.\n*/\nclass StringUtilsTest11 {"
	},
	{
		"original_code": "// StringUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * <p>Simple utility class for String operations useful across the framework.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @since 0.9\n */\npublic class StringUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Constant representing the empty string, equal to &quot;&quot;\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Constant representing the default delimiter character (comma), equal to <code>','</code>\n     */\n    public static final char DEFAULT_DELIMITER_CHAR = ',';\n\n    /**\n     * Constant representing the default quote character (double quote), equal to '&quot;'</code>\n     */\n    public static final char DEFAULT_QUOTE_CHAR = '\"';\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <p/>\n     * <code>StringUtils.hasText(null) == false<br/>\n     * StringUtils.hasText(\"\") == false<br/>\n     * StringUtils.hasText(\" \") == false<br/>\n     * StringUtils.hasText(\"12345\") == true<br/>\n     * StringUtils.hasText(\" 12345 \") == true</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(String str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * <p/>\n     * <code>StringUtils.hasLength(null) == false<br/>\n     * StringUtils.hasLength(\"\") == false<br/>\n     * StringUtils.hasLength(\" \") == true<br/>\n     * StringUtils.hasLength(\"Hello\") == true</code>\n     * <p/>\n     * Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(String str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Test if the given String starts with the specified prefix,\n     * ignoring upper/lower case.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str    the String to check\n     * @param prefix the prefix to look for\n     * @return <code>true</code> starts with the specified prefix (ignoring case), <code>false</code> if it does not.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:\n     *\n     * <ol>\n     * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>\n     * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>\n     * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>\n     * <li>If the trimmed string is not the empty string, return the trimmed version</li>.\n     * </ol>\n     *\n     * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>\n     * is returned.\n     *\n     * @param in the input String to clean.\n     * @return a populated-but-trimmed String or <code>null</code> otherwise\n     */\n    public static String clean(String in) {\n        String out = in;\n        if (in != null) {\n            out = in.trim();\n            if (out.equals(EMPTY_STRING)) {\n                out = null;\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str        the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     *                   (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param str               the String to tokenize\n     * @param delimiters        the delimiter characters, assembled as String\n     *                          (each of those characters is individually considered as delimiter)\n     * @param trimTokens        trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     *                          (only applies to tokens that are empty after trimming; StringTokenizer\n     *                          will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     *         was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List tokens = new ArrayList();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     *\n     * <p>Copied from the Spring Framework while retaining all license, copyright and author information.\n     *\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     *         Collection was <code>null</code>)\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static String[] toStringArray(Collection collection) {\n        if (collection == null) {\n            return null;\n        }\n        return (String[]) collection.toArray(new String[collection.size()]);\n    }\n\n    public static String[] splitKeyValue(String aLine) throws ParseException {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        String[] split = line.split(\" \", 2);\n        if (split.length != 2) {\n            //fallback to checking for an equals sign\n            split = line.split(\"=\", 2);\n            if (split.length != 2) {\n                String msg = \"Unable to determine Key/Value pair from line [\" + line + \"].  There is no space from \" + \"which the split location could be determined.\";\n                throw new ParseException(msg, 0);\n            }\n        }\n        split[0] = clean(split[0]);\n        split[1] = clean(split[1]);\n        if (split[1].startsWith(\"=\")) {\n            //they used spaces followed by an equals followed by zero or more spaces to split the key/value pair, so\n            //remove the equals sign to result in only the key and values in the\n            split[1] = clean(split[1].substring(1));\n        }\n        if (split[0] == null) {\n            String msg = \"No valid key could be found in line [\" + line + \"] to form a key/value pair.\";\n            throw new ParseException(msg, 0);\n        }\n        if (split[1] == null) {\n            String msg = \"No corresponding value could be found in line [\" + line + \"] for key [\" + split[0] + \"]\";\n            throw new ParseException(msg, 0);\n        }\n        return split;\n    }\n\n    public static String[] split(String line) {\n        return split(line, DEFAULT_DELIMITER_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter) {\n        return split(line, delimiter, DEFAULT_QUOTE_CHAR);\n    }\n\n    public static String[] split(String line, char delimiter, char quoteChar) {\n        return split(line, delimiter, quoteChar, quoteChar);\n    }\n\n    public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar) {\n        return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);\n    }\n\n    /**\n     * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves\n     * won't be tokenized.\n     *\n     * <p>This method's implementation is very loosely based (with significant modifications) on\n     * <a href=\"http://blogs.bytecode.com.au/glen\">Glen Smith</a>'s open-source\n     * <a href=\"http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup\">CSVReader.java</a>\n     * file.\n     *\n     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to\n     * our needs.\n     *\n     * @param aLine          the String to parse\n     * @param delimiter      the delimiter by which the <tt>line</tt> argument is to be split\n     * @param beginQuoteChar the character signifying the start of quoted text (so the quoted text will not be split)\n     * @param endQuoteChar   the character signifying the end of quoted text\n     * @param retainQuotes   if the quotes themselves should be retained when constructing the corresponding token\n     * @param trimTokens     if leading and trailing whitespace should be trimmed from discovered tokens.\n     * @return the tokens discovered from parsing the given delimited <tt>line</tt>.\n     */\n    public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens) {\n        String line = clean(aLine);\n        if (line == null) {\n            return null;\n        }\n        List<String> tokens = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        boolean inQuotes = false;\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n            if (c == beginQuoteChar) {\n                // this gets complex... the quote may end a quoted block, or escape another quote.\n                // do a 1-char lookahead:\n                if (// we are in quotes, therefore there can be escaped quotes in here.\n                inQuotes && // there is indeed another character to check.\n                line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {\n                    // ..and that char. is a quote also.\n                    // we have two quote chars in a row == one quote char, so consume them both and\n                    // put one on the token. we do *not* exit the quoted text.\n                    sb.append(line.charAt(i + 1));\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                    if (retainQuotes) {\n                        sb.append(c);\n                    }\n                }\n            } else if (c == endQuoteChar) {\n                inQuotes = !inQuotes;\n                if (retainQuotes) {\n                    sb.append(c);\n                }\n            } else if (c == delimiter && !inQuotes) {\n                String s = sb.toString();\n                if (trimTokens) {\n                    s = s.trim();\n                }\n                tokens.add(s);\n                // start work on next token\n                sb = new StringBuffer();\n            } else {\n                sb.append(c);\n            }\n        }\n        String s = sb.toString();\n        if (trimTokens) {\n            s = s.trim();\n        }\n        tokens.add(s);\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/StringUtilsTest12.java",
		"test_prompt": "// StringUtilsTest12.java\npackage org.jsecurity.util;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#split(String, char, char, char, boolean, boolean)} method.\n*/\nclass StringUtilsTest12 {"
	},
	{
		"original_code": "// AntPathMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * <p>PathMatcher implementation for Ant-style path patterns.\n * Examples are provided below.</p>\n *\n * <p>Part of this mapping code has been kindly borrowed from\n * <a href=\"http://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>? matches one character</li>\n * <li>* matches zero or more characters</li>\n * <li>** matches zero or more 'directories' in a path</li>\n * </ul>\n *\n * <p>Some examples:<br>\n * <ul>\n * <li><code>com/t?st.jsp</code> - matches <code>com/test.jsp</code> but also\n * <code>com/tast.jsp</code> or <code>com/txst.jsp</code></li>\n * <li><code>com/*.jsp</code> - matches all <code>.jsp</code> files in the\n * <code>com</code> directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> - matches all <code>test.jsp</code>\n * files underneath the <code>com</code> path</li>\n * <li><code>org/jsecurity/&#42;&#42;/*.jsp</code> - matches all <code>.jsp</code>\n * files underneath the <code>org/jsecurity</code> path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> - matches\n * <code>org/jsecurity/servlet/bla.jsp</code> but also\n * <code>org/jsecurity/testing/servlet/bla.jsp</code> and\n * <code>org/servlet/bla.jsp</code></li>\n * </ul>\n *\n * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the\n * <a href=\"http://www.springframework.org\">Spring Framework</a> with modifications.  We didn't want to reinvent the\n * wheel of great work they've done, but also didn't want to force every JSecurity user to depend on Spring</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PatternMatcher {\n\n    //TODO - complete JavaDoc\n    /**\n     * Default path separator: \"/\"\n     */\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    private String pathSeparator = DEFAULT_PATH_SEPARATOR;\n\n    /**\n     * Set the path separator to use for pattern parsing.\n     * Default is \"/\", as in Ant.\n     */\n    public void setPathSeparator(String pathSeparator) {\n        this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n    }\n\n    public boolean isPattern(String path) {\n        return (path.indexOf('*') != -1 || path.indexOf('?') != -1);\n    }\n\n    public boolean matches(String pattern, String source) {\n        return match(pattern, source);\n    }\n\n    public boolean match(String pattern, String path) {\n        return doMatch(pattern, path, true);\n    }\n\n    public boolean matchStart(String pattern, String path) {\n        return doMatch(pattern, path, false);\n    }\n\n    /**\n     * Actually match the given <code>path</code> against the given <code>pattern</code>.\n     *\n     * @param pattern   the pattern to match against\n     * @param path      the path String to test\n     * @param fullMatch whether a full pattern match is required\n     *                  (else a pattern match as far as the given base path goes is sufficient)\n     * @return <code>true</code> if the supplied <code>path</code> matched,\n     *         <code>false</code> if it didn't\n     */\n    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n            return false;\n        }\n        String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        int pattIdxStart = 0;\n        int pattIdxEnd = pattDirs.length - 1;\n        int pathIdxStart = 0;\n        int pathIdxEnd = pathDirs.length - 1;\n        // Match all elements up to the first **\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxStart];\n            if (\"**\".equals(patDir)) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n                return false;\n            }\n            pattIdxStart++;\n            pathIdxStart++;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // Path is exhausted, only match if rest of pattern is * or **'s\n            if (pattIdxStart > pattIdxEnd) {\n                return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));\n            }\n            if (!fullMatch) {\n                return true;\n            }\n            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n                return true;\n            }\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (pattIdxStart > pattIdxEnd) {\n            // String not exhausted, but pattern is. Failure.\n            return false;\n        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n            // Path start definitely matches due to \"**\" part in pattern.\n            return true;\n        }\n        // up to last '**'\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxEnd];\n            if (patDir.equals(\"**\")) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n                return false;\n            }\n            pattIdxEnd--;\n            pathIdxEnd--;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // String is exhausted\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n                if (pattDirs[i].equals(\"**\")) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == pattIdxStart + 1) {\n                // '**/**' situation, so skip one\n                pattIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - pattIdxStart - 1);\n            int strLength = (pathIdxEnd - pathIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = (String) pattDirs[pattIdxStart + j + 1];\n                    String subStr = (String) pathDirs[pathIdxStart + i + j];\n                    if (!matchStrings(subPat, subStr)) {\n                        continue strLoop;\n                    }\n                }\n                foundIdx = pathIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            pattIdxStart = patIdxTmp;\n            pathIdxStart = foundIdx + patLength;\n        }\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n            if (!pattDirs[i].equals(\"**\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @return <code>true</code> if the string matches against the\n     *         pattern, or <code>false</code> otherwise.\n     */\n    private boolean matchStrings(String pattern, String str) {\n        char[] patArr = pattern.toCharArray();\n        char[] strArr = str.toCharArray();\n        int patIdxStart = 0;\n        int patIdxEnd = patArr.length - 1;\n        int strIdxStart = 0;\n        int strIdxEnd = strArr.length - 1;\n        char ch;\n        boolean containsStar = false;\n        for (char aPatArr : patArr) {\n            if (aPatArr == '*') {\n                containsStar = true;\n                break;\n            }\n        }\n        if (!containsStar) {\n            // No '*'s, so we make a shortcut\n            if (patIdxEnd != strIdxEnd) {\n                // Pattern and string do not have the same size\n                return false;\n            }\n            for (int i = 0; i <= patIdxEnd; i++) {\n                ch = patArr[i];\n                if (ch != '?') {\n                    if (ch != strArr[i]) {\n                        // Character mismatch\n                        return false;\n                    }\n                }\n            }\n            // String matches against pattern\n            return true;\n        }\n        if (patIdxEnd == 0) {\n            // Pattern contains only '*', which matches anything\n            return true;\n        }\n        // Process characters before first star\n        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxStart]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxStart++;\n            strIdxStart++;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // Process characters after last star\n        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxEnd]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxEnd--;\n            strIdxEnd--;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // process pattern between stars. padIdxStart and patIdxEnd point\n        // always to a '*'.\n        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n                if (patArr[i] == '*') {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patIdxStart + 1) {\n                // Two stars next to each other, skip the first one.\n                patIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patIdxStart - 1);\n            int strLength = (strIdxEnd - strIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    ch = patArr[patIdxStart + j + 1];\n                    if (ch != '?') {\n                        if (ch != strArr[strIdxStart + i + j]) {\n                            continue strLoop;\n                        }\n                    }\n                }\n                foundIdx = strIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            patIdxStart = patIdxTmp;\n            strIdxStart = foundIdx + patLength;\n        }\n        // All characters in the string are used. Check if only '*'s are left\n        // in the pattern. If so, we succeeded. Otherwise failure.\n        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n            if (patArr[i] != '*') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Given a pattern and a full path, determine the pattern-mapped part.\n     * <p>For example:\n     * <ul>\n     * <li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>\n     * <li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>\n     * <li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/**\\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>\n     * <li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * </ul>\n     * <p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>'\n     * and '<code>path</code>', but does <strong>not</strong> enforce this.\n     */\n    public String extractPathWithinPattern(String pattern, String path) {\n        String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        StringBuffer buffer = new StringBuffer();\n        // Add any path parts that have a wildcarded pattern part.\n        int puts = 0;\n        for (int i = 0; i < patternParts.length; i++) {\n            String patternPart = patternParts[i];\n            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n                    buffer.append(this.pathSeparator);\n                }\n                buffer.append(pathParts[i]);\n                puts++;\n            }\n        }\n        // Append any trailing path parts.\n        for (int i = patternParts.length; i < pathParts.length; i++) {\n            if (puts > 0 || i > 0) {\n                buffer.append(this.pathSeparator);\n            }\n            buffer.append(pathParts[i]);\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/AntPathMatcherTest0.java",
		"test_prompt": "// AntPathMatcherTest0.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntPathMatcher}.\n* It contains ten unit test cases for the {@link AntPathMatcher#isPattern(String)} method.\n*/\nclass AntPathMatcherTest0 {"
	},
	{
		"original_code": "// AntPathMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * <p>PathMatcher implementation for Ant-style path patterns.\n * Examples are provided below.</p>\n *\n * <p>Part of this mapping code has been kindly borrowed from\n * <a href=\"http://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>? matches one character</li>\n * <li>* matches zero or more characters</li>\n * <li>** matches zero or more 'directories' in a path</li>\n * </ul>\n *\n * <p>Some examples:<br>\n * <ul>\n * <li><code>com/t?st.jsp</code> - matches <code>com/test.jsp</code> but also\n * <code>com/tast.jsp</code> or <code>com/txst.jsp</code></li>\n * <li><code>com/*.jsp</code> - matches all <code>.jsp</code> files in the\n * <code>com</code> directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> - matches all <code>test.jsp</code>\n * files underneath the <code>com</code> path</li>\n * <li><code>org/jsecurity/&#42;&#42;/*.jsp</code> - matches all <code>.jsp</code>\n * files underneath the <code>org/jsecurity</code> path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> - matches\n * <code>org/jsecurity/servlet/bla.jsp</code> but also\n * <code>org/jsecurity/testing/servlet/bla.jsp</code> and\n * <code>org/servlet/bla.jsp</code></li>\n * </ul>\n *\n * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the\n * <a href=\"http://www.springframework.org\">Spring Framework</a> with modifications.  We didn't want to reinvent the\n * wheel of great work they've done, but also didn't want to force every JSecurity user to depend on Spring</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PatternMatcher {\n\n    //TODO - complete JavaDoc\n    /**\n     * Default path separator: \"/\"\n     */\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    private String pathSeparator = DEFAULT_PATH_SEPARATOR;\n\n    /**\n     * Set the path separator to use for pattern parsing.\n     * Default is \"/\", as in Ant.\n     */\n    public void setPathSeparator(String pathSeparator) {\n        this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n    }\n\n    public boolean isPattern(String path) {\n        return (path.indexOf('*') != -1 || path.indexOf('?') != -1);\n    }\n\n    public boolean matches(String pattern, String source) {\n        return match(pattern, source);\n    }\n\n    public boolean match(String pattern, String path) {\n        return doMatch(pattern, path, true);\n    }\n\n    public boolean matchStart(String pattern, String path) {\n        return doMatch(pattern, path, false);\n    }\n\n    /**\n     * Actually match the given <code>path</code> against the given <code>pattern</code>.\n     *\n     * @param pattern   the pattern to match against\n     * @param path      the path String to test\n     * @param fullMatch whether a full pattern match is required\n     *                  (else a pattern match as far as the given base path goes is sufficient)\n     * @return <code>true</code> if the supplied <code>path</code> matched,\n     *         <code>false</code> if it didn't\n     */\n    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n            return false;\n        }\n        String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        int pattIdxStart = 0;\n        int pattIdxEnd = pattDirs.length - 1;\n        int pathIdxStart = 0;\n        int pathIdxEnd = pathDirs.length - 1;\n        // Match all elements up to the first **\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxStart];\n            if (\"**\".equals(patDir)) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n                return false;\n            }\n            pattIdxStart++;\n            pathIdxStart++;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // Path is exhausted, only match if rest of pattern is * or **'s\n            if (pattIdxStart > pattIdxEnd) {\n                return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));\n            }\n            if (!fullMatch) {\n                return true;\n            }\n            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n                return true;\n            }\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (pattIdxStart > pattIdxEnd) {\n            // String not exhausted, but pattern is. Failure.\n            return false;\n        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n            // Path start definitely matches due to \"**\" part in pattern.\n            return true;\n        }\n        // up to last '**'\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxEnd];\n            if (patDir.equals(\"**\")) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n                return false;\n            }\n            pattIdxEnd--;\n            pathIdxEnd--;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // String is exhausted\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n                if (pattDirs[i].equals(\"**\")) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == pattIdxStart + 1) {\n                // '**/**' situation, so skip one\n                pattIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - pattIdxStart - 1);\n            int strLength = (pathIdxEnd - pathIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = (String) pattDirs[pattIdxStart + j + 1];\n                    String subStr = (String) pathDirs[pathIdxStart + i + j];\n                    if (!matchStrings(subPat, subStr)) {\n                        continue strLoop;\n                    }\n                }\n                foundIdx = pathIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            pattIdxStart = patIdxTmp;\n            pathIdxStart = foundIdx + patLength;\n        }\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n            if (!pattDirs[i].equals(\"**\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @return <code>true</code> if the string matches against the\n     *         pattern, or <code>false</code> otherwise.\n     */\n    private boolean matchStrings(String pattern, String str) {\n        char[] patArr = pattern.toCharArray();\n        char[] strArr = str.toCharArray();\n        int patIdxStart = 0;\n        int patIdxEnd = patArr.length - 1;\n        int strIdxStart = 0;\n        int strIdxEnd = strArr.length - 1;\n        char ch;\n        boolean containsStar = false;\n        for (char aPatArr : patArr) {\n            if (aPatArr == '*') {\n                containsStar = true;\n                break;\n            }\n        }\n        if (!containsStar) {\n            // No '*'s, so we make a shortcut\n            if (patIdxEnd != strIdxEnd) {\n                // Pattern and string do not have the same size\n                return false;\n            }\n            for (int i = 0; i <= patIdxEnd; i++) {\n                ch = patArr[i];\n                if (ch != '?') {\n                    if (ch != strArr[i]) {\n                        // Character mismatch\n                        return false;\n                    }\n                }\n            }\n            // String matches against pattern\n            return true;\n        }\n        if (patIdxEnd == 0) {\n            // Pattern contains only '*', which matches anything\n            return true;\n        }\n        // Process characters before first star\n        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxStart]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxStart++;\n            strIdxStart++;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // Process characters after last star\n        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxEnd]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxEnd--;\n            strIdxEnd--;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // process pattern between stars. padIdxStart and patIdxEnd point\n        // always to a '*'.\n        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n                if (patArr[i] == '*') {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patIdxStart + 1) {\n                // Two stars next to each other, skip the first one.\n                patIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patIdxStart - 1);\n            int strLength = (strIdxEnd - strIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    ch = patArr[patIdxStart + j + 1];\n                    if (ch != '?') {\n                        if (ch != strArr[strIdxStart + i + j]) {\n                            continue strLoop;\n                        }\n                    }\n                }\n                foundIdx = strIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            patIdxStart = patIdxTmp;\n            strIdxStart = foundIdx + patLength;\n        }\n        // All characters in the string are used. Check if only '*'s are left\n        // in the pattern. If so, we succeeded. Otherwise failure.\n        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n            if (patArr[i] != '*') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Given a pattern and a full path, determine the pattern-mapped part.\n     * <p>For example:\n     * <ul>\n     * <li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>\n     * <li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>\n     * <li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/**\\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>\n     * <li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * </ul>\n     * <p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>'\n     * and '<code>path</code>', but does <strong>not</strong> enforce this.\n     */\n    public String extractPathWithinPattern(String pattern, String path) {\n        String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        StringBuffer buffer = new StringBuffer();\n        // Add any path parts that have a wildcarded pattern part.\n        int puts = 0;\n        for (int i = 0; i < patternParts.length; i++) {\n            String patternPart = patternParts[i];\n            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n                    buffer.append(this.pathSeparator);\n                }\n                buffer.append(pathParts[i]);\n                puts++;\n            }\n        }\n        // Append any trailing path parts.\n        for (int i = patternParts.length; i < pathParts.length; i++) {\n            if (puts > 0 || i > 0) {\n                buffer.append(this.pathSeparator);\n            }\n            buffer.append(pathParts[i]);\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/AntPathMatcherTest1.java",
		"test_prompt": "// AntPathMatcherTest1.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntPathMatcher}.\n* It contains ten unit test cases for the {@link AntPathMatcher#matches(String, String)} method.\n*/\nclass AntPathMatcherTest1 {"
	},
	{
		"original_code": "// AntPathMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * <p>PathMatcher implementation for Ant-style path patterns.\n * Examples are provided below.</p>\n *\n * <p>Part of this mapping code has been kindly borrowed from\n * <a href=\"http://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>? matches one character</li>\n * <li>* matches zero or more characters</li>\n * <li>** matches zero or more 'directories' in a path</li>\n * </ul>\n *\n * <p>Some examples:<br>\n * <ul>\n * <li><code>com/t?st.jsp</code> - matches <code>com/test.jsp</code> but also\n * <code>com/tast.jsp</code> or <code>com/txst.jsp</code></li>\n * <li><code>com/*.jsp</code> - matches all <code>.jsp</code> files in the\n * <code>com</code> directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> - matches all <code>test.jsp</code>\n * files underneath the <code>com</code> path</li>\n * <li><code>org/jsecurity/&#42;&#42;/*.jsp</code> - matches all <code>.jsp</code>\n * files underneath the <code>org/jsecurity</code> path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> - matches\n * <code>org/jsecurity/servlet/bla.jsp</code> but also\n * <code>org/jsecurity/testing/servlet/bla.jsp</code> and\n * <code>org/servlet/bla.jsp</code></li>\n * </ul>\n *\n * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the\n * <a href=\"http://www.springframework.org\">Spring Framework</a> with modifications.  We didn't want to reinvent the\n * wheel of great work they've done, but also didn't want to force every JSecurity user to depend on Spring</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PatternMatcher {\n\n    //TODO - complete JavaDoc\n    /**\n     * Default path separator: \"/\"\n     */\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    private String pathSeparator = DEFAULT_PATH_SEPARATOR;\n\n    /**\n     * Set the path separator to use for pattern parsing.\n     * Default is \"/\", as in Ant.\n     */\n    public void setPathSeparator(String pathSeparator) {\n        this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n    }\n\n    public boolean isPattern(String path) {\n        return (path.indexOf('*') != -1 || path.indexOf('?') != -1);\n    }\n\n    public boolean matches(String pattern, String source) {\n        return match(pattern, source);\n    }\n\n    public boolean match(String pattern, String path) {\n        return doMatch(pattern, path, true);\n    }\n\n    public boolean matchStart(String pattern, String path) {\n        return doMatch(pattern, path, false);\n    }\n\n    /**\n     * Actually match the given <code>path</code> against the given <code>pattern</code>.\n     *\n     * @param pattern   the pattern to match against\n     * @param path      the path String to test\n     * @param fullMatch whether a full pattern match is required\n     *                  (else a pattern match as far as the given base path goes is sufficient)\n     * @return <code>true</code> if the supplied <code>path</code> matched,\n     *         <code>false</code> if it didn't\n     */\n    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n            return false;\n        }\n        String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        int pattIdxStart = 0;\n        int pattIdxEnd = pattDirs.length - 1;\n        int pathIdxStart = 0;\n        int pathIdxEnd = pathDirs.length - 1;\n        // Match all elements up to the first **\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxStart];\n            if (\"**\".equals(patDir)) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n                return false;\n            }\n            pattIdxStart++;\n            pathIdxStart++;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // Path is exhausted, only match if rest of pattern is * or **'s\n            if (pattIdxStart > pattIdxEnd) {\n                return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));\n            }\n            if (!fullMatch) {\n                return true;\n            }\n            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n                return true;\n            }\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (pattIdxStart > pattIdxEnd) {\n            // String not exhausted, but pattern is. Failure.\n            return false;\n        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n            // Path start definitely matches due to \"**\" part in pattern.\n            return true;\n        }\n        // up to last '**'\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxEnd];\n            if (patDir.equals(\"**\")) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n                return false;\n            }\n            pattIdxEnd--;\n            pathIdxEnd--;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // String is exhausted\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n                if (pattDirs[i].equals(\"**\")) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == pattIdxStart + 1) {\n                // '**/**' situation, so skip one\n                pattIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - pattIdxStart - 1);\n            int strLength = (pathIdxEnd - pathIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = (String) pattDirs[pattIdxStart + j + 1];\n                    String subStr = (String) pathDirs[pathIdxStart + i + j];\n                    if (!matchStrings(subPat, subStr)) {\n                        continue strLoop;\n                    }\n                }\n                foundIdx = pathIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            pattIdxStart = patIdxTmp;\n            pathIdxStart = foundIdx + patLength;\n        }\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n            if (!pattDirs[i].equals(\"**\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @return <code>true</code> if the string matches against the\n     *         pattern, or <code>false</code> otherwise.\n     */\n    private boolean matchStrings(String pattern, String str) {\n        char[] patArr = pattern.toCharArray();\n        char[] strArr = str.toCharArray();\n        int patIdxStart = 0;\n        int patIdxEnd = patArr.length - 1;\n        int strIdxStart = 0;\n        int strIdxEnd = strArr.length - 1;\n        char ch;\n        boolean containsStar = false;\n        for (char aPatArr : patArr) {\n            if (aPatArr == '*') {\n                containsStar = true;\n                break;\n            }\n        }\n        if (!containsStar) {\n            // No '*'s, so we make a shortcut\n            if (patIdxEnd != strIdxEnd) {\n                // Pattern and string do not have the same size\n                return false;\n            }\n            for (int i = 0; i <= patIdxEnd; i++) {\n                ch = patArr[i];\n                if (ch != '?') {\n                    if (ch != strArr[i]) {\n                        // Character mismatch\n                        return false;\n                    }\n                }\n            }\n            // String matches against pattern\n            return true;\n        }\n        if (patIdxEnd == 0) {\n            // Pattern contains only '*', which matches anything\n            return true;\n        }\n        // Process characters before first star\n        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxStart]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxStart++;\n            strIdxStart++;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // Process characters after last star\n        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxEnd]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxEnd--;\n            strIdxEnd--;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // process pattern between stars. padIdxStart and patIdxEnd point\n        // always to a '*'.\n        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n                if (patArr[i] == '*') {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patIdxStart + 1) {\n                // Two stars next to each other, skip the first one.\n                patIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patIdxStart - 1);\n            int strLength = (strIdxEnd - strIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    ch = patArr[patIdxStart + j + 1];\n                    if (ch != '?') {\n                        if (ch != strArr[strIdxStart + i + j]) {\n                            continue strLoop;\n                        }\n                    }\n                }\n                foundIdx = strIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            patIdxStart = patIdxTmp;\n            strIdxStart = foundIdx + patLength;\n        }\n        // All characters in the string are used. Check if only '*'s are left\n        // in the pattern. If so, we succeeded. Otherwise failure.\n        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n            if (patArr[i] != '*') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Given a pattern and a full path, determine the pattern-mapped part.\n     * <p>For example:\n     * <ul>\n     * <li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>\n     * <li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>\n     * <li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/**\\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>\n     * <li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * </ul>\n     * <p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>'\n     * and '<code>path</code>', but does <strong>not</strong> enforce this.\n     */\n    public String extractPathWithinPattern(String pattern, String path) {\n        String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        StringBuffer buffer = new StringBuffer();\n        // Add any path parts that have a wildcarded pattern part.\n        int puts = 0;\n        for (int i = 0; i < patternParts.length; i++) {\n            String patternPart = patternParts[i];\n            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n                    buffer.append(this.pathSeparator);\n                }\n                buffer.append(pathParts[i]);\n                puts++;\n            }\n        }\n        // Append any trailing path parts.\n        for (int i = patternParts.length; i < pathParts.length; i++) {\n            if (puts > 0 || i > 0) {\n                buffer.append(this.pathSeparator);\n            }\n            buffer.append(pathParts[i]);\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/AntPathMatcherTest2.java",
		"test_prompt": "// AntPathMatcherTest2.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntPathMatcher}.\n* It contains ten unit test cases for the {@link AntPathMatcher#match(String, String)} method.\n*/\nclass AntPathMatcherTest2 {"
	},
	{
		"original_code": "// AntPathMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * <p>PathMatcher implementation for Ant-style path patterns.\n * Examples are provided below.</p>\n *\n * <p>Part of this mapping code has been kindly borrowed from\n * <a href=\"http://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>? matches one character</li>\n * <li>* matches zero or more characters</li>\n * <li>** matches zero or more 'directories' in a path</li>\n * </ul>\n *\n * <p>Some examples:<br>\n * <ul>\n * <li><code>com/t?st.jsp</code> - matches <code>com/test.jsp</code> but also\n * <code>com/tast.jsp</code> or <code>com/txst.jsp</code></li>\n * <li><code>com/*.jsp</code> - matches all <code>.jsp</code> files in the\n * <code>com</code> directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> - matches all <code>test.jsp</code>\n * files underneath the <code>com</code> path</li>\n * <li><code>org/jsecurity/&#42;&#42;/*.jsp</code> - matches all <code>.jsp</code>\n * files underneath the <code>org/jsecurity</code> path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> - matches\n * <code>org/jsecurity/servlet/bla.jsp</code> but also\n * <code>org/jsecurity/testing/servlet/bla.jsp</code> and\n * <code>org/servlet/bla.jsp</code></li>\n * </ul>\n *\n * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the\n * <a href=\"http://www.springframework.org\">Spring Framework</a> with modifications.  We didn't want to reinvent the\n * wheel of great work they've done, but also didn't want to force every JSecurity user to depend on Spring</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PatternMatcher {\n\n    //TODO - complete JavaDoc\n    /**\n     * Default path separator: \"/\"\n     */\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    private String pathSeparator = DEFAULT_PATH_SEPARATOR;\n\n    /**\n     * Set the path separator to use for pattern parsing.\n     * Default is \"/\", as in Ant.\n     */\n    public void setPathSeparator(String pathSeparator) {\n        this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n    }\n\n    public boolean isPattern(String path) {\n        return (path.indexOf('*') != -1 || path.indexOf('?') != -1);\n    }\n\n    public boolean matches(String pattern, String source) {\n        return match(pattern, source);\n    }\n\n    public boolean match(String pattern, String path) {\n        return doMatch(pattern, path, true);\n    }\n\n    public boolean matchStart(String pattern, String path) {\n        return doMatch(pattern, path, false);\n    }\n\n    /**\n     * Actually match the given <code>path</code> against the given <code>pattern</code>.\n     *\n     * @param pattern   the pattern to match against\n     * @param path      the path String to test\n     * @param fullMatch whether a full pattern match is required\n     *                  (else a pattern match as far as the given base path goes is sufficient)\n     * @return <code>true</code> if the supplied <code>path</code> matched,\n     *         <code>false</code> if it didn't\n     */\n    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n            return false;\n        }\n        String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        int pattIdxStart = 0;\n        int pattIdxEnd = pattDirs.length - 1;\n        int pathIdxStart = 0;\n        int pathIdxEnd = pathDirs.length - 1;\n        // Match all elements up to the first **\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxStart];\n            if (\"**\".equals(patDir)) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n                return false;\n            }\n            pattIdxStart++;\n            pathIdxStart++;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // Path is exhausted, only match if rest of pattern is * or **'s\n            if (pattIdxStart > pattIdxEnd) {\n                return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));\n            }\n            if (!fullMatch) {\n                return true;\n            }\n            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n                return true;\n            }\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (pattIdxStart > pattIdxEnd) {\n            // String not exhausted, but pattern is. Failure.\n            return false;\n        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n            // Path start definitely matches due to \"**\" part in pattern.\n            return true;\n        }\n        // up to last '**'\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxEnd];\n            if (patDir.equals(\"**\")) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n                return false;\n            }\n            pattIdxEnd--;\n            pathIdxEnd--;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // String is exhausted\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n                if (pattDirs[i].equals(\"**\")) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == pattIdxStart + 1) {\n                // '**/**' situation, so skip one\n                pattIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - pattIdxStart - 1);\n            int strLength = (pathIdxEnd - pathIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = (String) pattDirs[pattIdxStart + j + 1];\n                    String subStr = (String) pathDirs[pathIdxStart + i + j];\n                    if (!matchStrings(subPat, subStr)) {\n                        continue strLoop;\n                    }\n                }\n                foundIdx = pathIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            pattIdxStart = patIdxTmp;\n            pathIdxStart = foundIdx + patLength;\n        }\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n            if (!pattDirs[i].equals(\"**\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @return <code>true</code> if the string matches against the\n     *         pattern, or <code>false</code> otherwise.\n     */\n    private boolean matchStrings(String pattern, String str) {\n        char[] patArr = pattern.toCharArray();\n        char[] strArr = str.toCharArray();\n        int patIdxStart = 0;\n        int patIdxEnd = patArr.length - 1;\n        int strIdxStart = 0;\n        int strIdxEnd = strArr.length - 1;\n        char ch;\n        boolean containsStar = false;\n        for (char aPatArr : patArr) {\n            if (aPatArr == '*') {\n                containsStar = true;\n                break;\n            }\n        }\n        if (!containsStar) {\n            // No '*'s, so we make a shortcut\n            if (patIdxEnd != strIdxEnd) {\n                // Pattern and string do not have the same size\n                return false;\n            }\n            for (int i = 0; i <= patIdxEnd; i++) {\n                ch = patArr[i];\n                if (ch != '?') {\n                    if (ch != strArr[i]) {\n                        // Character mismatch\n                        return false;\n                    }\n                }\n            }\n            // String matches against pattern\n            return true;\n        }\n        if (patIdxEnd == 0) {\n            // Pattern contains only '*', which matches anything\n            return true;\n        }\n        // Process characters before first star\n        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxStart]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxStart++;\n            strIdxStart++;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // Process characters after last star\n        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxEnd]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxEnd--;\n            strIdxEnd--;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // process pattern between stars. padIdxStart and patIdxEnd point\n        // always to a '*'.\n        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n                if (patArr[i] == '*') {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patIdxStart + 1) {\n                // Two stars next to each other, skip the first one.\n                patIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patIdxStart - 1);\n            int strLength = (strIdxEnd - strIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    ch = patArr[patIdxStart + j + 1];\n                    if (ch != '?') {\n                        if (ch != strArr[strIdxStart + i + j]) {\n                            continue strLoop;\n                        }\n                    }\n                }\n                foundIdx = strIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            patIdxStart = patIdxTmp;\n            strIdxStart = foundIdx + patLength;\n        }\n        // All characters in the string are used. Check if only '*'s are left\n        // in the pattern. If so, we succeeded. Otherwise failure.\n        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n            if (patArr[i] != '*') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Given a pattern and a full path, determine the pattern-mapped part.\n     * <p>For example:\n     * <ul>\n     * <li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>\n     * <li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>\n     * <li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/**\\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>\n     * <li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * </ul>\n     * <p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>'\n     * and '<code>path</code>', but does <strong>not</strong> enforce this.\n     */\n    public String extractPathWithinPattern(String pattern, String path) {\n        String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        StringBuffer buffer = new StringBuffer();\n        // Add any path parts that have a wildcarded pattern part.\n        int puts = 0;\n        for (int i = 0; i < patternParts.length; i++) {\n            String patternPart = patternParts[i];\n            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n                    buffer.append(this.pathSeparator);\n                }\n                buffer.append(pathParts[i]);\n                puts++;\n            }\n        }\n        // Append any trailing path parts.\n        for (int i = patternParts.length; i < pathParts.length; i++) {\n            if (puts > 0 || i > 0) {\n                buffer.append(this.pathSeparator);\n            }\n            buffer.append(pathParts[i]);\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/AntPathMatcherTest3.java",
		"test_prompt": "// AntPathMatcherTest3.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntPathMatcher}.\n* It contains ten unit test cases for the {@link AntPathMatcher#matchStart(String, String)} method.\n*/\nclass AntPathMatcherTest3 {"
	},
	{
		"original_code": "// AntPathMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * <p>PathMatcher implementation for Ant-style path patterns.\n * Examples are provided below.</p>\n *\n * <p>Part of this mapping code has been kindly borrowed from\n * <a href=\"http://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>? matches one character</li>\n * <li>* matches zero or more characters</li>\n * <li>** matches zero or more 'directories' in a path</li>\n * </ul>\n *\n * <p>Some examples:<br>\n * <ul>\n * <li><code>com/t?st.jsp</code> - matches <code>com/test.jsp</code> but also\n * <code>com/tast.jsp</code> or <code>com/txst.jsp</code></li>\n * <li><code>com/*.jsp</code> - matches all <code>.jsp</code> files in the\n * <code>com</code> directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> - matches all <code>test.jsp</code>\n * files underneath the <code>com</code> path</li>\n * <li><code>org/jsecurity/&#42;&#42;/*.jsp</code> - matches all <code>.jsp</code>\n * files underneath the <code>org/jsecurity</code> path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> - matches\n * <code>org/jsecurity/servlet/bla.jsp</code> but also\n * <code>org/jsecurity/testing/servlet/bla.jsp</code> and\n * <code>org/servlet/bla.jsp</code></li>\n * </ul>\n *\n * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the\n * <a href=\"http://www.springframework.org\">Spring Framework</a> with modifications.  We didn't want to reinvent the\n * wheel of great work they've done, but also didn't want to force every JSecurity user to depend on Spring</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PatternMatcher {\n\n    //TODO - complete JavaDoc\n    /**\n     * Default path separator: \"/\"\n     */\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    private String pathSeparator = DEFAULT_PATH_SEPARATOR;\n\n    /**\n     * Set the path separator to use for pattern parsing.\n     * Default is \"/\", as in Ant.\n     */\n    public void setPathSeparator(String pathSeparator) {\n        this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n    }\n\n    public boolean isPattern(String path) {\n        return (path.indexOf('*') != -1 || path.indexOf('?') != -1);\n    }\n\n    public boolean matches(String pattern, String source) {\n        return match(pattern, source);\n    }\n\n    public boolean match(String pattern, String path) {\n        return doMatch(pattern, path, true);\n    }\n\n    public boolean matchStart(String pattern, String path) {\n        return doMatch(pattern, path, false);\n    }\n\n    /**\n     * Actually match the given <code>path</code> against the given <code>pattern</code>.\n     *\n     * @param pattern   the pattern to match against\n     * @param path      the path String to test\n     * @param fullMatch whether a full pattern match is required\n     *                  (else a pattern match as far as the given base path goes is sufficient)\n     * @return <code>true</code> if the supplied <code>path</code> matched,\n     *         <code>false</code> if it didn't\n     */\n    protected boolean doMatch(String pattern, String path, boolean fullMatch) {\n        if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n            return false;\n        }\n        String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        int pattIdxStart = 0;\n        int pattIdxEnd = pattDirs.length - 1;\n        int pathIdxStart = 0;\n        int pathIdxEnd = pathDirs.length - 1;\n        // Match all elements up to the first **\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxStart];\n            if (\"**\".equals(patDir)) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxStart])) {\n                return false;\n            }\n            pattIdxStart++;\n            pathIdxStart++;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // Path is exhausted, only match if rest of pattern is * or **'s\n            if (pattIdxStart > pattIdxEnd) {\n                return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));\n            }\n            if (!fullMatch) {\n                return true;\n            }\n            if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n                return true;\n            }\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (pattIdxStart > pattIdxEnd) {\n            // String not exhausted, but pattern is. Failure.\n            return false;\n        } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n            // Path start definitely matches due to \"**\" part in pattern.\n            return true;\n        }\n        // up to last '**'\n        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            String patDir = pattDirs[pattIdxEnd];\n            if (patDir.equals(\"**\")) {\n                break;\n            }\n            if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {\n                return false;\n            }\n            pattIdxEnd--;\n            pathIdxEnd--;\n        }\n        if (pathIdxStart > pathIdxEnd) {\n            // String is exhausted\n            for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n                if (!pattDirs[i].equals(\"**\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n                if (pattDirs[i].equals(\"**\")) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == pattIdxStart + 1) {\n                // '**/**' situation, so skip one\n                pattIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - pattIdxStart - 1);\n            int strLength = (pathIdxEnd - pathIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = (String) pattDirs[pattIdxStart + j + 1];\n                    String subStr = (String) pathDirs[pathIdxStart + i + j];\n                    if (!matchStrings(subPat, subStr)) {\n                        continue strLoop;\n                    }\n                }\n                foundIdx = pathIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            pattIdxStart = patIdxTmp;\n            pathIdxStart = foundIdx + patLength;\n        }\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n            if (!pattDirs[i].equals(\"**\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @return <code>true</code> if the string matches against the\n     *         pattern, or <code>false</code> otherwise.\n     */\n    private boolean matchStrings(String pattern, String str) {\n        char[] patArr = pattern.toCharArray();\n        char[] strArr = str.toCharArray();\n        int patIdxStart = 0;\n        int patIdxEnd = patArr.length - 1;\n        int strIdxStart = 0;\n        int strIdxEnd = strArr.length - 1;\n        char ch;\n        boolean containsStar = false;\n        for (char aPatArr : patArr) {\n            if (aPatArr == '*') {\n                containsStar = true;\n                break;\n            }\n        }\n        if (!containsStar) {\n            // No '*'s, so we make a shortcut\n            if (patIdxEnd != strIdxEnd) {\n                // Pattern and string do not have the same size\n                return false;\n            }\n            for (int i = 0; i <= patIdxEnd; i++) {\n                ch = patArr[i];\n                if (ch != '?') {\n                    if (ch != strArr[i]) {\n                        // Character mismatch\n                        return false;\n                    }\n                }\n            }\n            // String matches against pattern\n            return true;\n        }\n        if (patIdxEnd == 0) {\n            // Pattern contains only '*', which matches anything\n            return true;\n        }\n        // Process characters before first star\n        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxStart]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxStart++;\n            strIdxStart++;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // Process characters after last star\n        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n            if (ch != '?') {\n                if (ch != strArr[strIdxEnd]) {\n                    // Character mismatch\n                    return false;\n                }\n            }\n            patIdxEnd--;\n            strIdxEnd--;\n        }\n        if (strIdxStart > strIdxEnd) {\n            // All characters in the string are used. Check if only '*'s are\n            // left in the pattern. If so, we succeeded. Otherwise failure.\n            for (int i = patIdxStart; i <= patIdxEnd; i++) {\n                if (patArr[i] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // process pattern between stars. padIdxStart and patIdxEnd point\n        // always to a '*'.\n        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n            int patIdxTmp = -1;\n            for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {\n                if (patArr[i] == '*') {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patIdxStart + 1) {\n                // Two stars next to each other, skip the first one.\n                patIdxStart++;\n                continue;\n            }\n            // Find the pattern between padIdxStart & padIdxTmp in str between\n            // strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patIdxStart - 1);\n            int strLength = (strIdxEnd - strIdxStart + 1);\n            int foundIdx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    ch = patArr[patIdxStart + j + 1];\n                    if (ch != '?') {\n                        if (ch != strArr[strIdxStart + i + j]) {\n                            continue strLoop;\n                        }\n                    }\n                }\n                foundIdx = strIdxStart + i;\n                break;\n            }\n            if (foundIdx == -1) {\n                return false;\n            }\n            patIdxStart = patIdxTmp;\n            strIdxStart = foundIdx + patLength;\n        }\n        // All characters in the string are used. Check if only '*'s are left\n        // in the pattern. If so, we succeeded. Otherwise failure.\n        for (int i = patIdxStart; i <= patIdxEnd; i++) {\n            if (patArr[i] != '*') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Given a pattern and a full path, determine the pattern-mapped part.\n     * <p>For example:\n     * <ul>\n     * <li>'<code>/docs/cvs/commit.html</code>' and '<code>/docs/cvs/commit.html</code> -> ''</li>\n     * <li>'<code>/docs/*</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/cvs/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>commit.html</code>'</li>\n     * <li>'<code>/docs/**</code>' and '<code>/docs/cvs/commit</code> -> '<code>cvs/commit</code>'</li>\n     * <li>'<code>/docs/**\\/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>cvs/commit.html</code>'</li>\n     * <li>'<code>/*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*.html</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * <li>'<code>*</code>' and '<code>/docs/cvs/commit.html</code> -> '<code>/docs/cvs/commit.html</code>'</li>\n     * </ul>\n     * <p>Assumes that {@link #match} returns <code>true</code> for '<code>pattern</code>'\n     * and '<code>path</code>', but does <strong>not</strong> enforce this.\n     */\n    public String extractPathWithinPattern(String pattern, String path) {\n        String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);\n        String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);\n        StringBuffer buffer = new StringBuffer();\n        // Add any path parts that have a wildcarded pattern part.\n        int puts = 0;\n        for (int i = 0; i < patternParts.length; i++) {\n            String patternPart = patternParts[i];\n            if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {\n                if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {\n                    buffer.append(this.pathSeparator);\n                }\n                buffer.append(pathParts[i]);\n                puts++;\n            }\n        }\n        // Append any trailing path parts.\n        for (int i = patternParts.length; i < pathParts.length; i++) {\n            if (puts > 0 || i > 0) {\n                buffer.append(this.pathSeparator);\n            }\n            buffer.append(pathParts[i]);\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/AntPathMatcherTest4.java",
		"test_prompt": "// AntPathMatcherTest4.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntPathMatcher}.\n* It contains ten unit test cases for the {@link AntPathMatcher#extractPathWithinPattern(String, String)} method.\n*/\nclass AntPathMatcherTest4 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest0.java",
		"test_prompt": "// ClassUtilsTest0.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#getResourceAsStream(String)} method.\n*/\nclass ClassUtilsTest0 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest1.java",
		"test_prompt": "// ClassUtilsTest1.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#forName(String)} method.\n*/\nclass ClassUtilsTest1 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest2.java",
		"test_prompt": "// ClassUtilsTest2.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#isAvailable(String)} method.\n*/\nclass ClassUtilsTest2 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest3.java",
		"test_prompt": "// ClassUtilsTest3.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#newInstance(String)} method.\n*/\nclass ClassUtilsTest3 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest4.java",
		"test_prompt": "// ClassUtilsTest4.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#newInstance(String, Object[])} method.\n*/\nclass ClassUtilsTest4 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest5.java",
		"test_prompt": "// ClassUtilsTest5.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#newInstance(Class)} method.\n*/\nclass ClassUtilsTest5 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest6.java",
		"test_prompt": "// ClassUtilsTest6.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#newInstance(Class, Object[])} method.\n*/\nclass ClassUtilsTest6 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest7.java",
		"test_prompt": "// ClassUtilsTest7.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#getConstructor(Class, Class[])} method.\n*/\nclass ClassUtilsTest7 {"
	},
	{
		"original_code": "// ClassUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\n\n/**\n * Utility method library used to conveniently interact with <code>Class</code>es, such as acquiring them from the\n * application <code>ClassLoader</code>s and instantiating Objects from them.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class ClassUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ClassUtils.class);\n\n    /**\n     * Returns the specified resource by checking the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order, using\n     * {@link ClassLoader#getResourceAsStream(String) getResourceAsStream(name)}.\n     *\n     * @param name the name of the resource to acquire from the classloader(s).\n     * @return the InputStream of the resource found, or <code>null</code> if the resource cannot be found from any\n     *         of the three mentioned ClassLoaders.\n     * @since 0.9\n     */\n    public static InputStream getResourceAsStream(String name) {\n        InputStream is = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            is = cl.getResourceAsStream(name);\n        }\n        if (is == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resource [\" + name + \"] was not found via the thread context ClassLoader.  Trying the \" + \"current ClassLoader...\");\n            }\n            cl = ClassUtils.class.getClassLoader();\n            is = cl.getResourceAsStream(name);\n            if (is == null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the current class loader.  Trying the \" + \"system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                is = cl.getResourceAsStream(name);\n                if (is == null && log.isTraceEnabled()) {\n                    log.trace(\"Resource [\" + name + \"] was not found via the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.\");\n                }\n            }\n        }\n        return is;\n    }\n\n    /**\n     * Attempts to load the specified class name from the current thread's\n     * {@link Thread#getContextClassLoader() context class loader}, then the\n     * current ClassLoader (<code>ClassUtils.class.getClassLoader()</code>), then the system/application\n     * ClassLoader (<code>ClassLoader.getSystemClassLoader()</code>, in that order.  If any of them cannot locate\n     * the specified class, an <code>UnknownClassException</code> is thrown (our RuntimeException equivalent of\n     * the JRE's <code>ClassNotFoundException</code>.\n     *\n     * @param fqcn the fully qualified class name to load\n     * @return the located class\n     * @throws UnknownClassException if the class cannot be found.\n     */\n    public static Class forName(String fqcn) throws UnknownClassException {\n        Class clazz = null;\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl != null) {\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the thread context ClassLoader.  Trying the current ClassLoader...\");\n                }\n            }\n        }\n        if (clazz == null) {\n            cl = ClassUtils.class.getClassLoader();\n            try {\n                clazz = cl.loadClass(fqcn);\n            } catch (ClassNotFoundException e1) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Unable to load class named [\" + fqcn + \"] from the current ClassLoader.  \" + \"Trying the system/application ClassLoader...\");\n                }\n                cl = ClassLoader.getSystemClassLoader();\n                try {\n                    clazz = cl.loadClass(fqcn);\n                } catch (ClassNotFoundException ignored) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Unable to load class named [\" + fqcn + \"] from the \" + \"system/application ClassLoader.\");\n                    }\n                }\n            }\n        }\n        if (clazz == null) {\n            String msg = \"Unable to load class named [\" + fqcn + \"] from the thread context, current, or \" + \"system/application ClassLoaders.  All heuristics have been exausted.  Class could not be found.\";\n            throw new UnknownClassException(msg);\n        }\n        return clazz;\n    }\n\n    public static boolean isAvailable(String fullyQualifiedClassName) {\n        try {\n            forName(fullyQualifiedClassName);\n            return true;\n        } catch (UnknownClassException e) {\n            return false;\n        }\n    }\n\n    public static Object newInstance(String fqcn) {\n        return newInstance(forName(fqcn));\n    }\n\n    public static Object newInstance(String fqcn, Object... args) {\n        return newInstance(forName(fqcn), args);\n    }\n\n    public static Object newInstance(Class clazz) {\n        if (clazz == null) {\n            String msg = \"Class method parameter cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        try {\n            return clazz.newInstance();\n        } catch (Exception e) {\n            throw new org.jsecurity.util.InstantiationException(\"Unable to instantiate class [\" + clazz.getName() + \"]\", e);\n        }\n    }\n\n    public static Object newInstance(Class clazz, Object... args) {\n        Class[] argTypes = new Class[args.length];\n        for (int i = 0; i < args.length; i++) {\n            argTypes[i] = args[i].getClass();\n        }\n        Constructor ctor = getConstructor(clazz, argTypes);\n        return instantiate(ctor, args);\n    }\n\n    public static Constructor getConstructor(Class clazz, Class... argTypes) {\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static Object instantiate(Constructor ctor, Object... args) {\n        try {\n            return ctor.newInstance(args);\n        } catch (Exception e) {\n            String msg = \"Unable to instantiate Permission instance with constructor [\" + ctor + \"]\";\n            throw new org.jsecurity.util.InstantiationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ClassUtilsTest8.java",
		"test_prompt": "// ClassUtilsTest8.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtils}.\n* It contains ten unit test cases for the {@link ClassUtils#instantiate(Constructor, Object[])} method.\n*/\nclass ClassUtilsTest8 {"
	},
	{
		"original_code": "// CollectionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.util.*;\n\n/**\n * Static helper class for use dealing with Arrays.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class CollectionUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Simple method that just returns <code>Collections.EMPTY_SET</code>.\n     * This exists to enable type-safe empty collections so other locations in JSecurity code\n     * do not need to worry about suppressing warnings.\n     *\n     * @param clazz the class of the collection type to return\n     * @return an empty collection\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Collection<E> emptyCollection(Class<E> clazz) {\n        return Collections.EMPTY_SET;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Set<E> asSet(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_SET;\n        }\n        LinkedHashSet<E> set = new LinkedHashSet<E>(elements.length * 4 / 3 + 1);\n        Collections.addAll(set, elements);\n        return set;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> List<E> asList(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_LIST;\n        }\n        // Avoid integer overflow when a large array is passed in\n        int capacity = computeListCapacity(elements.length);\n        ArrayList<E> list = new ArrayList<E>(capacity);\n        Collections.addAll(list, elements);\n        return list;\n    }\n\n    static int computeListCapacity(int arraySize) {\n        return (int) Math.min(5L + arraySize + (arraySize / 10), Integer.MAX_VALUE);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/CollectionUtilsTest0.java",
		"test_prompt": "// CollectionUtilsTest0.java\npackage org.jsecurity.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CollectionUtils}.\n* It contains ten unit test cases for the {@link CollectionUtils#emptyCollection(Class)} method.\n*/\nclass CollectionUtilsTest0 {"
	},
	{
		"original_code": "// CollectionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.util.*;\n\n/**\n * Static helper class for use dealing with Arrays.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class CollectionUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Simple method that just returns <code>Collections.EMPTY_SET</code>.\n     * This exists to enable type-safe empty collections so other locations in JSecurity code\n     * do not need to worry about suppressing warnings.\n     *\n     * @param clazz the class of the collection type to return\n     * @return an empty collection\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Collection<E> emptyCollection(Class<E> clazz) {\n        return Collections.EMPTY_SET;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Set<E> asSet(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_SET;\n        }\n        LinkedHashSet<E> set = new LinkedHashSet<E>(elements.length * 4 / 3 + 1);\n        Collections.addAll(set, elements);\n        return set;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> List<E> asList(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_LIST;\n        }\n        // Avoid integer overflow when a large array is passed in\n        int capacity = computeListCapacity(elements.length);\n        ArrayList<E> list = new ArrayList<E>(capacity);\n        Collections.addAll(list, elements);\n        return list;\n    }\n\n    static int computeListCapacity(int arraySize) {\n        return (int) Math.min(5L + arraySize + (arraySize / 10), Integer.MAX_VALUE);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/CollectionUtilsTest1.java",
		"test_prompt": "// CollectionUtilsTest1.java\npackage org.jsecurity.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CollectionUtils}.\n* It contains ten unit test cases for the {@link CollectionUtils#asSet(E[])} method.\n*/\nclass CollectionUtilsTest1 {"
	},
	{
		"original_code": "// CollectionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport java.util.*;\n\n/**\n * Static helper class for use dealing with Arrays.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class CollectionUtils {\n\n    //TODO - complete JavaDoc\n    /**\n     * Simple method that just returns <code>Collections.EMPTY_SET</code>.\n     * This exists to enable type-safe empty collections so other locations in JSecurity code\n     * do not need to worry about suppressing warnings.\n     *\n     * @param clazz the class of the collection type to return\n     * @return an empty collection\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Collection<E> emptyCollection(Class<E> clazz) {\n        return Collections.EMPTY_SET;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> Set<E> asSet(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_SET;\n        }\n        LinkedHashSet<E> set = new LinkedHashSet<E>(elements.length * 4 / 3 + 1);\n        Collections.addAll(set, elements);\n        return set;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public static <E> List<E> asList(E... elements) {\n        if (elements == null || elements.length == 0) {\n            return Collections.EMPTY_LIST;\n        }\n        // Avoid integer overflow when a large array is passed in\n        int capacity = computeListCapacity(elements.length);\n        ArrayList<E> list = new ArrayList<E>(capacity);\n        Collections.addAll(list, elements);\n        return list;\n    }\n\n    static int computeListCapacity(int arraySize) {\n        return (int) Math.min(5L + arraySize + (arraySize / 10), Integer.MAX_VALUE);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/CollectionUtilsTest2.java",
		"test_prompt": "// CollectionUtilsTest2.java\npackage org.jsecurity.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CollectionUtils}.\n* It contains ten unit test cases for the {@link CollectionUtils#asList(E[])} method.\n*/\nclass CollectionUtilsTest2 {"
	},
	{
		"original_code": "// JavaEnvironment.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * Internal helper class used to find the Java/JDK version\n * that JSecurity is operating within, to allow for automatically\n * adapting to the present platform's capabilities.\n *\n * <p>Note that JSecurity does not support 1.2 or earlier JVMs - only 1.3 and later.\n *\n * <p><em>This class was borrowed and heavily based upon a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework</a>, with minor modifications.\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Rick Evans for making this available.</em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class JavaEnvironment {\n\n    /**\n     * Constant identifying the 1.3.x JVM (JDK 1.3).\n     */\n    public static final int JAVA_13 = 0;\n\n    /**\n     * Constant identifying the 1.4.x JVM (J2SE 1.4).\n     */\n    public static final int JAVA_14 = 1;\n\n    /**\n     * Constant identifying the 1.5 JVM (Java 5).\n     */\n    public static final int JAVA_15 = 2;\n\n    /**\n     * Constant identifying the 1.6 JVM (Java 6).\n     */\n    public static final int JAVA_16 = 3;\n\n    /**\n     * Constant identifying the 1.7 JVM.\n     */\n    public static final int JAVA_17 = 4;\n\n    /**\n     * The virtual machine version, i.e. <code>System.getProperty(\"java.version\");</code>.\n     */\n    private static final String version;\n\n    /**\n     * The virtual machine <em>major</em> version.  For example, with a <code>version</code> of\n     * <code>1.5.6_10</code>, this would be <code>1.5</code>\n     */\n    private static final int majorVersion;\n\n    /**\n     * Static code initialization block that sets the\n     * <code>version</code> and <code>majorVersion</code> Class constants\n     * upon initialization.\n     */\n    static {\n        version = System.getProperty(\"java.version\");\n        // version String should look like \"1.4.2_10\"\n        if (version.indexOf(\"1.7.\") != -1) {\n            majorVersion = JAVA_17;\n        } else if (version.indexOf(\"1.6.\") != -1) {\n            majorVersion = JAVA_16;\n        } else if (version.indexOf(\"1.5.\") != -1) {\n            majorVersion = JAVA_15;\n        } else if (version.indexOf(\"1.4.\") != -1) {\n            majorVersion = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            majorVersion = JAVA_13;\n        }\n    }\n\n    /**\n     * Return the full Java version string, as returned by\n     * <code>System.getProperty(\"java.version\")</code>.\n     *\n     * @return the full Java version string\n     * @see System#getProperty(String)\n     */\n    public static String getVersion() {\n        return version;\n    }\n\n    /**\n     * Get the major version code. This means we can do things like\n     * <code>if (getMajorVersion() < JAVA_14)</code>.\n     *\n     * @return a code comparable to the JAVA_XX codes in this class\n     * @see #JAVA_13\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least Java 1.4.\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.4\n     * @see #getMajorVersion()\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion14() {\n        return getMajorVersion() >= JAVA_14;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least\n     * Java 1.5 (Java 5).\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.5\n     * @see #getMajorVersion()\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion15() {\n        return getMajorVersion() >= JAVA_15;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/JavaEnvironmentTest0.java",
		"test_prompt": "// JavaEnvironmentTest0.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaEnvironment}.\n* It contains ten unit test cases for the {@link JavaEnvironment#getVersion()} method.\n*/\nclass JavaEnvironmentTest0 {"
	},
	{
		"original_code": "// JavaEnvironment.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * Internal helper class used to find the Java/JDK version\n * that JSecurity is operating within, to allow for automatically\n * adapting to the present platform's capabilities.\n *\n * <p>Note that JSecurity does not support 1.2 or earlier JVMs - only 1.3 and later.\n *\n * <p><em>This class was borrowed and heavily based upon a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework</a>, with minor modifications.\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Rick Evans for making this available.</em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class JavaEnvironment {\n\n    /**\n     * Constant identifying the 1.3.x JVM (JDK 1.3).\n     */\n    public static final int JAVA_13 = 0;\n\n    /**\n     * Constant identifying the 1.4.x JVM (J2SE 1.4).\n     */\n    public static final int JAVA_14 = 1;\n\n    /**\n     * Constant identifying the 1.5 JVM (Java 5).\n     */\n    public static final int JAVA_15 = 2;\n\n    /**\n     * Constant identifying the 1.6 JVM (Java 6).\n     */\n    public static final int JAVA_16 = 3;\n\n    /**\n     * Constant identifying the 1.7 JVM.\n     */\n    public static final int JAVA_17 = 4;\n\n    /**\n     * The virtual machine version, i.e. <code>System.getProperty(\"java.version\");</code>.\n     */\n    private static final String version;\n\n    /**\n     * The virtual machine <em>major</em> version.  For example, with a <code>version</code> of\n     * <code>1.5.6_10</code>, this would be <code>1.5</code>\n     */\n    private static final int majorVersion;\n\n    /**\n     * Static code initialization block that sets the\n     * <code>version</code> and <code>majorVersion</code> Class constants\n     * upon initialization.\n     */\n    static {\n        version = System.getProperty(\"java.version\");\n        // version String should look like \"1.4.2_10\"\n        if (version.indexOf(\"1.7.\") != -1) {\n            majorVersion = JAVA_17;\n        } else if (version.indexOf(\"1.6.\") != -1) {\n            majorVersion = JAVA_16;\n        } else if (version.indexOf(\"1.5.\") != -1) {\n            majorVersion = JAVA_15;\n        } else if (version.indexOf(\"1.4.\") != -1) {\n            majorVersion = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            majorVersion = JAVA_13;\n        }\n    }\n\n    /**\n     * Return the full Java version string, as returned by\n     * <code>System.getProperty(\"java.version\")</code>.\n     *\n     * @return the full Java version string\n     * @see System#getProperty(String)\n     */\n    public static String getVersion() {\n        return version;\n    }\n\n    /**\n     * Get the major version code. This means we can do things like\n     * <code>if (getMajorVersion() < JAVA_14)</code>.\n     *\n     * @return a code comparable to the JAVA_XX codes in this class\n     * @see #JAVA_13\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least Java 1.4.\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.4\n     * @see #getMajorVersion()\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion14() {\n        return getMajorVersion() >= JAVA_14;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least\n     * Java 1.5 (Java 5).\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.5\n     * @see #getMajorVersion()\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion15() {\n        return getMajorVersion() >= JAVA_15;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/JavaEnvironmentTest1.java",
		"test_prompt": "// JavaEnvironmentTest1.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaEnvironment}.\n* It contains ten unit test cases for the {@link JavaEnvironment#getMajorVersion()} method.\n*/\nclass JavaEnvironmentTest1 {"
	},
	{
		"original_code": "// JavaEnvironment.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * Internal helper class used to find the Java/JDK version\n * that JSecurity is operating within, to allow for automatically\n * adapting to the present platform's capabilities.\n *\n * <p>Note that JSecurity does not support 1.2 or earlier JVMs - only 1.3 and later.\n *\n * <p><em>This class was borrowed and heavily based upon a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework</a>, with minor modifications.\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Rick Evans for making this available.</em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class JavaEnvironment {\n\n    /**\n     * Constant identifying the 1.3.x JVM (JDK 1.3).\n     */\n    public static final int JAVA_13 = 0;\n\n    /**\n     * Constant identifying the 1.4.x JVM (J2SE 1.4).\n     */\n    public static final int JAVA_14 = 1;\n\n    /**\n     * Constant identifying the 1.5 JVM (Java 5).\n     */\n    public static final int JAVA_15 = 2;\n\n    /**\n     * Constant identifying the 1.6 JVM (Java 6).\n     */\n    public static final int JAVA_16 = 3;\n\n    /**\n     * Constant identifying the 1.7 JVM.\n     */\n    public static final int JAVA_17 = 4;\n\n    /**\n     * The virtual machine version, i.e. <code>System.getProperty(\"java.version\");</code>.\n     */\n    private static final String version;\n\n    /**\n     * The virtual machine <em>major</em> version.  For example, with a <code>version</code> of\n     * <code>1.5.6_10</code>, this would be <code>1.5</code>\n     */\n    private static final int majorVersion;\n\n    /**\n     * Static code initialization block that sets the\n     * <code>version</code> and <code>majorVersion</code> Class constants\n     * upon initialization.\n     */\n    static {\n        version = System.getProperty(\"java.version\");\n        // version String should look like \"1.4.2_10\"\n        if (version.indexOf(\"1.7.\") != -1) {\n            majorVersion = JAVA_17;\n        } else if (version.indexOf(\"1.6.\") != -1) {\n            majorVersion = JAVA_16;\n        } else if (version.indexOf(\"1.5.\") != -1) {\n            majorVersion = JAVA_15;\n        } else if (version.indexOf(\"1.4.\") != -1) {\n            majorVersion = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            majorVersion = JAVA_13;\n        }\n    }\n\n    /**\n     * Return the full Java version string, as returned by\n     * <code>System.getProperty(\"java.version\")</code>.\n     *\n     * @return the full Java version string\n     * @see System#getProperty(String)\n     */\n    public static String getVersion() {\n        return version;\n    }\n\n    /**\n     * Get the major version code. This means we can do things like\n     * <code>if (getMajorVersion() < JAVA_14)</code>.\n     *\n     * @return a code comparable to the JAVA_XX codes in this class\n     * @see #JAVA_13\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least Java 1.4.\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.4\n     * @see #getMajorVersion()\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion14() {\n        return getMajorVersion() >= JAVA_14;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least\n     * Java 1.5 (Java 5).\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.5\n     * @see #getMajorVersion()\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion15() {\n        return getMajorVersion() >= JAVA_15;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/JavaEnvironmentTest2.java",
		"test_prompt": "// JavaEnvironmentTest2.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaEnvironment}.\n* It contains ten unit test cases for the {@link JavaEnvironment#isAtLeastVersion14()} method.\n*/\nclass JavaEnvironmentTest2 {"
	},
	{
		"original_code": "// JavaEnvironment.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\n/**\n * Internal helper class used to find the Java/JDK version\n * that JSecurity is operating within, to allow for automatically\n * adapting to the present platform's capabilities.\n *\n * <p>Note that JSecurity does not support 1.2 or earlier JVMs - only 1.3 and later.\n *\n * <p><em>This class was borrowed and heavily based upon a nearly identical version found in\n * the <a href=\"http://www.springframework.org/\">Spring Framework</a>, with minor modifications.\n * The original author names and copyright (Apache 2.0) has been left in place.  A special\n * thanks to Rod Johnson, Juergen Hoeller, and Rick Evans for making this available.</em>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class JavaEnvironment {\n\n    /**\n     * Constant identifying the 1.3.x JVM (JDK 1.3).\n     */\n    public static final int JAVA_13 = 0;\n\n    /**\n     * Constant identifying the 1.4.x JVM (J2SE 1.4).\n     */\n    public static final int JAVA_14 = 1;\n\n    /**\n     * Constant identifying the 1.5 JVM (Java 5).\n     */\n    public static final int JAVA_15 = 2;\n\n    /**\n     * Constant identifying the 1.6 JVM (Java 6).\n     */\n    public static final int JAVA_16 = 3;\n\n    /**\n     * Constant identifying the 1.7 JVM.\n     */\n    public static final int JAVA_17 = 4;\n\n    /**\n     * The virtual machine version, i.e. <code>System.getProperty(\"java.version\");</code>.\n     */\n    private static final String version;\n\n    /**\n     * The virtual machine <em>major</em> version.  For example, with a <code>version</code> of\n     * <code>1.5.6_10</code>, this would be <code>1.5</code>\n     */\n    private static final int majorVersion;\n\n    /**\n     * Static code initialization block that sets the\n     * <code>version</code> and <code>majorVersion</code> Class constants\n     * upon initialization.\n     */\n    static {\n        version = System.getProperty(\"java.version\");\n        // version String should look like \"1.4.2_10\"\n        if (version.indexOf(\"1.7.\") != -1) {\n            majorVersion = JAVA_17;\n        } else if (version.indexOf(\"1.6.\") != -1) {\n            majorVersion = JAVA_16;\n        } else if (version.indexOf(\"1.5.\") != -1) {\n            majorVersion = JAVA_15;\n        } else if (version.indexOf(\"1.4.\") != -1) {\n            majorVersion = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            majorVersion = JAVA_13;\n        }\n    }\n\n    /**\n     * Return the full Java version string, as returned by\n     * <code>System.getProperty(\"java.version\")</code>.\n     *\n     * @return the full Java version string\n     * @see System#getProperty(String)\n     */\n    public static String getVersion() {\n        return version;\n    }\n\n    /**\n     * Get the major version code. This means we can do things like\n     * <code>if (getMajorVersion() < JAVA_14)</code>.\n     *\n     * @return a code comparable to the JAVA_XX codes in this class\n     * @see #JAVA_13\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least Java 1.4.\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.4\n     * @see #getMajorVersion()\n     * @see #JAVA_14\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion14() {\n        return getMajorVersion() >= JAVA_14;\n    }\n\n    /**\n     * Convenience method to determine if the current JVM is at least\n     * Java 1.5 (Java 5).\n     *\n     * @return <code>true</code> if the current JVM is at least Java 1.5\n     * @see #getMajorVersion()\n     * @see #JAVA_15\n     * @see #JAVA_16\n     * @see #JAVA_17\n     */\n    public static boolean isAtLeastVersion15() {\n        return getMajorVersion() >= JAVA_15;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/JavaEnvironmentTest3.java",
		"test_prompt": "// JavaEnvironmentTest3.java\npackage org.jsecurity.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaEnvironment}.\n* It contains ten unit test cases for the {@link JavaEnvironment#isAtLeastVersion15()} method.\n*/\nclass JavaEnvironmentTest3 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest0.java",
		"test_prompt": "// ThreadContextTest0.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#get(Object)} method.\n*/\nclass ThreadContextTest0 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest1.java",
		"test_prompt": "// ThreadContextTest1.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#remove(Object)} method.\n*/\nclass ThreadContextTest1 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest2.java",
		"test_prompt": "// ThreadContextTest2.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#containsKey(Object)} method.\n*/\nclass ThreadContextTest2 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest3.java",
		"test_prompt": "// ThreadContextTest3.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#getSecurityManager()} method.\n*/\nclass ThreadContextTest3 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest4.java",
		"test_prompt": "// ThreadContextTest4.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#unbindSecurityManager()} method.\n*/\nclass ThreadContextTest4 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest5.java",
		"test_prompt": "// ThreadContextTest5.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#getSubject()} method.\n*/\nclass ThreadContextTest5 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest6.java",
		"test_prompt": "// ThreadContextTest6.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#unbindSubject()} method.\n*/\nclass ThreadContextTest6 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest7.java",
		"test_prompt": "// ThreadContextTest7.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#getInetAddress()} method.\n*/\nclass ThreadContextTest7 {"
	},
	{
		"original_code": "// ThreadContext.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A ThreadContext provides a means of binding and unbinding objects to the\n * current thread based on key/value pairs.\n *\n * <p>An internal {@link java.util.HashMap} is used to maintain the key/value pairs\n * for each thread.</p>\n *\n * <p>If the desired behavior is to ensure that bound data is not shared across\n * threads in a pooled or reusable threaded environment, the application (or more likely a framework) must\n * bind and remove any necessary values at the beginning and end of stack\n * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>\n *\n * @author Les Hazlewood\n * @see #clear()\n * @since 0.1\n */\n@SuppressWarnings(value = { \"unchecked\", \"unsafe\" })\npublic abstract class ThreadContext {\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ThreadContext.class);\n\n    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + \"_SECURITY_MANAGER_KEY\";\n\n    public static final String SUBJECT_KEY = ThreadContext.class.getName() + \"_SUBJECT_KEY\";\n\n    public static final String INET_ADDRESS_KEY = ThreadContext.class.getName() + \"_INET_ADDRESS_KEY\";\n\n    protected static ThreadLocal<Map<Object, Object>> resources = new InheritableThreadLocal<Map<Object, Object>>() {\n\n        protected Map<Object, Object> initialValue() {\n            return new HashMap<Object, Object>();\n        }\n\n        /**\n         * This implementation was added to address a\n         * <a href=\"http://jsecurity.markmail.org/search/?q=#query:+page:1+mid:xqi2yxurwmrpqrvj+state:results\">\n         * user-reported issue</a>.\n         * @param parentValue the parent value, a HashMap as defined in the {@link #initialValue()} method.\n         * @return the HashMap to be used by any parent-spawned child threads (a clone of the parent HashMap).\n         */\n        protected Map<Object, Object> childValue(Map<Object, Object> parentValue) {\n            if (parentValue != null) {\n                return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();\n            } else {\n                return null;\n            }\n        }\n    };\n\n    /**\n     * Default no-argument constructor.\n     */\n    protected ThreadContext() {\n    }\n\n    /**\n     * Returns the ThreadLocal Map. This Map is used internally to bind objects\n     * to the current thread by storing each object under a unique key.\n     *\n     * @return the map of bound resources\n     */\n    protected static Map<Object, Object> getResources() {\n        return resources.get();\n    }\n\n    /**\n     * Returns the object for the specified <code>key</code> that is bound to\n     * the current thread.\n     *\n     * @param key the key that identifies the value to return\n     * @return the object keyed by <code>key</code> or <code>null</code> if\n     *         no value exists for the specified <code>key</code>\n     */\n    public static Object get(Object key) {\n        if (log.isTraceEnabled()) {\n            String msg = \"get() - in thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        Object value = getResources().get(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Retrieved value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] \" + \"bound to thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Binds <tt>value</tt> for the given <code>key</code> to the current thread.\n     *\n     * <p>A <tt>null</tt> <tt>value</tt> has the same effect as if <tt>remove</tt> was called for the given\n     * <tt>key</tt>, i.e.:\n     *\n     * <pre>\n     * if ( value == null ) {\n     *     remove( key );\n     * }</pre>\n     *\n     * @param key   The key with which to identify the <code>value</code>.\n     * @param value The value to bind to the thread.\n     * @throws IllegalArgumentException if the <code>key</code> argument is <tt>null</tt>.\n     */\n    public static void put(Object key, Object value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key cannot be null\");\n        }\n        if (value == null) {\n            remove(key);\n            return;\n        }\n        getResources().put(key, value);\n        if (log.isTraceEnabled()) {\n            String msg = \"Bound value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"] to thread \" + \"[\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n    }\n\n    /**\n     * Unbinds the value for the given <code>key</code> from the current\n     * thread.\n     *\n     * @param key The key identifying the value bound to the current thread.\n     * @return the object unbound or <tt>null</tt> if there was nothing bound\n     *         under the specified <tt>key</tt> name.\n     */\n    public static Object remove(Object key) {\n        Object value = getResources().remove(key);\n        if ((value != null) && log.isTraceEnabled()) {\n            String msg = \"Removed value of type [\" + value.getClass().getName() + \"] for key [\" + key + \"]\" + \"from thread [\" + Thread.currentThread().getName() + \"]\";\n            log.trace(msg);\n        }\n        return value;\n    }\n\n    /**\n     * Returns true if a value for the <code>key</code> is bound to the current thread, false otherwise.\n     *\n     * @param key the key that may identify a value bound to the current thread.\n     * @return true if a value for the key is bound to the current thread, false\n     *         otherwise.\n     */\n    public static boolean containsKey(Object key) {\n        return getResources().containsKey(key);\n    }\n\n    /**\n     * Removes <em>all</em> values bound to this ThreadContext, which includes any Subject, Session, or InetAddress\n     * that may be bound by these respective objects' conveninece methods, as well as all values bound by your\n     * application code.\n     *\n     * <p>This operation is meant as a clean-up operation that may be called at the end of\n     * thread execution to prevent data corruption in a pooled thread environment.\n     */\n    public static void clear() {\n        getResources().clear();\n        if (log.isTraceEnabled()) {\n            log.trace(\"Removed all ThreadContext values from thread [\" + Thread.currentThread().getName() + \"]\");\n        }\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of the application's SecurityManager instance from the current\n     * thread. If there is no SecurityManager bound to the thread (probably because framework code did not bind it\n     * to the thread), this method returns <tt>null</tt>.\n     * <p/>\n     * It is merely a convenient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)get( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSecurityManager() unbindSecurityManager()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.9\n     */\n    public static SecurityManager getSecurityManager() {\n        return (SecurityManager) get(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding the application's SecurityManager instance to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the SecurityManager is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (securityManager != null) {\n     *     put( SECURITY_MANAGER_KEY, securityManager);\n     * }</pre>\n     *\n     * @param securityManager the application's SecurityManager instance to bind to the thread.  If the argument is\n     *                        null, nothing will be done.\n     * @since 0.9\n     */\n    public static void bind(SecurityManager securityManager) {\n        if (securityManager != null) {\n            put(SECURITY_MANAGER_KEY, securityManager);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later\n     * during thread execution), use the {@link #getSecurityManager() getSecurityManager()} method instead.\n     *\n     * @return the application's SecurityManager instance previously bound to the thread, or <tt>null</tt> if there\n     *         was none bound.\n     * @since 0.9\n     */\n    public static SecurityManager unbindSecurityManager() {\n        return (SecurityManager) remove(SECURITY_MANAGER_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound Subject.  If there is no\n     * Subject bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (Subject)get( SUBJECT_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindSubject() unbindSubject()} instead.\n     *\n     * @return the Subject object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static Subject getSubject() {\n        return (Subject) get(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding a Subject to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the Subject is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (subject != null) {\n     *     put( SUBJECT_KEY, subject );\n     * }</pre>\n     *\n     * @param subject the Subject object to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(Subject subject) {\n        if (subject != null) {\n            put(SUBJECT_KEY, subject);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local Subject from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (Subject)remove( SUBJECT_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getSubject() getSubject()} method for that purpose.\n     *\n     * @return the Subject object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static Subject unbindSubject() {\n        return (Subject) remove(SUBJECT_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a thread-bound InetAddress.  If there is no\n     * InetAddress bound to the thread, this method returns <tt>null</tt>.  It is merely a convenient wrapper\n     * for the following:\n     * <p/>\n     * <code>return (InetAddress)get( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindInetAddress() unbindInetAddress} instead.\n     *\n     * @return the InetAddress object bound to the thread, or <tt>null</tt> if there isn't one bound.\n     * @since 0.2\n     */\n    public static InetAddress getInetAddress() {\n        return (InetAddress) get(INET_ADDRESS_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies binding an InetAddress to the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the inetAddress is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (inetAddress != null) {\n     *     put( INET_ADDRESS_KEY, inetAddress );\n     * }</pre>\n     *\n     * @param inetAddress the InetAddress to bind to the thread.  If the argument is null, nothing will be done.\n     * @since 0.2\n     */\n    public static void bind(InetAddress inetAddress) {\n        if (inetAddress != null) {\n            put(INET_ADDRESS_KEY, inetAddress);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local InetAddress from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (InetAddress)remove( INET_ADDRESS_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getInetAddress() getInetAddress()} method for that purpose.\n     *\n     * @return the InetAddress object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     * @since 0.2\n     */\n    public static InetAddress unbindInetAddress() {\n        return (InetAddress) remove(INET_ADDRESS_KEY);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/ThreadContextTest8.java",
		"test_prompt": "// ThreadContextTest8.java\npackage org.jsecurity.util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport java.net.InetAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThreadContext}.\n* It contains ten unit test cases for the {@link ThreadContext#unbindInetAddress()} method.\n*/\nclass ThreadContextTest8 {"
	},
	{
		"original_code": "// PermissionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * TODO - comlete JavaDoc\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class PermissionUtils {\n\n    public static Set<Permission> resolveDelimitedPermissions(String s, PermissionResolver permissionResolver) {\n        Set<String> permStrings = toPermissionStrings(s);\n        return resolvePermissions(permStrings, permissionResolver);\n    }\n\n    public static Set<String> toPermissionStrings(String permissionsString) {\n        String[] tokens = StringUtils.split(permissionsString);\n        if (tokens != null && tokens.length > 0) {\n            return new LinkedHashSet<String>(Arrays.asList(tokens));\n        }\n        return null;\n    }\n\n    public static Set<Permission> resolvePermissions(Collection<String> permissionStrings, PermissionResolver permissionResolver) {\n        Set<Permission> permissions = new LinkedHashSet<Permission>(permissionStrings.size());\n        for (String permissionString : permissionStrings) {\n            permissions.add(permissionResolver.resolvePermission(permissionString));\n        }\n        return permissions;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/PermissionUtilsTest0.java",
		"test_prompt": "// PermissionUtilsTest0.java\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PermissionUtils}.\n* It contains ten unit test cases for the {@link PermissionUtils#resolveDelimitedPermissions(String, PermissionResolver)} method.\n*/\nclass PermissionUtilsTest0 {"
	},
	{
		"original_code": "// PermissionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * TODO - comlete JavaDoc\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class PermissionUtils {\n\n    public static Set<Permission> resolveDelimitedPermissions(String s, PermissionResolver permissionResolver) {\n        Set<String> permStrings = toPermissionStrings(s);\n        return resolvePermissions(permStrings, permissionResolver);\n    }\n\n    public static Set<String> toPermissionStrings(String permissionsString) {\n        String[] tokens = StringUtils.split(permissionsString);\n        if (tokens != null && tokens.length > 0) {\n            return new LinkedHashSet<String>(Arrays.asList(tokens));\n        }\n        return null;\n    }\n\n    public static Set<Permission> resolvePermissions(Collection<String> permissionStrings, PermissionResolver permissionResolver) {\n        Set<Permission> permissions = new LinkedHashSet<Permission>(permissionStrings.size());\n        for (String permissionString : permissionStrings) {\n            permissions.add(permissionResolver.resolvePermission(permissionString));\n        }\n        return permissions;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/PermissionUtilsTest1.java",
		"test_prompt": "// PermissionUtilsTest1.java\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PermissionUtils}.\n* It contains ten unit test cases for the {@link PermissionUtils#toPermissionStrings(String)} method.\n*/\nclass PermissionUtilsTest1 {"
	},
	{
		"original_code": "// PermissionUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * TODO - comlete JavaDoc\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class PermissionUtils {\n\n    public static Set<Permission> resolveDelimitedPermissions(String s, PermissionResolver permissionResolver) {\n        Set<String> permStrings = toPermissionStrings(s);\n        return resolvePermissions(permStrings, permissionResolver);\n    }\n\n    public static Set<String> toPermissionStrings(String permissionsString) {\n        String[] tokens = StringUtils.split(permissionsString);\n        if (tokens != null && tokens.length > 0) {\n            return new LinkedHashSet<String>(Arrays.asList(tokens));\n        }\n        return null;\n    }\n\n    public static Set<Permission> resolvePermissions(Collection<String> permissionStrings, PermissionResolver permissionResolver) {\n        Set<Permission> permissions = new LinkedHashSet<Permission>(permissionStrings.size());\n        for (String permissionString : permissionStrings) {\n            permissions.add(permissionResolver.resolvePermission(permissionString));\n        }\n        return permissions;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/util/PermissionUtilsTest2.java",
		"test_prompt": "// PermissionUtilsTest2.java\npackage org.jsecurity.util;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PermissionUtils}.\n* It contains ten unit test cases for the {@link PermissionUtils#resolvePermissions(Collection, PermissionResolver)} method.\n*/\nclass PermissionUtilsTest2 {"
	},
	{
		"original_code": "// ReflectionBuilder.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.config;\r\n\r\nimport org.apache.commons.beanutils.BeanUtils;\r\nimport org.apache.commons.beanutils.PropertyUtils;\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.util.ClassUtils;\r\nimport org.jsecurity.util.Nameable;\r\nimport java.beans.PropertyDescriptor;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a\r\n * map of \"property values\".  Typically these come from the JSecurity INI configuration and are used\r\n * to construct or modify the SecurityManager, its dependencies, and web-based security filters.\r\n *\r\n * @author Les Hazlewood\r\n * @author Jeremy Haile\r\n * @since 0.9\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic class ReflectionBuilder {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(ReflectionBuilder.class);\r\n\r\n    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = \"$\";\r\n\r\n    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = \"\\\\$\";\r\n\r\n    private static final String GLOBAL_PROPERTY_PREFIX = \"jsecurity\";\r\n\r\n    protected Map objects;\r\n\r\n    public ReflectionBuilder() {\r\n        setObjects(new LinkedHashMap<String, Object>());\r\n    }\r\n\r\n    public ReflectionBuilder(Map defaults) {\r\n        setObjects(defaults);\r\n    }\r\n\r\n    public Map getObjects() {\r\n        return objects;\r\n    }\r\n\r\n    public void setObjects(Map objects) {\r\n        this.objects = objects;\r\n    }\r\n\r\n    public Map buildObjects(Map<String, String> kvPairs) {\r\n        if (kvPairs != null && !kvPairs.isEmpty()) {\r\n            // Separate key value pairs into object declarations and property assignment\r\n            // so that all objects can be created up front\r\n            Map<String, String> instanceMap = new HashMap<String, String>();\r\n            Map<String, String> propertyMap = new HashMap<String, String>();\r\n            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {\r\n                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(\".class\")) {\r\n                    instanceMap.put(entry.getKey(), entry.getValue());\r\n                } else {\r\n                    propertyMap.put(entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n            // Create all instances\r\n            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {\r\n                createNewInstance(objects, entry.getKey(), entry.getValue());\r\n            }\r\n            // Set all properties\r\n            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {\r\n                applyProperty(entry.getKey(), entry.getValue(), objects);\r\n            }\r\n        }\r\n        return objects;\r\n    }\r\n\r\n    protected void createNewInstance(Map objects, String name, String value) {\r\n        Object currentInstance = objects.get(name);\r\n        if (currentInstance != null) {\r\n            log.info(\"An instance with name [\" + name + \"] already exists.  \" + \"Redefining this object as a new instance of type [\" + value + \"].\");\r\n        }\r\n        //name with no property, assume right hand side of equals sign is the class name:\r\n        Object instance;\r\n        try {\r\n            instance = ClassUtils.newInstance(value);\r\n            if (instance instanceof Nameable) {\r\n                ((Nameable) instance).setName(name);\r\n            }\r\n        } catch (Exception e) {\r\n            String msg = \"Unable to instantiate class [\" + value + \"] for object named '\" + name + \"'.  \" + \"Please ensure you've specified the fully qualified class name correctly.\";\r\n            throw new ConfigurationException(msg, e);\r\n        }\r\n        objects.put(name, instance);\r\n    }\r\n\r\n    protected void applyProperty(String key, String value, Map objects) {\r\n        int index = key.indexOf('.');\r\n        if (index >= 0) {\r\n            String name = key.substring(0, index);\r\n            String property = key.substring(index + 1, key.length());\r\n            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {\r\n                applyGlobalProperty(objects, property, value);\r\n            } else {\r\n                applySingleProperty(objects, name, property, value);\r\n            }\r\n        } else {\r\n            throw new IllegalArgumentException(\"All property keys must contain a '.' character. \" + \"(e.g. myBean.property = value)  These should already be separated out by buildObjects().\");\r\n        }\r\n    }\r\n\r\n    protected void applyGlobalProperty(Map objects, String property, String value) {\r\n        for (Object instance : objects.values()) {\r\n            try {\r\n                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);\r\n                if (pd != null) {\r\n                    applyProperty(instance, property, value);\r\n                }\r\n            } catch (Exception e) {\r\n                String msg = \"Error retrieving property descriptor for instance \" + \"of type [\" + instance.getClass().getName() + \"] \" + \"while setting property [\" + property + \"]\";\r\n                throw new ConfigurationException(msg, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void applySingleProperty(Map objects, String name, String property, String value) {\r\n        Object instance = objects.get(name);\r\n        if (property.equals(\"class\")) {\r\n            throw new IllegalArgumentException(\"Property keys should not contain 'class' properties since these \" + \"should already be separated out by buildObjects().\");\r\n        } else if (instance == null) {\r\n            String msg = \"Configuration error.  Specified object [\" + name + \"] with property [\" + property + \"] without first defining that object's class.  Please first \" + \"specify the class property first, e.g. myObject.class = fully_qualified_class_name \" + \"and then define additional properties.\";\r\n            throw new IllegalArgumentException(msg);\r\n        } else {\r\n            applyProperty(instance, property, value);\r\n        }\r\n    }\r\n\r\n    protected boolean isReference(String value) {\r\n        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);\r\n    }\r\n\r\n    protected String getId(String referenceToken) {\r\n        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());\r\n    }\r\n\r\n    protected Object getReferencedObject(String id) {\r\n        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;\r\n        if (o == null) {\r\n            String msg = \"The object with id [\" + id + \"] has not yet been defined and therefore cannot be \" + \"referenced.  Please ensure objects are defined in the order in which they should be \" + \"created and made avaialable for future reference.\";\r\n            throw new UnresolveableReferenceException(msg);\r\n        }\r\n        return o;\r\n    }\r\n\r\n    protected String unescapeIfNecessary(String value) {\r\n        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {\r\n            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    protected void applyProperty(Object object, String propertyName, String stringValue) {\r\n        Object value;\r\n        if (isReference(stringValue)) {\r\n            String id = getId(stringValue);\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Encountered object reference [\" + stringValue + \"].  Looking up object \" + \"with id [\" + id + \"]\");\r\n            }\r\n            value = getReferencedObject(id);\r\n        } else {\r\n            value = unescapeIfNecessary(stringValue);\r\n        }\r\n        try {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Applying property [\" + propertyName + \"] value [\" + value + \"] on object of type [\" + object.getClass().getName() + \"]\");\r\n            }\r\n            BeanUtils.setProperty(object, propertyName, value);\r\n        } catch (Exception e) {\r\n            String msg = \"Unable to set property [\" + propertyName + \"] with value [\" + stringValue + \"].  If \" + \"'\" + stringValue + \"' is a reference to another (previously defined) object, please prefix it with \" + \"'\" + OBJECT_REFERENCE_BEGIN_TOKEN + \"' to indicate that the referenced \" + \"object should be used as the actual value.  \" + \"For example, \" + OBJECT_REFERENCE_BEGIN_TOKEN + stringValue;\r\n            throw new ConfigurationException(msg, e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/config/ReflectionBuilderTest.java",
		"test_prompt": "// ReflectionBuilderTest.java\npackage org.jsecurity.config;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport org.jsecurity.util.Nameable;\nimport java.beans.PropertyDescriptor;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReflectionBuilder}.\n* It contains ten unit test cases for the {@link ReflectionBuilder#buildObjects(Map)} method.\n*/\nclass ReflectionBuilderTest {"
	},
	{
		"original_code": "// JSecurityHttpServletResponse.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\n/**\n * HttpServletResponse implementation to support URL Encoding of JSecurity Session IDs.\n *\n * It is only used when using JSecurity's native Session Management configuration (and not when using the Servlet\n * Container session configuration, which is JSecurity's default in a web environment).  Because the servlet container\n * already performs url encoding of its own session ids, instances of this class are only needed when using JSecurity\n * native sessions.\n *\n * <p>Note that this implementation relies in part on source code from the Tomcat 6.x distribution for\n * encoding URLs for session ID URL Rewriting (we didn't want to re-invent the wheel).  Since JSecurity is also\n * Apache 2.0 license, all regular licenses and conditions have remained in tact.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletResponse extends HttpServletResponseWrapper {\n\n    //TODO - complete JavaDoc\n    private static final String DEFAULT_SESSION_ID_PARAMETER_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    private ServletContext context = null;\n\n    //the associated request\n    private JSecurityHttpServletRequest request = null;\n\n    public JSecurityHttpServletResponse(HttpServletResponse wrapped, ServletContext context, JSecurityHttpServletRequest request) {\n        super(wrapped);\n        this.context = context;\n        this.request = request;\n    }\n\n    public ServletContext getContext() {\n        return context;\n    }\n\n    public void setContext(ServletContext context) {\n        this.context = context;\n    }\n\n    public JSecurityHttpServletRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(JSecurityHttpServletRequest request) {\n        this.request = request;\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified redirect URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeRedirectURL(String url) {\n        if (isEncodeable(toAbsolute(url))) {\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeRedirectUrl(String s) {\n        return encodeRedirectURL(s);\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeURL(String url) {\n        String absolute = toAbsolute(url);\n        if (isEncodeable(absolute)) {\n            // W3c spec clearly said\n            if (url.equalsIgnoreCase(\"\")) {\n                url = absolute;\n            }\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeUrl(String s) {\n        return encodeURL(s);\n    }\n\n    /**\n     * Return <code>true</code> if the specified URL should be encoded with\n     * a session identifier.  This will be true if all of the following\n     * conditions are met:\n     * <ul>\n     * <li>The request we are responding to asked for a valid session\n     * <li>The requested session ID was not received via a cookie\n     * <li>The specified URL points back to somewhere within the web\n     * application that is responding to this request\n     * </ul>\n     *\n     * @param location Absolute URL to be validated\n     */\n    protected boolean isEncodeable(final String location) {\n        if (location == null)\n            return (false);\n        // Is this an intra-document reference?\n        if (location.startsWith(\"#\"))\n            return (false);\n        // Are we in a valid session that is not using cookies?\n        final HttpServletRequest hreq = request;\n        final HttpSession session = hreq.getSession(false);\n        if (session == null)\n            return (false);\n        if (hreq.isRequestedSessionIdFromCookie())\n            return (false);\n        return doIsEncodeable(hreq, session, location);\n    }\n\n    private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location) {\n        // Is this a valid absolute URL?\n        URL url = null;\n        try {\n            url = new URL(location);\n        } catch (MalformedURLException e) {\n            return (false);\n        }\n        // Does this URL match down to (and including) the context path?\n        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))\n            return (false);\n        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))\n            return (false);\n        int serverPort = hreq.getServerPort();\n        if (serverPort == -1) {\n            if (\"https\".equals(hreq.getScheme()))\n                serverPort = 443;\n            else\n                serverPort = 80;\n        }\n        int urlPort = url.getPort();\n        if (urlPort == -1) {\n            if (\"https\".equals(url.getProtocol()))\n                urlPort = 443;\n            else\n                urlPort = 80;\n        }\n        if (serverPort != urlPort)\n            return (false);\n        String contextPath = getRequest().getContextPath();\n        if (contextPath != null) {\n            String file = url.getFile();\n            if ((file == null) || !file.startsWith(contextPath))\n                return (false);\n            String tok = \";\" + DEFAULT_SESSION_ID_PARAMETER_NAME + \"=\" + session.getId();\n            if (file.indexOf(tok, contextPath.length()) >= 0)\n                return (false);\n        }\n        // This URL belongs to our web application, so it is encodeable\n        return (true);\n    }\n\n    /**\n     * Convert (if necessary) and return the absolute URL that represents the\n     * resource referenced by this possibly relative URL.  If this URL is\n     * already absolute, return it unchanged.\n     *\n     * @param location URL to be (possibly) converted and then returned\n     * @throws IllegalArgumentException if a MalformedURLException is\n     *                                  thrown when converting the relative URL to an absolute one\n     */\n    private String toAbsolute(String location) {\n        if (location == null)\n            return (location);\n        boolean leadingSlash = location.startsWith(\"/\");\n        if (leadingSlash || !hasScheme(location)) {\n            StringBuffer buf = new StringBuffer();\n            String scheme = request.getScheme();\n            String name = request.getServerName();\n            int port = request.getServerPort();\n            try {\n                buf.append(scheme).append(\"://\").append(name);\n                if ((scheme.equals(\"http\") && port != 80) || (scheme.equals(\"https\") && port != 443)) {\n                    buf.append(':').append(port);\n                }\n                if (!leadingSlash) {\n                    String relativePath = request.getRequestURI();\n                    int pos = relativePath.lastIndexOf('/');\n                    relativePath = relativePath.substring(0, pos);\n                    String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());\n                    buf.append(encodedURI).append('/');\n                }\n                buf.append(location);\n            } catch (IOException e) {\n                IllegalArgumentException iae = new IllegalArgumentException(location);\n                iae.initCause(e);\n                throw iae;\n            }\n            return buf.toString();\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Determine if the character is allowed in the scheme of a URI.\n     * See RFC 2396, Section 3.1\n     */\n    public static boolean isSchemeChar(char c) {\n        return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';\n    }\n\n    /**\n     * Determine if a URI string has a <code>scheme</code> component.\n     */\n    private boolean hasScheme(String uri) {\n        int len = uri.length();\n        for (int i = 0; i < len; i++) {\n            char c = uri.charAt(i);\n            if (c == ':') {\n                return i > 0;\n            } else if (!isSchemeChar(c)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the specified URL with the specified session identifier\n     * suitably encoded.\n     *\n     * @param url       URL to be encoded with the session id\n     * @param sessionId Session id to be included in the encoded URL\n     */\n    protected String toEncoded(String url, String sessionId) {\n        if ((url == null) || (sessionId == null))\n            return (url);\n        String path = url;\n        String query = \"\";\n        String anchor = \"\";\n        int question = url.indexOf('?');\n        if (question >= 0) {\n            path = url.substring(0, question);\n            query = url.substring(question);\n        }\n        int pound = path.indexOf('#');\n        if (pound >= 0) {\n            anchor = path.substring(pound);\n            path = path.substring(0, pound);\n        }\n        StringBuffer sb = new StringBuffer(path);\n        if (sb.length() > 0) {\n            // jsessionid can't be first.\n            sb.append(\";\");\n            sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);\n            sb.append(\"=\");\n            sb.append(sessionId);\n        }\n        sb.append(anchor);\n        sb.append(query);\n        return (sb.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletResponseTest0.java",
		"test_prompt": "// JSecurityHttpServletResponseTest0.java\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletResponse}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletResponse#encodeRedirectURL(String)} method.\n*/\nclass JSecurityHttpServletResponseTest0 {"
	},
	{
		"original_code": "// JSecurityHttpServletResponse.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\n/**\n * HttpServletResponse implementation to support URL Encoding of JSecurity Session IDs.\n *\n * It is only used when using JSecurity's native Session Management configuration (and not when using the Servlet\n * Container session configuration, which is JSecurity's default in a web environment).  Because the servlet container\n * already performs url encoding of its own session ids, instances of this class are only needed when using JSecurity\n * native sessions.\n *\n * <p>Note that this implementation relies in part on source code from the Tomcat 6.x distribution for\n * encoding URLs for session ID URL Rewriting (we didn't want to re-invent the wheel).  Since JSecurity is also\n * Apache 2.0 license, all regular licenses and conditions have remained in tact.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletResponse extends HttpServletResponseWrapper {\n\n    //TODO - complete JavaDoc\n    private static final String DEFAULT_SESSION_ID_PARAMETER_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    private ServletContext context = null;\n\n    //the associated request\n    private JSecurityHttpServletRequest request = null;\n\n    public JSecurityHttpServletResponse(HttpServletResponse wrapped, ServletContext context, JSecurityHttpServletRequest request) {\n        super(wrapped);\n        this.context = context;\n        this.request = request;\n    }\n\n    public ServletContext getContext() {\n        return context;\n    }\n\n    public void setContext(ServletContext context) {\n        this.context = context;\n    }\n\n    public JSecurityHttpServletRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(JSecurityHttpServletRequest request) {\n        this.request = request;\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified redirect URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeRedirectURL(String url) {\n        if (isEncodeable(toAbsolute(url))) {\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeRedirectUrl(String s) {\n        return encodeRedirectURL(s);\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeURL(String url) {\n        String absolute = toAbsolute(url);\n        if (isEncodeable(absolute)) {\n            // W3c spec clearly said\n            if (url.equalsIgnoreCase(\"\")) {\n                url = absolute;\n            }\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeUrl(String s) {\n        return encodeURL(s);\n    }\n\n    /**\n     * Return <code>true</code> if the specified URL should be encoded with\n     * a session identifier.  This will be true if all of the following\n     * conditions are met:\n     * <ul>\n     * <li>The request we are responding to asked for a valid session\n     * <li>The requested session ID was not received via a cookie\n     * <li>The specified URL points back to somewhere within the web\n     * application that is responding to this request\n     * </ul>\n     *\n     * @param location Absolute URL to be validated\n     */\n    protected boolean isEncodeable(final String location) {\n        if (location == null)\n            return (false);\n        // Is this an intra-document reference?\n        if (location.startsWith(\"#\"))\n            return (false);\n        // Are we in a valid session that is not using cookies?\n        final HttpServletRequest hreq = request;\n        final HttpSession session = hreq.getSession(false);\n        if (session == null)\n            return (false);\n        if (hreq.isRequestedSessionIdFromCookie())\n            return (false);\n        return doIsEncodeable(hreq, session, location);\n    }\n\n    private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location) {\n        // Is this a valid absolute URL?\n        URL url = null;\n        try {\n            url = new URL(location);\n        } catch (MalformedURLException e) {\n            return (false);\n        }\n        // Does this URL match down to (and including) the context path?\n        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))\n            return (false);\n        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))\n            return (false);\n        int serverPort = hreq.getServerPort();\n        if (serverPort == -1) {\n            if (\"https\".equals(hreq.getScheme()))\n                serverPort = 443;\n            else\n                serverPort = 80;\n        }\n        int urlPort = url.getPort();\n        if (urlPort == -1) {\n            if (\"https\".equals(url.getProtocol()))\n                urlPort = 443;\n            else\n                urlPort = 80;\n        }\n        if (serverPort != urlPort)\n            return (false);\n        String contextPath = getRequest().getContextPath();\n        if (contextPath != null) {\n            String file = url.getFile();\n            if ((file == null) || !file.startsWith(contextPath))\n                return (false);\n            String tok = \";\" + DEFAULT_SESSION_ID_PARAMETER_NAME + \"=\" + session.getId();\n            if (file.indexOf(tok, contextPath.length()) >= 0)\n                return (false);\n        }\n        // This URL belongs to our web application, so it is encodeable\n        return (true);\n    }\n\n    /**\n     * Convert (if necessary) and return the absolute URL that represents the\n     * resource referenced by this possibly relative URL.  If this URL is\n     * already absolute, return it unchanged.\n     *\n     * @param location URL to be (possibly) converted and then returned\n     * @throws IllegalArgumentException if a MalformedURLException is\n     *                                  thrown when converting the relative URL to an absolute one\n     */\n    private String toAbsolute(String location) {\n        if (location == null)\n            return (location);\n        boolean leadingSlash = location.startsWith(\"/\");\n        if (leadingSlash || !hasScheme(location)) {\n            StringBuffer buf = new StringBuffer();\n            String scheme = request.getScheme();\n            String name = request.getServerName();\n            int port = request.getServerPort();\n            try {\n                buf.append(scheme).append(\"://\").append(name);\n                if ((scheme.equals(\"http\") && port != 80) || (scheme.equals(\"https\") && port != 443)) {\n                    buf.append(':').append(port);\n                }\n                if (!leadingSlash) {\n                    String relativePath = request.getRequestURI();\n                    int pos = relativePath.lastIndexOf('/');\n                    relativePath = relativePath.substring(0, pos);\n                    String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());\n                    buf.append(encodedURI).append('/');\n                }\n                buf.append(location);\n            } catch (IOException e) {\n                IllegalArgumentException iae = new IllegalArgumentException(location);\n                iae.initCause(e);\n                throw iae;\n            }\n            return buf.toString();\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Determine if the character is allowed in the scheme of a URI.\n     * See RFC 2396, Section 3.1\n     */\n    public static boolean isSchemeChar(char c) {\n        return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';\n    }\n\n    /**\n     * Determine if a URI string has a <code>scheme</code> component.\n     */\n    private boolean hasScheme(String uri) {\n        int len = uri.length();\n        for (int i = 0; i < len; i++) {\n            char c = uri.charAt(i);\n            if (c == ':') {\n                return i > 0;\n            } else if (!isSchemeChar(c)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the specified URL with the specified session identifier\n     * suitably encoded.\n     *\n     * @param url       URL to be encoded with the session id\n     * @param sessionId Session id to be included in the encoded URL\n     */\n    protected String toEncoded(String url, String sessionId) {\n        if ((url == null) || (sessionId == null))\n            return (url);\n        String path = url;\n        String query = \"\";\n        String anchor = \"\";\n        int question = url.indexOf('?');\n        if (question >= 0) {\n            path = url.substring(0, question);\n            query = url.substring(question);\n        }\n        int pound = path.indexOf('#');\n        if (pound >= 0) {\n            anchor = path.substring(pound);\n            path = path.substring(0, pound);\n        }\n        StringBuffer sb = new StringBuffer(path);\n        if (sb.length() > 0) {\n            // jsessionid can't be first.\n            sb.append(\";\");\n            sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);\n            sb.append(\"=\");\n            sb.append(sessionId);\n        }\n        sb.append(anchor);\n        sb.append(query);\n        return (sb.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletResponseTest1.java",
		"test_prompt": "// JSecurityHttpServletResponseTest1.java\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletResponse}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletResponse#encodeRedirectUrl(String)} method.\n*/\nclass JSecurityHttpServletResponseTest1 {"
	},
	{
		"original_code": "// JSecurityHttpServletResponse.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\n/**\n * HttpServletResponse implementation to support URL Encoding of JSecurity Session IDs.\n *\n * It is only used when using JSecurity's native Session Management configuration (and not when using the Servlet\n * Container session configuration, which is JSecurity's default in a web environment).  Because the servlet container\n * already performs url encoding of its own session ids, instances of this class are only needed when using JSecurity\n * native sessions.\n *\n * <p>Note that this implementation relies in part on source code from the Tomcat 6.x distribution for\n * encoding URLs for session ID URL Rewriting (we didn't want to re-invent the wheel).  Since JSecurity is also\n * Apache 2.0 license, all regular licenses and conditions have remained in tact.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletResponse extends HttpServletResponseWrapper {\n\n    //TODO - complete JavaDoc\n    private static final String DEFAULT_SESSION_ID_PARAMETER_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    private ServletContext context = null;\n\n    //the associated request\n    private JSecurityHttpServletRequest request = null;\n\n    public JSecurityHttpServletResponse(HttpServletResponse wrapped, ServletContext context, JSecurityHttpServletRequest request) {\n        super(wrapped);\n        this.context = context;\n        this.request = request;\n    }\n\n    public ServletContext getContext() {\n        return context;\n    }\n\n    public void setContext(ServletContext context) {\n        this.context = context;\n    }\n\n    public JSecurityHttpServletRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(JSecurityHttpServletRequest request) {\n        this.request = request;\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified redirect URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeRedirectURL(String url) {\n        if (isEncodeable(toAbsolute(url))) {\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeRedirectUrl(String s) {\n        return encodeRedirectURL(s);\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeURL(String url) {\n        String absolute = toAbsolute(url);\n        if (isEncodeable(absolute)) {\n            // W3c spec clearly said\n            if (url.equalsIgnoreCase(\"\")) {\n                url = absolute;\n            }\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeUrl(String s) {\n        return encodeURL(s);\n    }\n\n    /**\n     * Return <code>true</code> if the specified URL should be encoded with\n     * a session identifier.  This will be true if all of the following\n     * conditions are met:\n     * <ul>\n     * <li>The request we are responding to asked for a valid session\n     * <li>The requested session ID was not received via a cookie\n     * <li>The specified URL points back to somewhere within the web\n     * application that is responding to this request\n     * </ul>\n     *\n     * @param location Absolute URL to be validated\n     */\n    protected boolean isEncodeable(final String location) {\n        if (location == null)\n            return (false);\n        // Is this an intra-document reference?\n        if (location.startsWith(\"#\"))\n            return (false);\n        // Are we in a valid session that is not using cookies?\n        final HttpServletRequest hreq = request;\n        final HttpSession session = hreq.getSession(false);\n        if (session == null)\n            return (false);\n        if (hreq.isRequestedSessionIdFromCookie())\n            return (false);\n        return doIsEncodeable(hreq, session, location);\n    }\n\n    private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location) {\n        // Is this a valid absolute URL?\n        URL url = null;\n        try {\n            url = new URL(location);\n        } catch (MalformedURLException e) {\n            return (false);\n        }\n        // Does this URL match down to (and including) the context path?\n        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))\n            return (false);\n        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))\n            return (false);\n        int serverPort = hreq.getServerPort();\n        if (serverPort == -1) {\n            if (\"https\".equals(hreq.getScheme()))\n                serverPort = 443;\n            else\n                serverPort = 80;\n        }\n        int urlPort = url.getPort();\n        if (urlPort == -1) {\n            if (\"https\".equals(url.getProtocol()))\n                urlPort = 443;\n            else\n                urlPort = 80;\n        }\n        if (serverPort != urlPort)\n            return (false);\n        String contextPath = getRequest().getContextPath();\n        if (contextPath != null) {\n            String file = url.getFile();\n            if ((file == null) || !file.startsWith(contextPath))\n                return (false);\n            String tok = \";\" + DEFAULT_SESSION_ID_PARAMETER_NAME + \"=\" + session.getId();\n            if (file.indexOf(tok, contextPath.length()) >= 0)\n                return (false);\n        }\n        // This URL belongs to our web application, so it is encodeable\n        return (true);\n    }\n\n    /**\n     * Convert (if necessary) and return the absolute URL that represents the\n     * resource referenced by this possibly relative URL.  If this URL is\n     * already absolute, return it unchanged.\n     *\n     * @param location URL to be (possibly) converted and then returned\n     * @throws IllegalArgumentException if a MalformedURLException is\n     *                                  thrown when converting the relative URL to an absolute one\n     */\n    private String toAbsolute(String location) {\n        if (location == null)\n            return (location);\n        boolean leadingSlash = location.startsWith(\"/\");\n        if (leadingSlash || !hasScheme(location)) {\n            StringBuffer buf = new StringBuffer();\n            String scheme = request.getScheme();\n            String name = request.getServerName();\n            int port = request.getServerPort();\n            try {\n                buf.append(scheme).append(\"://\").append(name);\n                if ((scheme.equals(\"http\") && port != 80) || (scheme.equals(\"https\") && port != 443)) {\n                    buf.append(':').append(port);\n                }\n                if (!leadingSlash) {\n                    String relativePath = request.getRequestURI();\n                    int pos = relativePath.lastIndexOf('/');\n                    relativePath = relativePath.substring(0, pos);\n                    String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());\n                    buf.append(encodedURI).append('/');\n                }\n                buf.append(location);\n            } catch (IOException e) {\n                IllegalArgumentException iae = new IllegalArgumentException(location);\n                iae.initCause(e);\n                throw iae;\n            }\n            return buf.toString();\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Determine if the character is allowed in the scheme of a URI.\n     * See RFC 2396, Section 3.1\n     */\n    public static boolean isSchemeChar(char c) {\n        return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';\n    }\n\n    /**\n     * Determine if a URI string has a <code>scheme</code> component.\n     */\n    private boolean hasScheme(String uri) {\n        int len = uri.length();\n        for (int i = 0; i < len; i++) {\n            char c = uri.charAt(i);\n            if (c == ':') {\n                return i > 0;\n            } else if (!isSchemeChar(c)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the specified URL with the specified session identifier\n     * suitably encoded.\n     *\n     * @param url       URL to be encoded with the session id\n     * @param sessionId Session id to be included in the encoded URL\n     */\n    protected String toEncoded(String url, String sessionId) {\n        if ((url == null) || (sessionId == null))\n            return (url);\n        String path = url;\n        String query = \"\";\n        String anchor = \"\";\n        int question = url.indexOf('?');\n        if (question >= 0) {\n            path = url.substring(0, question);\n            query = url.substring(question);\n        }\n        int pound = path.indexOf('#');\n        if (pound >= 0) {\n            anchor = path.substring(pound);\n            path = path.substring(0, pound);\n        }\n        StringBuffer sb = new StringBuffer(path);\n        if (sb.length() > 0) {\n            // jsessionid can't be first.\n            sb.append(\";\");\n            sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);\n            sb.append(\"=\");\n            sb.append(sessionId);\n        }\n        sb.append(anchor);\n        sb.append(query);\n        return (sb.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletResponseTest2.java",
		"test_prompt": "// JSecurityHttpServletResponseTest2.java\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletResponse}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletResponse#encodeURL(String)} method.\n*/\nclass JSecurityHttpServletResponseTest2 {"
	},
	{
		"original_code": "// JSecurityHttpServletResponse.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\n/**\n * HttpServletResponse implementation to support URL Encoding of JSecurity Session IDs.\n *\n * It is only used when using JSecurity's native Session Management configuration (and not when using the Servlet\n * Container session configuration, which is JSecurity's default in a web environment).  Because the servlet container\n * already performs url encoding of its own session ids, instances of this class are only needed when using JSecurity\n * native sessions.\n *\n * <p>Note that this implementation relies in part on source code from the Tomcat 6.x distribution for\n * encoding URLs for session ID URL Rewriting (we didn't want to re-invent the wheel).  Since JSecurity is also\n * Apache 2.0 license, all regular licenses and conditions have remained in tact.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletResponse extends HttpServletResponseWrapper {\n\n    //TODO - complete JavaDoc\n    private static final String DEFAULT_SESSION_ID_PARAMETER_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    private ServletContext context = null;\n\n    //the associated request\n    private JSecurityHttpServletRequest request = null;\n\n    public JSecurityHttpServletResponse(HttpServletResponse wrapped, ServletContext context, JSecurityHttpServletRequest request) {\n        super(wrapped);\n        this.context = context;\n        this.request = request;\n    }\n\n    public ServletContext getContext() {\n        return context;\n    }\n\n    public void setContext(ServletContext context) {\n        this.context = context;\n    }\n\n    public JSecurityHttpServletRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(JSecurityHttpServletRequest request) {\n        this.request = request;\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified redirect URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeRedirectURL(String url) {\n        if (isEncodeable(toAbsolute(url))) {\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeRedirectUrl(String s) {\n        return encodeRedirectURL(s);\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeURL(String url) {\n        String absolute = toAbsolute(url);\n        if (isEncodeable(absolute)) {\n            // W3c spec clearly said\n            if (url.equalsIgnoreCase(\"\")) {\n                url = absolute;\n            }\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeUrl(String s) {\n        return encodeURL(s);\n    }\n\n    /**\n     * Return <code>true</code> if the specified URL should be encoded with\n     * a session identifier.  This will be true if all of the following\n     * conditions are met:\n     * <ul>\n     * <li>The request we are responding to asked for a valid session\n     * <li>The requested session ID was not received via a cookie\n     * <li>The specified URL points back to somewhere within the web\n     * application that is responding to this request\n     * </ul>\n     *\n     * @param location Absolute URL to be validated\n     */\n    protected boolean isEncodeable(final String location) {\n        if (location == null)\n            return (false);\n        // Is this an intra-document reference?\n        if (location.startsWith(\"#\"))\n            return (false);\n        // Are we in a valid session that is not using cookies?\n        final HttpServletRequest hreq = request;\n        final HttpSession session = hreq.getSession(false);\n        if (session == null)\n            return (false);\n        if (hreq.isRequestedSessionIdFromCookie())\n            return (false);\n        return doIsEncodeable(hreq, session, location);\n    }\n\n    private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location) {\n        // Is this a valid absolute URL?\n        URL url = null;\n        try {\n            url = new URL(location);\n        } catch (MalformedURLException e) {\n            return (false);\n        }\n        // Does this URL match down to (and including) the context path?\n        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))\n            return (false);\n        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))\n            return (false);\n        int serverPort = hreq.getServerPort();\n        if (serverPort == -1) {\n            if (\"https\".equals(hreq.getScheme()))\n                serverPort = 443;\n            else\n                serverPort = 80;\n        }\n        int urlPort = url.getPort();\n        if (urlPort == -1) {\n            if (\"https\".equals(url.getProtocol()))\n                urlPort = 443;\n            else\n                urlPort = 80;\n        }\n        if (serverPort != urlPort)\n            return (false);\n        String contextPath = getRequest().getContextPath();\n        if (contextPath != null) {\n            String file = url.getFile();\n            if ((file == null) || !file.startsWith(contextPath))\n                return (false);\n            String tok = \";\" + DEFAULT_SESSION_ID_PARAMETER_NAME + \"=\" + session.getId();\n            if (file.indexOf(tok, contextPath.length()) >= 0)\n                return (false);\n        }\n        // This URL belongs to our web application, so it is encodeable\n        return (true);\n    }\n\n    /**\n     * Convert (if necessary) and return the absolute URL that represents the\n     * resource referenced by this possibly relative URL.  If this URL is\n     * already absolute, return it unchanged.\n     *\n     * @param location URL to be (possibly) converted and then returned\n     * @throws IllegalArgumentException if a MalformedURLException is\n     *                                  thrown when converting the relative URL to an absolute one\n     */\n    private String toAbsolute(String location) {\n        if (location == null)\n            return (location);\n        boolean leadingSlash = location.startsWith(\"/\");\n        if (leadingSlash || !hasScheme(location)) {\n            StringBuffer buf = new StringBuffer();\n            String scheme = request.getScheme();\n            String name = request.getServerName();\n            int port = request.getServerPort();\n            try {\n                buf.append(scheme).append(\"://\").append(name);\n                if ((scheme.equals(\"http\") && port != 80) || (scheme.equals(\"https\") && port != 443)) {\n                    buf.append(':').append(port);\n                }\n                if (!leadingSlash) {\n                    String relativePath = request.getRequestURI();\n                    int pos = relativePath.lastIndexOf('/');\n                    relativePath = relativePath.substring(0, pos);\n                    String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());\n                    buf.append(encodedURI).append('/');\n                }\n                buf.append(location);\n            } catch (IOException e) {\n                IllegalArgumentException iae = new IllegalArgumentException(location);\n                iae.initCause(e);\n                throw iae;\n            }\n            return buf.toString();\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Determine if the character is allowed in the scheme of a URI.\n     * See RFC 2396, Section 3.1\n     */\n    public static boolean isSchemeChar(char c) {\n        return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';\n    }\n\n    /**\n     * Determine if a URI string has a <code>scheme</code> component.\n     */\n    private boolean hasScheme(String uri) {\n        int len = uri.length();\n        for (int i = 0; i < len; i++) {\n            char c = uri.charAt(i);\n            if (c == ':') {\n                return i > 0;\n            } else if (!isSchemeChar(c)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the specified URL with the specified session identifier\n     * suitably encoded.\n     *\n     * @param url       URL to be encoded with the session id\n     * @param sessionId Session id to be included in the encoded URL\n     */\n    protected String toEncoded(String url, String sessionId) {\n        if ((url == null) || (sessionId == null))\n            return (url);\n        String path = url;\n        String query = \"\";\n        String anchor = \"\";\n        int question = url.indexOf('?');\n        if (question >= 0) {\n            path = url.substring(0, question);\n            query = url.substring(question);\n        }\n        int pound = path.indexOf('#');\n        if (pound >= 0) {\n            anchor = path.substring(pound);\n            path = path.substring(0, pound);\n        }\n        StringBuffer sb = new StringBuffer(path);\n        if (sb.length() > 0) {\n            // jsessionid can't be first.\n            sb.append(\";\");\n            sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);\n            sb.append(\"=\");\n            sb.append(sessionId);\n        }\n        sb.append(anchor);\n        sb.append(query);\n        return (sb.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletResponseTest3.java",
		"test_prompt": "// JSecurityHttpServletResponseTest3.java\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletResponse}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletResponse#encodeUrl(String)} method.\n*/\nclass JSecurityHttpServletResponseTest3 {"
	},
	{
		"original_code": "// JSecurityHttpServletResponse.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\n/**\n * HttpServletResponse implementation to support URL Encoding of JSecurity Session IDs.\n *\n * It is only used when using JSecurity's native Session Management configuration (and not when using the Servlet\n * Container session configuration, which is JSecurity's default in a web environment).  Because the servlet container\n * already performs url encoding of its own session ids, instances of this class are only needed when using JSecurity\n * native sessions.\n *\n * <p>Note that this implementation relies in part on source code from the Tomcat 6.x distribution for\n * encoding URLs for session ID URL Rewriting (we didn't want to re-invent the wheel).  Since JSecurity is also\n * Apache 2.0 license, all regular licenses and conditions have remained in tact.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletResponse extends HttpServletResponseWrapper {\n\n    //TODO - complete JavaDoc\n    private static final String DEFAULT_SESSION_ID_PARAMETER_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    private ServletContext context = null;\n\n    //the associated request\n    private JSecurityHttpServletRequest request = null;\n\n    public JSecurityHttpServletResponse(HttpServletResponse wrapped, ServletContext context, JSecurityHttpServletRequest request) {\n        super(wrapped);\n        this.context = context;\n        this.request = request;\n    }\n\n    public ServletContext getContext() {\n        return context;\n    }\n\n    public void setContext(ServletContext context) {\n        this.context = context;\n    }\n\n    public JSecurityHttpServletRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(JSecurityHttpServletRequest request) {\n        this.request = request;\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified redirect URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeRedirectURL(String url) {\n        if (isEncodeable(toAbsolute(url))) {\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeRedirectUrl(String s) {\n        return encodeRedirectURL(s);\n    }\n\n    /**\n     * Encode the session identifier associated with this response\n     * into the specified URL, if necessary.\n     *\n     * @param url URL to be encoded\n     */\n    public String encodeURL(String url) {\n        String absolute = toAbsolute(url);\n        if (isEncodeable(absolute)) {\n            // W3c spec clearly said\n            if (url.equalsIgnoreCase(\"\")) {\n                url = absolute;\n            }\n            return toEncoded(url, request.getSession().getId());\n        } else {\n            return url;\n        }\n    }\n\n    public String encodeUrl(String s) {\n        return encodeURL(s);\n    }\n\n    /**\n     * Return <code>true</code> if the specified URL should be encoded with\n     * a session identifier.  This will be true if all of the following\n     * conditions are met:\n     * <ul>\n     * <li>The request we are responding to asked for a valid session\n     * <li>The requested session ID was not received via a cookie\n     * <li>The specified URL points back to somewhere within the web\n     * application that is responding to this request\n     * </ul>\n     *\n     * @param location Absolute URL to be validated\n     */\n    protected boolean isEncodeable(final String location) {\n        if (location == null)\n            return (false);\n        // Is this an intra-document reference?\n        if (location.startsWith(\"#\"))\n            return (false);\n        // Are we in a valid session that is not using cookies?\n        final HttpServletRequest hreq = request;\n        final HttpSession session = hreq.getSession(false);\n        if (session == null)\n            return (false);\n        if (hreq.isRequestedSessionIdFromCookie())\n            return (false);\n        return doIsEncodeable(hreq, session, location);\n    }\n\n    private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location) {\n        // Is this a valid absolute URL?\n        URL url = null;\n        try {\n            url = new URL(location);\n        } catch (MalformedURLException e) {\n            return (false);\n        }\n        // Does this URL match down to (and including) the context path?\n        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))\n            return (false);\n        if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))\n            return (false);\n        int serverPort = hreq.getServerPort();\n        if (serverPort == -1) {\n            if (\"https\".equals(hreq.getScheme()))\n                serverPort = 443;\n            else\n                serverPort = 80;\n        }\n        int urlPort = url.getPort();\n        if (urlPort == -1) {\n            if (\"https\".equals(url.getProtocol()))\n                urlPort = 443;\n            else\n                urlPort = 80;\n        }\n        if (serverPort != urlPort)\n            return (false);\n        String contextPath = getRequest().getContextPath();\n        if (contextPath != null) {\n            String file = url.getFile();\n            if ((file == null) || !file.startsWith(contextPath))\n                return (false);\n            String tok = \";\" + DEFAULT_SESSION_ID_PARAMETER_NAME + \"=\" + session.getId();\n            if (file.indexOf(tok, contextPath.length()) >= 0)\n                return (false);\n        }\n        // This URL belongs to our web application, so it is encodeable\n        return (true);\n    }\n\n    /**\n     * Convert (if necessary) and return the absolute URL that represents the\n     * resource referenced by this possibly relative URL.  If this URL is\n     * already absolute, return it unchanged.\n     *\n     * @param location URL to be (possibly) converted and then returned\n     * @throws IllegalArgumentException if a MalformedURLException is\n     *                                  thrown when converting the relative URL to an absolute one\n     */\n    private String toAbsolute(String location) {\n        if (location == null)\n            return (location);\n        boolean leadingSlash = location.startsWith(\"/\");\n        if (leadingSlash || !hasScheme(location)) {\n            StringBuffer buf = new StringBuffer();\n            String scheme = request.getScheme();\n            String name = request.getServerName();\n            int port = request.getServerPort();\n            try {\n                buf.append(scheme).append(\"://\").append(name);\n                if ((scheme.equals(\"http\") && port != 80) || (scheme.equals(\"https\") && port != 443)) {\n                    buf.append(':').append(port);\n                }\n                if (!leadingSlash) {\n                    String relativePath = request.getRequestURI();\n                    int pos = relativePath.lastIndexOf('/');\n                    relativePath = relativePath.substring(0, pos);\n                    String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());\n                    buf.append(encodedURI).append('/');\n                }\n                buf.append(location);\n            } catch (IOException e) {\n                IllegalArgumentException iae = new IllegalArgumentException(location);\n                iae.initCause(e);\n                throw iae;\n            }\n            return buf.toString();\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Determine if the character is allowed in the scheme of a URI.\n     * See RFC 2396, Section 3.1\n     */\n    public static boolean isSchemeChar(char c) {\n        return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';\n    }\n\n    /**\n     * Determine if a URI string has a <code>scheme</code> component.\n     */\n    private boolean hasScheme(String uri) {\n        int len = uri.length();\n        for (int i = 0; i < len; i++) {\n            char c = uri.charAt(i);\n            if (c == ':') {\n                return i > 0;\n            } else if (!isSchemeChar(c)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the specified URL with the specified session identifier\n     * suitably encoded.\n     *\n     * @param url       URL to be encoded with the session id\n     * @param sessionId Session id to be included in the encoded URL\n     */\n    protected String toEncoded(String url, String sessionId) {\n        if ((url == null) || (sessionId == null))\n            return (url);\n        String path = url;\n        String query = \"\";\n        String anchor = \"\";\n        int question = url.indexOf('?');\n        if (question >= 0) {\n            path = url.substring(0, question);\n            query = url.substring(question);\n        }\n        int pound = path.indexOf('#');\n        if (pound >= 0) {\n            anchor = path.substring(pound);\n            path = path.substring(0, pound);\n        }\n        StringBuffer sb = new StringBuffer(path);\n        if (sb.length() > 0) {\n            // jsessionid can't be first.\n            sb.append(\";\");\n            sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);\n            sb.append(\"=\");\n            sb.append(sessionId);\n        }\n        sb.append(anchor);\n        sb.append(query);\n        return (sb.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletResponseTest4.java",
		"test_prompt": "// JSecurityHttpServletResponseTest4.java\npackage org.jsecurity.web.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletResponse}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletResponse#isSchemeChar(char)} method.\n*/\nclass JSecurityHttpServletResponseTest4 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest0.java",
		"test_prompt": "// JSecurityHttpServletRequestTest0.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isHttpSessions()} method.\n*/\nclass JSecurityHttpServletRequestTest0 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest1.java",
		"test_prompt": "// JSecurityHttpServletRequestTest1.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isUserInRole(String)} method.\n*/\nclass JSecurityHttpServletRequestTest1 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest2.java",
		"test_prompt": "// JSecurityHttpServletRequestTest2.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isRequestedSessionIdValid()} method.\n*/\nclass JSecurityHttpServletRequestTest2 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest3.java",
		"test_prompt": "// JSecurityHttpServletRequestTest3.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isRequestedSessionIdFromCookie()} method.\n*/\nclass JSecurityHttpServletRequestTest3 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest4.java",
		"test_prompt": "// JSecurityHttpServletRequestTest4.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isRequestedSessionIdFromURL()} method.\n*/\nclass JSecurityHttpServletRequestTest4 {"
	},
	{
		"original_code": "// JSecurityHttpServletRequest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecated\", \"deprecation\" })\npublic class JSecurityHttpServletRequest extends HttpServletRequestWrapper {\n\n    //TODO - complete JavaDoc\n    //The following 7 constants support the JSecurity's implementation of the Servlet Specification\n    public static final String COOKIE_SESSION_ID_SOURCE = \"cookie\";\n\n    public static final String URL_SESSION_ID_SOURCE = \"url\";\n\n    public static final String REFERENCED_SESSION_ID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID\";\n\n    public static final String REFERENCED_SESSION_ID_IS_VALID = JSecurityHttpServletRequest.class.getName() + \"_REQUESTED_SESSION_ID_VALID\";\n\n    public static final String REFERENCED_SESSION_IS_NEW = JSecurityHttpServletRequest.class.getName() + \"_REFERENCED_SESSION_IS_NEW\";\n\n    public static final String REFERENCED_SESSION_ID_SOURCE = JSecurityHttpServletRequest.class.getName() + \"REFERENCED_SESSION_ID_SOURCE\";\n\n    public static final String SESSION_ID_NAME = JSecurityHttpSession.DEFAULT_SESSION_ID_NAME;\n\n    /**\n     * Key that may be used to alert that the request's  referenced JSecurity Session has expired prior to\n     * request processing.\n     */\n    public static final String EXPIRED_SESSION_KEY = JSecurityHttpServletRequest.class.getName() + \"_EXPIRED_SESSION_KEY\";\n\n    protected ServletContext servletContext = null;\n\n    protected HttpSession session = null;\n\n    protected boolean httpSessions = true;\n\n    public JSecurityHttpServletRequest(HttpServletRequest wrapped, ServletContext servletContext, boolean httpSessions) {\n        super(wrapped);\n        this.servletContext = servletContext;\n        this.httpSessions = httpSessions;\n    }\n\n    public boolean isHttpSessions() {\n        return httpSessions;\n    }\n\n    public String getRemoteUser() {\n        String remoteUser;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof String) {\n                return (String) scPrincipal;\n            } else if (scPrincipal instanceof Principal) {\n                remoteUser = ((Principal) scPrincipal).getName();\n            } else {\n                remoteUser = scPrincipal.toString();\n            }\n        } else {\n            remoteUser = super.getRemoteUser();\n        }\n        return remoteUser;\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected Object getSubjectPrincipal() {\n        Object userPrincipal = null;\n        Subject subject = getSubject();\n        if (subject != null) {\n            userPrincipal = subject.getPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public boolean isUserInRole(String s) {\n        Subject subject = getSubject();\n        boolean inRole = (subject != null && subject.hasRole(s));\n        if (!inRole) {\n            inRole = super.isUserInRole(s);\n        }\n        return inRole;\n    }\n\n    public Principal getUserPrincipal() {\n        Principal userPrincipal;\n        Object scPrincipal = getSubjectPrincipal();\n        if (scPrincipal != null) {\n            if (scPrincipal instanceof Principal) {\n                userPrincipal = (Principal) scPrincipal;\n            } else {\n                userPrincipal = new ObjectPrincipal(scPrincipal);\n            }\n        } else {\n            userPrincipal = super.getUserPrincipal();\n        }\n        return userPrincipal;\n    }\n\n    public String getRequestedSessionId() {\n        String requestedSessionId = null;\n        if (isHttpSessions()) {\n            requestedSessionId = super.getRequestedSessionId();\n        } else {\n            Object sessionId = getAttribute(REFERENCED_SESSION_ID);\n            if (sessionId != null) {\n                requestedSessionId = sessionId.toString();\n            }\n        }\n        return requestedSessionId;\n    }\n\n    public HttpSession getSession(boolean create) {\n        HttpSession httpSession;\n        if (isHttpSessions()) {\n            httpSession = super.getSession(create);\n        } else {\n            if (this.session == null) {\n                boolean existing = getSubject().getSession(false) != null;\n                Session jsecSession = getSubject().getSession(create);\n                if (jsecSession != null) {\n                    this.session = new JSecurityHttpSession(jsecSession, this, this.servletContext);\n                    if (!existing) {\n                        setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n                    }\n                }\n            }\n            httpSession = this.session;\n        }\n        return httpSession;\n    }\n\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    public boolean isRequestedSessionIdValid() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdValid();\n        } else {\n            Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);\n            return (value != null && value.equals(Boolean.TRUE));\n        }\n    }\n\n    public boolean isRequestedSessionIdFromCookie() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromCookie();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromURL() {\n        if (isHttpSessions()) {\n            return super.isRequestedSessionIdFromURL();\n        } else {\n            String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);\n            return value != null && value.equals(URL_SESSION_ID_SOURCE);\n        }\n    }\n\n    public boolean isRequestedSessionIdFromUrl() {\n        return isRequestedSessionIdFromURL();\n    }\n\n    private class ObjectPrincipal implements java.security.Principal {\n\n        private Object object = null;\n\n        public ObjectPrincipal(Object object) {\n            this.object = object;\n        }\n\n        public Object getObject() {\n            return object;\n        }\n\n        public String getName() {\n            return getObject().toString();\n        }\n\n        public int hashCode() {\n            return object.hashCode();\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof ObjectPrincipal) {\n                ObjectPrincipal op = (ObjectPrincipal) o;\n                return getObject().equals(op.getObject());\n            }\n            return false;\n        }\n\n        public String toString() {\n            return object.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpServletRequestTest5.java",
		"test_prompt": "// JSecurityHttpServletRequestTest5.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\nimport java.security.Principal;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpServletRequest}.\n* It contains ten unit test cases for the {@link JSecurityHttpServletRequest#isRequestedSessionIdFromUrl()} method.\n*/\nclass JSecurityHttpServletRequestTest5 {"
	},
	{
		"original_code": "// JSecurityHttpSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.session.WebSession;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.*;\nimport java.util.*;\n\n/**\n * Wrapper class that uses a JSecurity session under the hood for all session operations instead of the\n * Servlet Container's session mechanism.  This is preferred in heterogeneous client environments where the Session\n * is used on both the business tier as well as in multiple client technologies (web, swing, flash, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\n@SuppressWarnings({ \"deprecation\" })\npublic class JSecurityHttpSession implements HttpSession {\n\n    //TODO - complete JavaDoc\n    public static final String DEFAULT_SESSION_ID_NAME = \"JSESSIONID\";\n\n    private static final Enumeration EMPTY_ENUMERATION = new Enumeration() {\n\n        public boolean hasMoreElements() {\n            return false;\n        }\n\n        public Object nextElement() {\n            return null;\n        }\n    };\n\n    private static final HttpSessionContext HTTP_SESSION_CONTEXT = new HttpSessionContext() {\n\n        public HttpSession getSession(String s) {\n            return null;\n        }\n\n        public Enumeration getIds() {\n            return EMPTY_ENUMERATION;\n        }\n    };\n\n    protected ServletContext servletContext = null;\n\n    protected HttpServletRequest currentRequest = null;\n\n    //'real' JSecurity Session\n    protected Session session = null;\n\n    public JSecurityHttpSession(Session session, HttpServletRequest currentRequest, ServletContext servletContext) {\n        if (session instanceof WebSession) {\n            String msg = \"Session constructor argument cannot be an instance of WebSession.  This is enforced to \" + \"prevent circular dependencies and infinite loops.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.session = session;\n        this.currentRequest = currentRequest;\n        this.servletContext = servletContext;\n    }\n\n    public Session getSession() {\n        return this.session;\n    }\n\n    public long getCreationTime() {\n        try {\n            return getSession().getStartTimestamp().getTime();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public String getId() {\n        return getSession().getId().toString();\n    }\n\n    public long getLastAccessedTime() {\n        return getSession().getLastAccessTime().getTime();\n    }\n\n    public ServletContext getServletContext() {\n        return this.servletContext;\n    }\n\n    public void setMaxInactiveInterval(int i) {\n        try {\n            getSession().setTimeout(i * 1000);\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public int getMaxInactiveInterval() {\n        try {\n            return (new Long(getSession().getTimeout() / 1000)).intValue();\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public HttpSessionContext getSessionContext() {\n        return HTTP_SESSION_CONTEXT;\n    }\n\n    public Object getAttribute(String s) {\n        try {\n            return getSession().getAttribute(s);\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public Object getValue(String s) {\n        return getAttribute(s);\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected Set<String> getKeyNames() {\n        Collection<Object> keySet;\n        try {\n            keySet = getSession().getAttributeKeys();\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n        Set<String> keyNames;\n        if (keySet != null && !keySet.isEmpty()) {\n            keyNames = new HashSet<String>(keySet.size());\n            for (Object o : keySet) {\n                keyNames.add(o.toString());\n            }\n        } else {\n            keyNames = Collections.EMPTY_SET;\n        }\n        return keyNames;\n    }\n\n    public Enumeration getAttributeNames() {\n        Set<String> keyNames = getKeyNames();\n        final Iterator iterator = keyNames.iterator();\n        return new Enumeration() {\n\n            public boolean hasMoreElements() {\n                return iterator.hasNext();\n            }\n\n            public Object nextElement() {\n                return iterator.next();\n            }\n        };\n    }\n\n    public String[] getValueNames() {\n        Set<String> keyNames = getKeyNames();\n        String[] array = new String[keyNames.size()];\n        if (keyNames.size() > 0) {\n            array = keyNames.toArray(array);\n        }\n        return array;\n    }\n\n    protected void afterBound(String s, Object o) {\n        if (o instanceof HttpSessionBindingListener) {\n            HttpSessionBindingListener listener = (HttpSessionBindingListener) o;\n            HttpSessionBindingEvent event = new HttpSessionBindingEvent(this, s, o);\n            listener.valueBound(event);\n        }\n    }\n\n    protected void afterUnbound(String s, Object o) {\n        if (o instanceof HttpSessionBindingListener) {\n            HttpSessionBindingListener listener = (HttpSessionBindingListener) o;\n            HttpSessionBindingEvent event = new HttpSessionBindingEvent(this, s, o);\n            listener.valueUnbound(event);\n        }\n    }\n\n    public void setAttribute(String s, Object o) {\n        try {\n            getSession().setAttribute(s, o);\n            afterBound(s, o);\n        } catch (InvalidSessionException e) {\n            //noinspection finally\n            try {\n                afterUnbound(s, o);\n            } finally {\n                //noinspection ThrowFromFinallyBlock\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n\n    public void putValue(String s, Object o) {\n        setAttribute(s, o);\n    }\n\n    public void removeAttribute(String s) {\n        try {\n            Object attribute = getSession().removeAttribute(s);\n            afterUnbound(s, attribute);\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public void removeValue(String s) {\n        removeAttribute(s);\n    }\n\n    public void invalidate() {\n        try {\n            getSession().stop();\n        } catch (InvalidSessionException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public boolean isNew() {\n        Boolean value = (Boolean) currentRequest.getAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW);\n        return value != null && value.equals(Boolean.TRUE);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/servlet/JSecurityHttpSessionTest.java",
		"test_prompt": "// JSecurityHttpSessionTest.java\npackage org.jsecurity.web.servlet;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.session.WebSession;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSecurityHttpSession}.\n* It contains ten unit test cases for the {@link JSecurityHttpSession#isNew()} method.\n*/\nclass JSecurityHttpSessionTest {"
	},
	{
		"original_code": "// DefaultWebSecurityManager.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.mgt.DefaultSecurityManager;\r\nimport org.jsecurity.realm.Realm;\r\nimport org.jsecurity.session.Session;\r\nimport org.jsecurity.session.mgt.SessionManager;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport org.jsecurity.subject.Subject;\r\nimport org.jsecurity.util.LifecycleUtils;\r\nimport org.jsecurity.web.session.DefaultWebSessionManager;\r\nimport org.jsecurity.web.session.ServletContainerSessionManager;\r\nimport org.jsecurity.web.session.WebSessionManager;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport java.net.InetAddress;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * SecurityManager implementation that should be used in web-based applications or any application that requires\r\n * HTTP connectivity (SOAP, http remoting, etc).\r\n *\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class DefaultWebSecurityManager extends DefaultSecurityManager {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(DefaultWebSecurityManager.class);\r\n\r\n    public static final String HTTP_SESSION_MODE = \"http\";\r\n\r\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\r\n\r\n    /**\r\n     * The key that is used to store subject principals in the session.\r\n     */\r\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\r\n\r\n    /**\r\n     * The key that is used to store whether or not the user is authenticated in the session.\r\n     */\r\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\r\n\r\n    //default\r\n    private String sessionMode = HTTP_SESSION_MODE;\r\n\r\n    public DefaultWebSecurityManager() {\r\n        setRememberMeManager(new WebRememberMeManager());\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Realm singleRealm) {\r\n        setRealm(singleRealm);\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\r\n        setRealms(realms);\r\n    }\r\n\r\n    /**\r\n     * Sets the path used to store the remember me cookie.  This determines which paths\r\n     * are able to view the remember me cookie.\r\n     *\r\n     * @param rememberMeCookiePath the path to use for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookiePath(String rememberMeCookiePath) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookiePath(rememberMeCookiePath);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum age allowed for the remember me cookie.  This basically sets how long\r\n     * a user will be remembered by the \"remember me\" feature.  Used when calling\r\n     * {@link javax.servlet.http.Cookie#setMaxAge(int) maxAge}.  Please see that JavaDoc for the semantics on the\r\n     * repercussions of negative, zero, and positive values for the maxAge.\r\n     *\r\n     * @param rememberMeMaxAge the maximum age for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookieMaxAge(Integer rememberMeMaxAge) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookieMaxAge(rememberMeMaxAge);\r\n    }\r\n\r\n    private DefaultWebSessionManager getSessionManagerForCookieAttributes() {\r\n        SessionManager sessionManager = getSessionManager();\r\n        if (!(sessionManager instanceof DefaultWebSessionManager)) {\r\n            String msg = \"The convenience passthrough methods for setting session id cookie attributes \" + \"are only available when the underlying SessionManager implementation is \" + DefaultWebSessionManager.class.getName() + \", which is enabled by default when the \" + \"sessionMode is 'jsecurity'.\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n        return (DefaultWebSessionManager) sessionManager;\r\n    }\r\n\r\n    public void setSessionIdCookieName(String name) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieName(name);\r\n    }\r\n\r\n    public void setSessionIdCookiePath(String path) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookiePath(path);\r\n    }\r\n\r\n    public void setSessionIdCookieMaxAge(int maxAge) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieMaxAge(maxAge);\r\n    }\r\n\r\n    public void setSessionIdCookieSecure(boolean secure) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieSecure(secure);\r\n    }\r\n\r\n    public String getSessionMode() {\r\n        return sessionMode;\r\n    }\r\n\r\n    public void setSessionMode(String sessionMode) {\r\n        if (sessionMode == null || (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE))) {\r\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" + \"public static final String constants in the \" + getClass().getName() + \" class: '\" + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" + HTTP_SESSION_MODE + \"' being the default.\";\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(sessionMode);\r\n        this.sessionMode = sessionMode;\r\n        if (recreate) {\r\n            LifecycleUtils.destroy(getSessionManager());\r\n            SessionManager sm = createSessionManager();\r\n            setSessionManager(sm);\r\n        }\r\n    }\r\n\r\n    public boolean isHttpSessionMode() {\r\n        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);\r\n    }\r\n\r\n    protected SessionManager newSessionManagerInstance() {\r\n        if (isHttpSessionMode()) {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\");\r\n            }\r\n            return new ServletContainerSessionManager();\r\n        } else {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\r\n            }\r\n            return new DefaultWebSessionManager();\r\n        }\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session session) {\r\n        PrincipalCollection principals = null;\r\n        if (session != null) {\r\n            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        PrincipalCollection principals = getPrincipals(existing);\r\n        if (principals == null) {\r\n            //check remember me:\r\n            principals = getRememberedIdentity();\r\n            if (principals != null && existing != null) {\r\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n            }\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session session) {\r\n        Boolean value = null;\r\n        if (session != null) {\r\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\r\n        }\r\n        return value != null && value;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        return isAuthenticated(existing);\r\n    }\r\n\r\n    public Subject createSubject() {\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        return createSubject(request, response);\r\n    }\r\n\r\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\r\n        Session session = ((WebSessionManager) getSessionManager()).getSession(request, response);\r\n        if (session == null) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"No session found for the incoming request.  The Subject instance created for \" + \"the incoming request will not have an associated Session.\");\r\n            }\r\n        }\r\n        return createSubject(session, request, response);\r\n    }\r\n\r\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = getPrincipals(existing, request, response);\r\n        boolean authenticated = isAuthenticated(existing, request, response);\r\n        return createSubject(principals, authenticated, existing, request, response);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, boolean authenticated, Session existing, ServletRequest request, ServletResponse response) {\r\n        InetAddress inetAddress = WebUtils.getInetAddress(request);\r\n        return createSubject(principals, existing, authenticated, inetAddress);\r\n    }\r\n\r\n    protected void bind(Subject subject) {\r\n        super.bind(subject);\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        bind(subject, request, response);\r\n    }\r\n\r\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = subject.getPrincipals();\r\n        if (principals != null && !principals.isEmpty()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\r\n            }\r\n        }\r\n        if (subject.isAuthenticated()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/DefaultWebSecurityManagerTest0.java",
		"test_prompt": "// DefaultWebSecurityManagerTest0.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSecurityManager}.\n* It contains ten unit test cases for the {@link DefaultWebSecurityManager#isHttpSessionMode()} method.\n*/\nclass DefaultWebSecurityManagerTest0 {"
	},
	{
		"original_code": "// DefaultWebSecurityManager.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.mgt.DefaultSecurityManager;\r\nimport org.jsecurity.realm.Realm;\r\nimport org.jsecurity.session.Session;\r\nimport org.jsecurity.session.mgt.SessionManager;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport org.jsecurity.subject.Subject;\r\nimport org.jsecurity.util.LifecycleUtils;\r\nimport org.jsecurity.web.session.DefaultWebSessionManager;\r\nimport org.jsecurity.web.session.ServletContainerSessionManager;\r\nimport org.jsecurity.web.session.WebSessionManager;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport java.net.InetAddress;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * SecurityManager implementation that should be used in web-based applications or any application that requires\r\n * HTTP connectivity (SOAP, http remoting, etc).\r\n *\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class DefaultWebSecurityManager extends DefaultSecurityManager {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(DefaultWebSecurityManager.class);\r\n\r\n    public static final String HTTP_SESSION_MODE = \"http\";\r\n\r\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\r\n\r\n    /**\r\n     * The key that is used to store subject principals in the session.\r\n     */\r\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\r\n\r\n    /**\r\n     * The key that is used to store whether or not the user is authenticated in the session.\r\n     */\r\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\r\n\r\n    //default\r\n    private String sessionMode = HTTP_SESSION_MODE;\r\n\r\n    public DefaultWebSecurityManager() {\r\n        setRememberMeManager(new WebRememberMeManager());\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Realm singleRealm) {\r\n        setRealm(singleRealm);\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\r\n        setRealms(realms);\r\n    }\r\n\r\n    /**\r\n     * Sets the path used to store the remember me cookie.  This determines which paths\r\n     * are able to view the remember me cookie.\r\n     *\r\n     * @param rememberMeCookiePath the path to use for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookiePath(String rememberMeCookiePath) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookiePath(rememberMeCookiePath);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum age allowed for the remember me cookie.  This basically sets how long\r\n     * a user will be remembered by the \"remember me\" feature.  Used when calling\r\n     * {@link javax.servlet.http.Cookie#setMaxAge(int) maxAge}.  Please see that JavaDoc for the semantics on the\r\n     * repercussions of negative, zero, and positive values for the maxAge.\r\n     *\r\n     * @param rememberMeMaxAge the maximum age for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookieMaxAge(Integer rememberMeMaxAge) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookieMaxAge(rememberMeMaxAge);\r\n    }\r\n\r\n    private DefaultWebSessionManager getSessionManagerForCookieAttributes() {\r\n        SessionManager sessionManager = getSessionManager();\r\n        if (!(sessionManager instanceof DefaultWebSessionManager)) {\r\n            String msg = \"The convenience passthrough methods for setting session id cookie attributes \" + \"are only available when the underlying SessionManager implementation is \" + DefaultWebSessionManager.class.getName() + \", which is enabled by default when the \" + \"sessionMode is 'jsecurity'.\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n        return (DefaultWebSessionManager) sessionManager;\r\n    }\r\n\r\n    public void setSessionIdCookieName(String name) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieName(name);\r\n    }\r\n\r\n    public void setSessionIdCookiePath(String path) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookiePath(path);\r\n    }\r\n\r\n    public void setSessionIdCookieMaxAge(int maxAge) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieMaxAge(maxAge);\r\n    }\r\n\r\n    public void setSessionIdCookieSecure(boolean secure) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieSecure(secure);\r\n    }\r\n\r\n    public String getSessionMode() {\r\n        return sessionMode;\r\n    }\r\n\r\n    public void setSessionMode(String sessionMode) {\r\n        if (sessionMode == null || (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE))) {\r\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" + \"public static final String constants in the \" + getClass().getName() + \" class: '\" + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" + HTTP_SESSION_MODE + \"' being the default.\";\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(sessionMode);\r\n        this.sessionMode = sessionMode;\r\n        if (recreate) {\r\n            LifecycleUtils.destroy(getSessionManager());\r\n            SessionManager sm = createSessionManager();\r\n            setSessionManager(sm);\r\n        }\r\n    }\r\n\r\n    public boolean isHttpSessionMode() {\r\n        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);\r\n    }\r\n\r\n    protected SessionManager newSessionManagerInstance() {\r\n        if (isHttpSessionMode()) {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\");\r\n            }\r\n            return new ServletContainerSessionManager();\r\n        } else {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\r\n            }\r\n            return new DefaultWebSessionManager();\r\n        }\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session session) {\r\n        PrincipalCollection principals = null;\r\n        if (session != null) {\r\n            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        PrincipalCollection principals = getPrincipals(existing);\r\n        if (principals == null) {\r\n            //check remember me:\r\n            principals = getRememberedIdentity();\r\n            if (principals != null && existing != null) {\r\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n            }\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session session) {\r\n        Boolean value = null;\r\n        if (session != null) {\r\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\r\n        }\r\n        return value != null && value;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        return isAuthenticated(existing);\r\n    }\r\n\r\n    public Subject createSubject() {\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        return createSubject(request, response);\r\n    }\r\n\r\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\r\n        Session session = ((WebSessionManager) getSessionManager()).getSession(request, response);\r\n        if (session == null) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"No session found for the incoming request.  The Subject instance created for \" + \"the incoming request will not have an associated Session.\");\r\n            }\r\n        }\r\n        return createSubject(session, request, response);\r\n    }\r\n\r\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = getPrincipals(existing, request, response);\r\n        boolean authenticated = isAuthenticated(existing, request, response);\r\n        return createSubject(principals, authenticated, existing, request, response);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, boolean authenticated, Session existing, ServletRequest request, ServletResponse response) {\r\n        InetAddress inetAddress = WebUtils.getInetAddress(request);\r\n        return createSubject(principals, existing, authenticated, inetAddress);\r\n    }\r\n\r\n    protected void bind(Subject subject) {\r\n        super.bind(subject);\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        bind(subject, request, response);\r\n    }\r\n\r\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = subject.getPrincipals();\r\n        if (principals != null && !principals.isEmpty()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\r\n            }\r\n        }\r\n        if (subject.isAuthenticated()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/DefaultWebSecurityManagerTest1.java",
		"test_prompt": "// DefaultWebSecurityManagerTest1.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSecurityManager}.\n* It contains ten unit test cases for the {@link DefaultWebSecurityManager#createSubject()} method.\n*/\nclass DefaultWebSecurityManagerTest1 {"
	},
	{
		"original_code": "// DefaultWebSecurityManager.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.mgt.DefaultSecurityManager;\r\nimport org.jsecurity.realm.Realm;\r\nimport org.jsecurity.session.Session;\r\nimport org.jsecurity.session.mgt.SessionManager;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport org.jsecurity.subject.Subject;\r\nimport org.jsecurity.util.LifecycleUtils;\r\nimport org.jsecurity.web.session.DefaultWebSessionManager;\r\nimport org.jsecurity.web.session.ServletContainerSessionManager;\r\nimport org.jsecurity.web.session.WebSessionManager;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport java.net.InetAddress;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * SecurityManager implementation that should be used in web-based applications or any application that requires\r\n * HTTP connectivity (SOAP, http remoting, etc).\r\n *\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class DefaultWebSecurityManager extends DefaultSecurityManager {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(DefaultWebSecurityManager.class);\r\n\r\n    public static final String HTTP_SESSION_MODE = \"http\";\r\n\r\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\r\n\r\n    /**\r\n     * The key that is used to store subject principals in the session.\r\n     */\r\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\r\n\r\n    /**\r\n     * The key that is used to store whether or not the user is authenticated in the session.\r\n     */\r\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\r\n\r\n    //default\r\n    private String sessionMode = HTTP_SESSION_MODE;\r\n\r\n    public DefaultWebSecurityManager() {\r\n        setRememberMeManager(new WebRememberMeManager());\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Realm singleRealm) {\r\n        setRealm(singleRealm);\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\r\n        setRealms(realms);\r\n    }\r\n\r\n    /**\r\n     * Sets the path used to store the remember me cookie.  This determines which paths\r\n     * are able to view the remember me cookie.\r\n     *\r\n     * @param rememberMeCookiePath the path to use for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookiePath(String rememberMeCookiePath) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookiePath(rememberMeCookiePath);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum age allowed for the remember me cookie.  This basically sets how long\r\n     * a user will be remembered by the \"remember me\" feature.  Used when calling\r\n     * {@link javax.servlet.http.Cookie#setMaxAge(int) maxAge}.  Please see that JavaDoc for the semantics on the\r\n     * repercussions of negative, zero, and positive values for the maxAge.\r\n     *\r\n     * @param rememberMeMaxAge the maximum age for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookieMaxAge(Integer rememberMeMaxAge) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookieMaxAge(rememberMeMaxAge);\r\n    }\r\n\r\n    private DefaultWebSessionManager getSessionManagerForCookieAttributes() {\r\n        SessionManager sessionManager = getSessionManager();\r\n        if (!(sessionManager instanceof DefaultWebSessionManager)) {\r\n            String msg = \"The convenience passthrough methods for setting session id cookie attributes \" + \"are only available when the underlying SessionManager implementation is \" + DefaultWebSessionManager.class.getName() + \", which is enabled by default when the \" + \"sessionMode is 'jsecurity'.\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n        return (DefaultWebSessionManager) sessionManager;\r\n    }\r\n\r\n    public void setSessionIdCookieName(String name) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieName(name);\r\n    }\r\n\r\n    public void setSessionIdCookiePath(String path) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookiePath(path);\r\n    }\r\n\r\n    public void setSessionIdCookieMaxAge(int maxAge) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieMaxAge(maxAge);\r\n    }\r\n\r\n    public void setSessionIdCookieSecure(boolean secure) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieSecure(secure);\r\n    }\r\n\r\n    public String getSessionMode() {\r\n        return sessionMode;\r\n    }\r\n\r\n    public void setSessionMode(String sessionMode) {\r\n        if (sessionMode == null || (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE))) {\r\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" + \"public static final String constants in the \" + getClass().getName() + \" class: '\" + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" + HTTP_SESSION_MODE + \"' being the default.\";\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(sessionMode);\r\n        this.sessionMode = sessionMode;\r\n        if (recreate) {\r\n            LifecycleUtils.destroy(getSessionManager());\r\n            SessionManager sm = createSessionManager();\r\n            setSessionManager(sm);\r\n        }\r\n    }\r\n\r\n    public boolean isHttpSessionMode() {\r\n        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);\r\n    }\r\n\r\n    protected SessionManager newSessionManagerInstance() {\r\n        if (isHttpSessionMode()) {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\");\r\n            }\r\n            return new ServletContainerSessionManager();\r\n        } else {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\r\n            }\r\n            return new DefaultWebSessionManager();\r\n        }\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session session) {\r\n        PrincipalCollection principals = null;\r\n        if (session != null) {\r\n            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        PrincipalCollection principals = getPrincipals(existing);\r\n        if (principals == null) {\r\n            //check remember me:\r\n            principals = getRememberedIdentity();\r\n            if (principals != null && existing != null) {\r\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n            }\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session session) {\r\n        Boolean value = null;\r\n        if (session != null) {\r\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\r\n        }\r\n        return value != null && value;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        return isAuthenticated(existing);\r\n    }\r\n\r\n    public Subject createSubject() {\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        return createSubject(request, response);\r\n    }\r\n\r\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\r\n        Session session = ((WebSessionManager) getSessionManager()).getSession(request, response);\r\n        if (session == null) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"No session found for the incoming request.  The Subject instance created for \" + \"the incoming request will not have an associated Session.\");\r\n            }\r\n        }\r\n        return createSubject(session, request, response);\r\n    }\r\n\r\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = getPrincipals(existing, request, response);\r\n        boolean authenticated = isAuthenticated(existing, request, response);\r\n        return createSubject(principals, authenticated, existing, request, response);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, boolean authenticated, Session existing, ServletRequest request, ServletResponse response) {\r\n        InetAddress inetAddress = WebUtils.getInetAddress(request);\r\n        return createSubject(principals, existing, authenticated, inetAddress);\r\n    }\r\n\r\n    protected void bind(Subject subject) {\r\n        super.bind(subject);\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        bind(subject, request, response);\r\n    }\r\n\r\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = subject.getPrincipals();\r\n        if (principals != null && !principals.isEmpty()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\r\n            }\r\n        }\r\n        if (subject.isAuthenticated()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/DefaultWebSecurityManagerTest2.java",
		"test_prompt": "// DefaultWebSecurityManagerTest2.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSecurityManager}.\n* It contains ten unit test cases for the {@link DefaultWebSecurityManager#createSubject(ServletRequest, ServletResponse)} method.\n*/\nclass DefaultWebSecurityManagerTest2 {"
	},
	{
		"original_code": "// DefaultWebSecurityManager.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.mgt.DefaultSecurityManager;\r\nimport org.jsecurity.realm.Realm;\r\nimport org.jsecurity.session.Session;\r\nimport org.jsecurity.session.mgt.SessionManager;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport org.jsecurity.subject.Subject;\r\nimport org.jsecurity.util.LifecycleUtils;\r\nimport org.jsecurity.web.session.DefaultWebSessionManager;\r\nimport org.jsecurity.web.session.ServletContainerSessionManager;\r\nimport org.jsecurity.web.session.WebSessionManager;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport java.net.InetAddress;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * SecurityManager implementation that should be used in web-based applications or any application that requires\r\n * HTTP connectivity (SOAP, http remoting, etc).\r\n *\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class DefaultWebSecurityManager extends DefaultSecurityManager {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(DefaultWebSecurityManager.class);\r\n\r\n    public static final String HTTP_SESSION_MODE = \"http\";\r\n\r\n    public static final String JSECURITY_SESSION_MODE = \"jsecurity\";\r\n\r\n    /**\r\n     * The key that is used to store subject principals in the session.\r\n     */\r\n    public static final String PRINCIPALS_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_PRINCIPALS_SESSION_KEY\";\r\n\r\n    /**\r\n     * The key that is used to store whether or not the user is authenticated in the session.\r\n     */\r\n    public static final String AUTHENTICATED_SESSION_KEY = DefaultWebSecurityManager.class.getName() + \"_AUTHENTICATED_SESSION_KEY\";\r\n\r\n    //default\r\n    private String sessionMode = HTTP_SESSION_MODE;\r\n\r\n    public DefaultWebSecurityManager() {\r\n        setRememberMeManager(new WebRememberMeManager());\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Realm singleRealm) {\r\n        setRealm(singleRealm);\r\n    }\r\n\r\n    public DefaultWebSecurityManager(Collection<Realm> realms) {\r\n        setRealms(realms);\r\n    }\r\n\r\n    /**\r\n     * Sets the path used to store the remember me cookie.  This determines which paths\r\n     * are able to view the remember me cookie.\r\n     *\r\n     * @param rememberMeCookiePath the path to use for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookiePath(String rememberMeCookiePath) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookiePath(rememberMeCookiePath);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum age allowed for the remember me cookie.  This basically sets how long\r\n     * a user will be remembered by the \"remember me\" feature.  Used when calling\r\n     * {@link javax.servlet.http.Cookie#setMaxAge(int) maxAge}.  Please see that JavaDoc for the semantics on the\r\n     * repercussions of negative, zero, and positive values for the maxAge.\r\n     *\r\n     * @param rememberMeMaxAge the maximum age for the remember me cookie.\r\n     */\r\n    public void setRememberMeCookieMaxAge(Integer rememberMeMaxAge) {\r\n        ((WebRememberMeManager) getRememberMeManager()).setCookieMaxAge(rememberMeMaxAge);\r\n    }\r\n\r\n    private DefaultWebSessionManager getSessionManagerForCookieAttributes() {\r\n        SessionManager sessionManager = getSessionManager();\r\n        if (!(sessionManager instanceof DefaultWebSessionManager)) {\r\n            String msg = \"The convenience passthrough methods for setting session id cookie attributes \" + \"are only available when the underlying SessionManager implementation is \" + DefaultWebSessionManager.class.getName() + \", which is enabled by default when the \" + \"sessionMode is 'jsecurity'.\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n        return (DefaultWebSessionManager) sessionManager;\r\n    }\r\n\r\n    public void setSessionIdCookieName(String name) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieName(name);\r\n    }\r\n\r\n    public void setSessionIdCookiePath(String path) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookiePath(path);\r\n    }\r\n\r\n    public void setSessionIdCookieMaxAge(int maxAge) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieMaxAge(maxAge);\r\n    }\r\n\r\n    public void setSessionIdCookieSecure(boolean secure) {\r\n        getSessionManagerForCookieAttributes().setSessionIdCookieSecure(secure);\r\n    }\r\n\r\n    public String getSessionMode() {\r\n        return sessionMode;\r\n    }\r\n\r\n    public void setSessionMode(String sessionMode) {\r\n        if (sessionMode == null || (!sessionMode.equals(HTTP_SESSION_MODE) && !sessionMode.equals(JSECURITY_SESSION_MODE))) {\r\n            String msg = \"Invalid sessionMode [\" + sessionMode + \"].  Allowed values are \" + \"public static final String constants in the \" + getClass().getName() + \" class: '\" + HTTP_SESSION_MODE + \"' or '\" + JSECURITY_SESSION_MODE + \"', with '\" + HTTP_SESSION_MODE + \"' being the default.\";\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(sessionMode);\r\n        this.sessionMode = sessionMode;\r\n        if (recreate) {\r\n            LifecycleUtils.destroy(getSessionManager());\r\n            SessionManager sm = createSessionManager();\r\n            setSessionManager(sm);\r\n        }\r\n    }\r\n\r\n    public boolean isHttpSessionMode() {\r\n        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);\r\n    }\r\n\r\n    protected SessionManager newSessionManagerInstance() {\r\n        if (isHttpSessionMode()) {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(HTTP_SESSION_MODE + \" mode - enabling ServletContainerSessionManager (Http Sessions)\");\r\n            }\r\n            return new ServletContainerSessionManager();\r\n        } else {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(JSECURITY_SESSION_MODE + \" mode - enabling WebSessionManager (JSecurity heterogenous sessions)\");\r\n            }\r\n            return new DefaultWebSessionManager();\r\n        }\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session session) {\r\n        PrincipalCollection principals = null;\r\n        if (session != null) {\r\n            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected PrincipalCollection getPrincipals(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        PrincipalCollection principals = getPrincipals(existing);\r\n        if (principals == null) {\r\n            //check remember me:\r\n            principals = getRememberedIdentity();\r\n            if (principals != null && existing != null) {\r\n                existing.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n            }\r\n        }\r\n        return principals;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session session) {\r\n        Boolean value = null;\r\n        if (session != null) {\r\n            value = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);\r\n        }\r\n        return value != null && value;\r\n    }\r\n\r\n    protected boolean isAuthenticated(Session existing, ServletRequest servletRequest, ServletResponse servletResponse) {\r\n        return isAuthenticated(existing);\r\n    }\r\n\r\n    public Subject createSubject() {\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        return createSubject(request, response);\r\n    }\r\n\r\n    public Subject createSubject(ServletRequest request, ServletResponse response) {\r\n        Session session = ((WebSessionManager) getSessionManager()).getSession(request, response);\r\n        if (session == null) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"No session found for the incoming request.  The Subject instance created for \" + \"the incoming request will not have an associated Session.\");\r\n            }\r\n        }\r\n        return createSubject(session, request, response);\r\n    }\r\n\r\n    public Subject createSubject(Session existing, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = getPrincipals(existing, request, response);\r\n        boolean authenticated = isAuthenticated(existing, request, response);\r\n        return createSubject(principals, authenticated, existing, request, response);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, boolean authenticated, Session existing, ServletRequest request, ServletResponse response) {\r\n        InetAddress inetAddress = WebUtils.getInetAddress(request);\r\n        return createSubject(principals, existing, authenticated, inetAddress);\r\n    }\r\n\r\n    protected void bind(Subject subject) {\r\n        super.bind(subject);\r\n        ServletRequest request = WebUtils.getRequiredServletRequest();\r\n        ServletResponse response = WebUtils.getRequiredServletResponse();\r\n        bind(subject, request, response);\r\n    }\r\n\r\n    protected void bind(Subject subject, ServletRequest request, ServletResponse response) {\r\n        PrincipalCollection principals = subject.getPrincipals();\r\n        if (principals != null && !principals.isEmpty()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(PRINCIPALS_SESSION_KEY, principals);\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(PRINCIPALS_SESSION_KEY);\r\n            }\r\n        }\r\n        if (subject.isAuthenticated()) {\r\n            Session session = subject.getSession();\r\n            session.setAttribute(AUTHENTICATED_SESSION_KEY, subject.isAuthenticated());\r\n        } else {\r\n            Session session = subject.getSession(false);\r\n            if (session != null) {\r\n                session.removeAttribute(AUTHENTICATED_SESSION_KEY);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/DefaultWebSecurityManagerTest3.java",
		"test_prompt": "// DefaultWebSecurityManagerTest3.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.DefaultSecurityManager;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.LifecycleUtils;\nimport org.jsecurity.web.session.DefaultWebSessionManager;\nimport org.jsecurity.web.session.ServletContainerSessionManager;\nimport org.jsecurity.web.session.WebSessionManager;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSecurityManager}.\n* It contains ten unit test cases for the {@link DefaultWebSecurityManager#createSubject(Session, ServletRequest, ServletResponse)} method.\n*/\nclass DefaultWebSecurityManagerTest3 {"
	},
	{
		"original_code": "// IniWebConfiguration.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.config;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport org.jsecurity.util.PatternMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.AnonymousFilter;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.UserFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport org.jsecurity.web.servlet.ProxiedFilterChain;\nimport javax.servlet.*;\nimport java.util.*;\n\n/**\n * A <code>WebConfiguration</code> that supports configuration via the\n * <a href=\"http://en.wikipedia.org/wiki/INI_file\">.ini format</a>.\n *\n * @author Les Hazlewood\n * @since Jun 1, 2008 11:02:44 PM\n */\npublic class IniWebConfiguration extends IniConfiguration implements WebConfiguration {\n\n    //TODO - complete JavaDoc\n    private static final transient Log log = LogFactory.getLog(IniWebConfiguration.class);\n\n    public static final String FILTERS = \"filters\";\n\n    public static final String URLS = \"urls\";\n\n    protected FilterConfig filterConfig;\n\n    protected Map<String, List<Filter>> chains;\n\n    protected PatternMatcher pathMatcher = new AntPathMatcher();\n\n    public IniWebConfiguration() {\n        chains = new LinkedHashMap<String, List<Filter>>();\n    }\n\n    /**\n     * Returns the <code>PatternMatcher</code> used when determining if an incoming request's path\n     * matches a configured filter chain path in the <code>[urls]</code> section.  Unless overridden, the\n     * default implementation is an {@link org.jsecurity.util.AntPathMatcher AntPathMatcher}.\n     *\n     * @return the <code>PatternMatcher</code> used when determining if an incoming request's path\n     *         matches a configured filter chain path in the <code>[urls]</code> section.\n     * @since 0.9.0 final\n     */\n    public PatternMatcher getPathMatcher() {\n        return pathMatcher;\n    }\n\n    /**\n     * Sets the <code>PatternMatcher</code> used when determining if an incoming request's path\n     * matches a configured filter chain path in the <code>[urls]</code> section.  Unless overridden, the\n     * default implementation is an {@link org.jsecurity.util.AntPathMatcher AntPathMatcher}.\n     *\n     * @param pathMatcher the <code>PatternMatcher</code> used when determining if an incoming request's path\n     *                    matches a configured filter chain path in the <code>[urls]</code> section.\n     * @since 0.9.0 final\n     */\n    public void setPathMatcher(PatternMatcher pathMatcher) {\n        this.pathMatcher = pathMatcher;\n    }\n\n    /**\n     * Returns the <code>FilterConfig</code> provided by the Servlet container at webapp startup.\n     *\n     * @return the <code>FilterConfig</code> provided by the Servlet container at webapp startup.\n     */\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    /**\n     * Sets the <code>FilterConfig</code> provided by the Servlet container at webapp startup.\n     *\n     * @param filterConfig the <code>FilterConfig</code> provided by the Servlet container at webapp startup.\n     */\n    public void setFilterConfig(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n    }\n\n    //TODO - JAVADOC\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        if (this.chains == null || this.chains.isEmpty()) {\n            return null;\n        }\n        String requestURI = getPathWithinApplication(request);\n        for (String path : this.chains.keySet()) {\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatches(path, requestURI)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Matched path [\" + path + \"] for requestURI [\" + requestURI + \"].  \" + \"Utilizing corresponding filter chain...\");\n                }\n                return getChain(path, originalChain);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the <code>FilterChain</code> to use for the specified application path, or <code>null</code> if the\n     * original <code>FilterChain</code> should be used.\n     * <p/>\n     * The default implementation simply calls <code>this.chains.get(chainUrl)</code> to acquire the configured\n     * <code>List&lt;Filter&gt;</code> filter chain.  If that configured chain is non-null and not empty, it is\n     * returned, otherwise <code>null</code> is returned to indicate that the <code>originalChain</code> should be\n     * used instead.\n     *\n     * @param chainUrl      the configured filter chain url\n     * @param originalChain the original FilterChain given by the Servlet container.\n     * @return the <code>FilterChain</code> to use for the specified application path, or <code>null</code> if the\n     *         original <code>FilterChain</code> should be used.\n     */\n    protected FilterChain getChain(String chainUrl, FilterChain originalChain) {\n        List<Filter> pathFilters = this.chains.get(chainUrl);\n        if (pathFilters != null && !pathFilters.isEmpty()) {\n            return createChain(pathFilters, originalChain);\n        }\n        return null;\n    }\n\n    /**\n     * Creates a new FilterChain based on the specified configured url filter chain and original chain.\n     * <p/>\n     * The input arguments are expected be be non-null and non-empty, since these conditions are accounted for in the\n     * {@link #getChain(String, javax.servlet.FilterChain) getChain(chainUrl,originalChain)} implementation that\n     * calls this method.\n     * <p/>\n     * The default implementation merely returns\n     * <code>new {@link org.jsecurity.web.servlet.ProxiedFilterChain FilterChainWrapper(filters, originalChain)}</code>,\n     * and can be overridden by subclasses for custom creation.\n     *\n     * @param filters       the configured filter chain for the incoming request application path\n     * @param originalChain the original FilterChain given by the Servlet container.\n     * @return a new FilterChain based on the specified configured url filter chain and original chain.\n     */\n    protected FilterChain createChain(List<Filter> filters, FilterChain originalChain) {\n        return new ProxiedFilterChain(originalChain, filters);\n    }\n\n    /**\n     * Returns <code>true</code> if an incoming request's path (the <code>path</code> argument)\n     * matches a configured filter chain path in the <code>[urls]</code> section (the <code>pattern</code> argument),\n     * <code>false</code> otherwise.\n     * <p/>\n     * Simply delegates to\n     * <b><code>{@link #getPathMatcher() getPathMatcher()}.{@link org.jsecurity.util.PatternMatcher#matches(String, String) matches(pattern,path)}</code></b>,\n     * but can be overridden by subclasses for custom matching behavior.\n     *\n     * @param pattern the pattern to match against\n     * @param path    the value to match with the specified <code>pattern</code>\n     * @return <code>true</code> if the request <code>path</code> matches the specified filter chain url <code>pattern</code>,\n     *         <code>false</code> otherwise.\n     */\n    protected boolean pathMatches(String pattern, String path) {\n        PatternMatcher pathMatcher = getPathMatcher();\n        return pathMatcher.matches(pattern, path);\n    }\n\n    /**\n     * Merely returns\n     * <code>WebUtils.{@link WebUtils#getPathWithinApplication(javax.servlet.http.HttpServletRequest) getPathWithinApplication(request)}</code>\n     * and can be overridden by subclasses for custom request-to-application-path resolution behavior.\n     *\n     * @param request the incoming <code>ServletRequest</code>\n     * @return the request's path within the appliation.\n     */\n    protected String getPathWithinApplication(ServletRequest request) {\n        return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));\n    }\n\n    /**\n     * Creates a new, uninitialized <code>SecurityManager</code> instance that will be used to build up\n     * the JSecurity environment for the web application.\n     * <p/>\n     * The default implementation simply returns\n     * <code>new {@link org.jsecurity.web.DefaultWebSecurityManager DefaultWebSecurityManager()};</code>\n     *\n     * @return a new, uninitialized <code>SecurityManager</code> instance that will be used to build up\n     *         the JSecurity environment for the web application.\n     */\n    protected RealmSecurityManager newSecurityManagerInstance() {\n        return new DefaultWebSecurityManager();\n    }\n\n    /**\n     * This implementation:\n     * <ol>\n     * <li>First builds the filter instances by processing the [filters] section</li>\n     * <li>Builds a collection filter chains according to the definitions in the [urls] section</li>\n     * <li>Initializes the filter instances in the order in which they were defined</li>\n     * </ol>\n     *\n     * @param sections the configured .ini sections where the key is the section name (without [] brackets)\n     *                 and the value is the key/value pairs inside that section.\n     */\n    protected void afterSecurityManagerSet(Map<String, Map<String, String>> sections) {\n        //filters section:\n        Map<String, String> section = sections.get(FILTERS);\n        Map<String, Filter> filters = getFilters(section);\n        //urls section:\n        section = sections.get(URLS);\n        this.chains = createChains(section, filters);\n        initFilters(this.chains);\n    }\n\n    protected void initFilters(Map<String, List<Filter>> chains) {\n        if (chains == null || chains.isEmpty()) {\n            return;\n        }\n        //add 'em to a set so we only initialize each one once:\n        Set<Filter> filters = new LinkedHashSet<Filter>();\n        for (List<Filter> pathFilters : chains.values()) {\n            filters.addAll(pathFilters);\n        }\n        //now initialize each one:\n        for (Filter filter : filters) {\n            initFilter(filter);\n        }\n    }\n\n    /**\n     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );</code>.\n     *\n     * @param filter the filter to initialize with the <code>FilterConfig</code>.\n     */\n    protected void initFilter(Filter filter) {\n        try {\n            filter.init(getFilterConfig());\n        } catch (ServletException e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected Map<String, Filter> getFilters(Map<String, String> section) {\n        Map<String, Filter> filters = createDefaultFilters();\n        if (section != null && !section.isEmpty()) {\n            ReflectionBuilder builder = new ReflectionBuilder(filters);\n            Map built = builder.buildObjects(section);\n            assertFilters(built);\n            filters = (Map<String, Filter>) built;\n        }\n        return filters;\n    }\n\n    protected void assertFilters(Map<String, ?> map) {\n        if (map == null || map.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            assertFilter(key, value);\n        }\n    }\n\n    protected void assertFilter(String name, Object o) throws ConfigurationException {\n        if (!(o instanceof Filter)) {\n            String msg = \"[\" + FILTERS + \"] section specified a filter named '\" + name + \"', which does not \" + \"implement the \" + Filter.class.getName() + \" interface.  Only Filter implementations may be \" + \"defined.\";\n            throw new ConfigurationException(msg);\n        }\n    }\n\n    protected Map<String, Filter> createDefaultFilters() {\n        Map<String, Filter> filters = new LinkedHashMap<String, Filter>();\n        String name = \"anon\";\n        AdviceFilter filter = new AnonymousFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        name = \"user\";\n        filter = new UserFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        name = \"authc\";\n        filter = new FormAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        name = \"authcBasic\";\n        filter = new BasicHttpAuthenticationFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        name = \"roles\";\n        filter = new RolesAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        name = \"perms\";\n        filter = new PermissionsAuthorizationFilter();\n        filter.setName(name);\n        filters.put(name, filter);\n        return filters;\n    }\n\n    public Map<String, List<Filter>> createChains(Map<String, String> urls, Map<String, Filter> filters) {\n        if (urls == null || urls.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No urls to process.\");\n            }\n            return null;\n        }\n        if (filters == null || filters.isEmpty()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No filters to process.\");\n            }\n            return null;\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Before url processing.\");\n        }\n        Map<String, List<Filter>> pathChains = new LinkedHashMap<String, List<Filter>>(urls.size());\n        for (Map.Entry<String, String> entry : urls.entrySet()) {\n            String path = entry.getKey();\n            String value = entry.getValue();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Processing path [\" + path + \"] with value [\" + value + \"]\");\n            }\n            List<Filter> pathFilters = new ArrayList<Filter>();\n            //parse the value by tokenizing it to get the resulting filter-specific config entries\n            //\n            //e.g. for a value of\n            //\n            //     \"authc, roles[admin,user], perms[file:edit]\"\n            //\n            // the resulting token array would equal\n            //\n            //     { \"authc\", \"roles[admin,user]\", \"perms[file:edit]\" }\n            //\n            String[] filterTokens = split(value, ',', '[', ']', true, true);\n            //each token is specific to each filter.\n            //strip the name and extract any filter-specific config between brackets [ ]\n            for (String token : filterTokens) {\n                String[] nameAndConfig = token.split(\"\\\\[\", 2);\n                String name = nameAndConfig[0];\n                String config = null;\n                if (nameAndConfig.length == 2) {\n                    config = nameAndConfig[1];\n                    //if there was an open bracket, there was a close bracket, so strip it too:\n                    config = config.substring(0, config.length() - 1);\n                }\n                //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:\n                Filter filter = filters.get(name);\n                if (filter == null) {\n                    String msg = \"Path [\" + path + \"] specified a filter named '\" + name + \"', but that \" + \"filter has not been specified in the [\" + FILTERS + \"] section.\";\n                    throw new ConfigurationException(msg);\n                }\n                if (filter instanceof PathConfigProcessor) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Applying path [\" + path + \"] to filter [\" + name + \"] \" + \"with config [\" + config + \"]\");\n                    }\n                    ((PathConfigProcessor) filter).processPathConfig(path, config);\n                }\n                pathFilters.add(filter);\n            }\n            if (!pathFilters.isEmpty()) {\n                pathChains.put(path, pathFilters);\n            }\n        }\n        if (pathChains.isEmpty()) {\n            return null;\n        }\n        return pathChains;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/config/IniWebConfigurationTest.java",
		"test_prompt": "// IniWebConfigurationTest.java\npackage org.jsecurity.web.config;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.config.ConfigurationException;\nimport org.jsecurity.config.IniConfiguration;\nimport org.jsecurity.config.ReflectionBuilder;\nimport org.jsecurity.mgt.RealmSecurityManager;\nimport org.jsecurity.util.AntPathMatcher;\nimport org.jsecurity.util.PatternMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.filter.PathConfigProcessor;\nimport org.jsecurity.web.filter.authc.AnonymousFilter;\nimport org.jsecurity.web.filter.authc.BasicHttpAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.FormAuthenticationFilter;\nimport org.jsecurity.web.filter.authc.UserFilter;\nimport org.jsecurity.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.jsecurity.web.filter.authz.RolesAuthorizationFilter;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport org.jsecurity.web.servlet.ProxiedFilterChain;\nimport javax.servlet.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IniWebConfiguration}.\n* It contains ten unit test cases for the {@link IniWebConfiguration#createChains(Map, Map)} method.\n*/\nclass IniWebConfigurationTest {"
	},
	{
		"original_code": "// AuthenticatedTag.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web.tags;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport javax.servlet.jsp.JspException;\r\nimport javax.servlet.jsp.tagext.TagSupport;\r\n\r\n/**\r\n * JSP tag that renders the tag body only if the current user has executed a <b>successful</b> authentication attempt\r\n * <em>during their current session</em>.\r\n *\r\n * <p>This is more restrictive than the {@link UserTag}, which only\r\n * ensures the current user is known to the system, either via a current login or from Remember Me services,\r\n * which only makes the assumption that the current user is who they say they are, and does not guarantee it like\r\n * this tag does.\r\n *\r\n * <p>The logically opposite tag of this one is the {@link NotAuthenticatedTag}\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class AuthenticatedTag extends SecureTag {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(AuthenticatedTag.class);\r\n\r\n    public int onDoStartTag() throws JspException {\r\n        if (getSubject() != null && getSubject().isAuthenticated()) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Subject exists and is authenticated.  Tag body will be evaluated.\");\r\n            }\r\n            return TagSupport.EVAL_BODY_INCLUDE;\r\n        } else {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Subject does not exist or is not authenticated.  Tag body will not be evaluated.\");\r\n            }\r\n            return TagSupport.SKIP_BODY;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/AuthenticatedTagTest.java",
		"test_prompt": "// AuthenticatedTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticatedTag}.\n* It contains ten unit test cases for the {@link AuthenticatedTag#onDoStartTag()} method.\n*/\nclass AuthenticatedTagTest {"
	},
	{
		"original_code": "// PermissionTag.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.tags;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic abstract class PermissionTag extends SecureTag {\n\n    //TODO - complete JavaDoc\n    private String name = null;\n\n    public PermissionTag() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    protected void verifyAttributes() throws JspException {\n        String permission = getName();\n        if (permission == null || permission.length() == 0) {\n            String msg = \"The 'name' tag attribute must be set.\";\n            throw new JspException(msg);\n        }\n    }\n\n    public int onDoStartTag() throws JspException {\n        String p = getName();\n        boolean show = showTagBody(p);\n        if (show) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected boolean isPermitted(String p) {\n        return getSubject() != null && getSubject().isPermitted(p);\n    }\n\n    protected abstract boolean showTagBody(String p);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/PermissionTagTest.java",
		"test_prompt": "// PermissionTagTest.java\npackage org.jsecurity.web.tags;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PermissionTag}.\n* It contains ten unit test cases for the {@link PermissionTag#onDoStartTag()} method.\n*/\nclass PermissionTagTest {"
	},
	{
		"original_code": "// GuestTag.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * JSP tag that renders the tag body if the current user <em>is not</em> known to the system, either because they\n * haven't logged in yet, or because they have no 'RememberMe' identity.\n *\n * <p>The logically opposite tag of this one is the {@link UserTag}.  Please read that class's JavaDoc as it explains\n * more about the differences between Authenticated/Unauthenticated and User/Guest semantic differences.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class GuestTag extends SecureTag {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(GuestTag.class);\n\n    public int onDoStartTag() throws JspException {\n        if (getSubject() == null || getSubject().getPrincipal() == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Subject does not exist or does not have a known identity (aka 'principal').  \" + \"Tag body will be evaluated.\");\n            }\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Subject exists or has a known identity (aka 'principal').  \" + \"Tag body will not be evaluated.\");\n            }\n            return TagSupport.SKIP_BODY;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/GuestTagTest.java",
		"test_prompt": "// GuestTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GuestTag}.\n* It contains ten unit test cases for the {@link GuestTag#onDoStartTag()} method.\n*/\nclass GuestTagTest {"
	},
	{
		"original_code": "// NotAuthenticatedTag.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web.tags;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport javax.servlet.jsp.JspException;\r\nimport javax.servlet.jsp.tagext.TagSupport;\r\n\r\n/**\r\n * JSP tag that renders the tag body only if the current user has <em>not</em> executed a successful authentication\r\n * attempt <em>during their current session</em>.\r\n *\r\n * <p>The logically opposite tag of this one is the {@link AuthenticatedTag}.\r\n *\r\n * @author Jeremy Haile\r\n * @since 0.2\r\n */\r\npublic class NotAuthenticatedTag extends SecureTag {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(NotAuthenticatedTag.class);\r\n\r\n    public int onDoStartTag() throws JspException {\r\n        if (getSubject() == null || !getSubject().isAuthenticated()) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Subject does not exist or is not authenticated.  Tag body will be evaluated.\");\r\n            }\r\n            return TagSupport.EVAL_BODY_INCLUDE;\r\n        } else {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Subject exists and is authenticated.  Tag body will not be evaluated.\");\r\n            }\r\n            return TagSupport.SKIP_BODY;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/NotAuthenticatedTagTest.java",
		"test_prompt": "// NotAuthenticatedTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotAuthenticatedTag}.\n* It contains ten unit test cases for the {@link NotAuthenticatedTag#onDoStartTag()} method.\n*/\nclass NotAuthenticatedTagTest {"
	},
	{
		"original_code": "// SecureTag.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class SecureTag extends TagSupport {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(SecureTag.class);\n\n    public SecureTag() {\n    }\n\n    protected Subject getSubject() {\n        return SecurityUtils.getSubject();\n    }\n\n    protected void verifyAttributes() throws JspException {\n    }\n\n    public int doStartTag() throws JspException {\n        verifyAttributes();\n        return onDoStartTag();\n    }\n\n    public abstract int onDoStartTag() throws JspException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/SecureTagTest.java",
		"test_prompt": "// SecureTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SecureTag}.\n* It contains ten unit test cases for the {@link SecureTag#doStartTag()} method.\n*/\nclass SecureTagTest {"
	},
	{
		"original_code": "// UserTag.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * JSP tag that renders the tag body if the current user known to the system, either from a successful login attempt\n * (not necessarily during the current session) or from 'RememberMe' services.\n *\n * <p><b>Note:</b> This is <em>less</em> restrictive than the <code>AuthenticatedTag</code> since it only assumes\n * the user is who they say they are, either via a current session login <em>or</em> via Remember Me services, which\n * makes no guarantee the user is who they say they are.  The <code>AuthenticatedTag</code> however\n * guarantees that the current user has logged in <em>during their current session</em>, proving they really are\n * who they say they are.\n *\n * <p>The logically opposite tag of this one is the {@link GuestTag}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class UserTag extends SecureTag {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(UserTag.class);\n\n    public int onDoStartTag() throws JspException {\n        if (getSubject() != null && getSubject().getPrincipal() != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Subject has known identity (aka 'principal').  \" + \"Tag body will be evaluated.\");\n            }\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Subject does not exist or have a known identity (aka 'principal').  \" + \"Tag body will not be evaluated.\");\n            }\n            return TagSupport.SKIP_BODY;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/UserTagTest.java",
		"test_prompt": "// UserTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserTag}.\n* It contains ten unit test cases for the {@link UserTag#onDoStartTag()} method.\n*/\nclass UserTagTest {"
	},
	{
		"original_code": "// RoleTag.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.tags;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class RoleTag extends SecureTag {\n\n    //TODO - complete JavaDoc\n    private String name = null;\n\n    public RoleTag() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int onDoStartTag() throws JspException {\n        boolean show = showTagBody(getName());\n        if (show) {\n            return TagSupport.EVAL_BODY_INCLUDE;\n        } else {\n            return TagSupport.SKIP_BODY;\n        }\n    }\n\n    protected abstract boolean showTagBody(String roleName);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/RoleTagTest.java",
		"test_prompt": "// RoleTagTest.java\npackage org.jsecurity.web.tags;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RoleTag}.\n* It contains ten unit test cases for the {@link RoleTag#onDoStartTag()} method.\n*/\nclass RoleTagTest {"
	},
	{
		"original_code": "// PrincipalTag.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.web.tags;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport javax.servlet.jsp.JspException;\r\nimport javax.servlet.jsp.JspTagException;\r\nimport java.beans.BeanInfo;\r\nimport java.beans.Introspector;\r\nimport java.beans.PropertyDescriptor;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * <p>Tag used to print out the String value of a user's default principal,\r\n * or a specific principal as specified by the tag's attributes.</p>\r\n *\r\n * <p> If no attributes are specified, the tag prints out the <tt>toString()</tt>\r\n * value of the user's default principal.  If the <tt>type</tt> attribute\r\n * is specified, the tag looks for a principal with the given type.  If the\r\n * <tt>property</tt> attribute is specified, the tag prints the string value of\r\n * the specified property of the principal.  If no principal is found or the user\r\n * is not authenticated, the tag displays nothing unless a <tt>defaultValue</tt>\r\n * is specified.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @since 0.2\r\n */\r\npublic class PrincipalTag extends SecureTag {\r\n\r\n    //TODO - complete JavaDoc\r\n    /*--------------------------------------------\r\n    |             C O N S T A N T S             |\r\n    ============================================*/\r\n    /*--------------------------------------------\r\n    |    I N S T A N C E   V A R I A B L E S    |\r\n    ============================================*/\r\n    private static final Log log = LogFactory.getLog(PrincipalTag.class);\r\n\r\n    /**\r\n     * The type of principal to be retrieved, or null if the default principal should be used.\r\n     */\r\n    private String type;\r\n\r\n    /**\r\n     * The property name to retrieve of the principal, or null if the <tt>toString()</tt> value should be used.\r\n     */\r\n    private String property;\r\n\r\n    /**\r\n     * The default value that should be displayed if the user is not authenticated, or no principal is found.\r\n     */\r\n    private String defaultValue;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    /*--------------------------------------------\r\n    |  A C C E S S O R S / M O D I F I E R S    |\r\n    ============================================*/\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    public String getProperty() {\r\n        return property;\r\n    }\r\n\r\n    public void setProperty(String property) {\r\n        this.property = property;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public void setDefaultValue(String defaultValue) {\r\n        this.defaultValue = defaultValue;\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public int onDoStartTag() throws JspException {\r\n        String strValue = null;\r\n        if (getSubject() != null) {\r\n            // Get the principal to print out\r\n            Object principal;\r\n            if (type == null) {\r\n                principal = getSubject().getPrincipal();\r\n            } else {\r\n                principal = getPrincipalFromClassName();\r\n            }\r\n            // Get the string value of the principal\r\n            if (principal != null) {\r\n                if (property == null) {\r\n                    strValue = principal.toString();\r\n                } else {\r\n                    strValue = getPrincipalProperty(principal, property);\r\n                }\r\n            }\r\n        }\r\n        // Print out the principal value if not null\r\n        if (strValue != null) {\r\n            try {\r\n                pageContext.getOut().write(strValue);\r\n            } catch (IOException e) {\r\n                throw new JspTagException(\"Error writing [\" + strValue + \"] to JSP.\", e);\r\n            }\r\n        }\r\n        return SKIP_BODY;\r\n    }\r\n\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    private Object getPrincipalFromClassName() {\r\n        Object principal = null;\r\n        try {\r\n            Class cls = Class.forName(type);\r\n            principal = getSubject().getPrincipals().oneByType(cls);\r\n        } catch (ClassNotFoundException e) {\r\n            if (log.isErrorEnabled()) {\r\n                log.error(\"Unable to find class for name [\" + type + \"]\");\r\n            }\r\n        }\r\n        return principal;\r\n    }\r\n\r\n    private String getPrincipalProperty(Object principal, String property) throws JspTagException {\r\n        String strValue = null;\r\n        try {\r\n            BeanInfo bi = Introspector.getBeanInfo(principal.getClass());\r\n            // Loop through the properties to get the string value of the specified property\r\n            boolean foundProperty = false;\r\n            for (PropertyDescriptor pd : bi.getPropertyDescriptors()) {\r\n                if (pd.getName().equals(property)) {\r\n                    Object value = pd.getReadMethod().invoke(principal, (Object[]) null);\r\n                    strValue = String.valueOf(value);\r\n                    foundProperty = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!foundProperty) {\r\n                final String message = \"Property [\" + property + \"] not found in principal of type [\" + principal.getClass().getName() + \"]\";\r\n                if (log.isErrorEnabled()) {\r\n                    log.error(message);\r\n                }\r\n                throw new JspTagException(message);\r\n            }\r\n        } catch (Exception e) {\r\n            final String message = \"Error reading property [\" + property + \"] from principal of type [\" + principal.getClass().getName() + \"]\";\r\n            if (log.isErrorEnabled()) {\r\n                log.error(message, e);\r\n            }\r\n            throw new JspTagException(message, e);\r\n        }\r\n        return strValue;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/tags/PrincipalTagTest.java",
		"test_prompt": "// PrincipalTagTest.java\npackage org.jsecurity.web.tags;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PrincipalTag}.\n* It contains ten unit test cases for the {@link PrincipalTag#onDoStartTag()} method.\n*/\nclass PrincipalTagTest {"
	},
	{
		"original_code": "// CookieAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute</tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @author Peter Ledbrook\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(CookieAttribute.class);\n\n    /**\n     * The number of seconds in one year (= 60 * 60 * 24 * 365).\n     */\n    public static final int ONE_YEAR = 60 * 60 * 24 * 365;\n\n    /**\n     * This is the same value as Integer.MAX_VALUE, and while Tomcat does fine with cookie max age with this value,\n     * Jetty apparently has problems with it.  If you're using Jetty, you might want to use the\n     * {@link #ONE_YEAR ONE_YEAR} constant or another value.\n     */\n    public static final int INDEFINITE = Integer.MAX_VALUE;\n\n    /**\n     * <code>null</code>, indicating the cookie should be set on the request context root.\n     */\n    public static final String DEFAULT_PATH = null;\n\n    /**\n     * <code>-1</code>, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * Default value is <code>false</code>.\n     */\n    public static final boolean DEFAULT_SECURE = false;\n\n    private String path = DEFAULT_PATH;\n\n    private int maxAge = DEFAULT_MAX_AGE;\n\n    private boolean secure = DEFAULT_SECURE;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1</tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute(String name) {\n        super(name);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     *\n     * <p>A <tt>null</tt> <tt>path</tt> value means the request context's path will be used by default.\n     *\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1</tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute(String name, String path) {\n        super(name);\n        setPath(path);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     *\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, int maxAge) {\n        super(name);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, String path, int maxAge) {\n        this(name, path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor</tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor</tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute(String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass) {\n        super(name, editorClass);\n        setPath(path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null</tt>, the <tt>request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     *\n     * <p>The default is <code>null</code>.</p>\n     *\n     * @return the Cookie's path, or <tt>null</tt> if the request's context path should be used as the path when the\n     *         cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null</tt>, the <tt>request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     *\n     * <p>The default is <code>null</code>.</p>\n     *\n     * @param path the Cookie's path, or <tt>null</tt> if the request's context path should be used as the path when the\n     *             cookie is created.\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     *\n     * <p>The default value is <code>-1</code>, meaning the cookie will expire when the browser is closed.</p>\n     *\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     *\n     * <p>The default value is <code>-1</code>, meaning the cookie will expire when the browser is closed.</p>\n     *\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge(int maxAge) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null</tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null</tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie(HttpServletRequest request, String cookieName) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        String stringValue;\n        Cookie cookie = getCookie(toHttp(request), getName());\n        if (cookie != null && cookie.getMaxAge() != 0) {\n            stringValue = cookie.getValue();\n            if (log.isInfoEnabled()) {\n                log.info(\"Found string value [\" + stringValue + \"] from HttpServletRequest Cookie [\" + getName() + \"]\");\n            }\n            value = fromStringValue(stringValue);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No value found in request Cookies under cookie name [\" + getName() + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public void onStoreValue(T value, ServletRequest servletRequest, ServletResponse servletResponse) {\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n        String name = getName();\n        int maxAge = getMaxAge();\n        String path = getPath() != null ? getPath() : request.getContextPath();\n        String stringValue = toStringValue(value);\n        Cookie cookie = new Cookie(name, stringValue);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n        if (isSecure()) {\n            cookie.setSecure(true);\n        }\n        response.addCookie(cookie);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Added Cookie [\" + name + \"] to path [\" + path + \"] with value [\" + stringValue + \"] to the HttpServletResponse.\");\n        }\n    }\n\n    public void removeValue(ServletRequest servletRequest, ServletResponse response) {\n        HttpServletRequest request = toHttp(servletRequest);\n        Cookie cookie = getCookie(request, getName());\n        if (cookie != null) {\n            cookie.setMaxAge(0);\n            //JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            //retrieved cookie?)\n            cookie.setPath(getPath() == null ? request.getContextPath() : getPath());\n            cookie.setSecure(isSecure());\n            toHttp(response).addCookie(cookie);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/CookieAttributeTest0.java",
		"test_prompt": "// CookieAttributeTest0.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CookieAttribute}.\n* It contains ten unit test cases for the {@link CookieAttribute#isSecure()} method.\n*/\nclass CookieAttributeTest0 {"
	},
	{
		"original_code": "// CookieAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * A <tt>CookieAttribute</tt> stores an object as a {@link Cookie} for access on later requests.\n *\n * @author Les Hazlewood\n * @author Peter Ledbrook\n * @since 0.2\n */\npublic class CookieAttribute<T> extends AbstractWebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(CookieAttribute.class);\n\n    /**\n     * The number of seconds in one year (= 60 * 60 * 24 * 365).\n     */\n    public static final int ONE_YEAR = 60 * 60 * 24 * 365;\n\n    /**\n     * This is the same value as Integer.MAX_VALUE, and while Tomcat does fine with cookie max age with this value,\n     * Jetty apparently has problems with it.  If you're using Jetty, you might want to use the\n     * {@link #ONE_YEAR ONE_YEAR} constant or another value.\n     */\n    public static final int INDEFINITE = Integer.MAX_VALUE;\n\n    /**\n     * <code>null</code>, indicating the cookie should be set on the request context root.\n     */\n    public static final String DEFAULT_PATH = null;\n\n    /**\n     * <code>-1</code>, indicating the cookie should expire when the browser closes.\n     */\n    public static final int DEFAULT_MAX_AGE = -1;\n\n    /**\n     * Default value is <code>false</code>.\n     */\n    public static final boolean DEFAULT_SECURE = false;\n\n    private String path = DEFAULT_PATH;\n\n    private int maxAge = DEFAULT_MAX_AGE;\n\n    private boolean secure = DEFAULT_SECURE;\n\n    public CookieAttribute() {\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified {@link Cookie#getName() name}\n     * using the request context's path and with a {@link Cookie#setMaxAge(int) maxAge} of <tt>-1</tt>, indicating the\n     * Cookie will persist until browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     */\n    public CookieAttribute(String name) {\n        super(name);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getPath() path}.\n     *\n     * <p>A <tt>null</tt> <tt>path</tt> value means the request context's path will be used by default.\n     *\n     * <p>The Cookie's {@link Cookie#getMaxAge() maxAge} will be <tt>-1</tt>, indicating the Cookie will persist until\n     * browser shutdown.\n     *\n     * @param name the Cookie {@link Cookie#getName() name}\n     * @param path the Cookie {@link Cookie#setPath(String) path}.\n     */\n    public CookieAttribute(String name, String path) {\n        super(name);\n        setPath(path);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name} and {@link Cookie#getMaxAge() maxAge}.\n     *\n     * <p>The Cookie's {@link javax.servlet.http.Cookie#getPath() path} will be the <tt>Request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path}.\n     *\n     * @param name   the Cookie {@link javax.servlet.http.Cookie#getName() name};\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, int maxAge) {\n        super(name);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}.\n     *\n     * @param name   the Cookie {@link Cookie#getName() name}\n     * @param path   the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge the Cookie {@link Cookie#getMaxAge() maxAge}\n     */\n    public CookieAttribute(String name, String path, int maxAge) {\n        this(name, path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Constructs a <tt>CookieAttribute</tt> using a {@link Cookie Cookie} with the specified\n     * {@link Cookie#getName() name}, {@link javax.servlet.http.Cookie#getPath() path}, and\n     * {@link Cookie#getMaxAge() maxAge}, utilizing the specified <tt>PropertyEditor</tt> to perform value/string\n     * conversion on the object stored as a cookie.\n     *\n     * @param name        the Cookie {@link Cookie#getName() name}\n     * @param path        the Cookie {@link Cookie#setPath(String) path}.\n     * @param maxAge      the Cookie {@link Cookie#getMaxAge() maxAge}\n     * @param editorClass the <tt>PropertyEditor</tt> to perform value/string conversion on the object stored as a\n     *                    Cookie.\n     */\n    public CookieAttribute(String name, String path, int maxAge, Class<? extends PropertyEditor> editorClass) {\n        super(name, editorClass);\n        setPath(path);\n        setMaxAge(maxAge);\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#getPath() path} setting.  If <tt>null</tt>, the <tt>request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     *\n     * <p>The default is <code>null</code>.</p>\n     *\n     * @return the Cookie's path, or <tt>null</tt> if the request's context path should be used as the path when the\n     *         cookie is created.\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#getPath() path} setting.  If the argument is <tt>null</tt>, the <tt>request</tt>'s\n     * {@link javax.servlet.http.HttpServletRequest#getContextPath() context path} will be used.\n     *\n     * <p>The default is <code>null</code>.</p>\n     *\n     * @param path the Cookie's path, or <tt>null</tt> if the request's context path should be used as the path when the\n     *             cookie is created.\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * Returns the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     *\n     * <p>The default value is <code>-1</code>, meaning the cookie will expire when the browser is closed.</p>\n     *\n     * @return the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public int getMaxAge() {\n        return maxAge;\n    }\n\n    /**\n     * Sets the Cookie's {@link Cookie#setMaxAge(int) maxAge} setting.  Please see that JavaDoc for the semantics on\n     * the repercussions of negative, zero, and positive values for the maxAge.\n     *\n     * <p>The default value is <code>-1</code>, meaning the cookie will expire when the browser is closed.</p>\n     *\n     * @param maxAge the Cookie's {@link Cookie#setMaxAge(int) maxAge}\n     */\n    public void setMaxAge(int maxAge) {\n        this.maxAge = maxAge;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    /**\n     * Returns the cookie with the given name from the request or <tt>null</tt> if no cookie\n     * with that name could be found.\n     *\n     * @param request    the current executing http request.\n     * @param cookieName the name of the cookie to find and return.\n     * @return the cookie with the given name from the request or <tt>null</tt> if no cookie\n     *         with that name could be found.\n     */\n    private static Cookie getCookie(HttpServletRequest request, String cookieName) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(cookieName)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public T onRetrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        String stringValue;\n        Cookie cookie = getCookie(toHttp(request), getName());\n        if (cookie != null && cookie.getMaxAge() != 0) {\n            stringValue = cookie.getValue();\n            if (log.isInfoEnabled()) {\n                log.info(\"Found string value [\" + stringValue + \"] from HttpServletRequest Cookie [\" + getName() + \"]\");\n            }\n            value = fromStringValue(stringValue);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No value found in request Cookies under cookie name [\" + getName() + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public void onStoreValue(T value, ServletRequest servletRequest, ServletResponse servletResponse) {\n        HttpServletRequest request = toHttp(servletRequest);\n        HttpServletResponse response = toHttp(servletResponse);\n        String name = getName();\n        int maxAge = getMaxAge();\n        String path = getPath() != null ? getPath() : request.getContextPath();\n        String stringValue = toStringValue(value);\n        Cookie cookie = new Cookie(name, stringValue);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n        if (isSecure()) {\n            cookie.setSecure(true);\n        }\n        response.addCookie(cookie);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Added Cookie [\" + name + \"] to path [\" + path + \"] with value [\" + stringValue + \"] to the HttpServletResponse.\");\n        }\n    }\n\n    public void removeValue(ServletRequest servletRequest, ServletResponse response) {\n        HttpServletRequest request = toHttp(servletRequest);\n        Cookie cookie = getCookie(request, getName());\n        if (cookie != null) {\n            cookie.setMaxAge(0);\n            //JSEC-94: Must set the path on the outgoing cookie (some browsers don't retain it from the\n            //retrieved cookie?)\n            cookie.setPath(getPath() == null ? request.getContextPath() : getPath());\n            cookie.setSecure(isSecure());\n            toHttp(response).addCookie(cookie);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/CookieAttributeTest1.java",
		"test_prompt": "// CookieAttributeTest1.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport static org.jsecurity.web.WebUtils.toHttp;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CookieAttribute}.\n* It contains ten unit test cases for the {@link CookieAttribute#onRetrieveValue(ServletRequest, ServletResponse)} method.\n*/\nclass CookieAttributeTest1 {"
	},
	{
		"original_code": "// AbstractWebAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * Convenient superclass for implementations of the {@link WebAttribute} interface.  This class encapsulates\n * converting values from a String form to Object form and vice versa through the use of a <tt>PropertyEditor</tt>\n * configured using {@link #setEditorClass(Class)}.  Subclasses are expected to implement the\n * {@link #onStoreValue(Object, javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and\n * {@link #onRetrieveValue(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * methods that perform the actual storing and retrieving of a String value.  This class also contains convenience\n * methods for retrieving the value of a request parameter to be stored.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class AbstractWebAttribute<T> implements WebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    public static final String DEFAULT_NAME = \"name\";\n\n    private static final Log log = LogFactory.getLog(AbstractWebAttribute.class);\n\n    protected String name = DEFAULT_NAME;\n\n    protected boolean checkRequestParams = true;\n\n    protected boolean checkRequestParamsFirst = true;\n\n    protected boolean mutable = true;\n\n    /**\n     * Property editor class to use to convert attributes to and from strings.\n     */\n    private Class<? extends PropertyEditor> editorClass = null;\n\n    public AbstractWebAttribute() {\n        this(DEFAULT_NAME, true);\n    }\n\n    public AbstractWebAttribute(String name) {\n        this(name, true);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n    }\n\n    public AbstractWebAttribute(String name, Class<? extends PropertyEditor> editorClass) {\n        this(name, true, editorClass);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams, Class<? extends PropertyEditor> editorClass) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n        setEditorClass(editorClass);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isCheckRequestParams() {\n        return checkRequestParams;\n    }\n\n    public void setCheckRequestParams(boolean checkRequestParams) {\n        this.checkRequestParams = checkRequestParams;\n    }\n\n    public boolean isCheckRequestParamsFirst() {\n        return checkRequestParamsFirst;\n    }\n\n    public void setCheckRequestParamsFirst(boolean checkRequestParamsFirst) {\n        this.checkRequestParamsFirst = checkRequestParamsFirst;\n    }\n\n    public Class<? extends PropertyEditor> getEditorClass() {\n        return editorClass;\n    }\n\n    /**\n     * If set, an instance of this class will be used to convert a the object value to a string value (and vice versa)\n     * when reading and populating values in\n     * {@link javax.servlet.http.HttpServletRequest HttpServletRequest}s, {@link javax.servlet.http.Cookie Cookie}s or\n     * {@link javax.servlet.http.HttpSession HttpSession}s.\n     *\n     * <p>If not set, the string itself will be used.\n     *\n     * @param editorClass {@link PropertyEditor PropertyEditor} implementation used to\n     *                    convert between string values and sessionId objects.\n     */\n    public void setEditorClass(Class<? extends PropertyEditor> editorClass) {\n        this.editorClass = editorClass;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     * <p>Default is <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     */\n    public boolean isMutable() {\n        return mutable;\n    }\n\n    public void setMutable(boolean mutable) {\n        this.mutable = mutable;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected T fromStringValue(String stringValue) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            try {\n                return (T) stringValue;\n            } catch (Exception e) {\n                String msg = \"If the type is not String, you must specify the 'editorClass' property.\";\n                throw new JSecurityException(msg, e);\n            }\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setAsText(stringValue);\n            Object value = editor.getValue();\n            try {\n                return (T) value;\n            } catch (ClassCastException e) {\n                String msg = \"Returned value from PropertyEditor does not match the specified type.\";\n                throw new JSecurityException(msg, e);\n            }\n        }\n    }\n\n    protected String toStringValue(T value) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No 'editorClass' property set - returning value.toString() as the string value for \" + \"method argument.\");\n            }\n            return value.toString();\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setValue(value);\n            return editor.getAsText();\n        }\n    }\n\n    protected T getFromRequestParam(ServletRequest request) {\n        T value = null;\n        String paramName = getName();\n        String paramValue = request.getParameter(paramName);\n        if (paramValue != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found string value [\" + paramValue + \"] from HttpServletRequest parameter [\" + paramName + \"]\");\n            }\n            value = fromStringValue(paramValue);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No string value found in the HttpServletRequest under parameter named [\" + paramName + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public final T retrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        if (isCheckRequestParams() && isCheckRequestParamsFirst()) {\n            value = getFromRequestParam(request);\n        }\n        if (value == null) {\n            value = onRetrieveValue(request, response);\n        }\n        if (value == null) {\n            if (isCheckRequestParams() && !isCheckRequestParamsFirst()) {\n                value = getFromRequestParam(request);\n            }\n        }\n        return value;\n    }\n\n    protected abstract T onRetrieveValue(ServletRequest request, ServletResponse response);\n\n    public void storeValue(T value, ServletRequest request, ServletResponse response) {\n        if (value == null && isMutable()) {\n            removeValue(request, response);\n            return;\n        }\n        if (!isMutable()) {\n            Object existing = onRetrieveValue(request, response);\n            if (existing != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Found existing value stored under name [\" + getName() + \"].  Ignoring new \" + \"storage request - this store is immutable after the value has initially been set.\");\n                }\n            }\n            return;\n        }\n        onStoreValue(value, request, response);\n    }\n\n    protected abstract void onStoreValue(T value, ServletRequest request, ServletResponse response);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/AbstractWebAttributeTest0.java",
		"test_prompt": "// AbstractWebAttributeTest0.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractWebAttribute}.\n* It contains ten unit test cases for the {@link AbstractWebAttribute#isCheckRequestParams()} method.\n*/\nclass AbstractWebAttributeTest0 {"
	},
	{
		"original_code": "// AbstractWebAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * Convenient superclass for implementations of the {@link WebAttribute} interface.  This class encapsulates\n * converting values from a String form to Object form and vice versa through the use of a <tt>PropertyEditor</tt>\n * configured using {@link #setEditorClass(Class)}.  Subclasses are expected to implement the\n * {@link #onStoreValue(Object, javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and\n * {@link #onRetrieveValue(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * methods that perform the actual storing and retrieving of a String value.  This class also contains convenience\n * methods for retrieving the value of a request parameter to be stored.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class AbstractWebAttribute<T> implements WebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    public static final String DEFAULT_NAME = \"name\";\n\n    private static final Log log = LogFactory.getLog(AbstractWebAttribute.class);\n\n    protected String name = DEFAULT_NAME;\n\n    protected boolean checkRequestParams = true;\n\n    protected boolean checkRequestParamsFirst = true;\n\n    protected boolean mutable = true;\n\n    /**\n     * Property editor class to use to convert attributes to and from strings.\n     */\n    private Class<? extends PropertyEditor> editorClass = null;\n\n    public AbstractWebAttribute() {\n        this(DEFAULT_NAME, true);\n    }\n\n    public AbstractWebAttribute(String name) {\n        this(name, true);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n    }\n\n    public AbstractWebAttribute(String name, Class<? extends PropertyEditor> editorClass) {\n        this(name, true, editorClass);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams, Class<? extends PropertyEditor> editorClass) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n        setEditorClass(editorClass);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isCheckRequestParams() {\n        return checkRequestParams;\n    }\n\n    public void setCheckRequestParams(boolean checkRequestParams) {\n        this.checkRequestParams = checkRequestParams;\n    }\n\n    public boolean isCheckRequestParamsFirst() {\n        return checkRequestParamsFirst;\n    }\n\n    public void setCheckRequestParamsFirst(boolean checkRequestParamsFirst) {\n        this.checkRequestParamsFirst = checkRequestParamsFirst;\n    }\n\n    public Class<? extends PropertyEditor> getEditorClass() {\n        return editorClass;\n    }\n\n    /**\n     * If set, an instance of this class will be used to convert a the object value to a string value (and vice versa)\n     * when reading and populating values in\n     * {@link javax.servlet.http.HttpServletRequest HttpServletRequest}s, {@link javax.servlet.http.Cookie Cookie}s or\n     * {@link javax.servlet.http.HttpSession HttpSession}s.\n     *\n     * <p>If not set, the string itself will be used.\n     *\n     * @param editorClass {@link PropertyEditor PropertyEditor} implementation used to\n     *                    convert between string values and sessionId objects.\n     */\n    public void setEditorClass(Class<? extends PropertyEditor> editorClass) {\n        this.editorClass = editorClass;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     * <p>Default is <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     */\n    public boolean isMutable() {\n        return mutable;\n    }\n\n    public void setMutable(boolean mutable) {\n        this.mutable = mutable;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected T fromStringValue(String stringValue) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            try {\n                return (T) stringValue;\n            } catch (Exception e) {\n                String msg = \"If the type is not String, you must specify the 'editorClass' property.\";\n                throw new JSecurityException(msg, e);\n            }\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setAsText(stringValue);\n            Object value = editor.getValue();\n            try {\n                return (T) value;\n            } catch (ClassCastException e) {\n                String msg = \"Returned value from PropertyEditor does not match the specified type.\";\n                throw new JSecurityException(msg, e);\n            }\n        }\n    }\n\n    protected String toStringValue(T value) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No 'editorClass' property set - returning value.toString() as the string value for \" + \"method argument.\");\n            }\n            return value.toString();\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setValue(value);\n            return editor.getAsText();\n        }\n    }\n\n    protected T getFromRequestParam(ServletRequest request) {\n        T value = null;\n        String paramName = getName();\n        String paramValue = request.getParameter(paramName);\n        if (paramValue != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found string value [\" + paramValue + \"] from HttpServletRequest parameter [\" + paramName + \"]\");\n            }\n            value = fromStringValue(paramValue);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No string value found in the HttpServletRequest under parameter named [\" + paramName + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public final T retrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        if (isCheckRequestParams() && isCheckRequestParamsFirst()) {\n            value = getFromRequestParam(request);\n        }\n        if (value == null) {\n            value = onRetrieveValue(request, response);\n        }\n        if (value == null) {\n            if (isCheckRequestParams() && !isCheckRequestParamsFirst()) {\n                value = getFromRequestParam(request);\n            }\n        }\n        return value;\n    }\n\n    protected abstract T onRetrieveValue(ServletRequest request, ServletResponse response);\n\n    public void storeValue(T value, ServletRequest request, ServletResponse response) {\n        if (value == null && isMutable()) {\n            removeValue(request, response);\n            return;\n        }\n        if (!isMutable()) {\n            Object existing = onRetrieveValue(request, response);\n            if (existing != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Found existing value stored under name [\" + getName() + \"].  Ignoring new \" + \"storage request - this store is immutable after the value has initially been set.\");\n                }\n            }\n            return;\n        }\n        onStoreValue(value, request, response);\n    }\n\n    protected abstract void onStoreValue(T value, ServletRequest request, ServletResponse response);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/AbstractWebAttributeTest1.java",
		"test_prompt": "// AbstractWebAttributeTest1.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractWebAttribute}.\n* It contains ten unit test cases for the {@link AbstractWebAttribute#isCheckRequestParamsFirst()} method.\n*/\nclass AbstractWebAttributeTest1 {"
	},
	{
		"original_code": "// AbstractWebAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * Convenient superclass for implementations of the {@link WebAttribute} interface.  This class encapsulates\n * converting values from a String form to Object form and vice versa through the use of a <tt>PropertyEditor</tt>\n * configured using {@link #setEditorClass(Class)}.  Subclasses are expected to implement the\n * {@link #onStoreValue(Object, javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and\n * {@link #onRetrieveValue(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * methods that perform the actual storing and retrieving of a String value.  This class also contains convenience\n * methods for retrieving the value of a request parameter to be stored.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class AbstractWebAttribute<T> implements WebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    public static final String DEFAULT_NAME = \"name\";\n\n    private static final Log log = LogFactory.getLog(AbstractWebAttribute.class);\n\n    protected String name = DEFAULT_NAME;\n\n    protected boolean checkRequestParams = true;\n\n    protected boolean checkRequestParamsFirst = true;\n\n    protected boolean mutable = true;\n\n    /**\n     * Property editor class to use to convert attributes to and from strings.\n     */\n    private Class<? extends PropertyEditor> editorClass = null;\n\n    public AbstractWebAttribute() {\n        this(DEFAULT_NAME, true);\n    }\n\n    public AbstractWebAttribute(String name) {\n        this(name, true);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n    }\n\n    public AbstractWebAttribute(String name, Class<? extends PropertyEditor> editorClass) {\n        this(name, true, editorClass);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams, Class<? extends PropertyEditor> editorClass) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n        setEditorClass(editorClass);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isCheckRequestParams() {\n        return checkRequestParams;\n    }\n\n    public void setCheckRequestParams(boolean checkRequestParams) {\n        this.checkRequestParams = checkRequestParams;\n    }\n\n    public boolean isCheckRequestParamsFirst() {\n        return checkRequestParamsFirst;\n    }\n\n    public void setCheckRequestParamsFirst(boolean checkRequestParamsFirst) {\n        this.checkRequestParamsFirst = checkRequestParamsFirst;\n    }\n\n    public Class<? extends PropertyEditor> getEditorClass() {\n        return editorClass;\n    }\n\n    /**\n     * If set, an instance of this class will be used to convert a the object value to a string value (and vice versa)\n     * when reading and populating values in\n     * {@link javax.servlet.http.HttpServletRequest HttpServletRequest}s, {@link javax.servlet.http.Cookie Cookie}s or\n     * {@link javax.servlet.http.HttpSession HttpSession}s.\n     *\n     * <p>If not set, the string itself will be used.\n     *\n     * @param editorClass {@link PropertyEditor PropertyEditor} implementation used to\n     *                    convert between string values and sessionId objects.\n     */\n    public void setEditorClass(Class<? extends PropertyEditor> editorClass) {\n        this.editorClass = editorClass;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     * <p>Default is <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     */\n    public boolean isMutable() {\n        return mutable;\n    }\n\n    public void setMutable(boolean mutable) {\n        this.mutable = mutable;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected T fromStringValue(String stringValue) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            try {\n                return (T) stringValue;\n            } catch (Exception e) {\n                String msg = \"If the type is not String, you must specify the 'editorClass' property.\";\n                throw new JSecurityException(msg, e);\n            }\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setAsText(stringValue);\n            Object value = editor.getValue();\n            try {\n                return (T) value;\n            } catch (ClassCastException e) {\n                String msg = \"Returned value from PropertyEditor does not match the specified type.\";\n                throw new JSecurityException(msg, e);\n            }\n        }\n    }\n\n    protected String toStringValue(T value) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No 'editorClass' property set - returning value.toString() as the string value for \" + \"method argument.\");\n            }\n            return value.toString();\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setValue(value);\n            return editor.getAsText();\n        }\n    }\n\n    protected T getFromRequestParam(ServletRequest request) {\n        T value = null;\n        String paramName = getName();\n        String paramValue = request.getParameter(paramName);\n        if (paramValue != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found string value [\" + paramValue + \"] from HttpServletRequest parameter [\" + paramName + \"]\");\n            }\n            value = fromStringValue(paramValue);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No string value found in the HttpServletRequest under parameter named [\" + paramName + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public final T retrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        if (isCheckRequestParams() && isCheckRequestParamsFirst()) {\n            value = getFromRequestParam(request);\n        }\n        if (value == null) {\n            value = onRetrieveValue(request, response);\n        }\n        if (value == null) {\n            if (isCheckRequestParams() && !isCheckRequestParamsFirst()) {\n                value = getFromRequestParam(request);\n            }\n        }\n        return value;\n    }\n\n    protected abstract T onRetrieveValue(ServletRequest request, ServletResponse response);\n\n    public void storeValue(T value, ServletRequest request, ServletResponse response) {\n        if (value == null && isMutable()) {\n            removeValue(request, response);\n            return;\n        }\n        if (!isMutable()) {\n            Object existing = onRetrieveValue(request, response);\n            if (existing != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Found existing value stored under name [\" + getName() + \"].  Ignoring new \" + \"storage request - this store is immutable after the value has initially been set.\");\n                }\n            }\n            return;\n        }\n        onStoreValue(value, request, response);\n    }\n\n    protected abstract void onStoreValue(T value, ServletRequest request, ServletResponse response);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/AbstractWebAttributeTest2.java",
		"test_prompt": "// AbstractWebAttributeTest2.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractWebAttribute}.\n* It contains ten unit test cases for the {@link AbstractWebAttribute#isMutable()} method.\n*/\nclass AbstractWebAttributeTest2 {"
	},
	{
		"original_code": "// AbstractWebAttribute.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\n\n/**\n * Convenient superclass for implementations of the {@link WebAttribute} interface.  This class encapsulates\n * converting values from a String form to Object form and vice versa through the use of a <tt>PropertyEditor</tt>\n * configured using {@link #setEditorClass(Class)}.  Subclasses are expected to implement the\n * {@link #onStoreValue(Object, javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and\n * {@link #onRetrieveValue(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * methods that perform the actual storing and retrieving of a String value.  This class also contains convenience\n * methods for retrieving the value of a request parameter to be stored.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class AbstractWebAttribute<T> implements WebAttribute<T> {\n\n    //TODO - complete JavaDoc\n    public static final String DEFAULT_NAME = \"name\";\n\n    private static final Log log = LogFactory.getLog(AbstractWebAttribute.class);\n\n    protected String name = DEFAULT_NAME;\n\n    protected boolean checkRequestParams = true;\n\n    protected boolean checkRequestParamsFirst = true;\n\n    protected boolean mutable = true;\n\n    /**\n     * Property editor class to use to convert attributes to and from strings.\n     */\n    private Class<? extends PropertyEditor> editorClass = null;\n\n    public AbstractWebAttribute() {\n        this(DEFAULT_NAME, true);\n    }\n\n    public AbstractWebAttribute(String name) {\n        this(name, true);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n    }\n\n    public AbstractWebAttribute(String name, Class<? extends PropertyEditor> editorClass) {\n        this(name, true, editorClass);\n    }\n\n    public AbstractWebAttribute(String name, boolean checkRequestParams, Class<? extends PropertyEditor> editorClass) {\n        setName(name);\n        setCheckRequestParams(checkRequestParams);\n        setEditorClass(editorClass);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isCheckRequestParams() {\n        return checkRequestParams;\n    }\n\n    public void setCheckRequestParams(boolean checkRequestParams) {\n        this.checkRequestParams = checkRequestParams;\n    }\n\n    public boolean isCheckRequestParamsFirst() {\n        return checkRequestParamsFirst;\n    }\n\n    public void setCheckRequestParamsFirst(boolean checkRequestParamsFirst) {\n        this.checkRequestParamsFirst = checkRequestParamsFirst;\n    }\n\n    public Class<? extends PropertyEditor> getEditorClass() {\n        return editorClass;\n    }\n\n    /**\n     * If set, an instance of this class will be used to convert a the object value to a string value (and vice versa)\n     * when reading and populating values in\n     * {@link javax.servlet.http.HttpServletRequest HttpServletRequest}s, {@link javax.servlet.http.Cookie Cookie}s or\n     * {@link javax.servlet.http.HttpSession HttpSession}s.\n     *\n     * <p>If not set, the string itself will be used.\n     *\n     * @param editorClass {@link PropertyEditor PropertyEditor} implementation used to\n     *                    convert between string values and sessionId objects.\n     */\n    public void setEditorClass(Class<? extends PropertyEditor> editorClass) {\n        this.editorClass = editorClass;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     * <p>Default is <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if the value stored can be changed once it has been set, <tt>false</tt> if it cannot.\n     */\n    public boolean isMutable() {\n        return mutable;\n    }\n\n    public void setMutable(boolean mutable) {\n        this.mutable = mutable;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected T fromStringValue(String stringValue) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            try {\n                return (T) stringValue;\n            } catch (Exception e) {\n                String msg = \"If the type is not String, you must specify the 'editorClass' property.\";\n                throw new JSecurityException(msg, e);\n            }\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setAsText(stringValue);\n            Object value = editor.getValue();\n            try {\n                return (T) value;\n            } catch (ClassCastException e) {\n                String msg = \"Returned value from PropertyEditor does not match the specified type.\";\n                throw new JSecurityException(msg, e);\n            }\n        }\n    }\n\n    protected String toStringValue(T value) {\n        Class clazz = getEditorClass();\n        if (clazz == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No 'editorClass' property set - returning value.toString() as the string value for \" + \"method argument.\");\n            }\n            return value.toString();\n        } else {\n            PropertyEditor editor = (PropertyEditor) ClassUtils.newInstance(getEditorClass());\n            editor.setValue(value);\n            return editor.getAsText();\n        }\n    }\n\n    protected T getFromRequestParam(ServletRequest request) {\n        T value = null;\n        String paramName = getName();\n        String paramValue = request.getParameter(paramName);\n        if (paramValue != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found string value [\" + paramValue + \"] from HttpServletRequest parameter [\" + paramName + \"]\");\n            }\n            value = fromStringValue(paramValue);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No string value found in the HttpServletRequest under parameter named [\" + paramName + \"]\");\n            }\n        }\n        return value;\n    }\n\n    public final T retrieveValue(ServletRequest request, ServletResponse response) {\n        T value = null;\n        if (isCheckRequestParams() && isCheckRequestParamsFirst()) {\n            value = getFromRequestParam(request);\n        }\n        if (value == null) {\n            value = onRetrieveValue(request, response);\n        }\n        if (value == null) {\n            if (isCheckRequestParams() && !isCheckRequestParamsFirst()) {\n                value = getFromRequestParam(request);\n            }\n        }\n        return value;\n    }\n\n    protected abstract T onRetrieveValue(ServletRequest request, ServletResponse response);\n\n    public void storeValue(T value, ServletRequest request, ServletResponse response) {\n        if (value == null && isMutable()) {\n            removeValue(request, response);\n            return;\n        }\n        if (!isMutable()) {\n            Object existing = onRetrieveValue(request, response);\n            if (existing != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Found existing value stored under name [\" + getName() + \"].  Ignoring new \" + \"storage request - this store is immutable after the value has initially been set.\");\n                }\n            }\n            return;\n        }\n        onStoreValue(value, request, response);\n    }\n\n    protected abstract void onStoreValue(T value, ServletRequest request, ServletResponse response);\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/attr/AbstractWebAttributeTest3.java",
		"test_prompt": "// AbstractWebAttributeTest3.java\npackage org.jsecurity.web.attr;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.JSecurityException;\nimport org.jsecurity.util.ClassUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.beans.PropertyEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractWebAttribute}.\n* It contains ten unit test cases for the {@link AbstractWebAttribute#retrieveValue(ServletRequest, ServletResponse)} method.\n*/\nclass AbstractWebAttributeTest3 {"
	},
	{
		"original_code": "// WebRememberMeManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.subject.AbstractRememberMeManager;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Remembers a Subject's identity by using a {@link WebAttribute WebAttribute} instance to retain\n * the identity value between web requests.\n *\n * <p>This class's default <code>WebAttribute</code> instance is a {@link CookieAttribute CookieAttribute}, storing\n * the Subject's {@link org.jsecurity.subject.Subject#getPrincipals principals} in a <code>Cookie</code>.  Note that\n * because this class subclasses the <code>AbstractRememberMeManager</code> which already provides serialization and\n * encryption logic, this class utilizes both for added security before setting the cookie value.</p>\n *\n * <p>This class also contains &quot;passthrough&quot; JavaBeans-compatible getters/setters for the underlying\n * <code>CookieAttribute</code>'s properties to make configuration easier.</p>\n *\n * <p>Note however as a basic sanity check, these passthrough methods will first assert that the underlying\n * {@link #getIdentityAttribute identityAttribute} is actually a {@link CookieAttribute CookieAttribute}.  If it\n * is not, an {@link IllegalStateException} will be thrown.  Because the default instance of this class <em>is</em>\n * already <code>CookieAttribute</code>, you would only ever experience the exception if you explicitly\n * override the internal instance with a different type and accidentally call one of these JavaBeans passthrough\n * methods.</p>\n *\n * <p>Just be aware of this if you manually override the {@link #getIdentityAttribute identityAttribute} property\n * to be an instance of something <em>other</em> than a <code>CookieAttribute</code>.</p>\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class WebRememberMeManager extends AbstractRememberMeManager {\n\n    //TODO - complete JavaDoc\n    private static transient final Log log = LogFactory.getLog(WebRememberMeManager.class);\n\n    /**\n     * The default name of the underlying rememberMe cookie which is <code>rememberMe</code>.\n     */\n    public static final String DEFAULT_REMEMBER_ME_COOKIE_NAME = \"rememberMe\";\n\n    protected WebAttribute<String> identityAttribute = null;\n\n    public WebRememberMeManager() {\n        CookieAttribute<String> attr = new CookieAttribute<String>(DEFAULT_REMEMBER_ME_COOKIE_NAME);\n        attr.setCheckRequestParams(false);\n        //Peter (JSecurity developer) said that Jetty didn't like the CookieAttribute.INDEFINITE value\n        // (Tomcat was ok with it), so just default to a few years for now.  If anyone doesn't visit a site in 3 years\n        // after last login, I doubt any JSecurity users would mind their end-users to be forced to log in. - LAH.\n        attr.setMaxAge(CookieAttribute.ONE_YEAR * 3);\n        this.identityAttribute = attr;\n    }\n\n    public WebAttribute<String> getIdentityAttribute() {\n        return identityAttribute;\n    }\n\n    public void setIdentityAttribute(WebAttribute<String> identityAttribute) {\n        this.identityAttribute = identityAttribute;\n    }\n\n    protected void assertCookieAttribute() {\n        if (!(this.identityAttribute instanceof CookieAttribute)) {\n            String msg = \"Attempting to access a Cookie property, but the underlying \" + WebAttribute.class.getName() + \" instance is not a \" + CookieAttribute.class.getName() + \" instance.  This is expected if you \" + \"are accessing or modifying a cookie property.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}</p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @return the underlying rememberMe cookie's name\n     */\n    public String getCookieName() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getName();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's name.\n     *\n     * <p>The default value is {@link #DEFAULT_REMEMBER_ME_COOKIE_NAME}</p>\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @param name the name to assign to the underlying rememberMe cookie\n     */\n    public void setCookieName(String name) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setName(name);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @return the underlying rememberMe cookie's path\n     */\n    public String getCookiePath() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getPath();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's path.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @param path the path to assign to the underlying rememberMe cookie\n     */\n    public void setCookiePath(String path) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setPath(path);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @return the underlying rememberMe cookie's max age.\n     */\n    public int getCookieMaxAge() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).getMaxAge();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's max age.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @param maxAge the max age to assign to the underlying rememberMe cookie\n     */\n    public void setCookieMaxAge(int maxAge) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setMaxAge(maxAge);\n    }\n\n    /**\n     * Passthrough JavaBeans property that will get the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @return the underlying rememberMe cookie's 'secure' flag\n     */\n    public boolean isCookieSecure() {\n        assertCookieAttribute();\n        return ((CookieAttribute) this.identityAttribute).isSecure();\n    }\n\n    /**\n     * Passthrough JavaBeans property that will set the underyling rememberMe cookie's 'secure' status.\n     *\n     * <p>This method performs a quick <code>CookieAttribute</code> sanity check as described in the class-level JavaDoc.</p>\n     *\n     * @param secure the 'secure' flag to assign to the underlying rememberMe cookie.\n     */\n    public void setCookieSecure(boolean secure) {\n        assertCookieAttribute();\n        ((CookieAttribute) this.identityAttribute).setSecure(secure);\n    }\n\n    protected void rememberSerializedIdentity(byte[] serialized) {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        //base 64 encode it and store as a cookie:\n        String base64 = Base64.encodeToString(serialized);\n        getIdentityAttribute().storeValue(base64, request, response);\n    }\n\n    protected byte[] getSerializedRememberedIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        String base64 = getIdentityAttribute().retrieveValue(request, response);\n        if (base64 != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\");\n            }\n            byte[] decoded = Base64.decode(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\");\n            }\n            return decoded;\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }\n\n    protected void forgetIdentity() {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getIdentityAttribute().removeValue(request, response);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebRememberMeManagerTest.java",
		"test_prompt": "// WebRememberMeManagerTest.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.subject.AbstractRememberMeManager;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebRememberMeManager}.\n* It contains ten unit test cases for the {@link WebRememberMeManager#isCookieSecure()} method.\n*/\nclass WebRememberMeManagerTest {"
	},
	{
		"original_code": "// PathMatchingFilter.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.AntPathMatcher;\nimport org.jsecurity.util.PatternMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * <p>Base class for Filters that will process only specified paths and allow all others to pass through.</p>\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic abstract class PathMatchingFilter extends AdviceFilter implements PathConfigProcessor {\n\n    /**\n     * Log available to this class only\n     */\n    private static final Log log = LogFactory.getLog(PathMatchingFilter.class);\n\n    /**\n     * PatternMatcher used in determining which paths to react to for a given request.\n     */\n    protected PatternMatcher pathMatcher = new AntPathMatcher();\n\n    /**\n     * A collection of path-to-config entries where the key is a path which this filter should process and\n     * the value is the (possibly null) configuration element specific to this Filter for that specific path.\n     *\n     * <p>To put it another way, the keys are the paths (urls) that this Filter will process.\n     * <p>The values are filter-specific data that this Filter should use when processing the corresponding\n     * key (path).  The values can be null if no Filter-specific config was specified for that url.\n     */\n    protected Map<String, Object> appliedPaths = new LinkedHashMap<String, Object>();\n\n    /**\n     * Splits any comma-delmited values that might be found in the <code>config</code> argument and sets the resulting\n     * <code>String[]</code> array on the <code>appliedPaths</code> internal Map.\n     * <p/>\n     * That is:\n     * <pre><code>\n     * String[] values = null;\n     * if (config != null) {\n     *     values = split(config);\n     * }\n     *\n     * this.{@link #appliedPaths appliedPaths}.put(path, values);\n     * </code></pre>\n     *\n     * @param path   the application context path to match for executing this filter.\n     * @param config the specified for <em>this particular filter only</em> for the given <code>path</code>\n     */\n    public void processPathConfig(String path, String config) {\n        String[] values = null;\n        if (config != null) {\n            values = split(config);\n        }\n        this.appliedPaths.put(path, values);\n    }\n\n    /**\n     * Returns the context path within the application based on the specified <code>request</code>.\n     * <p/>\n     * This implementation merely delegates to\n     * {@link WebUtils#getPathWithinApplication(javax.servlet.http.HttpServletRequest) WebUtils.getPathWithinApplication(request)},\n     * but can be overridden by subclasses for custom logic.\n     *\n     * @param request the incoming <code>ServletRequest</code>\n     * @return the context path within the application.\n     */\n    protected String getPathWithinApplication(ServletRequest request) {\n        return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));\n    }\n\n    /**\n     * Returns <code>true</code> if the incoming <code>request</code> matches the specified <code>path</code> pattern,\n     * <code>false</code> otherwise.\n     * <p/>\n     * The default implementation acquires the <code>request</code>'s path within the application and determines\n     * if that matches:\n     * <p/>\n     * <code>String requestURI = {@link #getPathWithinApplication(javax.servlet.ServletRequest) getPathWithinApplication(request)};<br/>\n     * return {@link #pathsMatch(String, String) pathsMatch(path,requestURI)}</code>\n     *\n     * @param path    the configured url pattern to check the incoming request against.\n     * @param request the incoming ServletRequest\n     * @return <code>true</code> if the incoming <code>request</code> matches the specified <code>path</code> pattern,\n     *         <code>false</code> otherwise.\n     */\n    protected boolean pathsMatch(String path, ServletRequest request) {\n        String requestURI = getPathWithinApplication(request);\n        if (log.isTraceEnabled()) {\n            log.trace(\"Attempting to match pattern [\" + path + \"] with current requestURI [\" + requestURI + \"]...\");\n        }\n        return pathsMatch(path, requestURI);\n    }\n\n    /**\n     * Returns <code>true</code> if the <code>path</code> matches the specified <code>pattern</code> string,\n     * <code>false</code> otherwise.\n     * <p/>\n     * Simply delegates to\n     * <b><code>this.pathMatcher.{@link PatternMatcher#matches(String, String) matches(pattern,path)}</code></b>,\n     * but can be overridden by subclasses for custom matching behavior.\n     *\n     * @param pattern the pattern to match against\n     * @param path    the value to match with the specified <code>pattern</code>\n     * @return <code>true</code> if the <code>path</code> matches the specified <code>pattern</code> string,\n     *         <code>false</code> otherwise.\n     */\n    protected boolean pathsMatch(String pattern, String path) {\n        return pathMatcher.matches(pattern, path);\n    }\n\n    /**\n     * Implementation that handles path-matching behavior before a request is evaluated.  If the path matches,\n     * the request will be allowed through via the result from\n     * {@link #onPreHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) onPreHandle}.  If the\n     * path does not match, this filter will allow passthrough immediately.\n     *\n     * <p>In order to retain path-matching functionality, subclasses should not override this method if at all\n     * possible, and instead override\n     * {@link #onPreHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) onPreHandle} instead.\n     *\n     * @param request  the incoming ServletRequest\n     * @param response the outgoing ServletResponse\n     * @return true - allow the request chain to continue in this default implementation\n     * @throws Exception\n     */\n    public boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\n        if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"appliedPaths property is null or empty.  This Filter will passthrough immediately.\");\n            }\n            return true;\n        }\n        for (String path : this.appliedPaths.keySet()) {\n            // If the path does match, then pass on to the subclass implementation for specific checks\n            //(first match 'wins'):\n            if (pathsMatch(path, request)) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Current requestURI matches pattern [\" + path + \"].  Performing onPreHandle check...\");\n                }\n                Object config = this.appliedPaths.get(path);\n                return onPreHandle(request, response, config);\n            }\n        }\n        //no path matched, allow the request to go through:\n        return true;\n    }\n\n    /**\n     * Default implementation always returns <code>true</code>.  Should be overridden by subclasses for custom\n     * logic.\n     *\n     * @param request     the incoming ServletRequest\n     * @param response    the outgoing ServletResponse\n     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.\n     * @return <code>true</code> if the request should be able to continue, <code>false</code> if the filter will\n     *         handle the response directly.\n     * @throws Exception if an error occurs\n     */\n    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/filter/PathMatchingFilterTest.java",
		"test_prompt": "// PathMatchingFilterTest.java\npackage org.jsecurity.web.filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.AntPathMatcher;\nimport org.jsecurity.util.PatternMatcher;\nimport static org.jsecurity.util.StringUtils.split;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.servlet.AdviceFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PathMatchingFilter}.\n* It contains ten unit test cases for the {@link PathMatchingFilter#preHandle(ServletRequest, ServletResponse)} method.\n*/\nclass PathMatchingFilterTest {"
	},
	{
		"original_code": "// AnonymousFilter.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authc;\n\nimport org.jsecurity.web.filter.PathMatchingFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * Filter that allows access to a path immeidately without performing security checks of any kind.\n * <p/>\n * This filter is useful primarily in exclusionary policies, where you have defined a url pattern\n * to require a certain security level, but maybe only subset of urls in that pattern should allow any access.\n * <p/>\n * For example, if you had a user-only section of a website, you might want to require that access to\n * any url in that section must be from an authenticated user.\n * <p/>\n * Here is how that would look in the JSecurityFilter configuration:\n * <p/>\n * <code>[urls]<br/>\n * /user/** = authc</code>\n * <p/>\n * But if you wanted <code>/user/signup/**</code> to be available to anyone, you have to exclude that path since\n * it is a subset of the first.  This is where the AnonymousFilter ('anon') is useful:\n * <p/>\n * <code>[urls]<br/>\n * /user/signup/** = anon<br/>\n * /user/** = authc</code>>\n * <p/>\n * Since the url pattern definitions follow a 'first match wins' paradigm, the <code>anon</code> filter will\n * match the <code>/user/signup/**</code> paths and the <code>/user/**</code> path chain will not be evaluated.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class AnonymousFilter extends PathMatchingFilter {\n\n    /**\n     * Always returns <code>true</code> allowing unchecked access to the underlying path or resource.\n     *\n     * @return <code>true</code> always, allowing unchecked access to the underlying path or resource.\n     */\n    @Override\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) {\n        // Always return true since we allow access to anyone\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/filter/authc/AnonymousFilterTest.java",
		"test_prompt": "// AnonymousFilterTest.java\npackage org.jsecurity.web.filter.authc;\n\nimport org.jsecurity.web.filter.PathMatchingFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnonymousFilter}.\n* It contains ten unit test cases for the {@link AnonymousFilter#onPreHandle(ServletRequest, ServletResponse, Object)} method.\n*/\nclass AnonymousFilterTest {"
	},
	{
		"original_code": "// AccessControlFilter.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.WebUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * Superclass for any filter that controls access to a resource and may redirect the user to the login page\n * if they are not authenticated.  This superclass provides the method\n * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}\n * which is used by many subclasses as the behavior when a user is unauthenticated.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AccessControlFilter extends PathMatchingFilter {\n\n    /**\n     * Simple default login URL equal to <code>/login.jsp</code>, which can be overridden by calling the\n     * {@link #setLoginUrl(String) setLoginUrl} method.\n     */\n    public static final String DEFAULT_LOGIN_URL = \"/login.jsp\";\n\n    /**\n     * Constant representing the HTTP 'GET' request method, equal to <code>GET</code>.\n     */\n    public static final String GET_METHOD = \"GET\";\n\n    /**\n     * Constant representing the HTTP 'POST' request method, equal to <code>POST</code>.\n     */\n    public static final String POST_METHOD = \"POST\";\n\n    /**\n     * The login url to used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    private String loginUrl = DEFAULT_LOGIN_URL;\n\n    /**\n     * Returns the login URL used to authenticate a user.\n     * <p/>\n     * Most JSecurity filters use this url\n     * as the location to redirect a user when the filter requires authentication.  Unless overridden, the\n     * {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed, which can be overridden via\n     * {@link #setLoginUrl(String) setLoginUrl}.\n     *\n     * @return the login URL used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    protected String getLoginUrl() {\n        return loginUrl;\n    }\n\n    /**\n     * Sets the login URL used to authenticate a user.\n     * <p/>\n     * Most JSecurity filters use this url as the location to redirect a user when the filter requires\n     * authentication.  Unless overridden, the {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed.\n     *\n     * @param loginUrl the login URL used to authenticate a user, used when redirecting users if authentication is required.\n     */\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    /**\n     * Convenience method that acquires the Subject associated with the request.\n     * <p/>\n     * The default implementation simply returns\n     * {@link org.jsecurity.SecurityUtils#getSubject() SecurityUtils.getSubject()}.\n     *\n     * @param request  the incoming <code>ServletRequest</code>\n     * @param response the outgoing <code>ServletResponse</code>\n     * @return the Subject associated with the request.\n     */\n    protected Subject getSubject(ServletRequest request, ServletResponse response) {\n        return SecurityUtils.getSubject();\n    }\n\n    /**\n     * Returns <code>true</code> if the request is allowed to proceed through the filter normally, or <code>false</code>\n     * if the request should be handled by the\n     * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied(request,response)}\n     * method instead.\n     *\n     * @param request     the incoming <code>ServletRequest</code>\n     * @param response    the outgoing <code>ServletResponse</code>\n     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.\n     * @return <code>true</code> if the request should proceed through the filter normally, <code>false</code> if the\n     *         request should be processed by this filter's\n     *         {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method instead.\n     * @throws Exception if an error occurs during processing.\n     */\n    protected abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;\n\n    /**\n     * Processes requests where the subject was denied access as determined by the\n     * {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed}\n     * method.\n     *\n     * @param request  the incoming <code>ServletRequest</code>\n     * @param response the outgoing <code>ServletResponse</code>\n     * @return <code>true</code> if the request should continue to be processed; false if the subclass will\n     *         handle/render the response directly.\n     * @throws Exception if there is an error processing the request.\n     */\n    protected abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;\n\n    /**\n     * Returns <code>true</code> if\n     * {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed},\n     * otherwise returns the result of\n     * {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied}.\n     *\n     * @return <code>true</code> if\n     *         {@link #isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed},\n     *         otherwise returns the result of\n     *         {@link #onAccessDenied(javax.servlet.ServletRequest, javax.servlet.ServletResponse) onAccessDenied}.\n     * @throws Exception if an error occurs.\n     */\n    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n        //mapped value is ignored - not needed for most (if not all) authc Filters.\n        return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response);\n    }\n\n    /**\n     * Returns <code>true</code> if the incoming request is a login request, <code>false</code> otherwise.\n     * <p/>\n     * The default implementation merely returns <code>true</code> if the incoming request matches the configured\n     * {@link #getLoginUrl() loginUrl} by calling\n     * <code>{@link #pathsMatch(String, String) pathsMatch(loginUrl, request)}</code>.\n     *\n     * @param request  the incoming <code>ServletRequest</code>\n     * @param response the outgoing <code>ServletResponse</code>\n     * @return <code>true</code> if the incoming request is a login request, <code>false</code> otherwise.\n     */\n    protected boolean isLoginRequest(ServletRequest request, ServletResponse response) {\n        return pathsMatch(getLoginUrl(), request);\n    }\n\n    /**\n     * Convenience method for subclasses to use when a login redirect is required.\n     * <p/>\n     * This implementation simply calls {@link #saveRequest(javax.servlet.ServletRequest) saveRequest(request)}\n     * and then {@link #redirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse) redirectToLogin(request,response)}.\n     *\n     * @param request  the incoming <code>ServletRequest</code>\n     * @param response the outgoing <code>ServletResponse</code>\n     * @throws IOException if an error occurs.\n     */\n    protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException {\n        saveRequest(request);\n        redirectToLogin(request, response);\n    }\n\n    /**\n     * Convenience method merely delegates to\n     * {@link WebUtils#saveRequest(javax.servlet.ServletRequest) WebUtils.saveRequest(request)} to save the request\n     * state for reuse later.  This is mostly used to retain user request state when a redirect is issued to\n     * return the user to their originally requested url/resource.\n     * <p/>\n     * If you need to save and then immediately redirect the user to login, consider using\n     * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     * saveRequestAndRedirectToLogin(request,response)} directly.\n     *\n     * @param request the incoming ServletRequest to save for re-use later (for example, after a redirect).\n     */\n    protected void saveRequest(ServletRequest request) {\n        WebUtils.saveRequest(request);\n    }\n\n    /**\n     * Convenience method for subclasses that merely acquires the {@link #getLoginUrl() getLoginUrl} and redirects\n     * the request to that url.\n     * <p/>\n     * <b>N.B.</b>  If you want to issue a redirect with the intention of allowing the user to then return to their\n     * originally requested URL, don't use this method directly.  Instead you should call\n     * {@link #saveRequestAndRedirectToLogin(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     * saveRequestAndRedirectToLogin(request,response)}, which will save the current request state so that it can\n     * be reconstructed and re-used after a successful login.\n     *\n     * @param request  the incoming <code>ServletRequest</code>\n     * @param response the outgoing <code>ServletResponse</code>\n     * @throws IOException if an error occurs.\n     */\n    protected void redirectToLogin(ServletRequest request, ServletResponse response) throws IOException {\n        String loginUrl = getLoginUrl();\n        WebUtils.issueRedirect(request, response, loginUrl);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/filter/AccessControlFilterTest.java",
		"test_prompt": "// AccessControlFilterTest.java\npackage org.jsecurity.web.filter;\n\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.web.WebUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AccessControlFilter}.\n* It contains ten unit test cases for the {@link AccessControlFilter#onPreHandle(ServletRequest, ServletResponse, Object)} method.\n*/\nclass AccessControlFilterTest {"
	},
	{
		"original_code": "// RolesAuthorizationFilter.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.CollectionUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Filter that allows access if the current user has the roles specified by the mapped value, or denies access\n * if the user does not have all of the roles specified.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class RolesAuthorizationFilter extends AuthorizationFilter {\n\n    //TODO - complete JavaDoc\n    @SuppressWarnings({ \"unchecked\" })\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n        Subject subject = getSubject(request, response);\n        String[] rolesArray = (String[]) mappedValue;\n        if (rolesArray == null || rolesArray.length == 0) {\n            //no roles specified, so nothing to check - allow access.\n            return true;\n        }\n        Set<String> roles = CollectionUtils.asSet(rolesArray);\n        return subject.hasAllRoles(roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/filter/authz/RolesAuthorizationFilterTest.java",
		"test_prompt": "// RolesAuthorizationFilterTest.java\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.CollectionUtils;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RolesAuthorizationFilter}.\n* It contains ten unit test cases for the {@link RolesAuthorizationFilter#isAccessAllowed(ServletRequest, ServletResponse, Object)} method.\n*/\nclass RolesAuthorizationFilterTest {"
	},
	{
		"original_code": "// PermissionsAuthorizationFilter.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * Filter that allows access if the current user has the permissions specified by the mapped value, or denies access\n * if the user does not have all of the permissions specified.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class PermissionsAuthorizationFilter extends AuthorizationFilter {\n\n    //TODO - complete JavaDoc\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n        Subject subject = getSubject(request, response);\n        String[] perms = (String[]) mappedValue;\n        boolean isPermitted = true;\n        if (perms != null && perms.length > 0) {\n            if (perms.length == 1) {\n                if (!subject.isPermitted(perms[0])) {\n                    isPermitted = false;\n                }\n            } else {\n                if (!subject.isPermittedAll(perms)) {\n                    isPermitted = false;\n                }\n            }\n        }\n        return isPermitted;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/filter/authz/PermissionsAuthorizationFilterTest.java",
		"test_prompt": "// PermissionsAuthorizationFilterTest.java\npackage org.jsecurity.web.filter.authz;\n\nimport org.jsecurity.subject.Subject;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PermissionsAuthorizationFilter}.\n* It contains ten unit test cases for the {@link PermissionsAuthorizationFilter#isAccessAllowed(ServletRequest, ServletResponse, Object)} method.\n*/\nclass PermissionsAuthorizationFilterTest {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest0.java",
		"test_prompt": "// WebUtilsTest0.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getPathWithinApplication(HttpServletRequest)} method.\n*/\nclass WebUtilsTest0 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest1.java",
		"test_prompt": "// WebUtilsTest1.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getRequestUri(HttpServletRequest)} method.\n*/\nclass WebUtilsTest1 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest2.java",
		"test_prompt": "// WebUtilsTest2.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getContextPath(HttpServletRequest)} method.\n*/\nclass WebUtilsTest2 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest3.java",
		"test_prompt": "// WebUtilsTest3.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#decodeRequestString(HttpServletRequest, String)} method.\n*/\nclass WebUtilsTest3 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest4.java",
		"test_prompt": "// WebUtilsTest4.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getInetAddress(ServletRequest)} method.\n*/\nclass WebUtilsTest4 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest5.java",
		"test_prompt": "// WebUtilsTest5.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#toHttp(ServletRequest)} method.\n*/\nclass WebUtilsTest5 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest6.java",
		"test_prompt": "// WebUtilsTest6.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#toHttp(ServletResponse)} method.\n*/\nclass WebUtilsTest6 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest7.java",
		"test_prompt": "// WebUtilsTest7.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getRequiredServletRequest()} method.\n*/\nclass WebUtilsTest7 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest8.java",
		"test_prompt": "// WebUtilsTest8.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#unbindServletRequest()} method.\n*/\nclass WebUtilsTest8 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest9.java",
		"test_prompt": "// WebUtilsTest9.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getRequiredServletResponse()} method.\n*/\nclass WebUtilsTest9 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest10.java",
		"test_prompt": "// WebUtilsTest10.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#unbindServletResponse()} method.\n*/\nclass WebUtilsTest10 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest11.java",
		"test_prompt": "// WebUtilsTest11.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#isTrue(ServletRequest, String)} method.\n*/\nclass WebUtilsTest11 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest12.java",
		"test_prompt": "// WebUtilsTest12.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getCleanParam(ServletRequest, String)} method.\n*/\nclass WebUtilsTest12 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest13.java",
		"test_prompt": "// WebUtilsTest13.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getAndClearSavedRequest(ServletRequest)} method.\n*/\nclass WebUtilsTest13 {"
	},
	{
		"original_code": "// WebUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n *\n * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(WebUtils.class);\n\n    /**\n     * Message displayed when a servlet request or response is not bound to the current thread context when expected.\n     */\n    private static final String NOT_BOUND_ERROR_MESSAGE = \"Make sure WebUtils.bind() is being called. (typically called by JSecurityFilter)  \" + \"This could also happen when running integration tests that don't properly call WebUtils.bind().\";\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_JSECURITY_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to <code>jsecuritySavedRequest</code>.\n     */\n    public static final String SAVED_REQUEST_KEY = \"jsecuritySavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * <p>Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return decodeAndCleanUriString(request, uri);\n    }\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({ \"deprecation\" })\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc + \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /**\n     * Returns the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     * address cannot be resolved/determined.\n     * <p/>\n     * This implementation returns the InetAddress resolved from the request's\n     * {@link javax.servlet.ServletRequest#getRemoteHost() remoteHost} value.  The returned <code>String</code>\n     * is resolved to an InetAddress by calling\n     * {@link InetAddress#getByName(String) InetAddress.getByName(remoteHost)}. If the remote host is <code>null</code>\n     * or <code>getByName(remoteHost)</code> throws an exception, <code>null</code> is returned.\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>InetAddress</code> associated with the current request, or <code>null</code> if the\n     *         address cannot be resolved/determined.\n     */\n    public static InetAddress getInetAddress(ServletRequest request) {\n        InetAddress clientAddress = null;\n        //get the Host/IP the client is coming from:\n        String addrString = request.getRemoteHost();\n        try {\n            clientAddress = InetAddress.getByName(addrString);\n        } catch (UnknownHostException e) {\n            if (log.isInfoEnabled()) {\n                log.info(\"Unable to acquire InetAddress from ServletRequest\", e);\n            }\n        }\n        return clientAddress;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    public static void bindInetAddressToThread(ServletRequest request) {\n        InetAddress ip = getInetAddress(request);\n        if (ip != null) {\n            ThreadContext.bind(ip);\n        }\n    }\n\n    public static void unbindInetAddressFromThread() {\n        ThreadContext.unbindInetAddress();\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletRequest.  If there is no\n     * ServletRequest bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>(ServletRequest){@link ThreadContext#get ThreadContext.get}( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletRequest() unbindServletRequest} instead.\n     *\n     * @return the ServletRequest bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no servlet request is bound in the {@link ThreadContext ThreadContext}.\n     */\n    public static ServletRequest getRequiredServletRequest() throws IllegalStateException {\n        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);\n        if (request == null) {\n            throw new IllegalStateException(\"No ServletRequest found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return request;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletRequest != null) {\n     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );\n     * }</pre>\n     *\n     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletRequest servletRequest) {\n        if (servletRequest != null) {\n            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletRequest from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletRequest)ThreadContext.remove( SERVLET_REQUEST_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletRequest() getRequiredServletRequest()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletRequest unbindServletRequest() {\n        return (ServletRequest) ThreadContext.remove(SERVLET_REQUEST_KEY);\n    }\n\n    /**\n     * Convenience method that simplifies retrieval of a required thread-bound ServletResponse.  If there is no\n     * ServletResponse bound to the thread when this method is called, an <code>IllegalStateException</code> is\n     * thrown.\n     * <p/>\n     * This method is basically a convenient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse){@link ThreadContext#get ThreadContext.get}( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * But throws an <code>IllegalStateException</code> if the value is not bound to the <code>ThreadContext</code>.\n     * <p/>\n     * This method only returns the bound value if it exists - it does not remove it\n     * from the thread.  To remove it, one must call {@link #unbindServletResponse() unbindServletResponse} instead.\n     *\n     * @return the ServletResponse bound to the thread.  Never returns null.\n     * @throws IllegalStateException if no <code>ServletResponse> is bound in the {@link ThreadContext ThreadContext}\n     */\n    public static ServletResponse getRequiredServletResponse() throws IllegalStateException {\n        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);\n        if (response == null) {\n            throw new IllegalStateException(\"No ServletResponse found in ThreadContext. \" + NOT_BOUND_ERROR_MESSAGE);\n        }\n        return response;\n    }\n\n    /**\n     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.\n     *\n     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of\n     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,\n     * it binds it to the thread, i.e.:\n     *\n     * <pre>\n     * if (servletResponse != null) {\n     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );\n     * }</pre>\n     *\n     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.\n     */\n    public static void bind(ServletResponse servletResponse) {\n        if (servletResponse != null) {\n            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);\n        }\n    }\n\n    /**\n     * Convenience method that simplifies removal of a thread-local ServletResponse from the thread.\n     * <p/>\n     * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is\n     * merely a conveient wrapper for the following:\n     * <p/>\n     * <code>return (ServletResponse)ThreadContext.remove( SERVLET_RESPONSE_KEY );</code>\n     * <p/>\n     * If you wish to just retrieve the object from the thread without removing it (so it can be retrieved later during\n     * thread execution), you should use the {@link #getRequiredServletResponse() getRequiredServletResponse()} method\n     * for that purpose.\n     *\n     * @return the Session object previously bound to the thread, or <tt>null</tt> if there was none bound.\n     */\n    public static ServletResponse unbindServletResponse() {\n        return (ServletResponse) ThreadContext.remove(SERVLET_RESPONSE_KEY);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     *\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"t\") || value.equalsIgnoreCase(\"1\") || value.equalsIgnoreCase(\"enabled\") || value.equalsIgnoreCase(\"y\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/WebUtilsTest14.java",
		"test_prompt": "// WebUtilsTest14.java\npackage org.jsecurity.web;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.SecurityUtils;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.StringUtils;\nimport org.jsecurity.util.ThreadContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUtils}.\n* It contains ten unit test cases for the {@link WebUtils#getSavedRequest(ServletRequest)} method.\n*/\nclass WebUtilsTest14 {"
	},
	{
		"original_code": "// DefaultWebSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager</tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DefaultWebSessionManager.class);\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    //default\n    private boolean validateRequestOrigin = false;\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute(CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute(RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true</tt>, this implementation will ensure that any\n     * <tt>HttpRequest</tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest</tt> that started the session.\n     *\n     * <p> If set to <tt>false</tt>, any <tt>HttpRequest</tt> with a reference to a valid\n     * session id may acquire that <tt>Session</tt>.\n     *\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee</em> that each IP address represents one and only one\n     * machine accessing the system.\n     *\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     *\n     * <p>For the reasons specified above, this property is <tt>false</tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin(boolean validateRequestOrigin) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void setSessionIdCookieName(String name) {\n        getSessionIdCookieAttribute().setName(name);\n    }\n\n    public void setSessionIdCookiePath(String path) {\n        getSessionIdCookieAttribute().setPath(path);\n    }\n\n    public void setSessionIdCookieMaxAge(int maxAge) {\n        getSessionIdCookieAttribute().setMaxAge(maxAge);\n    }\n\n    public void setSessionIdCookieSecure(boolean secure) {\n        getSessionIdCookieAttribute().setSecure(secure);\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if (cookieStore == null) {\n            cookieStore = new CookieAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            cookieStore.setCheckRequestParams(false);\n            setSessionIdCookieAttribute(cookieStore);\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if (reqParamStore == null) {\n            reqParamStore = new RequestParamAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            setSessionIdRequestParamAttribute(reqParamStore);\n        }\n    }\n\n    protected void validateSessionOrigin(ServletRequest request, Session session) throws HostUnauthorizedException {\n        InetAddress requestIp = WebUtils.getInetAddress(request);\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n        if (originIp == null) {\n            if (requestIp != null) {\n                String msg = \"No IP Address was specified when creating session with id [\" + sessionId + \"].  Attempting to access session from \" + \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        } else {\n            if (requestIp != null) {\n                if (!requestIp.equals(originIp)) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" + originIp + \"], but the current HttpServletRequest originated \" + \"from [\" + requestIp + \"].  Disallowing session access: \" + \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException(msg);\n                }\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" + \"Session with id [\" + sessionId + \"] originated from \" + \"[\" + originIp + \"].  Request IP must match the session's origin \" + \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        }\n    }\n\n    protected void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {\n        if (currentId == null) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException(msg);\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId(request, response);\n        if (existingId == null || !currentId.equals(existingId)) {\n            getSessionIdCookieAttribute().storeValue(currentId, request, response);\n        }\n    }\n\n    protected Serializable retrieveSessionId(ServletRequest request, ServletResponse response) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue(request, response);\n        if (id != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE);\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue(request, response);\n            if (id != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE);\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        return start(request, response, hostAddress);\n    }\n\n    protected Serializable start(ServletRequest request, ServletResponse response, InetAddress inetAddress) {\n        Serializable sessionId = super.start(inetAddress);\n        storeSessionId(sessionId, request, response);\n        request.removeAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);\n        request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n        return sessionId;\n    }\n\n    public Session retrieveSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if (sessionId != null) {\n            return super.retrieveSession(sessionId);\n        } else {\n            ServletRequest request = WebUtils.getRequiredServletRequest();\n            ServletResponse response = WebUtils.getRequiredServletResponse();\n            return getSession(request, response);\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null</tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null</tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException\n     *          if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException\n     *          if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession(ServletRequest request, ServletResponse response) throws InvalidSessionException, AuthorizationException {\n        Session session;\n        try {\n            session = doGetSession(request, response);\n        } catch (InvalidSessionException ise) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" + \"associated session cookie...\");\n            }\n            getSessionIdCookieAttribute().removeValue(request, response);\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession(request, response, ise);\n        }\n        return session;\n    }\n\n    protected Session doGetSession(ServletRequest request, ServletResponse response) {\n        Session session = null;\n        Serializable sessionId = retrieveSessionId(request, response);\n        if (sessionId != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId);\n            session = super.retrieveSession(sessionId);\n            if (isValidateRequestOrigin()) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Validating request origin against session origin\");\n                }\n                validateSessionOrigin(request, session);\n            }\n            if (session != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No JSecurity session id associated with the given \" + \"HttpServletRequest.  A Session will not be returned.\");\n            }\n        }\n        return session;\n    }\n\n    protected Session handleInvalidSession(ServletRequest request, ServletResponse response, InvalidSessionException ise) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getSessionIdCookieAttribute().removeValue(request, response);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/session/DefaultWebSessionManagerTest0.java",
		"test_prompt": "// DefaultWebSessionManagerTest0.java\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSessionManager}.\n* It contains ten unit test cases for the {@link DefaultWebSessionManager#isValidateRequestOrigin()} method.\n*/\nclass DefaultWebSessionManagerTest0 {"
	},
	{
		"original_code": "// DefaultWebSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager</tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DefaultWebSessionManager.class);\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    //default\n    private boolean validateRequestOrigin = false;\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute(CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute(RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true</tt>, this implementation will ensure that any\n     * <tt>HttpRequest</tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest</tt> that started the session.\n     *\n     * <p> If set to <tt>false</tt>, any <tt>HttpRequest</tt> with a reference to a valid\n     * session id may acquire that <tt>Session</tt>.\n     *\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee</em> that each IP address represents one and only one\n     * machine accessing the system.\n     *\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     *\n     * <p>For the reasons specified above, this property is <tt>false</tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin(boolean validateRequestOrigin) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void setSessionIdCookieName(String name) {\n        getSessionIdCookieAttribute().setName(name);\n    }\n\n    public void setSessionIdCookiePath(String path) {\n        getSessionIdCookieAttribute().setPath(path);\n    }\n\n    public void setSessionIdCookieMaxAge(int maxAge) {\n        getSessionIdCookieAttribute().setMaxAge(maxAge);\n    }\n\n    public void setSessionIdCookieSecure(boolean secure) {\n        getSessionIdCookieAttribute().setSecure(secure);\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if (cookieStore == null) {\n            cookieStore = new CookieAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            cookieStore.setCheckRequestParams(false);\n            setSessionIdCookieAttribute(cookieStore);\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if (reqParamStore == null) {\n            reqParamStore = new RequestParamAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            setSessionIdRequestParamAttribute(reqParamStore);\n        }\n    }\n\n    protected void validateSessionOrigin(ServletRequest request, Session session) throws HostUnauthorizedException {\n        InetAddress requestIp = WebUtils.getInetAddress(request);\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n        if (originIp == null) {\n            if (requestIp != null) {\n                String msg = \"No IP Address was specified when creating session with id [\" + sessionId + \"].  Attempting to access session from \" + \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        } else {\n            if (requestIp != null) {\n                if (!requestIp.equals(originIp)) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" + originIp + \"], but the current HttpServletRequest originated \" + \"from [\" + requestIp + \"].  Disallowing session access: \" + \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException(msg);\n                }\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" + \"Session with id [\" + sessionId + \"] originated from \" + \"[\" + originIp + \"].  Request IP must match the session's origin \" + \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        }\n    }\n\n    protected void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {\n        if (currentId == null) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException(msg);\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId(request, response);\n        if (existingId == null || !currentId.equals(existingId)) {\n            getSessionIdCookieAttribute().storeValue(currentId, request, response);\n        }\n    }\n\n    protected Serializable retrieveSessionId(ServletRequest request, ServletResponse response) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue(request, response);\n        if (id != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE);\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue(request, response);\n            if (id != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE);\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        return start(request, response, hostAddress);\n    }\n\n    protected Serializable start(ServletRequest request, ServletResponse response, InetAddress inetAddress) {\n        Serializable sessionId = super.start(inetAddress);\n        storeSessionId(sessionId, request, response);\n        request.removeAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);\n        request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n        return sessionId;\n    }\n\n    public Session retrieveSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if (sessionId != null) {\n            return super.retrieveSession(sessionId);\n        } else {\n            ServletRequest request = WebUtils.getRequiredServletRequest();\n            ServletResponse response = WebUtils.getRequiredServletResponse();\n            return getSession(request, response);\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null</tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null</tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException\n     *          if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException\n     *          if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession(ServletRequest request, ServletResponse response) throws InvalidSessionException, AuthorizationException {\n        Session session;\n        try {\n            session = doGetSession(request, response);\n        } catch (InvalidSessionException ise) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" + \"associated session cookie...\");\n            }\n            getSessionIdCookieAttribute().removeValue(request, response);\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession(request, response, ise);\n        }\n        return session;\n    }\n\n    protected Session doGetSession(ServletRequest request, ServletResponse response) {\n        Session session = null;\n        Serializable sessionId = retrieveSessionId(request, response);\n        if (sessionId != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId);\n            session = super.retrieveSession(sessionId);\n            if (isValidateRequestOrigin()) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Validating request origin against session origin\");\n                }\n                validateSessionOrigin(request, session);\n            }\n            if (session != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No JSecurity session id associated with the given \" + \"HttpServletRequest.  A Session will not be returned.\");\n            }\n        }\n        return session;\n    }\n\n    protected Session handleInvalidSession(ServletRequest request, ServletResponse response, InvalidSessionException ise) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getSessionIdCookieAttribute().removeValue(request, response);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/session/DefaultWebSessionManagerTest1.java",
		"test_prompt": "// DefaultWebSessionManagerTest1.java\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSessionManager}.\n* It contains ten unit test cases for the {@link DefaultWebSessionManager#start(InetAddress)} method.\n*/\nclass DefaultWebSessionManagerTest1 {"
	},
	{
		"original_code": "// DefaultWebSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\n\n/**\n * Web-application capable <tt>SessionManager</tt> implementation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DefaultWebSessionManager.class);\n\n    /**\n     * Property specifying if, after a session object is acquired from the request, if that session should be\n     * validated to ensure the starting origin of the session is the same as the incoming request.\n     */\n    //default\n    private boolean validateRequestOrigin = false;\n\n    protected CookieAttribute<Serializable> sessionIdCookieAttribute = null;\n\n    protected RequestParamAttribute<Serializable> sessionIdRequestParamAttribute = null;\n\n    public DefaultWebSessionManager() {\n        ensureCookieSessionIdStore();\n        ensureRequestParamSessionIdStore();\n    }\n\n    public CookieAttribute<Serializable> getSessionIdCookieAttribute() {\n        return sessionIdCookieAttribute;\n    }\n\n    public void setSessionIdCookieAttribute(CookieAttribute<Serializable> sessionIdCookieAttribute) {\n        this.sessionIdCookieAttribute = sessionIdCookieAttribute;\n    }\n\n    public RequestParamAttribute<Serializable> getSessionIdRequestParamAttribute() {\n        return sessionIdRequestParamAttribute;\n    }\n\n    public void setSessionIdRequestParamAttribute(RequestParamAttribute<Serializable> sessionIdRequestParamAttribute) {\n        this.sessionIdRequestParamAttribute = sessionIdRequestParamAttribute;\n    }\n\n    /**\n     * If set to <tt>true</tt>, this implementation will ensure that any\n     * <tt>HttpRequest</tt> attempting\n     * to join a session (i.e. via {@link #getSession getSession} must have the same\n     * IP Address of the <tt>HttpRequest</tt> that started the session.\n     *\n     * <p> If set to <tt>false</tt>, any <tt>HttpRequest</tt> with a reference to a valid\n     * session id may acquire that <tt>Session</tt>.\n     *\n     * <p>Although convenient, this should only be enabled in environments where the\n     * system can <em>guarantee</em> that each IP address represents one and only one\n     * machine accessing the system.\n     *\n     * <p>Public websites are not good candidates for enabling this\n     * feature since many browser clients often sit behind NAT routers (in\n     * which case many machines are viewed to come from the same IP, thereby making this\n     * validation check useless).  Also, some internet service providers (e.g. AOL) may change a\n     * client's IP in mid-session, making subsequent requests appear to come from a different\n     * location.  Again, this feature should only be enabled where IP Addresses can be guaranteed a\n     * 1-to-1 relationship with a user's session.\n     *\n     * <p>For the reasons specified above, this property is <tt>false</tt> by default.\n     *\n     * @return true if this factory will verify each HttpRequest joining a session\n     */\n    public boolean isValidateRequestOrigin() {\n        return validateRequestOrigin;\n    }\n\n    /**\n     * Sets whether or not a request's origin will be validated when accessing a session.  See\n     * the {@link #isValidateRequestOrigin} JavaDoc for an in-depth explanation of this property.\n     *\n     * @param validateRequestOrigin whether or not to validate the request's origin when accessing\n     *                              a session.\n     * @see #isValidateRequestOrigin\n     */\n    public void setValidateRequestOrigin(boolean validateRequestOrigin) {\n        this.validateRequestOrigin = validateRequestOrigin;\n    }\n\n    public void setSessionIdCookieName(String name) {\n        getSessionIdCookieAttribute().setName(name);\n    }\n\n    public void setSessionIdCookiePath(String path) {\n        getSessionIdCookieAttribute().setPath(path);\n    }\n\n    public void setSessionIdCookieMaxAge(int maxAge) {\n        getSessionIdCookieAttribute().setMaxAge(maxAge);\n    }\n\n    public void setSessionIdCookieSecure(boolean secure) {\n        getSessionIdCookieAttribute().setSecure(secure);\n    }\n\n    protected void ensureCookieSessionIdStore() {\n        CookieAttribute<Serializable> cookieStore = getSessionIdCookieAttribute();\n        if (cookieStore == null) {\n            cookieStore = new CookieAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            cookieStore.setCheckRequestParams(false);\n            setSessionIdCookieAttribute(cookieStore);\n        }\n    }\n\n    protected void ensureRequestParamSessionIdStore() {\n        RequestParamAttribute<Serializable> reqParamStore = getSessionIdRequestParamAttribute();\n        if (reqParamStore == null) {\n            reqParamStore = new RequestParamAttribute<Serializable>(JSecurityHttpSession.DEFAULT_SESSION_ID_NAME);\n            setSessionIdRequestParamAttribute(reqParamStore);\n        }\n    }\n\n    protected void validateSessionOrigin(ServletRequest request, Session session) throws HostUnauthorizedException {\n        InetAddress requestIp = WebUtils.getInetAddress(request);\n        InetAddress originIp = session.getHostAddress();\n        Serializable sessionId = session.getId();\n        if (originIp == null) {\n            if (requestIp != null) {\n                String msg = \"No IP Address was specified when creating session with id [\" + sessionId + \"].  Attempting to access session from \" + \"IP [\" + requestIp + \"].  Origin IP and request IP must match.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        } else {\n            if (requestIp != null) {\n                if (!requestIp.equals(originIp)) {\n                    String msg = \"Session with id [\" + sessionId + \"] originated from [\" + originIp + \"], but the current HttpServletRequest originated \" + \"from [\" + requestIp + \"].  Disallowing session access: \" + \"session origin and request origin must match to allow access.\";\n                    throw new HostUnauthorizedException(msg);\n                }\n            } else {\n                String msg = \"No IP Address associated with the current HttpServletRequest.  \" + \"Session with id [\" + sessionId + \"] originated from \" + \"[\" + originIp + \"].  Request IP must match the session's origin \" + \"IP in order to gain access to that session.\";\n                throw new HostUnauthorizedException(msg);\n            }\n        }\n    }\n\n    protected void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {\n        if (currentId == null) {\n            String msg = \"sessionId cannot be null when persisting for subsequent requests.\";\n            throw new IllegalArgumentException(msg);\n        }\n        //ensure that the id has been set in the idStore, or if it already has, that it is not different than the\n        //'real' session value:\n        Serializable existingId = retrieveSessionId(request, response);\n        if (existingId == null || !currentId.equals(existingId)) {\n            getSessionIdCookieAttribute().storeValue(currentId, request, response);\n        }\n    }\n\n    protected Serializable retrieveSessionId(ServletRequest request, ServletResponse response) {\n        WebAttribute<Serializable> cookieSessionIdAttribute = getSessionIdCookieAttribute();\n        Serializable id = cookieSessionIdAttribute.retrieveValue(request, response);\n        if (id != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.COOKIE_SESSION_ID_SOURCE);\n        } else {\n            id = getSessionIdRequestParamAttribute().retrieveValue(request, response);\n            if (id != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, JSecurityHttpServletRequest.URL_SESSION_ID_SOURCE);\n            }\n        }\n        return id;\n    }\n\n    public Serializable start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        return start(request, response, hostAddress);\n    }\n\n    protected Serializable start(ServletRequest request, ServletResponse response, InetAddress inetAddress) {\n        Serializable sessionId = super.start(inetAddress);\n        storeSessionId(sessionId, request, response);\n        request.removeAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);\n        request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);\n        return sessionId;\n    }\n\n    public Session retrieveSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        if (sessionId != null) {\n            return super.retrieveSession(sessionId);\n        } else {\n            ServletRequest request = WebUtils.getRequiredServletRequest();\n            ServletResponse response = WebUtils.getRequiredServletResponse();\n            return getSession(request, response);\n        }\n    }\n\n    /**\n     * Returns the Session associated with the specified request if it is valid or <tt>null</tt> if a Session doesn't\n     * exist or it was invalid.\n     *\n     * @param request  incoming servlet request\n     * @param response outgoing servlet response\n     * @return the Session associated with the incoming request or <tt>null</tt> if one does not exist.\n     * @throws org.jsecurity.session.InvalidSessionException\n     *          if the associated Session has expired prior to invoking this method.\n     * @throws org.jsecurity.authz.AuthorizationException\n     *          if the caller is not authorized to access the session associated with the request.\n     */\n    public final Session getSession(ServletRequest request, ServletResponse response) throws InvalidSessionException, AuthorizationException {\n        Session session;\n        try {\n            session = doGetSession(request, response);\n        } catch (InvalidSessionException ise) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Request Session is invalid, message: [\" + ise.getMessage() + \"].  Removing any \" + \"associated session cookie...\");\n            }\n            getSessionIdCookieAttribute().removeValue(request, response);\n            //give subclass a chance to do something additional if necessary.  Otherwise returning null is just fine:\n            session = handleInvalidSession(request, response, ise);\n        }\n        return session;\n    }\n\n    protected Session doGetSession(ServletRequest request, ServletResponse response) {\n        Session session = null;\n        Serializable sessionId = retrieveSessionId(request, response);\n        if (sessionId != null) {\n            request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID, sessionId);\n            session = super.retrieveSession(sessionId);\n            if (isValidateRequestOrigin()) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Validating request origin against session origin\");\n                }\n                validateSessionOrigin(request, session);\n            }\n            if (session != null) {\n                request.setAttribute(JSecurityHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No JSecurity session id associated with the given \" + \"HttpServletRequest.  A Session will not be returned.\");\n            }\n        }\n        return session;\n    }\n\n    protected Session handleInvalidSession(ServletRequest request, ServletResponse response, InvalidSessionException ise) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Sesssion associated with the current request is nonexistent or invalid.  Returning null.\");\n        }\n        return null;\n    }\n\n    protected void onStop(Session session) {\n        super.onStop(session);\n        ServletRequest request = WebUtils.getRequiredServletRequest();\n        ServletResponse response = WebUtils.getRequiredServletResponse();\n        getSessionIdCookieAttribute().removeValue(request, response);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/session/DefaultWebSessionManagerTest2.java",
		"test_prompt": "// DefaultWebSessionManagerTest2.java\npackage org.jsecurity.web.session;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.web.WebUtils;\nimport org.jsecurity.web.attr.CookieAttribute;\nimport org.jsecurity.web.attr.RequestParamAttribute;\nimport org.jsecurity.web.attr.WebAttribute;\nimport org.jsecurity.web.servlet.JSecurityHttpServletRequest;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultWebSessionManager}.\n* It contains ten unit test cases for the {@link DefaultWebSessionManager#retrieveSession(Serializable)} method.\n*/\nclass DefaultWebSessionManagerTest2 {"
	},
	{
		"original_code": "// WebSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.http.HttpSession;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\n\n/**\n * TODO class JavaDoc\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class WebSession implements Session {\n\n    //TODO - complete JavaDoc\n    private static final String INET_ADDRESS_SESSION_KEY = WebSession.class.getName() + \"_INET_ADDRESS_SESSION_KEY\";\n\n    private static final String TOUCH_OBJECT_SESSION_KEY = WebSession.class.getName() + \"_TOUCH_OBJECT_SESSION_KEY\";\n\n    private HttpSession httpSession = null;\n\n    public WebSession(HttpSession httpSession, InetAddress inetAddress) {\n        if (httpSession == null) {\n            String msg = \"HttpSession constructor argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (httpSession instanceof JSecurityHttpSession) {\n            String msg = \"HttpSession constructor argument cannot be an instance of JSecurityHttpSession.  This \" + \"is enforced to prevent circular dependencies and infinite loops.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.httpSession = httpSession;\n        if (inetAddress != null) {\n            setHostAddress(inetAddress);\n        }\n    }\n\n    public Serializable getId() {\n        return httpSession.getId();\n    }\n\n    public Date getStartTimestamp() {\n        return new Date(httpSession.getCreationTime());\n    }\n\n    public Date getLastAccessTime() {\n        return new Date(httpSession.getLastAccessedTime());\n    }\n\n    public long getTimeout() throws InvalidSessionException {\n        try {\n            return httpSession.getMaxInactiveInterval() * 1000;\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\n        try {\n            int timeout = Long.valueOf(maxIdleTimeInMillis / 1000).intValue();\n            httpSession.setMaxInactiveInterval(timeout);\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    protected void setHostAddress(InetAddress hostAddress) {\n        setAttribute(INET_ADDRESS_SESSION_KEY, hostAddress);\n    }\n\n    public InetAddress getHostAddress() {\n        return (InetAddress) getAttribute(INET_ADDRESS_SESSION_KEY);\n    }\n\n    public void touch() throws InvalidSessionException {\n        //just manipulate the session to update the access time:\n        try {\n            httpSession.setAttribute(TOUCH_OBJECT_SESSION_KEY, TOUCH_OBJECT_SESSION_KEY);\n            httpSession.removeAttribute(TOUCH_OBJECT_SESSION_KEY);\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    public void stop() throws InvalidSessionException {\n        try {\n            httpSession.invalidate();\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        try {\n            Enumeration namesEnum = httpSession.getAttributeNames();\n            Collection<Object> keys = null;\n            if (namesEnum != null) {\n                keys = new ArrayList<Object>();\n                while (namesEnum.hasMoreElements()) {\n                    keys.add(namesEnum.nextElement());\n                }\n            }\n            return keys;\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    private static String assertString(Object key) {\n        if (!(key instanceof String)) {\n            String msg = \"HttpSession based implementations of the JSecurity Session interface requires attribute keys \" + \"to be String objects.  The HttpSession class does not support anything other than String keys.\";\n            throw new IllegalArgumentException(msg);\n        }\n        return (String) key;\n    }\n\n    public Object getAttribute(Object key) throws InvalidSessionException {\n        try {\n            return httpSession.getAttribute(assertString(key));\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    public void setAttribute(Object key, Object value) throws InvalidSessionException {\n        try {\n            httpSession.setAttribute(assertString(key), value);\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n\n    public Object removeAttribute(Object key) throws InvalidSessionException {\n        try {\n            String sKey = assertString(key);\n            Object removed = httpSession.getAttribute(sKey);\n            httpSession.removeAttribute(sKey);\n            return removed;\n        } catch (Exception e) {\n            throw new InvalidSessionException(e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/web/session/WebSessionTest.java",
		"test_prompt": "// WebSessionTest.java\npackage org.jsecurity.web.session;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.web.servlet.JSecurityHttpSession;\nimport javax.servlet.http.HttpSession;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebSession}.\n* It contains ten unit test cases for the {@link WebSession#removeAttribute(Object)} method.\n*/\nclass WebSessionTest {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test0.java",
		"test_prompt": "// Base64Test0.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#isBase64(byte[])} method.\n*/\nclass Base64Test0 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test1.java",
		"test_prompt": "// Base64Test1.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#encodeToString(byte[])} method.\n*/\nclass Base64Test1 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test2.java",
		"test_prompt": "// Base64Test2.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#encodeChunked(byte[])} method.\n*/\nclass Base64Test2 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test3.java",
		"test_prompt": "// Base64Test3.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#encode(byte[])} method.\n*/\nclass Base64Test3 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test4.java",
		"test_prompt": "// Base64Test4.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#encode(byte[], boolean)} method.\n*/\nclass Base64Test4 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test5.java",
		"test_prompt": "// Base64Test5.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#decodeToString(String)} method.\n*/\nclass Base64Test5 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test6.java",
		"test_prompt": "// Base64Test6.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#decodeToString(byte[])} method.\n*/\nclass Base64Test6 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test7.java",
		"test_prompt": "// Base64Test7.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#decode(String)} method.\n*/\nclass Base64Test7 {"
	},
	{
		"original_code": "// Base64.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications\n * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 0.9\n */\npublic class Base64 {\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     *\n     * <p>The character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.</p>\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n\n    /**\n     * The base length.\n     */\n    private static final int BASELENGTH = 255;\n\n    /**\n     * Lookup length.\n     */\n    private static final int LOOKUPLENGTH = 64;\n\n    /**\n     * Used to calculate the number of bits in a byte.\n     */\n    private static final int EIGHTBIT = 8;\n\n    /**\n     * Used when encoding something which has fewer than 24 bits.\n     */\n    private static final int SIXTEENBIT = 16;\n\n    /**\n     * Used to determine how many bits data contains.\n     */\n    private static final int TWENTYFOURBITGROUP = 24;\n\n    /**\n     * Used to get the number of Quadruples.\n     */\n    private static final int FOURBYTE = 4;\n\n    /**\n     * Used to test the sign of a byte.\n     */\n    private static final int SIGN = -128;\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = (byte) '=';\n\n    /**\n     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n     * indices.\n     *\n     * <p>For example, <code>base64Alphabet['+']</code> returns <code>62</code>.</p>\n     *\n     * <p>The value of undefined encodings is <code>-1</code>.</p>\n     */\n    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n\n    /**\n     * <p>Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n     * <code>/</code>.</p>\n     *\n     * <p>This array is accessed by using character values as indices.</p>\n     *\n     * <p>For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.</p>\n     */\n    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n\n    // Populating the lookup and character arrays\n    static {\n        for (int i = 0; i < BASELENGTH; i++) {\n            base64Alphabet[i] = (byte) -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = (byte) '+';\n        lookUpBase64Alphabet[63] = (byte) '/';\n    }\n\n    /**\n     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n     *\n     * @param octect The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    private static boolean isBase64(byte octect) {\n        if (octect == PAD) {\n            return true;\n        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     *\n     * @param arrayOctect byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isBase64(byte[] arrayOctect) {\n        arrayOctect = discardWhitespace(arrayOctect);\n        int length = arrayOctect.length;\n        if (length == 0) {\n            // shouldn't a 0 length array be valid base64 data?\n            // return false;\n            return true;\n        }\n        for (int i = 0; i < length; i++) {\n            if (!isBase64(arrayOctect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     *\n     * @param data The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            switch(aByte) {\n                case (byte) ' ':\n                case (byte) '\\n':\n                case (byte) '\\r':\n                case (byte) '\\t':\n                    break;\n                default:\n                    groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Base64 encodes the specified byte array and then encodes it as a String using JSecurity's preferred character\n     * encoding (UTF-8).\n     *\n     * @param bytes the byte array to Base64 encode.\n     * @return a UTF-8 encoded String of the resulting Base64 encoded byte array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        byte[] encoded = encode(bytes);\n        return CodecSupport.toString(encoded);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData binary data to encodeToChars\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeChunked(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     *\n     * @param pArray a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public static byte[] encode(byte[] pArray) {\n        return encode(pArray, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData Array containing binary data to encodeToChars.\n     * @param isChunked  if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encode(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte[] encodedData = new byte[encodedDataLength];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n            encodedIndex += 4;\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);\n            }\n        }\n        return encodedData;\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a resultant UTF-8 encoded string.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(String base64Encoded) {\n        byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);\n        return decodeToString(encodedBytes);\n    }\n\n    /**\n     * Decodes the specified Base64 encoded byte array and returns the decoded result as a UTF-8 encoded.\n     *\n     * @param base64Encoded a Base64 encoded byte array\n     * @return the decoded String, UTF-8 encoded.\n     */\n    public static String decodeToString(byte[] base64Encoded) {\n        byte[] decoded = decode(base64Encoded);\n        return CodecSupport.toString(decoded);\n    }\n\n    /**\n     * Converts the specified UTF-8 Base64 encoded String and decodes it to a raw Base64 decoded byte array.\n     *\n     * @param base64Encoded a UTF-8 Base64 encoded String\n     * @return the raw Base64 decoded byte array.\n     */\n    public static byte[] decode(String base64Encoded) {\n        byte[] bytes = CodecSupport.toBytes(base64Encoded);\n        return decode(bytes);\n    }\n\n    /**\n     * Decodes Base64 data into octects\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decode(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte[] decodedData = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n        // Throw away anything not in base64Data\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     *\n     * @param data The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte[] groomedData = new byte[data.length];\n        int bytesCopied = 0;\n        for (byte aByte : data) {\n            if (isBase64(aByte)) {\n                groomedData[bytesCopied++] = aByte;\n            }\n        }\n        byte[] packedData = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/Base64Test8.java",
		"test_prompt": "// Base64Test8.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64}.\n* It contains ten unit test cases for the {@link Base64#decode(byte[])} method.\n*/\nclass Base64Test8 {"
	},
	{
		"original_code": "// Hex.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Hex encoder and decoder.\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications\n * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Hex {\n\n    /**\n     * Used to build output as Hex\n     */\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    /**\n     * Encodes the specifed byte array to a character array and then returns that character array\n     * as a String.\n     *\n     * @param bytes the byte array to Hex-encode.\n     * @return A String representation of the resultant hex-encoded char array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        char[] encodedChars = encode(bytes);\n        return new String(encodedChars);\n    }\n\n    /**\n     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data byte[] to convert to Hex characters\n     * @return A char[] containing hexidecimal characters\n     */\n    public static char[] encode(byte[] data) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS[0x0F & data[i]];\n        }\n        return out;\n    }\n\n    /**\n     * Converts an array of character bytes representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param array An array of character bytes containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied byte array (representing characters).\n     * @throws IllegalArgumentException Thrown if an odd number of characters is supplied\n     *                                  to this function\n     * @see #decode(char[])\n     */\n    public static byte[] decode(byte[] array) throws IllegalArgumentException {\n        String s = CodecSupport.toString(array);\n        return decode(s);\n    }\n\n    /**\n     * Converts the specified Hex-encoded String into a raw byte array.  This is a\n     * convenience method that merely delegates to {@link #decode(char[])} using the\n     * argument's hex.toCharArray() value.\n     *\n     * @param hex a Hex-encoded String.\n     * @return A byte array containing binary data decoded from the supplied String's char array.\n     */\n    public static byte[] decode(String hex) {\n        return decode(hex.toCharArray());\n    }\n\n    /**\n     * Converts an array of characters representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param data An array of characters containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied char array.\n     * @throws IllegalArgumentException if an odd number or illegal of characters\n     *                                  is supplied\n     */\n    public static byte[] decode(char[] data) throws IllegalArgumentException {\n        int len = data.length;\n        if ((len & 0x01) != 0) {\n            throw new IllegalArgumentException(\"Odd number of characters.\");\n        }\n        byte[] out = new byte[len >> 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n        return out;\n    }\n\n    /**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws IllegalArgumentException if ch is an illegal hex character\n     */\n    protected static int toDigit(char ch, int index) throws IllegalArgumentException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new IllegalArgumentException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/HexTest0.java",
		"test_prompt": "// HexTest0.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Hex}.\n* It contains ten unit test cases for the {@link Hex#encodeToString(byte[])} method.\n*/\nclass HexTest0 {"
	},
	{
		"original_code": "// Hex.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Hex encoder and decoder.\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications\n * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Hex {\n\n    /**\n     * Used to build output as Hex\n     */\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    /**\n     * Encodes the specifed byte array to a character array and then returns that character array\n     * as a String.\n     *\n     * @param bytes the byte array to Hex-encode.\n     * @return A String representation of the resultant hex-encoded char array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        char[] encodedChars = encode(bytes);\n        return new String(encodedChars);\n    }\n\n    /**\n     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data byte[] to convert to Hex characters\n     * @return A char[] containing hexidecimal characters\n     */\n    public static char[] encode(byte[] data) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS[0x0F & data[i]];\n        }\n        return out;\n    }\n\n    /**\n     * Converts an array of character bytes representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param array An array of character bytes containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied byte array (representing characters).\n     * @throws IllegalArgumentException Thrown if an odd number of characters is supplied\n     *                                  to this function\n     * @see #decode(char[])\n     */\n    public static byte[] decode(byte[] array) throws IllegalArgumentException {\n        String s = CodecSupport.toString(array);\n        return decode(s);\n    }\n\n    /**\n     * Converts the specified Hex-encoded String into a raw byte array.  This is a\n     * convenience method that merely delegates to {@link #decode(char[])} using the\n     * argument's hex.toCharArray() value.\n     *\n     * @param hex a Hex-encoded String.\n     * @return A byte array containing binary data decoded from the supplied String's char array.\n     */\n    public static byte[] decode(String hex) {\n        return decode(hex.toCharArray());\n    }\n\n    /**\n     * Converts an array of characters representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param data An array of characters containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied char array.\n     * @throws IllegalArgumentException if an odd number or illegal of characters\n     *                                  is supplied\n     */\n    public static byte[] decode(char[] data) throws IllegalArgumentException {\n        int len = data.length;\n        if ((len & 0x01) != 0) {\n            throw new IllegalArgumentException(\"Odd number of characters.\");\n        }\n        byte[] out = new byte[len >> 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n        return out;\n    }\n\n    /**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws IllegalArgumentException if ch is an illegal hex character\n     */\n    protected static int toDigit(char ch, int index) throws IllegalArgumentException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new IllegalArgumentException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/HexTest1.java",
		"test_prompt": "// HexTest1.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Hex}.\n* It contains ten unit test cases for the {@link Hex#encode(byte[])} method.\n*/\nclass HexTest1 {"
	},
	{
		"original_code": "// Hex.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Hex encoder and decoder.\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications\n * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Hex {\n\n    /**\n     * Used to build output as Hex\n     */\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    /**\n     * Encodes the specifed byte array to a character array and then returns that character array\n     * as a String.\n     *\n     * @param bytes the byte array to Hex-encode.\n     * @return A String representation of the resultant hex-encoded char array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        char[] encodedChars = encode(bytes);\n        return new String(encodedChars);\n    }\n\n    /**\n     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data byte[] to convert to Hex characters\n     * @return A char[] containing hexidecimal characters\n     */\n    public static char[] encode(byte[] data) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS[0x0F & data[i]];\n        }\n        return out;\n    }\n\n    /**\n     * Converts an array of character bytes representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param array An array of character bytes containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied byte array (representing characters).\n     * @throws IllegalArgumentException Thrown if an odd number of characters is supplied\n     *                                  to this function\n     * @see #decode(char[])\n     */\n    public static byte[] decode(byte[] array) throws IllegalArgumentException {\n        String s = CodecSupport.toString(array);\n        return decode(s);\n    }\n\n    /**\n     * Converts the specified Hex-encoded String into a raw byte array.  This is a\n     * convenience method that merely delegates to {@link #decode(char[])} using the\n     * argument's hex.toCharArray() value.\n     *\n     * @param hex a Hex-encoded String.\n     * @return A byte array containing binary data decoded from the supplied String's char array.\n     */\n    public static byte[] decode(String hex) {\n        return decode(hex.toCharArray());\n    }\n\n    /**\n     * Converts an array of characters representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param data An array of characters containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied char array.\n     * @throws IllegalArgumentException if an odd number or illegal of characters\n     *                                  is supplied\n     */\n    public static byte[] decode(char[] data) throws IllegalArgumentException {\n        int len = data.length;\n        if ((len & 0x01) != 0) {\n            throw new IllegalArgumentException(\"Odd number of characters.\");\n        }\n        byte[] out = new byte[len >> 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n        return out;\n    }\n\n    /**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws IllegalArgumentException if ch is an illegal hex character\n     */\n    protected static int toDigit(char ch, int index) throws IllegalArgumentException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new IllegalArgumentException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/HexTest2.java",
		"test_prompt": "// HexTest2.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Hex}.\n* It contains ten unit test cases for the {@link Hex#decode(byte[])} method.\n*/\nclass HexTest2 {"
	},
	{
		"original_code": "// Hex.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Hex encoder and decoder.\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications\n * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Hex {\n\n    /**\n     * Used to build output as Hex\n     */\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    /**\n     * Encodes the specifed byte array to a character array and then returns that character array\n     * as a String.\n     *\n     * @param bytes the byte array to Hex-encode.\n     * @return A String representation of the resultant hex-encoded char array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        char[] encodedChars = encode(bytes);\n        return new String(encodedChars);\n    }\n\n    /**\n     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data byte[] to convert to Hex characters\n     * @return A char[] containing hexidecimal characters\n     */\n    public static char[] encode(byte[] data) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS[0x0F & data[i]];\n        }\n        return out;\n    }\n\n    /**\n     * Converts an array of character bytes representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param array An array of character bytes containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied byte array (representing characters).\n     * @throws IllegalArgumentException Thrown if an odd number of characters is supplied\n     *                                  to this function\n     * @see #decode(char[])\n     */\n    public static byte[] decode(byte[] array) throws IllegalArgumentException {\n        String s = CodecSupport.toString(array);\n        return decode(s);\n    }\n\n    /**\n     * Converts the specified Hex-encoded String into a raw byte array.  This is a\n     * convenience method that merely delegates to {@link #decode(char[])} using the\n     * argument's hex.toCharArray() value.\n     *\n     * @param hex a Hex-encoded String.\n     * @return A byte array containing binary data decoded from the supplied String's char array.\n     */\n    public static byte[] decode(String hex) {\n        return decode(hex.toCharArray());\n    }\n\n    /**\n     * Converts an array of characters representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param data An array of characters containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied char array.\n     * @throws IllegalArgumentException if an odd number or illegal of characters\n     *                                  is supplied\n     */\n    public static byte[] decode(char[] data) throws IllegalArgumentException {\n        int len = data.length;\n        if ((len & 0x01) != 0) {\n            throw new IllegalArgumentException(\"Odd number of characters.\");\n        }\n        byte[] out = new byte[len >> 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n        return out;\n    }\n\n    /**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws IllegalArgumentException if ch is an illegal hex character\n     */\n    protected static int toDigit(char ch, int index) throws IllegalArgumentException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new IllegalArgumentException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/HexTest3.java",
		"test_prompt": "// HexTest3.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Hex}.\n* It contains ten unit test cases for the {@link Hex#decode(String)} method.\n*/\nclass HexTest3 {"
	},
	{
		"original_code": "// Hex.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\n/**\n * Hex encoder and decoder.\n *\n * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications\n * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of\n * great work they've done, but also didn't want to force every JSecurity user to depend on the commons-codec.jar</p>\n *\n * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have\n * remained in tact.</p>\n *\n * @author Apache Software Foundation\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class Hex {\n\n    /**\n     * Used to build output as Hex\n     */\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    /**\n     * Encodes the specifed byte array to a character array and then returns that character array\n     * as a String.\n     *\n     * @param bytes the byte array to Hex-encode.\n     * @return A String representation of the resultant hex-encoded char array.\n     */\n    public static String encodeToString(byte[] bytes) {\n        char[] encodedChars = encode(bytes);\n        return new String(encodedChars);\n    }\n\n    /**\n     * Converts an array of bytes into an array of characters representing the hexidecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data byte[] to convert to Hex characters\n     * @return A char[] containing hexidecimal characters\n     */\n    public static char[] encode(byte[] data) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS[0x0F & data[i]];\n        }\n        return out;\n    }\n\n    /**\n     * Converts an array of character bytes representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param array An array of character bytes containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied byte array (representing characters).\n     * @throws IllegalArgumentException Thrown if an odd number of characters is supplied\n     *                                  to this function\n     * @see #decode(char[])\n     */\n    public static byte[] decode(byte[] array) throws IllegalArgumentException {\n        String s = CodecSupport.toString(array);\n        return decode(s);\n    }\n\n    /**\n     * Converts the specified Hex-encoded String into a raw byte array.  This is a\n     * convenience method that merely delegates to {@link #decode(char[])} using the\n     * argument's hex.toCharArray() value.\n     *\n     * @param hex a Hex-encoded String.\n     * @return A byte array containing binary data decoded from the supplied String's char array.\n     */\n    public static byte[] decode(String hex) {\n        return decode(hex.toCharArray());\n    }\n\n    /**\n     * Converts an array of characters representing hexidecimal values into an\n     * array of bytes of those same values. The returned array will be half the\n     * length of the passed array, as it takes two characters to represent any\n     * given byte. An exception is thrown if the passed char array has an odd\n     * number of elements.\n     *\n     * @param data An array of characters containing hexidecimal digits\n     * @return A byte array containing binary data decoded from\n     *         the supplied char array.\n     * @throws IllegalArgumentException if an odd number or illegal of characters\n     *                                  is supplied\n     */\n    public static byte[] decode(char[] data) throws IllegalArgumentException {\n        int len = data.length;\n        if ((len & 0x01) != 0) {\n            throw new IllegalArgumentException(\"Odd number of characters.\");\n        }\n        byte[] out = new byte[len >> 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n        return out;\n    }\n\n    /**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws IllegalArgumentException if ch is an illegal hex character\n     */\n    protected static int toDigit(char ch, int index) throws IllegalArgumentException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new IllegalArgumentException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/HexTest4.java",
		"test_prompt": "// HexTest4.java\npackage org.jsecurity.codec;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Hex}.\n* It contains ten unit test cases for the {@link Hex#decode(char[])} method.\n*/\nclass HexTest4 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest0.java",
		"test_prompt": "// CodecSupportTest0.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toBytes(char[])} method.\n*/\nclass CodecSupportTest0 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest1.java",
		"test_prompt": "// CodecSupportTest1.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toBytes(char[], String)} method.\n*/\nclass CodecSupportTest1 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest2.java",
		"test_prompt": "// CodecSupportTest2.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toBytes(String)} method.\n*/\nclass CodecSupportTest2 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest3.java",
		"test_prompt": "// CodecSupportTest3.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toBytes(String, String)} method.\n*/\nclass CodecSupportTest3 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest4.java",
		"test_prompt": "// CodecSupportTest4.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toChars(byte[])} method.\n*/\nclass CodecSupportTest4 {"
	},
	{
		"original_code": "// CodecSupport.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Base abstract class that provides useful encoding and decoding operations, especially for character data.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class CodecSupport {\n\n    /**\n     * JSecurity's default preferred Character encoding, equal to <b><code>UTF-8</code></b>.\n     */\n    public static final String PREFERRED_ENCODING = \"UTF-8\";\n\n    /**\n     * Converts the specified character array to a byte array using the JSecurity's preferred encoding (UTF-8).\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING} );</code>\n     *\n     * @param chars the character array to be converted to a byte array.\n     * @return the byte array of the UTF-8 encoded character array.\n     */\n    public static byte[] toBytes(char[] chars) {\n        return toBytes(new String(chars), PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified character array into a byte array using the specified character encoding.\n     * <p/>\n     * This is a convenience method equivalent to calling the {@link #toBytes(String,String)} method with a\n     * a wrapping String and the specified encoding, i.e.\n     * <p/>\n     * <code>toBytes( new String(chars), encoding );</code>\n     *\n     * @param chars    the character array to be converted to a byte array\n     * @param encoding the character encoding to use to when converting to bytes.\n     * @return the bytes of the specified character array under the specified encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(char[] chars, String encoding) throws CodecException {\n        return toBytes(new String(chars), encoding);\n    }\n\n    /**\n     * Converts the specified source argument to a byte array with JSecurity's\n     * {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param source the string to convert to a byte array.\n     * @return the bytes representing the specified string under JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     */\n    public static byte[] toBytes(String source) {\n        return toBytes(source, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified source to a byte array via the specified encoding, throwing a\n     * {@link CodecException CodecException} if the encoding fails.\n     *\n     * @param source   the source string to convert to a byte array.\n     * @param encoding the encoding to use to use.\n     * @return the byte array of the specified source with the given encoding.\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static byte[] toBytes(String source, String encoding) throws CodecException {\n        try {\n            return source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert source [\" + source + \"] to byte array using \" + \"encoding '\" + encoding + \"'\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Converts the specified byte array to a string using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to turn into a String.\n     * @return the specified byte array as an encoded String ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static String toString(byte[] bytes) {\n        return toString(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a String using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the String.\n     * @return the specified byte array as an encoded String\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static String toString(byte[] bytes, String encoding) throws CodecException {\n        try {\n            return new String(bytes, encoding);\n        } catch (UnsupportedEncodingException e) {\n            String msg = \"Unable to convert byte array to String with encoding '\" + encoding + \"'.\";\n            throw new CodecException(msg, e);\n        }\n    }\n\n    /**\n     * Returns the specified byte array as a character array using JSecurity's {@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}.\n     *\n     * @param bytes the byte array to convert to a char array\n     * @return the specified byte array encoded as a character array ({@link CodecSupport#PREFERRED_ENCODING PREFERRED_ENCODING}).\n     */\n    public static char[] toChars(byte[] bytes) {\n        return toChars(bytes, PREFERRED_ENCODING);\n    }\n\n    /**\n     * Converts the specified byte array to a character array using the specified character encoding.\n     *\n     * @param bytes    the byte array to convert to a String\n     * @param encoding the character encoding used to encode the bytes.\n     * @return the specified byte array as an encoded char array\n     * @throws CodecException if the JVM does not support the specified encoding.\n     */\n    public static char[] toChars(byte[] bytes, String encoding) throws CodecException {\n        return toString(bytes, encoding).toCharArray();\n    }\n\n    /**\n     * Converts the specified Object into a byte array.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToBytes(Object) objectToBytes} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] toBytes(Object o) {\n        if (o == null) {\n            String msg = \"Argument for byte conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return (byte[]) o;\n        } else if (o instanceof char[]) {\n            return toBytes((char[]) o);\n        } else if (o instanceof String) {\n            return toBytes((String) o);\n        } else {\n            return objectToBytes(o);\n        }\n    }\n\n    /**\n     * Converts the specified Object into a String.\n     *\n     * <p>If the argument is a <tt>byte[]</tt>, <tt>char[]</tt>, or <tt>String</tt> it will be converted\n     * automatically and returned.</tt>\n     *\n     * <p>If the argument is anything other than these three types, it is passed to the\n     * {@link #objectToString(Object) objectToString} method which must be overridden by subclasses.\n     *\n     * @param o the Object to convert into a byte array\n     * @return a byte array representation of the Object argument.\n     */\n    protected String toString(Object o) {\n        if (o == null) {\n            String msg = \"Argument for String conversion cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        if (o instanceof byte[]) {\n            return toString((byte[]) o);\n        } else if (o instanceof char[]) {\n            return new String((char[]) o);\n        } else if (o instanceof String) {\n            return (String) o;\n        } else {\n            return objectToString(o);\n        }\n    }\n\n    /**\n     * Default implementation throws a CodecException immediately since it can't infer how to convert the Object\n     * to a byte array.  This method must be overridden by subclasses if anything other than the three default\n     * types (listed in the {@link #toBytes(Object) toBytes(Object)} JavaDoc) are to be converted to a byte array.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a byte array representation of the Object argument.\n     */\n    protected byte[] objectToBytes(Object o) {\n        String msg = \"The \" + getClass().getName() + \" implementation only supports conversion to \" + \"byte[] if the source is of type byte[], char[] or String.  The instance provided as a method \" + \"argument is of type [\" + o.getClass().getName() + \"].  If you would like to convert \" + \"this argument type to a byte[], you can 1) convert the argument to a byte[], char[] or String \" + \"yourself and then use that as the method argument or 2) subclass \" + getClass().getName() + \" and override the objectToBytes(Object o) method.\";\n        throw new CodecException(msg);\n    }\n\n    /**\n     * Default implementation merely returns <code>objectArgument.toString()</code>.  Subclasses can override this\n     * method for different mechanisms of converting an object to a String.\n     *\n     * @param o the Object to convert to a byte array.\n     * @return a String representation of the Object argument.\n     */\n    protected String objectToString(Object o) {\n        return o.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/codec/CodecSupportTest5.java",
		"test_prompt": "// CodecSupportTest5.java\npackage org.jsecurity.codec;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CodecSupport}.\n* It contains ten unit test cases for the {@link CodecSupport#toChars(byte[], String)} method.\n*/\nclass CodecSupportTest5 {"
	},
	{
		"original_code": "// XmlSerializer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\n\n/**\n * Serializer implementation that uses the JavaBeans\n * {@link java.beans.XMLEncoder XMLEncoder} and {@link java.beans.XMLDecoder XMLDecoder} to serialize\n * and deserialize, respectively.\n * <p/>\n * <b>NOTE:</b> The JavaBeans XMLEncoder/XMLDecoder only successfully encode/decode objects when they are\n * JavaBeans compatible!\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class XmlSerializer implements Serializer {\n\n    /**\n     * Serializes the specified <code>source</code> into a byte[] array by using the\n     * {@link java.beans.XMLEncoder XMLEncoder} to encode the object out to a\n     * {@link java.io.ByteArrayOutputStream ByteArrayOutputStream}, where the resulting byte[] array is returned.\n     * @param source the Object to convert into a byte[] array.\n     * @return the byte[] array representation of the XML encoded output.\n     */\n    public byte[] serialize(Object source) {\n        if (source == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        XMLEncoder encoder = new XMLEncoder(new BufferedOutputStream(bos));\n        encoder.writeObject(source);\n        encoder.close();\n        return bos.toByteArray();\n    }\n\n    /**\n     * Deserializes the specified <code>serialized</code> source back into an Object by using a\n     * {@link java.io.ByteArrayInputStream ByteArrayInputStream} to wrap the argument and then decode this\n     * stream via an {@link java.beans.XMLDecoder XMLDecoder}, where the\n     * {@link java.beans.XMLDecoder#readObject() readObject} call results in the original Object to return.\n     * @param serialized the byte[] array representation of the XML encoded output.\n     * @return the original source Object in reconstituted form.\n     */\n    public Object deserialize(byte[] serialized) {\n        if (serialized == null) {\n            throw new IllegalArgumentException(\"Argument cannot be null.\");\n        }\n        ByteArrayInputStream bis = new ByteArrayInputStream(serialized);\n        XMLDecoder decoder = new XMLDecoder(new BufferedInputStream(bis));\n        Object o = decoder.readObject();\n        decoder.close();\n        return o;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/XmlSerializerTest0.java",
		"test_prompt": "// XmlSerializerTest0.java\npackage org.jsecurity.io;\n\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlSerializer}.\n* It contains ten unit test cases for the {@link XmlSerializer#serialize(Object)} method.\n*/\nclass XmlSerializerTest0 {"
	},
	{
		"original_code": "// XmlSerializer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\n\n/**\n * Serializer implementation that uses the JavaBeans\n * {@link java.beans.XMLEncoder XMLEncoder} and {@link java.beans.XMLDecoder XMLDecoder} to serialize\n * and deserialize, respectively.\n * <p/>\n * <b>NOTE:</b> The JavaBeans XMLEncoder/XMLDecoder only successfully encode/decode objects when they are\n * JavaBeans compatible!\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class XmlSerializer implements Serializer {\n\n    /**\n     * Serializes the specified <code>source</code> into a byte[] array by using the\n     * {@link java.beans.XMLEncoder XMLEncoder} to encode the object out to a\n     * {@link java.io.ByteArrayOutputStream ByteArrayOutputStream}, where the resulting byte[] array is returned.\n     * @param source the Object to convert into a byte[] array.\n     * @return the byte[] array representation of the XML encoded output.\n     */\n    public byte[] serialize(Object source) {\n        if (source == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        XMLEncoder encoder = new XMLEncoder(new BufferedOutputStream(bos));\n        encoder.writeObject(source);\n        encoder.close();\n        return bos.toByteArray();\n    }\n\n    /**\n     * Deserializes the specified <code>serialized</code> source back into an Object by using a\n     * {@link java.io.ByteArrayInputStream ByteArrayInputStream} to wrap the argument and then decode this\n     * stream via an {@link java.beans.XMLDecoder XMLDecoder}, where the\n     * {@link java.beans.XMLDecoder#readObject() readObject} call results in the original Object to return.\n     * @param serialized the byte[] array representation of the XML encoded output.\n     * @return the original source Object in reconstituted form.\n     */\n    public Object deserialize(byte[] serialized) {\n        if (serialized == null) {\n            throw new IllegalArgumentException(\"Argument cannot be null.\");\n        }\n        ByteArrayInputStream bis = new ByteArrayInputStream(serialized);\n        XMLDecoder decoder = new XMLDecoder(new BufferedInputStream(bis));\n        Object o = decoder.readObject();\n        decoder.close();\n        return o;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/XmlSerializerTest1.java",
		"test_prompt": "// XmlSerializerTest1.java\npackage org.jsecurity.io;\n\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlSerializer}.\n* It contains ten unit test cases for the {@link XmlSerializer#deserialize(byte[])} method.\n*/\nclass XmlSerializerTest1 {"
	},
	{
		"original_code": "// ResourceUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n/**\n * Static helper methods for loading resources.\n *\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class ResourceUtils {\n\n    //TODO complete JavaDoc\n    /**\n     * Resource path prefix that specifies to load from a classpath location, value is <b><code>classpath:</code></b>\n     */\n    public static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    /**\n     * Resource path prefix that specifies to load from a url location, value is <b><code>url:</code></b>\n     */\n    public static final String URL_PREFIX = \"url:\";\n\n    /**\n     * Resource path prefix that specifies to load from a file location, value is <b><code>file:</code></b>\n     */\n    public static final String FILE_PREFIX = \"file:\";\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ResourceUtils.class);\n\n    /**\n     * Prevent instantiation.\n     */\n    private ResourceUtils() {\n    }\n\n    /**\n     * Returns <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes ({@link #CLASSPATH_PREFIX CLASSPATH_PREFIX},\n     * {@link #URL_PREFIX URL_PREFIX}, or {@link #FILE_PREFIX FILE_PREFIX}), <code>false</code> otherwise.\n     *\n     * @param resourcePath the resource path to check\n     * @return <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean hasResourcePrefix(String resourcePath) {\n        return resourcePath != null && (resourcePath.startsWith(CLASSPATH_PREFIX) || resourcePath.startsWith(URL_PREFIX) || resourcePath.startsWith(FILE_PREFIX));\n    }\n\n    /**\n     * Returns <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @param resourcePath the path of the resource to check.\n     * @return <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean resourceExists(String resourcePath) {\n        InputStream stream = null;\n        boolean exists = false;\n        try {\n            stream = getInputStreamForPath(resourcePath);\n            exists = true;\n        } catch (IOException e) {\n            stream = null;\n        } finally {\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n        return exists;\n    }\n\n    /**\n     * Returns the InputStream for the resource represented by the specified path.\n     *\n     * <p>The supporting prefixes are defined as as *_PREFIX constants in this class.</p>\n     *\n     * @param resourcePath the String path representing the resource to obtain.\n     * @return the InputStraem for the specified resource.\n     * @throws IOException if there is a problem acquiring the resource at the specified path.\n     */\n    public static InputStream getInputStreamForPath(String resourcePath) throws IOException {\n        InputStream is;\n        if (resourcePath.startsWith(CLASSPATH_PREFIX)) {\n            is = loadFromClassPath(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(URL_PREFIX)) {\n            is = loadFromUrl(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(FILE_PREFIX)) {\n            is = loadFromFile(stripPrefix(resourcePath));\n        } else {\n            is = loadFromFile(resourcePath);\n        }\n        if (is == null) {\n            throw new IOException(\"Resource [\" + resourcePath + \"] could not be found.\");\n        }\n        return is;\n    }\n\n    private static InputStream loadFromFile(String path) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening file [\" + path + \"]...\");\n        }\n        return new FileInputStream(path);\n    }\n\n    private static InputStream loadFromUrl(String urlPath) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening url [\" + urlPath + \"]...\");\n        }\n        URL url = new URL(urlPath);\n        return url.openStream();\n    }\n\n    private static InputStream loadFromClassPath(String path) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening resource from class path [\" + path + \"]...\");\n        }\n        return ClassUtils.getResourceAsStream(path);\n    }\n\n    private static String stripPrefix(String resourcePath) {\n        return resourcePath.substring(resourcePath.indexOf(\":\") + 1);\n    }\n\n    public static void close(InputStream is) {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                log.warn(\"Error closing input stream.\", e);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/ResourceUtilsTest0.java",
		"test_prompt": "// ResourceUtilsTest0.java\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceUtils}.\n* It contains ten unit test cases for the {@link ResourceUtils#hasResourcePrefix(String)} method.\n*/\nclass ResourceUtilsTest0 {"
	},
	{
		"original_code": "// ResourceUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n/**\n * Static helper methods for loading resources.\n *\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class ResourceUtils {\n\n    //TODO complete JavaDoc\n    /**\n     * Resource path prefix that specifies to load from a classpath location, value is <b><code>classpath:</code></b>\n     */\n    public static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    /**\n     * Resource path prefix that specifies to load from a url location, value is <b><code>url:</code></b>\n     */\n    public static final String URL_PREFIX = \"url:\";\n\n    /**\n     * Resource path prefix that specifies to load from a file location, value is <b><code>file:</code></b>\n     */\n    public static final String FILE_PREFIX = \"file:\";\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ResourceUtils.class);\n\n    /**\n     * Prevent instantiation.\n     */\n    private ResourceUtils() {\n    }\n\n    /**\n     * Returns <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes ({@link #CLASSPATH_PREFIX CLASSPATH_PREFIX},\n     * {@link #URL_PREFIX URL_PREFIX}, or {@link #FILE_PREFIX FILE_PREFIX}), <code>false</code> otherwise.\n     *\n     * @param resourcePath the resource path to check\n     * @return <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean hasResourcePrefix(String resourcePath) {\n        return resourcePath != null && (resourcePath.startsWith(CLASSPATH_PREFIX) || resourcePath.startsWith(URL_PREFIX) || resourcePath.startsWith(FILE_PREFIX));\n    }\n\n    /**\n     * Returns <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @param resourcePath the path of the resource to check.\n     * @return <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean resourceExists(String resourcePath) {\n        InputStream stream = null;\n        boolean exists = false;\n        try {\n            stream = getInputStreamForPath(resourcePath);\n            exists = true;\n        } catch (IOException e) {\n            stream = null;\n        } finally {\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n        return exists;\n    }\n\n    /**\n     * Returns the InputStream for the resource represented by the specified path.\n     *\n     * <p>The supporting prefixes are defined as as *_PREFIX constants in this class.</p>\n     *\n     * @param resourcePath the String path representing the resource to obtain.\n     * @return the InputStraem for the specified resource.\n     * @throws IOException if there is a problem acquiring the resource at the specified path.\n     */\n    public static InputStream getInputStreamForPath(String resourcePath) throws IOException {\n        InputStream is;\n        if (resourcePath.startsWith(CLASSPATH_PREFIX)) {\n            is = loadFromClassPath(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(URL_PREFIX)) {\n            is = loadFromUrl(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(FILE_PREFIX)) {\n            is = loadFromFile(stripPrefix(resourcePath));\n        } else {\n            is = loadFromFile(resourcePath);\n        }\n        if (is == null) {\n            throw new IOException(\"Resource [\" + resourcePath + \"] could not be found.\");\n        }\n        return is;\n    }\n\n    private static InputStream loadFromFile(String path) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening file [\" + path + \"]...\");\n        }\n        return new FileInputStream(path);\n    }\n\n    private static InputStream loadFromUrl(String urlPath) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening url [\" + urlPath + \"]...\");\n        }\n        URL url = new URL(urlPath);\n        return url.openStream();\n    }\n\n    private static InputStream loadFromClassPath(String path) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening resource from class path [\" + path + \"]...\");\n        }\n        return ClassUtils.getResourceAsStream(path);\n    }\n\n    private static String stripPrefix(String resourcePath) {\n        return resourcePath.substring(resourcePath.indexOf(\":\") + 1);\n    }\n\n    public static void close(InputStream is) {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                log.warn(\"Error closing input stream.\", e);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/ResourceUtilsTest1.java",
		"test_prompt": "// ResourceUtilsTest1.java\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceUtils}.\n* It contains ten unit test cases for the {@link ResourceUtils#resourceExists(String)} method.\n*/\nclass ResourceUtilsTest1 {"
	},
	{
		"original_code": "// ResourceUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n/**\n * Static helper methods for loading resources.\n *\n * @author Jeremy Haile\n * @since 0.2\n */\npublic class ResourceUtils {\n\n    //TODO complete JavaDoc\n    /**\n     * Resource path prefix that specifies to load from a classpath location, value is <b><code>classpath:</code></b>\n     */\n    public static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    /**\n     * Resource path prefix that specifies to load from a url location, value is <b><code>url:</code></b>\n     */\n    public static final String URL_PREFIX = \"url:\";\n\n    /**\n     * Resource path prefix that specifies to load from a file location, value is <b><code>file:</code></b>\n     */\n    public static final String FILE_PREFIX = \"file:\";\n\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ResourceUtils.class);\n\n    /**\n     * Prevent instantiation.\n     */\n    private ResourceUtils() {\n    }\n\n    /**\n     * Returns <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes ({@link #CLASSPATH_PREFIX CLASSPATH_PREFIX},\n     * {@link #URL_PREFIX URL_PREFIX}, or {@link #FILE_PREFIX FILE_PREFIX}), <code>false</code> otherwise.\n     *\n     * @param resourcePath the resource path to check\n     * @return <code>true</code> if the resource path is not null and starts with one of the recognized\n     * resource prefixes, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean hasResourcePrefix(String resourcePath) {\n        return resourcePath != null && (resourcePath.startsWith(CLASSPATH_PREFIX) || resourcePath.startsWith(URL_PREFIX) || resourcePath.startsWith(FILE_PREFIX));\n    }\n\n    /**\n     * Returns <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @param resourcePath the path of the resource to check.\n     * @return <code>true</code> if the resource at the specified path exists, <code>false</code> otherwise.\n     * @since 0.9\n     */\n    public static boolean resourceExists(String resourcePath) {\n        InputStream stream = null;\n        boolean exists = false;\n        try {\n            stream = getInputStreamForPath(resourcePath);\n            exists = true;\n        } catch (IOException e) {\n            stream = null;\n        } finally {\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n        return exists;\n    }\n\n    /**\n     * Returns the InputStream for the resource represented by the specified path.\n     *\n     * <p>The supporting prefixes are defined as as *_PREFIX constants in this class.</p>\n     *\n     * @param resourcePath the String path representing the resource to obtain.\n     * @return the InputStraem for the specified resource.\n     * @throws IOException if there is a problem acquiring the resource at the specified path.\n     */\n    public static InputStream getInputStreamForPath(String resourcePath) throws IOException {\n        InputStream is;\n        if (resourcePath.startsWith(CLASSPATH_PREFIX)) {\n            is = loadFromClassPath(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(URL_PREFIX)) {\n            is = loadFromUrl(stripPrefix(resourcePath));\n        } else if (resourcePath.startsWith(FILE_PREFIX)) {\n            is = loadFromFile(stripPrefix(resourcePath));\n        } else {\n            is = loadFromFile(resourcePath);\n        }\n        if (is == null) {\n            throw new IOException(\"Resource [\" + resourcePath + \"] could not be found.\");\n        }\n        return is;\n    }\n\n    private static InputStream loadFromFile(String path) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening file [\" + path + \"]...\");\n        }\n        return new FileInputStream(path);\n    }\n\n    private static InputStream loadFromUrl(String urlPath) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening url [\" + urlPath + \"]...\");\n        }\n        URL url = new URL(urlPath);\n        return url.openStream();\n    }\n\n    private static InputStream loadFromClassPath(String path) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Opening resource from class path [\" + path + \"]...\");\n        }\n        return ClassUtils.getResourceAsStream(path);\n    }\n\n    private static String stripPrefix(String resourcePath) {\n        return resourcePath.substring(resourcePath.indexOf(\":\") + 1);\n    }\n\n    public static void close(InputStream is) {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                log.warn(\"Error closing input stream.\", e);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/ResourceUtilsTest2.java",
		"test_prompt": "// ResourceUtilsTest2.java\npackage org.jsecurity.io;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.ClassUtils;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceUtils}.\n* It contains ten unit test cases for the {@link ResourceUtils#getInputStreamForPath(String)} method.\n*/\nclass ResourceUtilsTest2 {"
	},
	{
		"original_code": "// DefaultSerializer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport java.io.*;\n\n/**\n * Serializer implementation that uses the default JVM serialization mechanism (Object Input/Output Streams).\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultSerializer implements Serializer {\n\n    public byte[] serialize(Object o) throws SerializationException {\n        if (o == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BufferedOutputStream bos = new BufferedOutputStream(baos);\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(o);\n            oos.close();\n            return baos.toByteArray();\n        } catch (IOException e) {\n            String msg = \"Unable to serialize object [\" + o + \"].  \" + \"In order for the DefaultSerializer to serialize this object, the [\" + o.getClass().getName() + \"] \" + \"class must implement java.io.Serializable.\";\n            throw new SerializationException(msg, e);\n        }\n    }\n\n    public Object deserialize(byte[] serialized) throws SerializationException {\n        if (serialized == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(serialized);\n        BufferedInputStream bis = new BufferedInputStream(bais);\n        try {\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            Object deserialized = ois.readObject();\n            ois.close();\n            return deserialized;\n        } catch (Exception e) {\n            String msg = \"Unable to deserialze argument byte array.\";\n            throw new SerializationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/DefaultSerializerTest0.java",
		"test_prompt": "// DefaultSerializerTest0.java\npackage org.jsecurity.io;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultSerializer}.\n* It contains ten unit test cases for the {@link DefaultSerializer#serialize(Object)} method.\n*/\nclass DefaultSerializerTest0 {"
	},
	{
		"original_code": "// DefaultSerializer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.io;\n\nimport java.io.*;\n\n/**\n * Serializer implementation that uses the default JVM serialization mechanism (Object Input/Output Streams).\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class DefaultSerializer implements Serializer {\n\n    public byte[] serialize(Object o) throws SerializationException {\n        if (o == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BufferedOutputStream bos = new BufferedOutputStream(baos);\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(o);\n            oos.close();\n            return baos.toByteArray();\n        } catch (IOException e) {\n            String msg = \"Unable to serialize object [\" + o + \"].  \" + \"In order for the DefaultSerializer to serialize this object, the [\" + o.getClass().getName() + \"] \" + \"class must implement java.io.Serializable.\";\n            throw new SerializationException(msg, e);\n        }\n    }\n\n    public Object deserialize(byte[] serialized) throws SerializationException {\n        if (serialized == null) {\n            String msg = \"argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(serialized);\n        BufferedInputStream bis = new BufferedInputStream(bais);\n        try {\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            Object deserialized = ois.readObject();\n            ois.close();\n            return deserialized;\n        } catch (Exception e) {\n            String msg = \"Unable to deserialze argument byte array.\";\n            throw new SerializationException(msg, e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/io/DefaultSerializerTest1.java",
		"test_prompt": "// DefaultSerializerTest1.java\npackage org.jsecurity.io;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultSerializer}.\n* It contains ten unit test cases for the {@link DefaultSerializer#deserialize(byte[])} method.\n*/\nclass DefaultSerializerTest1 {"
	},
	{
		"original_code": "// SimpleAuthenticationInfo.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.subject.MutablePrincipalCollection;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link MergableAuthenticationInfo} interface that holds the principals and\n * credentials.\n *\n * @see org.jsecurity.realm.AuthenticatingRealm\n * @since 0.9\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class SimpleAuthenticationInfo implements MergableAuthenticationInfo {\n\n    /**\n     * The principals identifying the account associated with this AuthenticationInfo instance.\n     */\n    protected PrincipalCollection principals;\n\n    /**\n     * The credentials verifying the account principals.\n     */\n    protected Object credentials;\n\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAuthenticationInfo() {\n    }\n\n    /**\n     * Constructor that takes in a single 'primary' principal of the account and its corresponding credentials,\n     * associated with the specified realm.\n     * <p/>\n     * This is a convenience constructor and will construct a {@link PrincipalCollection PrincipalCollection} based\n     * on the <code>principal</code> and <code>realmName</code> argument.\n     *\n     * @param principal the 'primary' principal associated with the specified realm.\n     * @param credentials the credentials that verify the given principal.\n     * @param realmName the realm from where the principal and credentials were acquired.\n     */\n    public SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) {\n        this.principals = new SimplePrincipalCollection(principal, realmName);\n        this.credentials = credentials;\n    }\n\n    /**\n     * Constructor that takes in an account's identifying principal(s) and its corresponding credentials that verify\n     * the principals.\n     * @param principals a Realm's account's identifying principal(s)\n     * @param credentials the accounts corresponding principals that verify the principals.\n     */\n    public SimpleAuthenticationInfo(PrincipalCollection principals, Object credentials) {\n        this.principals = new SimplePrincipalCollection(principals);\n        this.credentials = credentials;\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return principals;\n    }\n\n    /**\n     * Sets the identifying principal(s) represented by this instance.\n     *\n     * @param principals the indentifying attributes of the corresponding Realm account.\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.principals = principals;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    /**\n     * Sets the credentials that verify the principals/identity of the associated Realm account.\n     * @param credentials attribute(s) that verify the account's identity/principals, such as a password or private key.\n     */\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    /**\n     * Takes the specified <code>info</code> argument and adds its principals and credentials into this instance.\n     * @param info the <code>AuthenticationInfo</code> to add into this instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void merge(AuthenticationInfo info) {\n        if (info == null || info.getPrincipals() == null || info.getPrincipals().isEmpty()) {\n            return;\n        }\n        if (this.principals == null) {\n            this.principals = info.getPrincipals();\n        } else {\n            if (this.principals instanceof MutablePrincipalCollection) {\n                ((MutablePrincipalCollection) this.principals).addAll(info.getPrincipals());\n            } else {\n                this.principals = new SimplePrincipalCollection(this.principals);\n            }\n        }\n        Object thisCredentials = getCredentials();\n        Object otherCredentials = info.getCredentials();\n        if (otherCredentials == null) {\n            return;\n        }\n        if (thisCredentials == null) {\n            this.credentials = otherCredentials;\n            return;\n        }\n        if (!(thisCredentials instanceof Collection)) {\n            Set newSet = new HashSet();\n            newSet.add(thisCredentials);\n            setCredentials(newSet);\n        }\n        // At this point, the credentials should be a collection\n        Collection credentialCollection = (Collection) getCredentials();\n        if (otherCredentials instanceof Collection) {\n            credentialCollection.addAll((Collection) otherCredentials);\n        } else {\n            credentialCollection.add(otherCredentials);\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the Object argument is an <code>instanceof SimpleAuthenticationInfo</code> and\n     * its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.\n     * @param o the object to compare for equality.\n     * @return <code>true</code> if the Object argument is an <code>instanceof SimpleAuthenticationInfo</code> and\n     * its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof SimpleAuthenticationInfo))\n            return false;\n        SimpleAuthenticationInfo that = (SimpleAuthenticationInfo) o;\n        if (principals != null ? !principals.equals(that.principals) : that.principals != null)\n            return false;\n        return true;\n    }\n\n    /**\n     * Returns the hashcode of the internal {@link #getPrincipals() principals} instance.\n     * @return the hashcode of the internal {@link #getPrincipals() principals} instance.\n     */\n    public int hashCode() {\n        return (principals != null ? principals.hashCode() : 0);\n    }\n\n    /**\n     * Simple implementation that merely returns <code>{@link #getPrincipals() principals}.toString()</code>\n     * @return <code>{@link #getPrincipals() principals}.toString()</code>\n     */\n    public String toString() {\n        return principals.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAuthenticationInfoTest0.java",
		"test_prompt": "// SimpleAuthenticationInfoTest0.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.subject.MutablePrincipalCollection;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthenticationInfo}.\n* It contains ten unit test cases for the {@link SimpleAuthenticationInfo#equals(Object)} method.\n*/\nclass SimpleAuthenticationInfoTest0 {"
	},
	{
		"original_code": "// SimpleAuthenticationInfo.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.subject.MutablePrincipalCollection;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link MergableAuthenticationInfo} interface that holds the principals and\n * credentials.\n *\n * @see org.jsecurity.realm.AuthenticatingRealm\n * @since 0.9\n * @author Jeremy Haile\n * @author Les Hazlewood\n */\npublic class SimpleAuthenticationInfo implements MergableAuthenticationInfo {\n\n    /**\n     * The principals identifying the account associated with this AuthenticationInfo instance.\n     */\n    protected PrincipalCollection principals;\n\n    /**\n     * The credentials verifying the account principals.\n     */\n    protected Object credentials;\n\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAuthenticationInfo() {\n    }\n\n    /**\n     * Constructor that takes in a single 'primary' principal of the account and its corresponding credentials,\n     * associated with the specified realm.\n     * <p/>\n     * This is a convenience constructor and will construct a {@link PrincipalCollection PrincipalCollection} based\n     * on the <code>principal</code> and <code>realmName</code> argument.\n     *\n     * @param principal the 'primary' principal associated with the specified realm.\n     * @param credentials the credentials that verify the given principal.\n     * @param realmName the realm from where the principal and credentials were acquired.\n     */\n    public SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) {\n        this.principals = new SimplePrincipalCollection(principal, realmName);\n        this.credentials = credentials;\n    }\n\n    /**\n     * Constructor that takes in an account's identifying principal(s) and its corresponding credentials that verify\n     * the principals.\n     * @param principals a Realm's account's identifying principal(s)\n     * @param credentials the accounts corresponding principals that verify the principals.\n     */\n    public SimpleAuthenticationInfo(PrincipalCollection principals, Object credentials) {\n        this.principals = new SimplePrincipalCollection(principals);\n        this.credentials = credentials;\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return principals;\n    }\n\n    /**\n     * Sets the identifying principal(s) represented by this instance.\n     *\n     * @param principals the indentifying attributes of the corresponding Realm account.\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.principals = principals;\n    }\n\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    /**\n     * Sets the credentials that verify the principals/identity of the associated Realm account.\n     * @param credentials attribute(s) that verify the account's identity/principals, such as a password or private key.\n     */\n    public void setCredentials(Object credentials) {\n        this.credentials = credentials;\n    }\n\n    /**\n     * Takes the specified <code>info</code> argument and adds its principals and credentials into this instance.\n     * @param info the <code>AuthenticationInfo</code> to add into this instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void merge(AuthenticationInfo info) {\n        if (info == null || info.getPrincipals() == null || info.getPrincipals().isEmpty()) {\n            return;\n        }\n        if (this.principals == null) {\n            this.principals = info.getPrincipals();\n        } else {\n            if (this.principals instanceof MutablePrincipalCollection) {\n                ((MutablePrincipalCollection) this.principals).addAll(info.getPrincipals());\n            } else {\n                this.principals = new SimplePrincipalCollection(this.principals);\n            }\n        }\n        Object thisCredentials = getCredentials();\n        Object otherCredentials = info.getCredentials();\n        if (otherCredentials == null) {\n            return;\n        }\n        if (thisCredentials == null) {\n            this.credentials = otherCredentials;\n            return;\n        }\n        if (!(thisCredentials instanceof Collection)) {\n            Set newSet = new HashSet();\n            newSet.add(thisCredentials);\n            setCredentials(newSet);\n        }\n        // At this point, the credentials should be a collection\n        Collection credentialCollection = (Collection) getCredentials();\n        if (otherCredentials instanceof Collection) {\n            credentialCollection.addAll((Collection) otherCredentials);\n        } else {\n            credentialCollection.add(otherCredentials);\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the Object argument is an <code>instanceof SimpleAuthenticationInfo</code> and\n     * its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.\n     * @param o the object to compare for equality.\n     * @return <code>true</code> if the Object argument is an <code>instanceof SimpleAuthenticationInfo</code> and\n     * its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof SimpleAuthenticationInfo))\n            return false;\n        SimpleAuthenticationInfo that = (SimpleAuthenticationInfo) o;\n        if (principals != null ? !principals.equals(that.principals) : that.principals != null)\n            return false;\n        return true;\n    }\n\n    /**\n     * Returns the hashcode of the internal {@link #getPrincipals() principals} instance.\n     * @return the hashcode of the internal {@link #getPrincipals() principals} instance.\n     */\n    public int hashCode() {\n        return (principals != null ? principals.hashCode() : 0);\n    }\n\n    /**\n     * Simple implementation that merely returns <code>{@link #getPrincipals() principals}.toString()</code>\n     * @return <code>{@link #getPrincipals() principals}.toString()</code>\n     */\n    public String toString() {\n        return principals.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAuthenticationInfoTest1.java",
		"test_prompt": "// SimpleAuthenticationInfoTest1.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.subject.MutablePrincipalCollection;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthenticationInfo}.\n* It contains ten unit test cases for the {@link SimpleAuthenticationInfo#hashCode()} method.\n*/\nclass SimpleAuthenticationInfoTest1 {"
	},
	{
		"original_code": "// AllowAllCredentialsMatcher.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authc.credential;\r\n\r\nimport org.jsecurity.authc.AuthenticationInfo;\r\nimport org.jsecurity.authc.AuthenticationToken;\r\n\r\n/**\r\n * A credentials matcher that always returns <tt>true</tt> when matching credentials no matter what arguments\r\n * are passed in.  This can be used for testing or when credentials are implicitly trusted for a particular\r\n * {@link org.jsecurity.realm.Realm Realm}.\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @since 0.2\r\n */\r\npublic class AllowAllCredentialsMatcher implements CredentialsMatcher {\r\n\r\n    /**\r\n     * Returns <code>true</code> <em>always</em> no matter what the method arguments are.\r\n     *\r\n     * @param token   the token submitted for authentication.\r\n     * @param info    the account being verified for access\r\n     * @return <code>true</code> <em>always</em>.\r\n     */\r\n    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/credential/AllowAllCredentialsMatcherTest.java",
		"test_prompt": "// AllowAllCredentialsMatcherTest.java\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AllowAllCredentialsMatcher}.\n* It contains ten unit test cases for the {@link AllowAllCredentialsMatcher#doCredentialsMatch(AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass AllowAllCredentialsMatcherTest {"
	},
	{
		"original_code": "// SimpleCredentialsMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.credential;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.CodecSupport;\nimport java.util.Arrays;\n\n/**\n * Simple CredentialsMatcher implementation.  Supports direct (plain) comparison for credentials of type\n * byte[], char[], and Strings, and if the arguments do not match these types, then reverts back to simple\n * <code>Object.equals</code> comparison.\n *\n * <p>Hashing comparisons (the most common technique used in secure applications) are not supported by this class, but\n * instead by {@link HashedCredentialsMatcher HashedCredentialsMatcher} implementations.\n *\n * @author Les Hazlewood\n * @see HashedCredentialsMatcher\n * @see Md5CredentialsMatcher\n * @see Sha1CredentialsMatcher\n * @since 0.9\n */\npublic class SimpleCredentialsMatcher extends CodecSupport implements CredentialsMatcher {\n\n    private static final Log log = LogFactory.getLog(SimpleCredentialsMatcher.class);\n\n    /**\n     * Returns the <tt>token</tt>'s credentials.\n     *\n     * <p>This default implementation merely returns\n     * {@link AuthenticationToken#getCredentials() authenticationToken.getCredentials()} and exists as a template hook\n     * if subclasses wish to obtain the credentials in a different way or convert them to a different format before\n     * returning.\n     *\n     * @param token the <tt>AuthenticationToken</tt> submitted during the authentication attempt.\n     * @return the <tt>token</tt>'s associated credentials.\n     */\n    protected Object getCredentials(AuthenticationToken token) {\n        return token.getCredentials();\n    }\n\n    /**\n     * Returns the <tt>account</tt>'s credentials.\n     *\n     * <p>This default implementation merely returns\n     * {@link AuthenticationInfo#getCredentials() account.getCredentials()} and exists as a template hook if subclasses\n     * wish to obtain the credentials in a different way or convert them to a different format before\n     * returning.\n     *\n     * @param info the <tt>AuthenticationInfo</tt> stored in the data store to be compared against the submitted authentication\n     *                token's credentials.\n     * @return the <tt>account</tt>'s associated credentials.\n     */\n    protected Object getCredentials(AuthenticationInfo info) {\n        return info.getCredentials();\n    }\n\n    /**\n     * Returns <tt>true</tt> if the <tt>tokenCredentials</tt> argument is logically equal to the\n     * <tt>accountCredentials</tt> argument.\n     *\n     * <p>If both arguments are either a byte array (byte[]), char array (char[]) or String, they will be both be\n     * converted to raw byte arrays via the {@link #toBytes toBytes} method first, and then resulting byte arrays\n     * are compared via {@link Arrays#equals(byte[], byte[]) Arrays.equals(byte[],byte[])}.</p>\n     *\n     * <p>If either argument cannot be converted to a byte array as described, a simple Object <code>equals</code>\n     * comparison is made.</p>\n     *\n     * <p>Subclasses should override this method for more explicit equality checks.\n     *\n     * @param tokenCredentials   the <tt>AuthenticationToken</tt>'s associated credentials.\n     * @param accountCredentials the <tt>AuthenticationInfo</tt>'s stored credentials.\n     * @return <tt>true</tt> if the <tt>tokenCredentials</tt> are equal to the <tt>accountCredentials</tt>.\n     */\n    protected boolean equals(Object tokenCredentials, Object accountCredentials) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Performing credentials equality check for tokenCredentials of type [\" + tokenCredentials.getClass().getName() + \" and accountCredentials of type [\" + accountCredentials.getClass().getName() + \"]\");\n        }\n        if ((tokenCredentials instanceof byte[] || tokenCredentials instanceof char[] || tokenCredentials instanceof String) && (accountCredentials instanceof byte[] || accountCredentials instanceof char[] || accountCredentials instanceof String)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Both credentials arguments can be easily converted to byte arrays.  Performing \" + \"array equals comparison\");\n            }\n            byte[] tokenBytes = toBytes(tokenCredentials);\n            byte[] accountBytes = toBytes(accountCredentials);\n            return Arrays.equals(tokenBytes, accountBytes);\n        } else {\n            return accountCredentials.equals(tokenCredentials);\n        }\n    }\n\n    /**\n     * This implementation acquires the <tt>token</tt>'s credentials\n     * (via {@link #getCredentials(AuthenticationToken) getCredentials(token)})\n     * and then the <tt>account</tt>'s credentials\n     * (via {@link #getCredentials(org.jsecurity.authc.AuthenticationInfo) getCredentials(account)}) and then passes both of\n     * them to the {@link #equals(Object,Object) equals(tokenCredentials, accountCredentials)} method for equality\n     * comparison.\n     *\n     * @param token   the <tt>AuthenticationToken</tt> submitted during the authentication attempt.\n     * @param info the <tt>AuthenticationInfo</tt> stored in the system matching the token principal.\n     * @return <tt>true</tt> if the provided token credentials are equal to the stored account credentials,\n     *         <tt>false</tt> otherwise\n     */\n    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n        Object tokenCredentials = getCredentials(token);\n        Object accountCredentials = getCredentials(info);\n        return equals(tokenCredentials, accountCredentials);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/credential/SimpleCredentialsMatcherTest.java",
		"test_prompt": "// SimpleCredentialsMatcherTest.java\npackage org.jsecurity.authc.credential;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.CodecSupport;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCredentialsMatcher}.\n* It contains ten unit test cases for the {@link SimpleCredentialsMatcher#doCredentialsMatch(AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass SimpleCredentialsMatcherTest {"
	},
	{
		"original_code": "// HashedCredentialsMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\n\n/**\n * A <tt>HashedCredentialMatcher</tt> provides support for hashing of supplied <tt>AuthenticationToken</tt> credentials\n * before being compared to those in the <tt>AuthenticationInfo</tt> from the data store.\n *\n * <p>Credential hashing is one of the most common security techniques when safeguarding a user's private credentials\n * (passwords, keys, etc).  Most developers never want to store their users' credentials in plain form, viewable by\n * anyone, so they often hash the users' credentials before they are saved in the data store.</p>\n *\n * <p>This class (and its subclasses) function as follows:</p>\n *\n * <p>It first hashes the <tt>AuthenticationToken</tt> credentials supplied by the user during their login.  It then\n * compares this hashed value directly with the <tt>AuthenticationInfo</tt> credentials stored in the system.  The stored account\n * credentials are expected to already be in hashed form.  If these two values are equal, the submitted credentials\n * match.</p>\n *\n * <h3>Salting and Multiple Hash Iterations</h3>\n *\n * <p>Because simple hashing is sometimes not good enough for many applications, this class also supports 'salting'\n * and multiple hash iterations.  Please read this excellent\n * <a href=\"http://www.owasp.org/index.php/Hashing_Java\" _target=\"blank\">Hashing Java article</a> to learn about\n * salting and multiple iterations and why you might want to use them. (Note of sections 5\n * &quot;Why add salt?&quot; and 6 \"Hardening against the attacker's attack\").\n *\n * <p>We should also note here that all of JSecurity's Hash implementations (for example,\n * {@link org.jsecurity.crypto.hash.Md5Hash Md5Hash}, {@link org.jsecurity.crypto.hash.Sha1Hash Sha1Hash}, etc)\n * support salting and multiple hash iterations via overloaded constructors.</p>\n *\n * <h4>Salting</h4>\n *\n * <p>Salting of the authentication token's credentials hash is disabled by default, but you may enable it by setting\n * {@link #setHashSalted hashSalted} to\n * <tt>true</tt>.  If you do enable it, the value used to salt the hash will be\n * obtained from {@link #getSalt(AuthenticationToken) getSalt(authenticationToken)}.\n *\n * <p>The default <tt>getSalt</tt> implementation merely returns\n * <code>token.getPrincipal()</code>, effectively using the user's identity as the salt, a most common\n * technique.  If you wish to provide the authentication token's salt another way, you may override this\n * <tt>getSalt</tt> method.\n *\n * <h4>Multiple Hash Iterations</h4>\n *\n * <p>If you hash your users' credentials multiple times before persisting to the data store, you will also need to\n * set this class's {@link #setHashIterations(int) hashIterations} property.</p>\n *\n * <p><b>Note:</b> <a href=\"http://en.wikipedia.org/wiki/MD5\">MD5</a> and\n * <a href=\"http://en.wikipedia.org/wiki/SHA_hash_functions\">SHA-1</a> algorithms are now known to be vulnerable to\n * compromise and/or collisions (read the linked pages for more).  While most applications are ok with either of these\n * two, if your application mandates high security, use the SHA-256 (or higher) hashing algorithms and their\n * supporting <code>CredentialsMatcher</code> implementations.</p>\n *\n * @author Les Hazlewood\n * @see org.jsecurity.crypto.hash.Md5Hash\n * @see org.jsecurity.crypto.hash.Sha1Hash\n * @see org.jsecurity.crypto.hash.Sha256Hash\n * @since 0.9\n */\npublic abstract class HashedCredentialsMatcher extends SimpleCredentialsMatcher {\n\n    //false means base64 encoded\n    private boolean storedCredentialsHexEncoded = true;\n\n    private boolean hashSalted = false;\n\n    private int hashIterations = 1;\n\n    /**\n     * Returns <tt>true</tt> if the system's stored credential hash is Hex encoded, <tt>false</tt> if it\n     * is Base64 encoded.\n     *\n     * <p>Default value is <tt>true</tt> for convenience - all of JSecurity's {@link Hash Hash#toString()}\n     * implementations return Hex encoded values by default, making this class's use with those implementations\n     * easier.</p>\n     *\n     * @return <tt>true</tt> if the system's stored credential hash is Hex encoded, <tt>false</tt> if it\n     *         is Base64 encoded.  Default is <tt>true</tt>\n     */\n    public boolean isStoredCredentialsHexEncoded() {\n        return storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Sets the indicator if this system's stored credential hash is Hex encoded or not.\n     *\n     * <p>A value of <tt>true</tt> will cause this class to decode the system credential from Hex, a\n     * value of <tt>false</tt> will cause this class to decode the system credential from Base64.</p>\n     *\n     * <p>Unless overridden via this method, the default value is <tt>true</tt> for convenience - all of JSecurity's\n     * {@link Hash Hash#toString()} implementations return Hex encoded values by default, making this class's use with\n     * those implementations easier.</p>.\n     *\n     * @param storedCredentialsHexEncoded the indicator if this system's stored credential hash is Hex\n     *                                    encoded or not ('not' automatically implying it is Base64 encoded).\n     */\n    public void setStoredCredentialsHexEncoded(boolean storedCredentialsHexEncoded) {\n        this.storedCredentialsHexEncoded = storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Returns <tt>true</tt> if a submitted <tt>AuthenticationToken</tt>'s credentials should be salted when hashing,\n     * <tt>false</tt> if it should not be salted.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false</tt>.\n     *\n     * @return <tt>true</tt> if a submitted <tt>AuthenticationToken</tt>'s credentials should be salted when hashing,\n     *         <tt>false</tt> if it should not be salted.\n     */\n    public boolean isHashSalted() {\n        return hashSalted;\n    }\n\n    /**\n     * Sets whether or not to salt a submitted <tt>AuthenticationToken</tt>'s credentials when hashing.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false</tt>.\n     *\n     * @param hashSalted whether or not to salt a submitted <tt>AuthenticationToken</tt>'s credentials when hashing.\n     */\n    public void setHashSalted(boolean hashSalted) {\n        this.hashSalted = hashSalted;\n    }\n\n    /**\n     * Returns the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1</tt>, meaning a normal hash execution will occur.\n     *\n     * @return the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before\n     *         comparing to the credentials stored in the system.\n     */\n    public int getHashIterations() {\n        return hashIterations;\n    }\n\n    /**\n     * Sets the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before comparing\n     * to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1</tt>, meaning a normal single hash execution will occur.\n     *\n     * <p>If this argument is less than 1 (i.e. 0 or negative), the default value of 1 is applied.  There must always be\n     * at least 1 hash iteration (otherwise there would be no hash).\n     *\n     * @param hashIterations the number of times to hash a submitted <tt>AuthenticationToken</tt>'s credentials.\n     */\n    public void setHashIterations(int hashIterations) {\n        if (hashIterations < 1) {\n            this.hashIterations = 1;\n        } else {\n            this.hashIterations = hashIterations;\n        }\n    }\n\n    /**\n     * Returns a salt value used to hash the token's credentials.\n     *\n     * <p>This default implementation merely returns <code>token.getPrincipal()</code>, effectively using the user's\n     * identity (username, user id, etc) as the salt, a most common technique.  If you wish to provide the\n     * authentication token's salt another way, you may override this method.\n     *\n     * @param token the AuthenticationToken submitted during the authentication attempt.\n     * @return a salt value to use to hash the authentication token's credentials.\n     */\n    protected Object getSalt(AuthenticationToken token) {\n        return token.getPrincipal();\n    }\n\n    /**\n     * As this is a HashedCredentialMatcher, this method overrides the parent method by returning a hashed value\n     * of the submitted token's credentials.\n     *\n     * <p>Based on this class's configuration, the return value may be salted and/or\n     * hashed multiple times (see the class-level JavaDoc for more information on salting and\n     * multiple hash iterations).\n     *\n     * @param token the authentication token submitted during the authentication attempt.\n     * @return the hashed value of the authentication token's credentials.\n     */\n    protected Object getCredentials(AuthenticationToken token) {\n        Object credentials = token.getCredentials();\n        Object salt = isHashSalted() ? getSalt(token) : null;\n        return hashProvidedCredentials(credentials, salt, getHashIterations());\n    }\n\n    /**\n     * Returns a {@link Hash Hash} instance representing the already-hashed AuthenticationInfo credentials stored in the system.\n     *\n     * <p>This method reconstructs a {@link Hash Hash} instance based on a <code>info.getCredentials</code> call,\n     * but it does <em>not</em> hash that value - it is expected that method call will return an already-hashed value.\n     *\n     * <p>This implementation's reconstruction effort functions as follows:\n     *\n     * <ol>\n     * <li>Convert <code>account.getCredentials()</code> to a byte array via the {@link #toBytes toBytes} method.\n     * <li>If <code>account.getCredentials()</code> was originally a String or char[] before <tt>toBytes</tt> was\n     * called, check for encoding:\n     * <li>If {@link #storedCredentialsHexEncoded storedCredentialsHexEncoded}, Hex decode that byte array, otherwise\n     * Base64 decode the byte array</li>\n     * <li>Set the byte[] array directly on the <tt>Hash</tt> implementation and return it.</li>\n     * </ol>\n     *\n     * @param info the AuthenticationInfo from which to retrive the credentials which assumed to be in already-hashed form.\n     * @return a {@link Hash Hash} instance representing the given AuthenticationInfo's stored credentials.\n     */\n    protected Object getCredentials(AuthenticationInfo info) {\n        Object credentials = info.getCredentials();\n        byte[] storedBytes = toBytes(credentials);\n        if (credentials instanceof String || credentials instanceof char[]) {\n            //account.credentials were a char[] or String, so\n            //we need to do text decoding first:\n            if (isStoredCredentialsHexEncoded()) {\n                storedBytes = Hex.decode(storedBytes);\n            } else {\n                storedBytes = Base64.decode(storedBytes);\n            }\n        }\n        AbstractHash hash = newHashInstance();\n        hash.setBytes(storedBytes);\n        return hash;\n    }\n\n    /**\n     * Hashes the provided credentials a total of <tt>hashIterations</tt> times, using the given salt.  The hash\n     * implementation/algorithm used is left to subclasses.\n     *\n     * @param credentials    the submitted authentication token's credentials to hash\n     * @param salt           the value to salt the hash, or <tt>null</tt> if a salt will not be used.\n     * @param hashIterations the number of times to hash the credentials.  At least one hash will always occur though,\n     *                       even if this argument is 0 or negative.\n     * @return the hashed value of the provided credentials, according to the specified salt and hash iterations.\n     */\n    protected abstract Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations);\n\n    /**\n     * Returns a new, <em>uninitialized</em> instance, without its byte array set.  Used as a utility method in the\n     * {@link SimpleCredentialsMatcher#getCredentials(org.jsecurity.authc.AuthenticationInfo) getCredentials(AuthenticationInfo)} implementation.\n     *\n     * @return a new, <em>uninitialized</em> instance, without its byte array set.\n     */\n    protected abstract AbstractHash newHashInstance();\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/credential/HashedCredentialsMatcherTest0.java",
		"test_prompt": "// HashedCredentialsMatcherTest0.java\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HashedCredentialsMatcher}.\n* It contains ten unit test cases for the {@link HashedCredentialsMatcher#isStoredCredentialsHexEncoded()} method.\n*/\nclass HashedCredentialsMatcherTest0 {"
	},
	{
		"original_code": "// HashedCredentialsMatcher.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\n\n/**\n * A <tt>HashedCredentialMatcher</tt> provides support for hashing of supplied <tt>AuthenticationToken</tt> credentials\n * before being compared to those in the <tt>AuthenticationInfo</tt> from the data store.\n *\n * <p>Credential hashing is one of the most common security techniques when safeguarding a user's private credentials\n * (passwords, keys, etc).  Most developers never want to store their users' credentials in plain form, viewable by\n * anyone, so they often hash the users' credentials before they are saved in the data store.</p>\n *\n * <p>This class (and its subclasses) function as follows:</p>\n *\n * <p>It first hashes the <tt>AuthenticationToken</tt> credentials supplied by the user during their login.  It then\n * compares this hashed value directly with the <tt>AuthenticationInfo</tt> credentials stored in the system.  The stored account\n * credentials are expected to already be in hashed form.  If these two values are equal, the submitted credentials\n * match.</p>\n *\n * <h3>Salting and Multiple Hash Iterations</h3>\n *\n * <p>Because simple hashing is sometimes not good enough for many applications, this class also supports 'salting'\n * and multiple hash iterations.  Please read this excellent\n * <a href=\"http://www.owasp.org/index.php/Hashing_Java\" _target=\"blank\">Hashing Java article</a> to learn about\n * salting and multiple iterations and why you might want to use them. (Note of sections 5\n * &quot;Why add salt?&quot; and 6 \"Hardening against the attacker's attack\").\n *\n * <p>We should also note here that all of JSecurity's Hash implementations (for example,\n * {@link org.jsecurity.crypto.hash.Md5Hash Md5Hash}, {@link org.jsecurity.crypto.hash.Sha1Hash Sha1Hash}, etc)\n * support salting and multiple hash iterations via overloaded constructors.</p>\n *\n * <h4>Salting</h4>\n *\n * <p>Salting of the authentication token's credentials hash is disabled by default, but you may enable it by setting\n * {@link #setHashSalted hashSalted} to\n * <tt>true</tt>.  If you do enable it, the value used to salt the hash will be\n * obtained from {@link #getSalt(AuthenticationToken) getSalt(authenticationToken)}.\n *\n * <p>The default <tt>getSalt</tt> implementation merely returns\n * <code>token.getPrincipal()</code>, effectively using the user's identity as the salt, a most common\n * technique.  If you wish to provide the authentication token's salt another way, you may override this\n * <tt>getSalt</tt> method.\n *\n * <h4>Multiple Hash Iterations</h4>\n *\n * <p>If you hash your users' credentials multiple times before persisting to the data store, you will also need to\n * set this class's {@link #setHashIterations(int) hashIterations} property.</p>\n *\n * <p><b>Note:</b> <a href=\"http://en.wikipedia.org/wiki/MD5\">MD5</a> and\n * <a href=\"http://en.wikipedia.org/wiki/SHA_hash_functions\">SHA-1</a> algorithms are now known to be vulnerable to\n * compromise and/or collisions (read the linked pages for more).  While most applications are ok with either of these\n * two, if your application mandates high security, use the SHA-256 (or higher) hashing algorithms and their\n * supporting <code>CredentialsMatcher</code> implementations.</p>\n *\n * @author Les Hazlewood\n * @see org.jsecurity.crypto.hash.Md5Hash\n * @see org.jsecurity.crypto.hash.Sha1Hash\n * @see org.jsecurity.crypto.hash.Sha256Hash\n * @since 0.9\n */\npublic abstract class HashedCredentialsMatcher extends SimpleCredentialsMatcher {\n\n    //false means base64 encoded\n    private boolean storedCredentialsHexEncoded = true;\n\n    private boolean hashSalted = false;\n\n    private int hashIterations = 1;\n\n    /**\n     * Returns <tt>true</tt> if the system's stored credential hash is Hex encoded, <tt>false</tt> if it\n     * is Base64 encoded.\n     *\n     * <p>Default value is <tt>true</tt> for convenience - all of JSecurity's {@link Hash Hash#toString()}\n     * implementations return Hex encoded values by default, making this class's use with those implementations\n     * easier.</p>\n     *\n     * @return <tt>true</tt> if the system's stored credential hash is Hex encoded, <tt>false</tt> if it\n     *         is Base64 encoded.  Default is <tt>true</tt>\n     */\n    public boolean isStoredCredentialsHexEncoded() {\n        return storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Sets the indicator if this system's stored credential hash is Hex encoded or not.\n     *\n     * <p>A value of <tt>true</tt> will cause this class to decode the system credential from Hex, a\n     * value of <tt>false</tt> will cause this class to decode the system credential from Base64.</p>\n     *\n     * <p>Unless overridden via this method, the default value is <tt>true</tt> for convenience - all of JSecurity's\n     * {@link Hash Hash#toString()} implementations return Hex encoded values by default, making this class's use with\n     * those implementations easier.</p>.\n     *\n     * @param storedCredentialsHexEncoded the indicator if this system's stored credential hash is Hex\n     *                                    encoded or not ('not' automatically implying it is Base64 encoded).\n     */\n    public void setStoredCredentialsHexEncoded(boolean storedCredentialsHexEncoded) {\n        this.storedCredentialsHexEncoded = storedCredentialsHexEncoded;\n    }\n\n    /**\n     * Returns <tt>true</tt> if a submitted <tt>AuthenticationToken</tt>'s credentials should be salted when hashing,\n     * <tt>false</tt> if it should not be salted.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false</tt>.\n     *\n     * @return <tt>true</tt> if a submitted <tt>AuthenticationToken</tt>'s credentials should be salted when hashing,\n     *         <tt>false</tt> if it should not be salted.\n     */\n    public boolean isHashSalted() {\n        return hashSalted;\n    }\n\n    /**\n     * Sets whether or not to salt a submitted <tt>AuthenticationToken</tt>'s credentials when hashing.\n     *\n     * <p>If enabled, the salt used will be obtained via the {@link #getSalt(AuthenticationToken) getSalt} method.\n     *\n     * <p>The default value is <tt>false</tt>.\n     *\n     * @param hashSalted whether or not to salt a submitted <tt>AuthenticationToken</tt>'s credentials when hashing.\n     */\n    public void setHashSalted(boolean hashSalted) {\n        this.hashSalted = hashSalted;\n    }\n\n    /**\n     * Returns the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before\n     * comparing to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1</tt>, meaning a normal hash execution will occur.\n     *\n     * @return the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before\n     *         comparing to the credentials stored in the system.\n     */\n    public int getHashIterations() {\n        return hashIterations;\n    }\n\n    /**\n     * Sets the number of times a submitted <tt>AuthenticationToken</tt>'s credentials will be hashed before comparing\n     * to the credentials stored in the system.\n     *\n     * <p>Unless overridden, the default value is <tt>1</tt>, meaning a normal single hash execution will occur.\n     *\n     * <p>If this argument is less than 1 (i.e. 0 or negative), the default value of 1 is applied.  There must always be\n     * at least 1 hash iteration (otherwise there would be no hash).\n     *\n     * @param hashIterations the number of times to hash a submitted <tt>AuthenticationToken</tt>'s credentials.\n     */\n    public void setHashIterations(int hashIterations) {\n        if (hashIterations < 1) {\n            this.hashIterations = 1;\n        } else {\n            this.hashIterations = hashIterations;\n        }\n    }\n\n    /**\n     * Returns a salt value used to hash the token's credentials.\n     *\n     * <p>This default implementation merely returns <code>token.getPrincipal()</code>, effectively using the user's\n     * identity (username, user id, etc) as the salt, a most common technique.  If you wish to provide the\n     * authentication token's salt another way, you may override this method.\n     *\n     * @param token the AuthenticationToken submitted during the authentication attempt.\n     * @return a salt value to use to hash the authentication token's credentials.\n     */\n    protected Object getSalt(AuthenticationToken token) {\n        return token.getPrincipal();\n    }\n\n    /**\n     * As this is a HashedCredentialMatcher, this method overrides the parent method by returning a hashed value\n     * of the submitted token's credentials.\n     *\n     * <p>Based on this class's configuration, the return value may be salted and/or\n     * hashed multiple times (see the class-level JavaDoc for more information on salting and\n     * multiple hash iterations).\n     *\n     * @param token the authentication token submitted during the authentication attempt.\n     * @return the hashed value of the authentication token's credentials.\n     */\n    protected Object getCredentials(AuthenticationToken token) {\n        Object credentials = token.getCredentials();\n        Object salt = isHashSalted() ? getSalt(token) : null;\n        return hashProvidedCredentials(credentials, salt, getHashIterations());\n    }\n\n    /**\n     * Returns a {@link Hash Hash} instance representing the already-hashed AuthenticationInfo credentials stored in the system.\n     *\n     * <p>This method reconstructs a {@link Hash Hash} instance based on a <code>info.getCredentials</code> call,\n     * but it does <em>not</em> hash that value - it is expected that method call will return an already-hashed value.\n     *\n     * <p>This implementation's reconstruction effort functions as follows:\n     *\n     * <ol>\n     * <li>Convert <code>account.getCredentials()</code> to a byte array via the {@link #toBytes toBytes} method.\n     * <li>If <code>account.getCredentials()</code> was originally a String or char[] before <tt>toBytes</tt> was\n     * called, check for encoding:\n     * <li>If {@link #storedCredentialsHexEncoded storedCredentialsHexEncoded}, Hex decode that byte array, otherwise\n     * Base64 decode the byte array</li>\n     * <li>Set the byte[] array directly on the <tt>Hash</tt> implementation and return it.</li>\n     * </ol>\n     *\n     * @param info the AuthenticationInfo from which to retrive the credentials which assumed to be in already-hashed form.\n     * @return a {@link Hash Hash} instance representing the given AuthenticationInfo's stored credentials.\n     */\n    protected Object getCredentials(AuthenticationInfo info) {\n        Object credentials = info.getCredentials();\n        byte[] storedBytes = toBytes(credentials);\n        if (credentials instanceof String || credentials instanceof char[]) {\n            //account.credentials were a char[] or String, so\n            //we need to do text decoding first:\n            if (isStoredCredentialsHexEncoded()) {\n                storedBytes = Hex.decode(storedBytes);\n            } else {\n                storedBytes = Base64.decode(storedBytes);\n            }\n        }\n        AbstractHash hash = newHashInstance();\n        hash.setBytes(storedBytes);\n        return hash;\n    }\n\n    /**\n     * Hashes the provided credentials a total of <tt>hashIterations</tt> times, using the given salt.  The hash\n     * implementation/algorithm used is left to subclasses.\n     *\n     * @param credentials    the submitted authentication token's credentials to hash\n     * @param salt           the value to salt the hash, or <tt>null</tt> if a salt will not be used.\n     * @param hashIterations the number of times to hash the credentials.  At least one hash will always occur though,\n     *                       even if this argument is 0 or negative.\n     * @return the hashed value of the provided credentials, according to the specified salt and hash iterations.\n     */\n    protected abstract Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations);\n\n    /**\n     * Returns a new, <em>uninitialized</em> instance, without its byte array set.  Used as a utility method in the\n     * {@link SimpleCredentialsMatcher#getCredentials(org.jsecurity.authc.AuthenticationInfo) getCredentials(AuthenticationInfo)} implementation.\n     *\n     * @return a new, <em>uninitialized</em> instance, without its byte array set.\n     */\n    protected abstract AbstractHash newHashInstance();\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/credential/HashedCredentialsMatcherTest1.java",
		"test_prompt": "// HashedCredentialsMatcherTest1.java\npackage org.jsecurity.authc.credential;\n\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.codec.Base64;\nimport org.jsecurity.codec.Hex;\nimport org.jsecurity.crypto.hash.AbstractHash;\nimport org.jsecurity.crypto.hash.Hash;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HashedCredentialsMatcher}.\n* It contains ten unit test cases for the {@link HashedCredentialsMatcher#isHashSalted()} method.\n*/\nclass HashedCredentialsMatcherTest1 {"
	},
	{
		"original_code": "// AbstractAuthenticator.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * Superclass for almost all {@link Authenticator} implementations that performs the common work around authentication\n * attempts.\n *\n * <p>This class delegates the actual authentication attempt to subclasses but supports notification for\n * successful and failed logins as well as logouts. Notification is sent to one or more registered\n * {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s to allow for custom processing logic\n * when these conditions occur.\n *\n * <p>In most cases, the only thing a subclass needs to do (via its {@link #doAuthenticate} implementation)\n * is perform the actual principal/credential verification process for the submitted <tt>AuthenticationToken</tt>.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractAuthenticator implements Authenticator, LogoutAware, AuthenticationListenerRegistrar {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * Private class log instance.\n     */\n    private static final Log log = LogFactory.getLog(AbstractAuthenticator.class);\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Any registered listeners that wish to know about things during the authentication process.\n     */\n    private Collection<AuthenticationListener> listeners;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor. Ensures the internal\n     * {@link AuthenticationListener AuthenticationListener} collection is a non-null <code>ArrayList</code>.\n     */\n    public AbstractAuthenticator() {\n        listeners = new ArrayList<AuthenticationListener>();\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationListeners(Collection<AuthenticationListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<AuthenticationListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(AuthenticationListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(AuthenticationListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that\n     * authentication was successful for the specified <code>token</code> which resulted in the specified\n     * <code>info</code>.  This implementation merely iterates over the internal <code>listeners</code> collection and\n     * calls {@link org.jsecurity.authc.AuthenticationListener#onSuccess(AuthenticationToken, AuthenticationInfo) onSuccess}\n     * for each.\n     * @param token the submitted <code>AuthenticationToken</code> that resulted in a successful authentication.\n     * @param info the returned <code>AuthenticationInfo</code> resulting from the successful authentication.\n     */\n    protected void notifySuccess(AuthenticationToken token, AuthenticationInfo info) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onSuccess(token, info);\n        }\n    }\n\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that\n     * authentication failed for the\n     * specified <code>token</code> which resulted in the specified <code>ae</code> exception.  This implementation merely\n     * iterates over the internal <code>listeners</code> collection and calls\n     * {@link org.jsecurity.authc.AuthenticationListener#onFailure(AuthenticationToken, AuthenticationException) onFailure}\n     * for each.\n     * @param token the submitted <code>AuthenticationToken</code> that resulted in a failed authentication.\n     * @param ae the resulting <code>AuthenticationException<code> that caused the authentication to fail.\n     */\n    protected void notifyFailure(AuthenticationToken token, AuthenticationException ae) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onFailure(token, ae);\n        }\n    }\n\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that a\n     * <code>Subject</code> has logged-out.  This implementation merely\n     * iterates over the internal <code>listeners</code> collection and calls\n     * {@link org.jsecurity.authc.AuthenticationListener#onLogout(org.jsecurity.subject.PrincipalCollection) onLogout}\n     * for each.\n     * @param principals the identifying principals of the <code>Subject</code>/account logging out.\n     */\n    protected void notifyLogout(PrincipalCollection principals) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onLogout(principals);\n        }\n    }\n\n    /**\n     * This implementation merely calls\n     * {@link #notifyLogout(org.jsecurity.subject.PrincipalCollection) notifyLogout} to allow any registered listeners\n     * to react to the logout.\n     * @param principals the identifying principals of the <code>Subject</code>/account logging out.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        notifyLogout(principals);\n    }\n\n    /**\n     * Implementation of the {@link Authenticator} interface that functions in the following manner:\n     *\n     * <ol>\n     * <li>Calls template {@link #doAuthenticate doAuthenticate} method for subclass execution of the actual\n     * authentication behavior.</li>\n     * <li>If an <tt>AuthenticationException</tt> is thrown during <tt>doAuthenticate</tt>,\n     * {@link #notifyFailure(AuthenticationToken, AuthenticationException) notify} any registered\n     * {@link AuthenticationListener AuthenticationListener}s of the exception and then propogate the exception\n     * for the caller to handle.</li>\n     * <li>If no exception is thrown (indicating a successful login),\n     * {@link #notifySuccess(AuthenticationToken, AuthenticationInfo) notify} any registered\n     * {@link AuthenticationListener AuthenticationListener}s of the successful attempt.</li>\n     * <li>Return the <tt>AuthenticationInfo</tt></li>\n     * </ol>\n     *\n     * @param token the submitted token representing the subject's (user's) login principals and credentials.\n     * @return the AuthenticationInfo referencing the authenticated user's account data.\n     * @throws AuthenticationException if there is any problem during the authentication process - see the\n     *                                 interface's JavaDoc for a more detailed explanation.\n     */\n    public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {\n        if (token == null) {\n            throw new IllegalArgumentException(\"Method argumet (authentication token) cannot be null.\");\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Authentication attempt received for token [\" + token + \"]\");\n        }\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate(token);\n            if (info == null) {\n                String msg = \"No account information found for authentication token [\" + token + \"] by this \" + \"Authenticator instance.  Please check that it is configured correctly.\";\n                throw new AuthenticationException(msg);\n            }\n        } catch (Throwable t) {\n            AuthenticationException ae = null;\n            if (t instanceof AuthenticationException) {\n                ae = (AuthenticationException) t;\n            }\n            if (ae == null) {\n                //Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more\n                //severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:\n                String msg = \"Authentication failed for token submission [\" + token + \"].  Possible unexpected \" + \"error? (Typical or expected login exceptions should extend from AuthenticationException).\";\n                ae = new AuthenticationException(msg, t);\n                if (log.isWarnEnabled()) {\n                    log.warn(msg, t);\n                }\n            }\n            try {\n                notifyFailure(token, ae);\n            } catch (Throwable t2) {\n                String msg = \"Unable to send notification for failed authentication attempt - listener error?.  \" + \"Please check your AuthenticationListener implementation(s).  Logging sending exception and \" + \"propagating original AuthenticationException instead...\";\n                if (log.isWarnEnabled()) {\n                    log.warn(msg, t2);\n                }\n            }\n            throw ae;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authentication successful for token [\" + token + \"].  Returned account: [\" + info + \"]\");\n        }\n        notifySuccess(token, info);\n        return info;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most authentication attempts is encapsulated in the\n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.</b> Subclasses <em>should</em> throw some kind of\n     * <tt>AuthenticationException</tt> if there is a problem during\n     * authentication instead of returning <tt>null</tt>.  A <tt>null</tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException</tt>s should\n     * indicate any expected problem (such as an unknown account or username, or invalid password, etc).\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo</tt> object encapsulating the user's account information\n     *         important to JSecurity.\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/AbstractAuthenticatorTest0.java",
		"test_prompt": "// AbstractAuthenticatorTest0.java\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticator}.\n* It contains ten unit test cases for the {@link AbstractAuthenticator#remove(AuthenticationListener)} method.\n*/\nclass AbstractAuthenticatorTest0 {"
	},
	{
		"original_code": "// AbstractAuthenticator.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * Superclass for almost all {@link Authenticator} implementations that performs the common work around authentication\n * attempts.\n *\n * <p>This class delegates the actual authentication attempt to subclasses but supports notification for\n * successful and failed logins as well as logouts. Notification is sent to one or more registered\n * {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s to allow for custom processing logic\n * when these conditions occur.\n *\n * <p>In most cases, the only thing a subclass needs to do (via its {@link #doAuthenticate} implementation)\n * is perform the actual principal/credential verification process for the submitted <tt>AuthenticationToken</tt>.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractAuthenticator implements Authenticator, LogoutAware, AuthenticationListenerRegistrar {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * Private class log instance.\n     */\n    private static final Log log = LogFactory.getLog(AbstractAuthenticator.class);\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * Any registered listeners that wish to know about things during the authentication process.\n     */\n    private Collection<AuthenticationListener> listeners;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor. Ensures the internal\n     * {@link AuthenticationListener AuthenticationListener} collection is a non-null <code>ArrayList</code>.\n     */\n    public AbstractAuthenticator() {\n        listeners = new ArrayList<AuthenticationListener>();\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthenticationListeners(Collection<AuthenticationListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<AuthenticationListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(AuthenticationListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(AuthenticationListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    /*-------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that\n     * authentication was successful for the specified <code>token</code> which resulted in the specified\n     * <code>info</code>.  This implementation merely iterates over the internal <code>listeners</code> collection and\n     * calls {@link org.jsecurity.authc.AuthenticationListener#onSuccess(AuthenticationToken, AuthenticationInfo) onSuccess}\n     * for each.\n     * @param token the submitted <code>AuthenticationToken</code> that resulted in a successful authentication.\n     * @param info the returned <code>AuthenticationInfo</code> resulting from the successful authentication.\n     */\n    protected void notifySuccess(AuthenticationToken token, AuthenticationInfo info) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onSuccess(token, info);\n        }\n    }\n\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that\n     * authentication failed for the\n     * specified <code>token</code> which resulted in the specified <code>ae</code> exception.  This implementation merely\n     * iterates over the internal <code>listeners</code> collection and calls\n     * {@link org.jsecurity.authc.AuthenticationListener#onFailure(AuthenticationToken, AuthenticationException) onFailure}\n     * for each.\n     * @param token the submitted <code>AuthenticationToken</code> that resulted in a failed authentication.\n     * @param ae the resulting <code>AuthenticationException<code> that caused the authentication to fail.\n     */\n    protected void notifyFailure(AuthenticationToken token, AuthenticationException ae) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onFailure(token, ae);\n        }\n    }\n\n    /**\n     * Notifies any registered {@link org.jsecurity.authc.AuthenticationListener AuthenticationListener}s that a\n     * <code>Subject</code> has logged-out.  This implementation merely\n     * iterates over the internal <code>listeners</code> collection and calls\n     * {@link org.jsecurity.authc.AuthenticationListener#onLogout(org.jsecurity.subject.PrincipalCollection) onLogout}\n     * for each.\n     * @param principals the identifying principals of the <code>Subject</code>/account logging out.\n     */\n    protected void notifyLogout(PrincipalCollection principals) {\n        for (AuthenticationListener listener : this.listeners) {\n            listener.onLogout(principals);\n        }\n    }\n\n    /**\n     * This implementation merely calls\n     * {@link #notifyLogout(org.jsecurity.subject.PrincipalCollection) notifyLogout} to allow any registered listeners\n     * to react to the logout.\n     * @param principals the identifying principals of the <code>Subject</code>/account logging out.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        notifyLogout(principals);\n    }\n\n    /**\n     * Implementation of the {@link Authenticator} interface that functions in the following manner:\n     *\n     * <ol>\n     * <li>Calls template {@link #doAuthenticate doAuthenticate} method for subclass execution of the actual\n     * authentication behavior.</li>\n     * <li>If an <tt>AuthenticationException</tt> is thrown during <tt>doAuthenticate</tt>,\n     * {@link #notifyFailure(AuthenticationToken, AuthenticationException) notify} any registered\n     * {@link AuthenticationListener AuthenticationListener}s of the exception and then propogate the exception\n     * for the caller to handle.</li>\n     * <li>If no exception is thrown (indicating a successful login),\n     * {@link #notifySuccess(AuthenticationToken, AuthenticationInfo) notify} any registered\n     * {@link AuthenticationListener AuthenticationListener}s of the successful attempt.</li>\n     * <li>Return the <tt>AuthenticationInfo</tt></li>\n     * </ol>\n     *\n     * @param token the submitted token representing the subject's (user's) login principals and credentials.\n     * @return the AuthenticationInfo referencing the authenticated user's account data.\n     * @throws AuthenticationException if there is any problem during the authentication process - see the\n     *                                 interface's JavaDoc for a more detailed explanation.\n     */\n    public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {\n        if (token == null) {\n            throw new IllegalArgumentException(\"Method argumet (authentication token) cannot be null.\");\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Authentication attempt received for token [\" + token + \"]\");\n        }\n        AuthenticationInfo info;\n        try {\n            info = doAuthenticate(token);\n            if (info == null) {\n                String msg = \"No account information found for authentication token [\" + token + \"] by this \" + \"Authenticator instance.  Please check that it is configured correctly.\";\n                throw new AuthenticationException(msg);\n            }\n        } catch (Throwable t) {\n            AuthenticationException ae = null;\n            if (t instanceof AuthenticationException) {\n                ae = (AuthenticationException) t;\n            }\n            if (ae == null) {\n                //Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more\n                //severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:\n                String msg = \"Authentication failed for token submission [\" + token + \"].  Possible unexpected \" + \"error? (Typical or expected login exceptions should extend from AuthenticationException).\";\n                ae = new AuthenticationException(msg, t);\n                if (log.isWarnEnabled()) {\n                    log.warn(msg, t);\n                }\n            }\n            try {\n                notifyFailure(token, ae);\n            } catch (Throwable t2) {\n                String msg = \"Unable to send notification for failed authentication attempt - listener error?.  \" + \"Please check your AuthenticationListener implementation(s).  Logging sending exception and \" + \"propagating original AuthenticationException instead...\";\n                if (log.isWarnEnabled()) {\n                    log.warn(msg, t2);\n                }\n            }\n            throw ae;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authentication successful for token [\" + token + \"].  Returned account: [\" + info + \"]\");\n        }\n        notifySuccess(token, info);\n        return info;\n    }\n\n    /**\n     * Template design pattern hook for subclasses to implement specific authentication behavior.\n     *\n     * <p>Common behavior for most authentication attempts is encapsulated in the\n     * {@link #authenticate} method and that method invokes this one for custom behavior.\n     *\n     * <p><b>N.B.</b> Subclasses <em>should</em> throw some kind of\n     * <tt>AuthenticationException</tt> if there is a problem during\n     * authentication instead of returning <tt>null</tt>.  A <tt>null</tt> return value indicates\n     * a configuration or programming error, since <tt>AuthenticationException</tt>s should\n     * indicate any expected problem (such as an unknown account or username, or invalid password, etc).\n     *\n     * @param token the authentication token encapsulating the user's login information.\n     * @return an <tt>AuthenticationInfo</tt> object encapsulating the user's account information\n     *         important to JSecurity.\n     * @throws AuthenticationException if there is a problem logging in the user.\n     */\n    protected abstract AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/AbstractAuthenticatorTest1.java",
		"test_prompt": "// AbstractAuthenticatorTest1.java\npackage org.jsecurity.authc;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticator}.\n* It contains ten unit test cases for the {@link AbstractAuthenticator#authenticate(AuthenticationToken)} method.\n*/\nclass AbstractAuthenticatorTest1 {"
	},
	{
		"original_code": "// SimpleAccount.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential and authorization information (roles and permissions) as instance variables and\n * exposes them via getters and setters using standard JavaBean notation.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccount implements Account, MergableAuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The authentication information (principals and credentials) for this account.\n     */\n    private SimpleAuthenticationInfo authcInfo;\n\n    /**\n     * The authorization information for this account.\n     */\n    private SimpleAuthorizationInfo authzInfo;\n\n    /**\n     * Indicates this account is locked.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean locked;\n\n    /**\n     * Indicates credentials on this account are expired.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean credentialsExpired;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAccount() {\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     *\n     * @param principal the 'primary' identifying attribute of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName) {\n        this(principal instanceof PrincipalCollection ? (PrincipalCollection) principal : new SimplePrincipalCollection(principal, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName) {\n        this(new SimplePrincipalCollection(principals, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo();\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials, with the assigned roles.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roles the names of the roles assigned to this account.\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roles) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roles);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principal and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principal the 'primary' identifying attributes of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principal, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principals, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance from the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually  the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     *\n     * @return all the principals, aka the identifying attributes, of this Account.\n     */\n    public PrincipalCollection getPrincipals() {\n        return authcInfo.getPrincipals();\n    }\n\n    /**\n     * Sets the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     * @param principals all the principals, aka the identifying attributes, of this Account.\n     * @see Account#getPrincipals()\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.authcInfo.setPrincipals(principals);\n    }\n\n    /**\n     * Simply returns <code>this.authcInfo.getCredentials</code>.  The <code>authcInfo</code> attribute is constructed\n     * via the constructors to wrap the input arguments.\n     *\n     * @return this Account's credentials.\n     */\n    public Object getCredentials() {\n        return authcInfo.getCredentials();\n    }\n\n    /**\n     * Sets this Account's credentials that verify one or more of the Account's\n     * {@link #getPrincipals() principals}, such as a password or private key.\n     *\n     * @param credentials the credentials associated with this Account that verify one or more of the Account principals.\n     * @see Account#getCredentials()\n     */\n    public void setCredentials(Object credentials) {\n        this.authcInfo.setCredentials(credentials);\n    }\n\n    /**\n     * Returns <code>this.authzInfo.getRoles();</code>\n     * @return the Account's assigned roles.\n     */\n    public Collection<String> getRoles() {\n        return authzInfo.getRoles();\n    }\n\n    /**\n     * Sets the Account's assigned roles.  Simply calls <code>this.authzInfo.setRoles(roles)</code>.\n     *\n     * @param roles the Account's assigned roles.\n     * @see Account#getRoles()\n     */\n    public void setRoles(Set<String> roles) {\n        this.authzInfo.setRoles(roles);\n    }\n\n    /**\n     * Adds a role to this Account's set of assigned roles.  Simply delegates to\n     * <code>this.authzInfo.addRole(role)</code>.\n     *\n     * @param role a role to assign to this Account.\n     */\n    public void addRole(String role) {\n        this.authzInfo.addRole(role);\n    }\n\n    /**\n     * Adds one or more roles to this Account's set of assigned roles. Simply delegates to\n     * <code>this.authzInfo.addRoles(roles)</code>.\n     *\n     * @param roles one or more roles to assign to this Account.\n     */\n    public void addRole(Collection<String> roles) {\n        this.authzInfo.addRoles(roles);\n    }\n\n    /**\n     * Returns all String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.getStringPermissions()</code>.\n     * @return all String-based permissions assigned to this Account.\n     */\n    public Collection<String> getStringPermissions() {\n        return authzInfo.getStringPermissions();\n    }\n\n    /**\n     * Sets the String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.setStringPermissions(permissions)</code>.\n     * @param permissions all String-based permissions assigned to this Account.\n     * @see Account#getStringPermissions()\n     */\n    public void setStringPermissions(Set<String> permissions) {\n        this.authzInfo.setStringPermissions(permissions);\n    }\n\n    /**\n     * Assigns a String-based permission directly to this Account (not to any of its realms).\n     * @param permission the String-based permission to assign.\n     */\n    public void addStringPermission(String permission) {\n        this.authzInfo.addStringPermission(permission);\n    }\n\n    /**\n     * Assigns one or more string-based permissions directly to this Account (not to any of its realms).\n     * @param permissions one or more String-based permissions to assign.\n     */\n    public void addStringPermissions(Collection<String> permissions) {\n        this.authzInfo.addStringPermissions(permissions);\n    }\n\n    /**\n     * Returns all object-based permissions assigned directly to this Account (not any of its realms).\n     * @return all object-based permissions assigned directly to this Account (not any of its realms).\n     */\n    public Collection<Permission> getObjectPermissions() {\n        return authzInfo.getObjectPermissions();\n    }\n\n    /**\n     * Sets all object-based permissions assigned directly to this Account (not any of its realms).\n     * @param permissions the object-based permissions to assign directly to this Account.\n     */\n    public void setObjectPermissions(Set<Permission> permissions) {\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Assigns an object-based permission directly to this Account (not any of its realms).\n     * @param permission the object-based permission to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermission(Permission permission) {\n        this.authzInfo.addObjectPermission(permission);\n    }\n\n    /**\n     * Assigns one or more object-based permissions directly to this Account (not any of its realms).\n     * @param permissions one or more object-based permissions to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermissions(Collection<Permission> permissions) {\n        this.authzInfo.addObjectPermissions(permissions);\n    }\n\n    /**\n     * Returns <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     * @return <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Sets whether or not the account is locked and can be used to login.\n     * @param locked <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    /**\n     * Returns whether or not the Account's credentials are expired.  This usually indicates that the Subject or an application\n     * administrator would need to change the credentials before the account could be used.\n     * @return whether or not the Account's credentials are expired.\n     */\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    /**\n     * Sets whether or not the Account's credentials are expired.  A <code>true</code> value indicates that the Subject\n     * or application administrator would need to change their credentials before the account could be used.\n     * @param credentialsExpired <code>true</code> if this Account's credentials are expired and need to be changed,\n     * <code>false</code> otherwise.\n     */\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /**\n     * Merges the specified <code>AuthenticationInfo</code> into this <code>Account</code>.\n     * <p/>\n     * If the specified argument is also an instance of {@link SimpleAccount SimpleAccount}, the\n     * {@link #isLocked()} and {@link #isCredentialsExpired()} attributes are merged (set on this instance) as well\n     * (only if their values are <code>true</code>).\n     *\n     * @param info the <code>AuthenticationInfo</code> to merge into this account.\n     */\n    public void merge(AuthenticationInfo info) {\n        authcInfo.merge(info);\n        // Merge SimpleAccount specific info\n        if (info instanceof SimpleAccount) {\n            SimpleAccount otherAccount = (SimpleAccount) info;\n            if (otherAccount.isLocked()) {\n                setLocked(true);\n            }\n            if (otherAccount.isCredentialsExpired()) {\n                setCredentialsExpired(true);\n            }\n        }\n    }\n\n    /**\n     * If the {@link #getPrincipals() principals} are not null, returns <code>principals.hashCode()</code>, otherwise\n     * returns 0 (zero).\n     * @return <code>principals.hashCode()</code> if they are not null, 0 (zero) otherwise.\n     */\n    public int hashCode() {\n        return (getPrincipals() != null ? getPrincipals().hashCode() : 0);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     * @param o the object to test for equality.\n     * @return <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipals() != null ? getPrincipals().equals(sa.getPrincipals()) : sa.getPrincipals() == null);\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@link #getPrincipals() principals}.toString() if they are not null, otherwise prints out the string\n     * &quot;empty&quot;\n     * @return the String representation of this Account object.\n     */\n    public String toString() {\n        return getPrincipals() != null ? getPrincipals().toString() : \"empty\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAccountTest0.java",
		"test_prompt": "// SimpleAccountTest0.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccount}.\n* It contains ten unit test cases for the {@link SimpleAccount#isLocked()} method.\n*/\nclass SimpleAccountTest0 {"
	},
	{
		"original_code": "// SimpleAccount.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential and authorization information (roles and permissions) as instance variables and\n * exposes them via getters and setters using standard JavaBean notation.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccount implements Account, MergableAuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The authentication information (principals and credentials) for this account.\n     */\n    private SimpleAuthenticationInfo authcInfo;\n\n    /**\n     * The authorization information for this account.\n     */\n    private SimpleAuthorizationInfo authzInfo;\n\n    /**\n     * Indicates this account is locked.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean locked;\n\n    /**\n     * Indicates credentials on this account are expired.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean credentialsExpired;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAccount() {\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     *\n     * @param principal the 'primary' identifying attribute of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName) {\n        this(principal instanceof PrincipalCollection ? (PrincipalCollection) principal : new SimplePrincipalCollection(principal, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName) {\n        this(new SimplePrincipalCollection(principals, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo();\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials, with the assigned roles.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roles the names of the roles assigned to this account.\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roles) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roles);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principal and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principal the 'primary' identifying attributes of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principal, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principals, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance from the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually  the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     *\n     * @return all the principals, aka the identifying attributes, of this Account.\n     */\n    public PrincipalCollection getPrincipals() {\n        return authcInfo.getPrincipals();\n    }\n\n    /**\n     * Sets the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     * @param principals all the principals, aka the identifying attributes, of this Account.\n     * @see Account#getPrincipals()\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.authcInfo.setPrincipals(principals);\n    }\n\n    /**\n     * Simply returns <code>this.authcInfo.getCredentials</code>.  The <code>authcInfo</code> attribute is constructed\n     * via the constructors to wrap the input arguments.\n     *\n     * @return this Account's credentials.\n     */\n    public Object getCredentials() {\n        return authcInfo.getCredentials();\n    }\n\n    /**\n     * Sets this Account's credentials that verify one or more of the Account's\n     * {@link #getPrincipals() principals}, such as a password or private key.\n     *\n     * @param credentials the credentials associated with this Account that verify one or more of the Account principals.\n     * @see Account#getCredentials()\n     */\n    public void setCredentials(Object credentials) {\n        this.authcInfo.setCredentials(credentials);\n    }\n\n    /**\n     * Returns <code>this.authzInfo.getRoles();</code>\n     * @return the Account's assigned roles.\n     */\n    public Collection<String> getRoles() {\n        return authzInfo.getRoles();\n    }\n\n    /**\n     * Sets the Account's assigned roles.  Simply calls <code>this.authzInfo.setRoles(roles)</code>.\n     *\n     * @param roles the Account's assigned roles.\n     * @see Account#getRoles()\n     */\n    public void setRoles(Set<String> roles) {\n        this.authzInfo.setRoles(roles);\n    }\n\n    /**\n     * Adds a role to this Account's set of assigned roles.  Simply delegates to\n     * <code>this.authzInfo.addRole(role)</code>.\n     *\n     * @param role a role to assign to this Account.\n     */\n    public void addRole(String role) {\n        this.authzInfo.addRole(role);\n    }\n\n    /**\n     * Adds one or more roles to this Account's set of assigned roles. Simply delegates to\n     * <code>this.authzInfo.addRoles(roles)</code>.\n     *\n     * @param roles one or more roles to assign to this Account.\n     */\n    public void addRole(Collection<String> roles) {\n        this.authzInfo.addRoles(roles);\n    }\n\n    /**\n     * Returns all String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.getStringPermissions()</code>.\n     * @return all String-based permissions assigned to this Account.\n     */\n    public Collection<String> getStringPermissions() {\n        return authzInfo.getStringPermissions();\n    }\n\n    /**\n     * Sets the String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.setStringPermissions(permissions)</code>.\n     * @param permissions all String-based permissions assigned to this Account.\n     * @see Account#getStringPermissions()\n     */\n    public void setStringPermissions(Set<String> permissions) {\n        this.authzInfo.setStringPermissions(permissions);\n    }\n\n    /**\n     * Assigns a String-based permission directly to this Account (not to any of its realms).\n     * @param permission the String-based permission to assign.\n     */\n    public void addStringPermission(String permission) {\n        this.authzInfo.addStringPermission(permission);\n    }\n\n    /**\n     * Assigns one or more string-based permissions directly to this Account (not to any of its realms).\n     * @param permissions one or more String-based permissions to assign.\n     */\n    public void addStringPermissions(Collection<String> permissions) {\n        this.authzInfo.addStringPermissions(permissions);\n    }\n\n    /**\n     * Returns all object-based permissions assigned directly to this Account (not any of its realms).\n     * @return all object-based permissions assigned directly to this Account (not any of its realms).\n     */\n    public Collection<Permission> getObjectPermissions() {\n        return authzInfo.getObjectPermissions();\n    }\n\n    /**\n     * Sets all object-based permissions assigned directly to this Account (not any of its realms).\n     * @param permissions the object-based permissions to assign directly to this Account.\n     */\n    public void setObjectPermissions(Set<Permission> permissions) {\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Assigns an object-based permission directly to this Account (not any of its realms).\n     * @param permission the object-based permission to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermission(Permission permission) {\n        this.authzInfo.addObjectPermission(permission);\n    }\n\n    /**\n     * Assigns one or more object-based permissions directly to this Account (not any of its realms).\n     * @param permissions one or more object-based permissions to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermissions(Collection<Permission> permissions) {\n        this.authzInfo.addObjectPermissions(permissions);\n    }\n\n    /**\n     * Returns <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     * @return <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Sets whether or not the account is locked and can be used to login.\n     * @param locked <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    /**\n     * Returns whether or not the Account's credentials are expired.  This usually indicates that the Subject or an application\n     * administrator would need to change the credentials before the account could be used.\n     * @return whether or not the Account's credentials are expired.\n     */\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    /**\n     * Sets whether or not the Account's credentials are expired.  A <code>true</code> value indicates that the Subject\n     * or application administrator would need to change their credentials before the account could be used.\n     * @param credentialsExpired <code>true</code> if this Account's credentials are expired and need to be changed,\n     * <code>false</code> otherwise.\n     */\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /**\n     * Merges the specified <code>AuthenticationInfo</code> into this <code>Account</code>.\n     * <p/>\n     * If the specified argument is also an instance of {@link SimpleAccount SimpleAccount}, the\n     * {@link #isLocked()} and {@link #isCredentialsExpired()} attributes are merged (set on this instance) as well\n     * (only if their values are <code>true</code>).\n     *\n     * @param info the <code>AuthenticationInfo</code> to merge into this account.\n     */\n    public void merge(AuthenticationInfo info) {\n        authcInfo.merge(info);\n        // Merge SimpleAccount specific info\n        if (info instanceof SimpleAccount) {\n            SimpleAccount otherAccount = (SimpleAccount) info;\n            if (otherAccount.isLocked()) {\n                setLocked(true);\n            }\n            if (otherAccount.isCredentialsExpired()) {\n                setCredentialsExpired(true);\n            }\n        }\n    }\n\n    /**\n     * If the {@link #getPrincipals() principals} are not null, returns <code>principals.hashCode()</code>, otherwise\n     * returns 0 (zero).\n     * @return <code>principals.hashCode()</code> if they are not null, 0 (zero) otherwise.\n     */\n    public int hashCode() {\n        return (getPrincipals() != null ? getPrincipals().hashCode() : 0);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     * @param o the object to test for equality.\n     * @return <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipals() != null ? getPrincipals().equals(sa.getPrincipals()) : sa.getPrincipals() == null);\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@link #getPrincipals() principals}.toString() if they are not null, otherwise prints out the string\n     * &quot;empty&quot;\n     * @return the String representation of this Account object.\n     */\n    public String toString() {\n        return getPrincipals() != null ? getPrincipals().toString() : \"empty\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAccountTest1.java",
		"test_prompt": "// SimpleAccountTest1.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccount}.\n* It contains ten unit test cases for the {@link SimpleAccount#isCredentialsExpired()} method.\n*/\nclass SimpleAccountTest1 {"
	},
	{
		"original_code": "// SimpleAccount.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential and authorization information (roles and permissions) as instance variables and\n * exposes them via getters and setters using standard JavaBean notation.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccount implements Account, MergableAuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The authentication information (principals and credentials) for this account.\n     */\n    private SimpleAuthenticationInfo authcInfo;\n\n    /**\n     * The authorization information for this account.\n     */\n    private SimpleAuthorizationInfo authzInfo;\n\n    /**\n     * Indicates this account is locked.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean locked;\n\n    /**\n     * Indicates credentials on this account are expired.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean credentialsExpired;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAccount() {\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     *\n     * @param principal the 'primary' identifying attribute of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName) {\n        this(principal instanceof PrincipalCollection ? (PrincipalCollection) principal : new SimplePrincipalCollection(principal, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName) {\n        this(new SimplePrincipalCollection(principals, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo();\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials, with the assigned roles.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roles the names of the roles assigned to this account.\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roles) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roles);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principal and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principal the 'primary' identifying attributes of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principal, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principals, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance from the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually  the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     *\n     * @return all the principals, aka the identifying attributes, of this Account.\n     */\n    public PrincipalCollection getPrincipals() {\n        return authcInfo.getPrincipals();\n    }\n\n    /**\n     * Sets the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     * @param principals all the principals, aka the identifying attributes, of this Account.\n     * @see Account#getPrincipals()\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.authcInfo.setPrincipals(principals);\n    }\n\n    /**\n     * Simply returns <code>this.authcInfo.getCredentials</code>.  The <code>authcInfo</code> attribute is constructed\n     * via the constructors to wrap the input arguments.\n     *\n     * @return this Account's credentials.\n     */\n    public Object getCredentials() {\n        return authcInfo.getCredentials();\n    }\n\n    /**\n     * Sets this Account's credentials that verify one or more of the Account's\n     * {@link #getPrincipals() principals}, such as a password or private key.\n     *\n     * @param credentials the credentials associated with this Account that verify one or more of the Account principals.\n     * @see Account#getCredentials()\n     */\n    public void setCredentials(Object credentials) {\n        this.authcInfo.setCredentials(credentials);\n    }\n\n    /**\n     * Returns <code>this.authzInfo.getRoles();</code>\n     * @return the Account's assigned roles.\n     */\n    public Collection<String> getRoles() {\n        return authzInfo.getRoles();\n    }\n\n    /**\n     * Sets the Account's assigned roles.  Simply calls <code>this.authzInfo.setRoles(roles)</code>.\n     *\n     * @param roles the Account's assigned roles.\n     * @see Account#getRoles()\n     */\n    public void setRoles(Set<String> roles) {\n        this.authzInfo.setRoles(roles);\n    }\n\n    /**\n     * Adds a role to this Account's set of assigned roles.  Simply delegates to\n     * <code>this.authzInfo.addRole(role)</code>.\n     *\n     * @param role a role to assign to this Account.\n     */\n    public void addRole(String role) {\n        this.authzInfo.addRole(role);\n    }\n\n    /**\n     * Adds one or more roles to this Account's set of assigned roles. Simply delegates to\n     * <code>this.authzInfo.addRoles(roles)</code>.\n     *\n     * @param roles one or more roles to assign to this Account.\n     */\n    public void addRole(Collection<String> roles) {\n        this.authzInfo.addRoles(roles);\n    }\n\n    /**\n     * Returns all String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.getStringPermissions()</code>.\n     * @return all String-based permissions assigned to this Account.\n     */\n    public Collection<String> getStringPermissions() {\n        return authzInfo.getStringPermissions();\n    }\n\n    /**\n     * Sets the String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.setStringPermissions(permissions)</code>.\n     * @param permissions all String-based permissions assigned to this Account.\n     * @see Account#getStringPermissions()\n     */\n    public void setStringPermissions(Set<String> permissions) {\n        this.authzInfo.setStringPermissions(permissions);\n    }\n\n    /**\n     * Assigns a String-based permission directly to this Account (not to any of its realms).\n     * @param permission the String-based permission to assign.\n     */\n    public void addStringPermission(String permission) {\n        this.authzInfo.addStringPermission(permission);\n    }\n\n    /**\n     * Assigns one or more string-based permissions directly to this Account (not to any of its realms).\n     * @param permissions one or more String-based permissions to assign.\n     */\n    public void addStringPermissions(Collection<String> permissions) {\n        this.authzInfo.addStringPermissions(permissions);\n    }\n\n    /**\n     * Returns all object-based permissions assigned directly to this Account (not any of its realms).\n     * @return all object-based permissions assigned directly to this Account (not any of its realms).\n     */\n    public Collection<Permission> getObjectPermissions() {\n        return authzInfo.getObjectPermissions();\n    }\n\n    /**\n     * Sets all object-based permissions assigned directly to this Account (not any of its realms).\n     * @param permissions the object-based permissions to assign directly to this Account.\n     */\n    public void setObjectPermissions(Set<Permission> permissions) {\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Assigns an object-based permission directly to this Account (not any of its realms).\n     * @param permission the object-based permission to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermission(Permission permission) {\n        this.authzInfo.addObjectPermission(permission);\n    }\n\n    /**\n     * Assigns one or more object-based permissions directly to this Account (not any of its realms).\n     * @param permissions one or more object-based permissions to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermissions(Collection<Permission> permissions) {\n        this.authzInfo.addObjectPermissions(permissions);\n    }\n\n    /**\n     * Returns <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     * @return <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Sets whether or not the account is locked and can be used to login.\n     * @param locked <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    /**\n     * Returns whether or not the Account's credentials are expired.  This usually indicates that the Subject or an application\n     * administrator would need to change the credentials before the account could be used.\n     * @return whether or not the Account's credentials are expired.\n     */\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    /**\n     * Sets whether or not the Account's credentials are expired.  A <code>true</code> value indicates that the Subject\n     * or application administrator would need to change their credentials before the account could be used.\n     * @param credentialsExpired <code>true</code> if this Account's credentials are expired and need to be changed,\n     * <code>false</code> otherwise.\n     */\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /**\n     * Merges the specified <code>AuthenticationInfo</code> into this <code>Account</code>.\n     * <p/>\n     * If the specified argument is also an instance of {@link SimpleAccount SimpleAccount}, the\n     * {@link #isLocked()} and {@link #isCredentialsExpired()} attributes are merged (set on this instance) as well\n     * (only if their values are <code>true</code>).\n     *\n     * @param info the <code>AuthenticationInfo</code> to merge into this account.\n     */\n    public void merge(AuthenticationInfo info) {\n        authcInfo.merge(info);\n        // Merge SimpleAccount specific info\n        if (info instanceof SimpleAccount) {\n            SimpleAccount otherAccount = (SimpleAccount) info;\n            if (otherAccount.isLocked()) {\n                setLocked(true);\n            }\n            if (otherAccount.isCredentialsExpired()) {\n                setCredentialsExpired(true);\n            }\n        }\n    }\n\n    /**\n     * If the {@link #getPrincipals() principals} are not null, returns <code>principals.hashCode()</code>, otherwise\n     * returns 0 (zero).\n     * @return <code>principals.hashCode()</code> if they are not null, 0 (zero) otherwise.\n     */\n    public int hashCode() {\n        return (getPrincipals() != null ? getPrincipals().hashCode() : 0);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     * @param o the object to test for equality.\n     * @return <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipals() != null ? getPrincipals().equals(sa.getPrincipals()) : sa.getPrincipals() == null);\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@link #getPrincipals() principals}.toString() if they are not null, otherwise prints out the string\n     * &quot;empty&quot;\n     * @return the String representation of this Account object.\n     */\n    public String toString() {\n        return getPrincipals() != null ? getPrincipals().toString() : \"empty\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAccountTest2.java",
		"test_prompt": "// SimpleAccountTest2.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccount}.\n* It contains ten unit test cases for the {@link SimpleAccount#hashCode()} method.\n*/\nclass SimpleAccountTest2 {"
	},
	{
		"original_code": "// SimpleAccount.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\n\n/**\n * Simple implementation of the {@link org.jsecurity.authc.Account} interface that\n * contains principal and credential and authorization information (roles and permissions) as instance variables and\n * exposes them via getters and setters using standard JavaBean notation.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccount implements Account, MergableAuthenticationInfo, Serializable {\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The authentication information (principals and credentials) for this account.\n     */\n    private SimpleAuthenticationInfo authcInfo;\n\n    /**\n     * The authorization information for this account.\n     */\n    private SimpleAuthorizationInfo authzInfo;\n\n    /**\n     * Indicates this account is locked.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean locked;\n\n    /**\n     * Indicates credentials on this account are expired.  This isn't honored by all <tt>Realms</tt> but is honored by\n     * {@link org.jsecurity.realm.SimpleAccountRealm}.\n     */\n    private boolean credentialsExpired;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default no-argument constructor.\n     */\n    public SimpleAccount() {\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     *\n     * @param principal the 'primary' identifying attribute of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName) {\n        this(principal instanceof PrincipalCollection ? (PrincipalCollection) principal : new SimplePrincipalCollection(principal, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName) {\n        this(new SimplePrincipalCollection(principals, realmName), credentials);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials.\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo();\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified principals and credentials, with the assigned roles.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roles the names of the roles assigned to this account.\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roles) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roles);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principal and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principal the 'primary' identifying attributes of the account, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principal, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance for the specified realm with the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param realmName the name of the realm that accesses this account data\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(new SimplePrincipalCollection(principals, realmName), credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Constructs a SimpleAccount instance from the given principals and credentials, with the\n     * the assigned roles and permissions.\n     *\n     * @param principals the identifying attributes of the account, at least one of which should be considered the\n     * account's 'primary' identifying attribute, for example, a user id or username.\n     * @param credentials the credentials that verify identity for the account\n     * @param roleNames the names of the roles assigned to this account.\n     * @param permissions the permissions assigned to this account directly (not those assigned to any of the realms).\n     */\n    public SimpleAccount(PrincipalCollection principals, Object credentials, Set<String> roleNames, Set<Permission> permissions) {\n        this.authcInfo = new SimpleAuthenticationInfo(principals, credentials);\n        this.authzInfo = new SimpleAuthorizationInfo(roleNames);\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually  the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     *\n     * @return all the principals, aka the identifying attributes, of this Account.\n     */\n    public PrincipalCollection getPrincipals() {\n        return authcInfo.getPrincipals();\n    }\n\n    /**\n     * Sets the principals, aka the identifying attributes (username, user id, first name, last name, etc) of this\n     * Account.\n     * <p/>\n     * At least one of these attributes should be the account's 'primary' identifier, such as a username or unique\n     * user id.  By convention, usually the first principal (that is, <code>principals.iterator().next()</code>) is the\n     * 'primary' one.\n     * @param principals all the principals, aka the identifying attributes, of this Account.\n     * @see Account#getPrincipals()\n     */\n    public void setPrincipals(PrincipalCollection principals) {\n        this.authcInfo.setPrincipals(principals);\n    }\n\n    /**\n     * Simply returns <code>this.authcInfo.getCredentials</code>.  The <code>authcInfo</code> attribute is constructed\n     * via the constructors to wrap the input arguments.\n     *\n     * @return this Account's credentials.\n     */\n    public Object getCredentials() {\n        return authcInfo.getCredentials();\n    }\n\n    /**\n     * Sets this Account's credentials that verify one or more of the Account's\n     * {@link #getPrincipals() principals}, such as a password or private key.\n     *\n     * @param credentials the credentials associated with this Account that verify one or more of the Account principals.\n     * @see Account#getCredentials()\n     */\n    public void setCredentials(Object credentials) {\n        this.authcInfo.setCredentials(credentials);\n    }\n\n    /**\n     * Returns <code>this.authzInfo.getRoles();</code>\n     * @return the Account's assigned roles.\n     */\n    public Collection<String> getRoles() {\n        return authzInfo.getRoles();\n    }\n\n    /**\n     * Sets the Account's assigned roles.  Simply calls <code>this.authzInfo.setRoles(roles)</code>.\n     *\n     * @param roles the Account's assigned roles.\n     * @see Account#getRoles()\n     */\n    public void setRoles(Set<String> roles) {\n        this.authzInfo.setRoles(roles);\n    }\n\n    /**\n     * Adds a role to this Account's set of assigned roles.  Simply delegates to\n     * <code>this.authzInfo.addRole(role)</code>.\n     *\n     * @param role a role to assign to this Account.\n     */\n    public void addRole(String role) {\n        this.authzInfo.addRole(role);\n    }\n\n    /**\n     * Adds one or more roles to this Account's set of assigned roles. Simply delegates to\n     * <code>this.authzInfo.addRoles(roles)</code>.\n     *\n     * @param roles one or more roles to assign to this Account.\n     */\n    public void addRole(Collection<String> roles) {\n        this.authzInfo.addRoles(roles);\n    }\n\n    /**\n     * Returns all String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.getStringPermissions()</code>.\n     * @return all String-based permissions assigned to this Account.\n     */\n    public Collection<String> getStringPermissions() {\n        return authzInfo.getStringPermissions();\n    }\n\n    /**\n     * Sets the String-based permissions assigned to this Account.  Simply delegates to\n     * <code>this.authzInfo.setStringPermissions(permissions)</code>.\n     * @param permissions all String-based permissions assigned to this Account.\n     * @see Account#getStringPermissions()\n     */\n    public void setStringPermissions(Set<String> permissions) {\n        this.authzInfo.setStringPermissions(permissions);\n    }\n\n    /**\n     * Assigns a String-based permission directly to this Account (not to any of its realms).\n     * @param permission the String-based permission to assign.\n     */\n    public void addStringPermission(String permission) {\n        this.authzInfo.addStringPermission(permission);\n    }\n\n    /**\n     * Assigns one or more string-based permissions directly to this Account (not to any of its realms).\n     * @param permissions one or more String-based permissions to assign.\n     */\n    public void addStringPermissions(Collection<String> permissions) {\n        this.authzInfo.addStringPermissions(permissions);\n    }\n\n    /**\n     * Returns all object-based permissions assigned directly to this Account (not any of its realms).\n     * @return all object-based permissions assigned directly to this Account (not any of its realms).\n     */\n    public Collection<Permission> getObjectPermissions() {\n        return authzInfo.getObjectPermissions();\n    }\n\n    /**\n     * Sets all object-based permissions assigned directly to this Account (not any of its realms).\n     * @param permissions the object-based permissions to assign directly to this Account.\n     */\n    public void setObjectPermissions(Set<Permission> permissions) {\n        this.authzInfo.setObjectPermissions(permissions);\n    }\n\n    /**\n     * Assigns an object-based permission directly to this Account (not any of its realms).\n     * @param permission the object-based permission to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermission(Permission permission) {\n        this.authzInfo.addObjectPermission(permission);\n    }\n\n    /**\n     * Assigns one or more object-based permissions directly to this Account (not any of its realms).\n     * @param permissions one or more object-based permissions to assign directly to this Account (not any of its realms).\n     */\n    public void addObjectPermissions(Collection<Permission> permissions) {\n        this.authzInfo.addObjectPermissions(permissions);\n    }\n\n    /**\n     * Returns <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     * @return <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public boolean isLocked() {\n        return locked;\n    }\n\n    /**\n     * Sets whether or not the account is locked and can be used to login.\n     * @param locked <code>true</code> if this Account is locked and thus cannot be used to login, <code>false</code> otherwise.\n     */\n    public void setLocked(boolean locked) {\n        this.locked = locked;\n    }\n\n    /**\n     * Returns whether or not the Account's credentials are expired.  This usually indicates that the Subject or an application\n     * administrator would need to change the credentials before the account could be used.\n     * @return whether or not the Account's credentials are expired.\n     */\n    public boolean isCredentialsExpired() {\n        return credentialsExpired;\n    }\n\n    /**\n     * Sets whether or not the Account's credentials are expired.  A <code>true</code> value indicates that the Subject\n     * or application administrator would need to change their credentials before the account could be used.\n     * @param credentialsExpired <code>true</code> if this Account's credentials are expired and need to be changed,\n     * <code>false</code> otherwise.\n     */\n    public void setCredentialsExpired(boolean credentialsExpired) {\n        this.credentialsExpired = credentialsExpired;\n    }\n\n    /**\n     * Merges the specified <code>AuthenticationInfo</code> into this <code>Account</code>.\n     * <p/>\n     * If the specified argument is also an instance of {@link SimpleAccount SimpleAccount}, the\n     * {@link #isLocked()} and {@link #isCredentialsExpired()} attributes are merged (set on this instance) as well\n     * (only if their values are <code>true</code>).\n     *\n     * @param info the <code>AuthenticationInfo</code> to merge into this account.\n     */\n    public void merge(AuthenticationInfo info) {\n        authcInfo.merge(info);\n        // Merge SimpleAccount specific info\n        if (info instanceof SimpleAccount) {\n            SimpleAccount otherAccount = (SimpleAccount) info;\n            if (otherAccount.isLocked()) {\n                setLocked(true);\n            }\n            if (otherAccount.isCredentialsExpired()) {\n                setCredentialsExpired(true);\n            }\n        }\n    }\n\n    /**\n     * If the {@link #getPrincipals() principals} are not null, returns <code>principals.hashCode()</code>, otherwise\n     * returns 0 (zero).\n     * @return <code>principals.hashCode()</code> if they are not null, 0 (zero) otherwise.\n     */\n    public int hashCode() {\n        return (getPrincipals() != null ? getPrincipals().hashCode() : 0);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     * @param o the object to test for equality.\n     * @return <code>true</code> if the specified object is also a {@link SimpleAccount SimpleAccount} and its\n     * {@link #getPrincipals() principals} are equal to this object's <code>principals</code>, <code>false</code> otherwise.\n     */\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleAccount) {\n            SimpleAccount sa = (SimpleAccount) o;\n            //principal should be unique across the application, so only check this for equality:\n            return (getPrincipals() != null ? getPrincipals().equals(sa.getPrincipals()) : sa.getPrincipals() == null);\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@link #getPrincipals() principals}.toString() if they are not null, otherwise prints out the string\n     * &quot;empty&quot;\n     * @return the String representation of this Account object.\n     */\n    public String toString() {\n        return getPrincipals() != null ? getPrincipals().toString() : \"empty\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/SimpleAccountTest3.java",
		"test_prompt": "// SimpleAccountTest3.java\npackage org.jsecurity.authc;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.SimpleAuthorizationInfo;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.SimplePrincipalCollection;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccount}.\n* It contains ten unit test cases for the {@link SimpleAccount#equals(Object)} method.\n*/\nclass SimpleAccountTest3 {"
	},
	{
		"original_code": "// UsernamePasswordToken.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc;\n\nimport java.net.InetAddress;\n\n/**\n * <p>A simple username/password authentication token to support the most widely-used authentication mechanism.  This\n * class also implements the {@link RememberMeAuthenticationToken RememberMeAuthenticationToken} interface to support\n * &quot;Remember Me&quot; services across user sessions as well as the\n * {@link InetAuthenticationToken InetAuthenticationToken} interface to retain the IP address location from where the\n * authentication attempt is occuring.</p>\n *\n * <p>&quot;Remember Me&quot; authentications are disabled by default, but if the application developer wishes to allow\n * it for a login attempt, all that is necessary is to call {@link #setRememberMe setRememberMe(true)}.  If the underlying\n * <tt>SecurityManager</tt> implementation also supports <tt>RememberMe</tt> services, the user's identity will be\n * remembered across sessions.\n *\n * <p>Note that this class stores a password as a char[] instead of a String\n * (which may seem more logical).  This is because Strings are immutable and their\n * internal value cannot be overwritten - meaning even a nulled String instance might be accessible in memory at a later\n * time (e.g. memory dump).  This is not good for sensitive information such as passwords. For more information, see the\n * <a href=\"http://java.sun.com/j2se/1.5.0/docs/guide/security/jce/JCERefGuide.html#PBEEx\">\n * Java Cryptography Extension Reference Guide</a>.</p>\n *\n * <p>To avoid this possibility of later memory access, the application developer should always call\n * {@link #clear() clear()} after using the token to perform a login attempt.</p>\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class UsernamePasswordToken implements InetAuthenticationToken, RememberMeAuthenticationToken {\n\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The username\n     */\n    private String username;\n\n    /**\n     * The password, in char[] format\n     */\n    private char[] password;\n\n    /**\n     * Whether or not 'rememberMe' should be enabled for the corresponding login attempt;\n     * default is <code>false</code>\n     */\n    private boolean rememberMe = false;\n\n    /**\n     * The location from where the login attempt occurs, or <code>null</code> if not known or explicitly\n     * omitted.\n     */\n    private InetAddress inetAddress;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * JavaBeans compatible no-arg constructor.\n     */\n    public UsernamePasswordToken() {\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted\n     * during an authentication attempt, with a <tt>null</tt> {@link #getInetAddress() inetAddress} and a\n     * <tt>rememberMe</tt> default of <tt>false</tt>.\n     *\n     * @param username the username submitted for authentication\n     * @param password the password character array submitted for authentication\n     */\n    public UsernamePasswordToken(final String username, final char[] password) {\n        this(username, password, false, null);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted\n     * during an authentication attempt, with a <tt>null</tt> {@link #getInetAddress() inetAddress} and\n     * a <tt>rememberMe</tt> default of <tt>false</tt>\n     *\n     * <p>This is a convience constructor and maintains the password internally via a character\n     * array, i.e. <tt>password.toCharArray();</tt>.  Note that storing a password as a String\n     * in your code could have possible security implications as noted in the class JavaDoc.</p>\n     *\n     * @param username the username submitted for authentication\n     * @param password the password string submitted for authentication\n     */\n    public UsernamePasswordToken(final String username, final String password) {\n        this(username, password != null ? password.toCharArray() : null, false, null);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, the\n     * inetAddress from where the attempt is occurring, and a default <tt>rememberMe</tt> value of <tt>false</tt>\n     *\n     * @param username    the username submitted for authentication\n     * @param password    the password string submitted for authentication\n     * @param inetAddress the inetAddress from where the attempt is occuring\n     * @since 0.2\n     */\n    public UsernamePasswordToken(final String username, final char[] password, final InetAddress inetAddress) {\n        this(username, password, false, inetAddress);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, the\n     * inetAddress from where the attempt is occurring, and a default <tt>rememberMe</tt> value of <tt>false</tt>\n     *\n     * <p>This is a convience constructor and maintains the password internally via a character\n     * array, i.e. <tt>password.toCharArray();</tt>.  Note that storing a password as a String\n     * in your code could have possible security implications as noted in the class JavaDoc.</p>\n     *\n     * @param username    the username submitted for authentication\n     * @param password    the password string submitted for authentication\n     * @param inetAddress the inetAddress from where the attempt is occuring\n     * @since 0.2\n     */\n    public UsernamePasswordToken(final String username, final String password, final InetAddress inetAddress) {\n        this(username, password != null ? password.toCharArray() : null, false, inetAddress);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, as well as if the user\n     * wishes their identity to be remembered across sessions.\n     *\n     * @param username   the username submitted for authentication\n     * @param password   the password string submitted for authentication\n     * @param rememberMe if the user wishes their identity to be remembered across sessions\n     * @since 0.9\n     */\n    public UsernamePasswordToken(final String username, final char[] password, final boolean rememberMe) {\n        this(username, password, rememberMe, null);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, as well as if the user\n     * wishes their identity to be remembered across sessions.\n     *\n     * <p>This is a convience constructor and maintains the password internally via a character\n     * array, i.e. <tt>password.toCharArray();</tt>.  Note that storing a password as a String\n     * in your code could have possible security implications as noted in the class JavaDoc.</p>\n     *\n     * @param username   the username submitted for authentication\n     * @param password   the password string submitted for authentication\n     * @param rememberMe if the user wishes their identity to be remembered across sessions\n     * @since 0.9\n     */\n    public UsernamePasswordToken(final String username, final String password, final boolean rememberMe) {\n        this(username, password != null ? password.toCharArray() : null, rememberMe, null);\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, if the user\n     * wishes their identity to be remembered across sessions, and the inetAddress from where the attempt is ocurring.\n     *\n     * @param username    the username submitted for authentication\n     * @param password    the password character array submitted for authentication\n     * @param rememberMe  if the user wishes their identity to be remembered across sessions\n     * @param inetAddress the inetAddress from where the attempt is occuring\n     * @since 0.9\n     */\n    public UsernamePasswordToken(final String username, final char[] password, final boolean rememberMe, final InetAddress inetAddress) {\n        this.username = username;\n        this.password = password;\n        this.rememberMe = rememberMe;\n        this.inetAddress = inetAddress;\n    }\n\n    /**\n     * Constructs a new UsernamePasswordToken encapsulating the username and password submitted, if the user\n     * wishes their identity to be remembered across sessions, and the inetAddress from where the attempt is ocurring.\n     *\n     * <p>This is a convience constructor and maintains the password internally via a character\n     * array, i.e. <tt>password.toCharArray();</tt>.  Note that storing a password as a String\n     * in your code could have possible security implications as noted in the class JavaDoc.</p>\n     *\n     * @param username    the username submitted for authentication\n     * @param password    the password string submitted for authentication\n     * @param rememberMe  if the user wishes their identity to be remembered across sessions\n     * @param inetAddress the inetAddress from where the attempt is occuring\n     * @since 0.9\n     */\n    public UsernamePasswordToken(final String username, final String password, final boolean rememberMe, final InetAddress inetAddress) {\n        this(username, password != null ? password.toCharArray() : null, rememberMe, inetAddress);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the username submitted during an authentication attempt.\n     *\n     * @return the username submitted during an authentication attempt.\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * Sets the username for submission during an authentication attempt.\n     *\n     * @param username the username to be used for submission during an authentication attempt.\n     */\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    /**\n     * Returns the password submitted during an authentication attempt as a character array.\n     *\n     * @return the password submitted during an authentication attempt as a character array.\n     */\n    public char[] getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password for submission during an authentication attempt.\n     *\n     * @param password the password to be used for submission during an authentication attemp.\n     */\n    public void setPassword(char[] password) {\n        this.password = password;\n    }\n\n    /**\n     * Simply returns {@link #getUsername() getUsername()}.\n     *\n     * @return the {@link #getUsername() username}.\n     * @see org.jsecurity.authc.AuthenticationToken#getPrincipal()\n     */\n    public Object getPrincipal() {\n        return getUsername();\n    }\n\n    /**\n     * Returns the {@link #getPassword() password} char array.\n     *\n     * @return the {@link #getPassword() password} char array.\n     * @see org.jsecurity.authc.AuthenticationToken#getCredentials()\n     */\n    public Object getCredentials() {\n        return getPassword();\n    }\n\n    /**\n     * Returns the inetAddress from where the authentication attempt occurs.  May be <tt>null</tt> if the inetAddress\n     * is unknown or explicitly omitted.  It is up to the Authenticator implementation processing this token if\n     * an authentication attempt without an inetAddress is valid or not.\n     *\n     * <p>(JSecurity's default Authenticator\n     * allows <tt>null</tt> IPs to support localhost and proxy server environments).</p>\n     *\n     * @return the inetAddress from where the authentication attempt occurs, or <tt>null</tt> if it is unknown or\n     *         explicitly omitted.\n     * @since 0.2\n     */\n    public InetAddress getInetAddress() {\n        return inetAddress;\n    }\n\n    /**\n     * Sets the inetAddress from where the authentication attempt occurs.  It is up to the Authenticator\n     * implementation processing this token if an authentication attempt without an inetAddress is valid or not.\n     *\n     * <p>(JSecurity's default Authenticator\n     * allows <tt>null</tt> IPs to allow localhost and proxy server environments).</p>\n     *\n     * @param inetAddress the inetAddress from where the authentication attempt occurs.\n     * @since 0.2\n     */\n    public void setInetAddress(InetAddress inetAddress) {\n        this.inetAddress = inetAddress;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the submitting user wishes their identity (principal(s)) to be remembered\n     * across sessions, <tt>false</tt> otherwise.  Unless overridden, this value is <tt>false</tt> by default.\n     *\n     * @return <tt>true</tt> if the submitting user wishes their identity (principal(s)) to be remembered\n     *         across sessions, <tt>false</tt> otherwise (<tt>false</tt> by default).\n     * @since 0.9\n     */\n    public boolean isRememberMe() {\n        return rememberMe;\n    }\n\n    /**\n     * Sets if the submitting user wishes their identity (pricipal(s)) to be remembered across sessions.  Unless\n     * overridden, the default value is <tt>false</tt>, indicating <em>not</em> to be remembered across sessions.\n     *\n     * @param rememberMe value inidicating if the user wishes their identity (principal(s)) to be remembered across\n     *                   sessions.\n     * @since 0.9\n     */\n    public void setRememberMe(boolean rememberMe) {\n        this.rememberMe = rememberMe;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Clears out (nulls) the username, password, rememberMe, and inetAddress.  The password bytes are explicitly set to\n     * <tt>0x00</tt> before nulling to eliminate the possibility of memory access at a later time.\n     */\n    public void clear() {\n        this.username = null;\n        this.inetAddress = null;\n        this.rememberMe = false;\n        if (this.password != null) {\n            for (int i = 0; i < password.length; i++) {\n                this.password[i] = 0x00;\n            }\n            this.password = null;\n        }\n    }\n\n    /**\n     * Returns the String representation.  It does not include the password in the resulting\n     * string for security reasons to prevent accidentially printing out a password\n     * that might be widely viewable).\n     *\n     * @return the String representation of the <tt>UsernamePasswordToken</tt>, omitting\n     *         the password.\n     */\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        sb.append(getClass().getName());\n        sb.append(\" - \");\n        sb.append(username);\n        sb.append(\", rememberMe=\").append(rememberMe);\n        if (inetAddress != null) {\n            sb.append(\" (\").append(inetAddress).append(\")\");\n        }\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/UsernamePasswordTokenTest.java",
		"test_prompt": "// UsernamePasswordTokenTest.java\npackage org.jsecurity.authc;\n\nimport java.net.InetAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsernamePasswordToken}.\n* It contains ten unit test cases for the {@link UsernamePasswordToken#isRememberMe()} method.\n*/\nclass UsernamePasswordTokenTest {"
	},
	{
		"original_code": "// FirstSuccessfulAuthenticationStrategy.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authc.pam;\r\n\r\nimport org.jsecurity.authc.AuthenticationException;\r\nimport org.jsecurity.authc.AuthenticationInfo;\r\nimport org.jsecurity.authc.AuthenticationToken;\r\nimport org.jsecurity.realm.Realm;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * {@link ModularAuthenticationStrategy} implementation that only accepts the account data from\r\n * the first successfully consulted Realm and ignores all subsequent realms.  This is slightly\r\n * different behavior than\r\n * {@link org.jsecurity.authc.pam.AtLeastOneSuccessfulModularAuthenticationStrategy AtLeastOneSuccessfulModularAuthenticationStrategy},\r\n * so please review both to see which one meets your needs better.\r\n *\r\n * @author Les Hazlewood\r\n * @see org.jsecurity.authc.pam.AtLeastOneSuccessfulModularAuthenticationStrategy AtLeastOneSuccessfulModularAuthenticationStrategy\r\n * @since 0.9\r\n */\r\npublic class FirstSuccessfulAuthenticationStrategy extends AbstractAuthenticationStrategy {\r\n\r\n    /**\r\n     * Returns <code>null</code> immediately, relying on this class's {@link #merge merge} implementation to return\r\n     * only the first <code>info</code> object it encounters, ignoring all subsequent ones.\r\n     */\r\n    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the specified <code>aggregate</code> instance if is non null and valid (that is, has principals and they are\r\n     * not empty) immediately, or, if it is null or not valid, the <code>info</code> argument is returned instead.\r\n     * <p/>\r\n     * This logic ensures that the first valid info encountered is the one retained and all subsequent ones are ignored,\r\n     * since this strategy mandates that only the info from the first successfully authenticated realm be used.\r\n     */\r\n    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {\r\n        if (aggregate != null && aggregate.getPrincipals() != null && !aggregate.getPrincipals().isEmpty()) {\r\n            return aggregate;\r\n        }\r\n        return info != null ? info : aggregate;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/FirstSuccessfulAuthenticationStrategyTest.java",
		"test_prompt": "// FirstSuccessfulAuthenticationStrategyTest.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FirstSuccessfulAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link FirstSuccessfulAuthenticationStrategy#beforeAllAttempts(Collection, AuthenticationToken)} method.\n*/\nclass FirstSuccessfulAuthenticationStrategyTest {"
	},
	{
		"original_code": "// AllSuccessfulModularAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\n\n/**\n * <tt>ModularAuthenticationStrategy</tt> implementation that requires <em>all</em> configured realms to\n * <b>successfully</b> process the submitted <tt>AuthenticationToken</tt> during the log-in attempt.\n *\n * <p>If one or more realms do not support the submitted token, or one or more are unable to acquire\n * <tt>AuthenticationInfo</tt> for the token, this implementation will immediately fail the log-in attempt for the\n * associated subject (user).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class AllSuccessfulModularAuthenticationStrategy extends AbstractAuthenticationStrategy {\n\n    /**\n     * Private class log instance.\n     */\n    private static final Log log = LogFactory.getLog(AllSuccessfulModularAuthenticationStrategy.class);\n\n    /**\n     * Because all realms in this strategy must complete successfully, this implementation ensures that the given\n     * <code>Realm</code> {@link Realm#supports(org.jsecurity.authc.AuthenticationToken) supports} the given\n     * <code>token</code> argument.  If it does not, this method throws an\n     * {@link org.jsecurity.authc.pam.UnsupportedTokenException UnsupportedTokenException} to end the authentication\n     * process immediately. If the realm does support the token, the <code>info</code> argument is returned immediately.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {\n        if (!realm.supports(token)) {\n            String msg = \"Realm [\" + realm + \"] of type [\" + realm.getClass().getName() + \"] does not support \" + \" the submitted AuthenticationToken [\" + token + \"].  The [\" + getClass().getName() + \"] implementation requires all configured realm(s) to support and be able to process the submitted \" + \"AuthenticationToken.\";\n            throw new UnsupportedTokenException(msg);\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> into the <code>aggregate</code> argument and returns it (just as the\n     * parent implementation does), but additionally ensures the following:\n     * <ol>\n     * <li>if the <code>Throwable</code> argument is not <code>null</code>, re-throws it to immediately cancel the\n     * authentication process, since this strategy requires all realms to authenticate successfully.</li>\n     * <li>neither the <code>info</code> or <code>aggregate</code> argument is <code>null</code> to ensure that each\n     * realm did in fact authenticate successfully</li>\n     * </ol>\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info, AuthenticationInfo aggregate, Throwable t) throws AuthenticationException {\n        if (t != null) {\n            if (t instanceof AuthenticationException) {\n                //propagate:\n                throw ((AuthenticationException) t);\n            } else {\n                String msg = \"Unable to acquire account data from realm [\" + realm + \"].  The [\" + getClass().getName() + \" implementation requires all configured realm(s) to operate successfully \" + \"for a successful authentication.\";\n                throw new AuthenticationException(msg, t);\n            }\n        }\n        if (info == null) {\n            String msg = \"Realm [\" + realm + \"] could not find any associated account data for the submitted \" + \"AuthenticationToken [\" + token + \"].  The [\" + getClass().getName() + \"] implementation requires \" + \"all configured realm(s) to acquire valid account data for a submitted token during the \" + \"log-in process.\";\n            throw new UnknownAccountException(msg);\n        }\n        // If non-null account is returned, then the realm was able to authenticate the\n        // user - so merge the account with any accumulated before:\n        if (log.isDebugEnabled()) {\n            log.debug(\"Account successfully authenticated using realm of type [\" + realm.getClass().getName() + \"]\");\n        }\n        merge(info, aggregate);\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AllSuccessfulModularAuthenticationStrategyTest0.java",
		"test_prompt": "// AllSuccessfulModularAuthenticationStrategyTest0.java\npackage org.jsecurity.authc.pam;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AllSuccessfulModularAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AllSuccessfulModularAuthenticationStrategy#beforeAttempt(Realm, AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass AllSuccessfulModularAuthenticationStrategyTest0 {"
	},
	{
		"original_code": "// AllSuccessfulModularAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\n\n/**\n * <tt>ModularAuthenticationStrategy</tt> implementation that requires <em>all</em> configured realms to\n * <b>successfully</b> process the submitted <tt>AuthenticationToken</tt> during the log-in attempt.\n *\n * <p>If one or more realms do not support the submitted token, or one or more are unable to acquire\n * <tt>AuthenticationInfo</tt> for the token, this implementation will immediately fail the log-in attempt for the\n * associated subject (user).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class AllSuccessfulModularAuthenticationStrategy extends AbstractAuthenticationStrategy {\n\n    /**\n     * Private class log instance.\n     */\n    private static final Log log = LogFactory.getLog(AllSuccessfulModularAuthenticationStrategy.class);\n\n    /**\n     * Because all realms in this strategy must complete successfully, this implementation ensures that the given\n     * <code>Realm</code> {@link Realm#supports(org.jsecurity.authc.AuthenticationToken) supports} the given\n     * <code>token</code> argument.  If it does not, this method throws an\n     * {@link org.jsecurity.authc.pam.UnsupportedTokenException UnsupportedTokenException} to end the authentication\n     * process immediately. If the realm does support the token, the <code>info</code> argument is returned immediately.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {\n        if (!realm.supports(token)) {\n            String msg = \"Realm [\" + realm + \"] of type [\" + realm.getClass().getName() + \"] does not support \" + \" the submitted AuthenticationToken [\" + token + \"].  The [\" + getClass().getName() + \"] implementation requires all configured realm(s) to support and be able to process the submitted \" + \"AuthenticationToken.\";\n            throw new UnsupportedTokenException(msg);\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> into the <code>aggregate</code> argument and returns it (just as the\n     * parent implementation does), but additionally ensures the following:\n     * <ol>\n     * <li>if the <code>Throwable</code> argument is not <code>null</code>, re-throws it to immediately cancel the\n     * authentication process, since this strategy requires all realms to authenticate successfully.</li>\n     * <li>neither the <code>info</code> or <code>aggregate</code> argument is <code>null</code> to ensure that each\n     * realm did in fact authenticate successfully</li>\n     * </ol>\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info, AuthenticationInfo aggregate, Throwable t) throws AuthenticationException {\n        if (t != null) {\n            if (t instanceof AuthenticationException) {\n                //propagate:\n                throw ((AuthenticationException) t);\n            } else {\n                String msg = \"Unable to acquire account data from realm [\" + realm + \"].  The [\" + getClass().getName() + \" implementation requires all configured realm(s) to operate successfully \" + \"for a successful authentication.\";\n                throw new AuthenticationException(msg, t);\n            }\n        }\n        if (info == null) {\n            String msg = \"Realm [\" + realm + \"] could not find any associated account data for the submitted \" + \"AuthenticationToken [\" + token + \"].  The [\" + getClass().getName() + \"] implementation requires \" + \"all configured realm(s) to acquire valid account data for a submitted token during the \" + \"log-in process.\";\n            throw new UnknownAccountException(msg);\n        }\n        // If non-null account is returned, then the realm was able to authenticate the\n        // user - so merge the account with any accumulated before:\n        if (log.isDebugEnabled()) {\n            log.debug(\"Account successfully authenticated using realm of type [\" + realm.getClass().getName() + \"]\");\n        }\n        merge(info, aggregate);\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AllSuccessfulModularAuthenticationStrategyTest1.java",
		"test_prompt": "// AllSuccessfulModularAuthenticationStrategyTest1.java\npackage org.jsecurity.authc.pam;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.UnknownAccountException;\nimport org.jsecurity.realm.Realm;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AllSuccessfulModularAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AllSuccessfulModularAuthenticationStrategy#afterAttempt(Realm, AuthenticationToken, AuthenticationInfo, AuthenticationInfo, Throwable)} method.\n*/\nclass AllSuccessfulModularAuthenticationStrategyTest1 {"
	},
	{
		"original_code": "// AtLeastOneSuccessfulModularAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\n\n/**\n * <tt>ModularAuthenticationStrategy</tt> implementation that requires <em>at least one</em> configured realm to\n * successfully process the submitted <tt>AuthenticationToken</tt> during the log-in attempt.\n *\n * <p>This means any number of configured realms do not have to support the submitted log-in token, or they may\n * be unable to acquire <tt>AuthenticationInfo</tt> for the token, but as long as at least one can do both, this\n * Strategy implementation will allow the log-in process to be successful.\n *\n * <p>Note that this implementation will aggregate the account data from <em>all</em> successfully consulted\n * realms during the authentication attempt. If you want only the account data from the first successfully\n * consulted realm and want to ignore all subsequent realms, use the\n * {@link FirstSuccessfulAuthenticationStrategy FirstSuccessfulAuthenticationStrategy} instead.\n *\n * @author Les Hazlewood\n * @see FirstSuccessfulAuthenticationStrategy FirstSuccessfulAuthenticationStrategy\n * @since 0.2\n */\npublic class AtLeastOneSuccessfulModularAuthenticationStrategy extends AbstractAuthenticationStrategy {\n\n    /**\n     * Ensures that the <code>aggregate</code> method argument is not <code>null</code> and\n     * <code>aggregate.{@link org.jsecurity.authc.AuthenticationInfo#getPrincipals() getPrincipals()}</code>\n     * is not <code>null</code>, and if either is <code>null</code>, throws an AuthenticationException to indicate\n     * that none of the realms authenticated successfully.\n     */\n    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        //we know if one or more were able to succesfully authenticate if the aggregated account object does not\n        //contain null or empty data:\n        boolean oneOrMoreSuccessful = aggregate != null && (aggregate.getPrincipals() != null);\n        if (!oneOrMoreSuccessful) {\n            throw new AuthenticationException(\"Authentication token of type [\" + token.getClass() + \"] \" + \"could not be authenticated by any configured realms.  Please ensure that at least one realm can \" + \"authenticate these tokens.\");\n        }\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AtLeastOneSuccessfulModularAuthenticationStrategyTest.java",
		"test_prompt": "// AtLeastOneSuccessfulModularAuthenticationStrategyTest.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationInfo;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AtLeastOneSuccessfulModularAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AtLeastOneSuccessfulModularAuthenticationStrategy#afterAllAttempts(AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass AtLeastOneSuccessfulModularAuthenticationStrategyTest {"
	},
	{
		"original_code": "// AbstractAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\n\n/**\n * Abstract base implementation for JSecurity's concrete <code>ModularAuthenticationStrategy</code>\n * implementations.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractAuthenticationStrategy implements ModularAuthenticationStrategy {\n\n    /**\n     * Simply returns <code>new {@link SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports\n     * aggregating account data across realms.\n     */\n    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> method argument, without modification.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n\n    /**\n     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the\n     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {\n        AuthenticationInfo info;\n        if (singleRealmInfo == null) {\n            info = aggregateInfo;\n        } else {\n            if (aggregateInfo == null) {\n                info = singleRealmInfo;\n            } else {\n                info = merge(singleRealmInfo, aggregateInfo);\n            }\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an\n     * aggregate for continued use throughout the login process.\n     * <p/>\n     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls\n     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of\n     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.\n     * Can be overridden by subclasses for custom merging behavior if implementing the\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.\n     */\n    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {\n        if (aggregate instanceof MergableAuthenticationInfo) {\n            ((MergableAuthenticationInfo) aggregate).merge(info);\n            return aggregate;\n        } else {\n            throw new IllegalArgumentException(\"Attempt to merge authentication info from multiple realms, but aggreagate \" + \"AuthenticationInfo is not of type MergableAuthenticationInfo.\");\n        }\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.\n     */\n    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AbstractAuthenticationStrategyTest0.java",
		"test_prompt": "// AbstractAuthenticationStrategyTest0.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AbstractAuthenticationStrategy#beforeAllAttempts(Collection, AuthenticationToken)} method.\n*/\nclass AbstractAuthenticationStrategyTest0 {"
	},
	{
		"original_code": "// AbstractAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\n\n/**\n * Abstract base implementation for JSecurity's concrete <code>ModularAuthenticationStrategy</code>\n * implementations.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractAuthenticationStrategy implements ModularAuthenticationStrategy {\n\n    /**\n     * Simply returns <code>new {@link SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports\n     * aggregating account data across realms.\n     */\n    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> method argument, without modification.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n\n    /**\n     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the\n     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {\n        AuthenticationInfo info;\n        if (singleRealmInfo == null) {\n            info = aggregateInfo;\n        } else {\n            if (aggregateInfo == null) {\n                info = singleRealmInfo;\n            } else {\n                info = merge(singleRealmInfo, aggregateInfo);\n            }\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an\n     * aggregate for continued use throughout the login process.\n     * <p/>\n     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls\n     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of\n     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.\n     * Can be overridden by subclasses for custom merging behavior if implementing the\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.\n     */\n    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {\n        if (aggregate instanceof MergableAuthenticationInfo) {\n            ((MergableAuthenticationInfo) aggregate).merge(info);\n            return aggregate;\n        } else {\n            throw new IllegalArgumentException(\"Attempt to merge authentication info from multiple realms, but aggreagate \" + \"AuthenticationInfo is not of type MergableAuthenticationInfo.\");\n        }\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.\n     */\n    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AbstractAuthenticationStrategyTest1.java",
		"test_prompt": "// AbstractAuthenticationStrategyTest1.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AbstractAuthenticationStrategy#beforeAttempt(Realm, AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass AbstractAuthenticationStrategyTest1 {"
	},
	{
		"original_code": "// AbstractAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\n\n/**\n * Abstract base implementation for JSecurity's concrete <code>ModularAuthenticationStrategy</code>\n * implementations.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractAuthenticationStrategy implements ModularAuthenticationStrategy {\n\n    /**\n     * Simply returns <code>new {@link SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports\n     * aggregating account data across realms.\n     */\n    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> method argument, without modification.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n\n    /**\n     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the\n     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {\n        AuthenticationInfo info;\n        if (singleRealmInfo == null) {\n            info = aggregateInfo;\n        } else {\n            if (aggregateInfo == null) {\n                info = singleRealmInfo;\n            } else {\n                info = merge(singleRealmInfo, aggregateInfo);\n            }\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an\n     * aggregate for continued use throughout the login process.\n     * <p/>\n     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls\n     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of\n     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.\n     * Can be overridden by subclasses for custom merging behavior if implementing the\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.\n     */\n    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {\n        if (aggregate instanceof MergableAuthenticationInfo) {\n            ((MergableAuthenticationInfo) aggregate).merge(info);\n            return aggregate;\n        } else {\n            throw new IllegalArgumentException(\"Attempt to merge authentication info from multiple realms, but aggreagate \" + \"AuthenticationInfo is not of type MergableAuthenticationInfo.\");\n        }\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.\n     */\n    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AbstractAuthenticationStrategyTest2.java",
		"test_prompt": "// AbstractAuthenticationStrategyTest2.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AbstractAuthenticationStrategy#afterAttempt(Realm, AuthenticationToken, AuthenticationInfo, AuthenticationInfo, Throwable)} method.\n*/\nclass AbstractAuthenticationStrategyTest2 {"
	},
	{
		"original_code": "// AbstractAuthenticationStrategy.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\n\n/**\n * Abstract base implementation for JSecurity's concrete <code>ModularAuthenticationStrategy</code>\n * implementations.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AbstractAuthenticationStrategy implements ModularAuthenticationStrategy {\n\n    /**\n     * Simply returns <code>new {@link SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports\n     * aggregating account data across realms.\n     */\n    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {\n        return new SimpleAuthenticationInfo();\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> method argument, without modification.\n     */\n    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n\n    /**\n     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the\n     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.\n     */\n    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {\n        AuthenticationInfo info;\n        if (singleRealmInfo == null) {\n            info = aggregateInfo;\n        } else {\n            if (aggregateInfo == null) {\n                info = singleRealmInfo;\n            } else {\n                info = merge(singleRealmInfo, aggregateInfo);\n            }\n        }\n        return info;\n    }\n\n    /**\n     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an\n     * aggregate for continued use throughout the login process.\n     * <p/>\n     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls\n     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of\n     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.\n     * Can be overridden by subclasses for custom merging behavior if implementing the\n     * {@link org.jsecurity.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.\n     */\n    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {\n        if (aggregate instanceof MergableAuthenticationInfo) {\n            ((MergableAuthenticationInfo) aggregate).merge(info);\n            return aggregate;\n        } else {\n            throw new IllegalArgumentException(\"Attempt to merge authentication info from multiple realms, but aggreagate \" + \"AuthenticationInfo is not of type MergableAuthenticationInfo.\");\n        }\n    }\n\n    /**\n     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.\n     */\n    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {\n        return aggregate;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authc/pam/AbstractAuthenticationStrategyTest3.java",
		"test_prompt": "// AbstractAuthenticationStrategyTest3.java\npackage org.jsecurity.authc.pam;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.realm.Realm;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractAuthenticationStrategy}.\n* It contains ten unit test cases for the {@link AbstractAuthenticationStrategy#afterAllAttempts(AuthenticationToken, AuthenticationInfo)} method.\n*/\nclass AbstractAuthenticationStrategyTest3 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest0.java",
		"test_prompt": "// DelegatingSubjectTest0.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermitted(String)} method.\n*/\nclass DelegatingSubjectTest0 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest1.java",
		"test_prompt": "// DelegatingSubjectTest1.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermitted(Permission)} method.\n*/\nclass DelegatingSubjectTest1 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest2.java",
		"test_prompt": "// DelegatingSubjectTest2.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermitted(String[])} method.\n*/\nclass DelegatingSubjectTest2 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest3.java",
		"test_prompt": "// DelegatingSubjectTest3.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermitted(List)} method.\n*/\nclass DelegatingSubjectTest3 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest4.java",
		"test_prompt": "// DelegatingSubjectTest4.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermittedAll(String[])} method.\n*/\nclass DelegatingSubjectTest4 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest5.java",
		"test_prompt": "// DelegatingSubjectTest5.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isPermittedAll(Collection)} method.\n*/\nclass DelegatingSubjectTest5 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest6.java",
		"test_prompt": "// DelegatingSubjectTest6.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#hasRole(String)} method.\n*/\nclass DelegatingSubjectTest6 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest7.java",
		"test_prompt": "// DelegatingSubjectTest7.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#hasRoles(List)} method.\n*/\nclass DelegatingSubjectTest7 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest8.java",
		"test_prompt": "// DelegatingSubjectTest8.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#hasAllRoles(Collection)} method.\n*/\nclass DelegatingSubjectTest8 {"
	},
	{
		"original_code": "// DelegatingSubject.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Implementation of the <tt>Subject</tt> interface that delegates\n * method calls to an underlying {@link org.jsecurity.mgt.SecurityManager SecurityManager} instance for security checks.\n * It is essentially a <tt>SecurityManager</tt> proxy.\n * <p/>\n * This implementation does not maintain state such as roles and permissions (only <code>Subject</code>\n * {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless\n * architecture.  It instead asks the underlying <tt>SecurityManager</tt> every time to perform\n * the authorization check.\n * <p/>\n * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would\n * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is\n * up to the implementation of the underlying <tt>SecurityManager</tt> instance.  If caching of authorization\n * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered\n * much more elegant to let the underlying <tt>SecurityManager</tt> implementation or its delegate components\n * manage caching, not this class.  A <tt>SecurityManager</tt> is considered a business-tier component,\n * where caching strategies are better suited.\n * <p/>\n * Applications from large and clustered to simple and vm local all benefit from\n * stateless architectures.  This implementation plays a part in the stateless programming\n * paradigm and should be used whenever possible.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSubject implements Subject {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(DelegatingSubject.class);\n\n    protected PrincipalCollection principals = new SimplePrincipalCollection();\n\n    protected boolean authenticated = false;\n\n    protected InetAddress inetAddress = null;\n\n    protected Session session = null;\n\n    protected SecurityManager securityManager;\n\n    protected static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    public DelegatingSubject(SecurityManager securityManager) {\n        this(null, false, getLocalHost(), null, securityManager);\n    }\n\n    public DelegatingSubject(PrincipalCollection principals, boolean authenticated, InetAddress inetAddress, Session session, SecurityManager securityManager) {\n        if (securityManager == null) {\n            throw new IllegalArgumentException(\"SecurityManager argument cannot be null.\");\n        }\n        this.securityManager = securityManager;\n        this.principals = principals;\n        this.authenticated = authenticated;\n        if (inetAddress != null) {\n            this.inetAddress = inetAddress;\n        } else {\n            this.inetAddress = getLocalHost();\n        }\n        if (session != null) {\n            this.session = new StoppingAwareProxiedSession(session, this);\n        }\n    }\n\n    public org.jsecurity.mgt.SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    protected boolean hasPrincipals() {\n        PrincipalCollection pc = getPrincipals();\n        return pc != null && !pc.isEmpty();\n    }\n\n    /**\n     * Returns the InetAddress associated with the client who created/is interacting with this Subject.\n     *\n     * @return the InetAddress associated with the client who created/is interacting with this Subject.\n     */\n    public InetAddress getInetAddress() {\n        return this.inetAddress;\n    }\n\n    /**\n     * @see Subject#getPrincipal()\n     */\n    public Object getPrincipal() {\n        PrincipalCollection principals = getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            return null;\n        }\n        return principals.asSet().iterator().next();\n    }\n\n    public PrincipalCollection getPrincipals() {\n        return this.principals;\n    }\n\n    public boolean isPermitted(String permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean isPermitted(Permission permission) {\n        return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);\n    }\n\n    public boolean[] isPermitted(String... permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.length];\n        }\n    }\n\n    public boolean[] isPermitted(List<Permission> permissions) {\n        if (hasPrincipals()) {\n            return securityManager.isPermitted(getPrincipals(), permissions);\n        } else {\n            return new boolean[permissions.size()];\n        }\n    }\n\n    public boolean isPermittedAll(String... permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    public boolean isPermittedAll(Collection<Permission> permissions) {\n        return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);\n    }\n\n    protected void assertAuthzCheckPossible() throws AuthorizationException {\n        if (!hasPrincipals()) {\n            String msg = \"Identity principals are not associated with this Subject instance - \" + \"authorization operations require an identity to check against.  A Subject instance will \" + \"acquire these identifying principals automatically after a successful login is performed \" + \"be executing \" + Subject.class.getName() + \".login(AuthenticationToken) or when 'Remember Me' \" + \"functionality is enabled.  This exception can also occur when the current Subject has logged out, \" + \"which relinquishes its identity and essentially makes it anonymous again.  \" + \"Because an identity is currently not known due to any of these conditions, \" + \"authorization is denied.\";\n            throw new UnauthenticatedException(msg);\n        }\n    }\n\n    public void checkPermission(String permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermission(Permission permission) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermission(getPrincipals(), permission);\n    }\n\n    public void checkPermissions(String... permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkPermissions(getPrincipals(), permissions);\n    }\n\n    public boolean hasRole(String roleIdentifier) {\n        return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);\n    }\n\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\n        if (hasPrincipals()) {\n            return securityManager.hasRoles(getPrincipals(), roleIdentifiers);\n        } else {\n            return new boolean[roleIdentifiers.size()];\n        }\n    }\n\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\n        return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);\n    }\n\n    public void checkRole(String role) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRole(getPrincipals(), role);\n    }\n\n    public void checkRoles(Collection<String> roles) throws AuthorizationException {\n        assertAuthzCheckPossible();\n        securityManager.checkRoles(getPrincipals(), roles);\n    }\n\n    public void login(AuthenticationToken token) throws AuthenticationException {\n        Subject authcSecCtx = securityManager.login(token);\n        PrincipalCollection principals = authcSecCtx.getPrincipals();\n        if (principals == null || principals.isEmpty()) {\n            String msg = \"Principals returned from securityManager.login( token ) returned a null or \" + \"empty value.  This value must be non null and populated with one or more elements.  \" + \"Please check the SecurityManager implementation to ensure this happens after a \" + \"successful login attempt.\";\n            throw new IllegalStateException(msg);\n        }\n        this.principals = principals;\n        Session session = authcSecCtx.getSession(false);\n        if (session != null) {\n            if (session instanceof StoppingAwareProxiedSession) {\n                this.session = session;\n            } else {\n                this.session = new StoppingAwareProxiedSession(session, this);\n            }\n        } else {\n            this.session = null;\n        }\n        this.authenticated = true;\n        if (token instanceof InetAuthenticationToken) {\n            InetAddress addy = ((InetAuthenticationToken) token).getInetAddress();\n            if (addy != null) {\n                this.inetAddress = addy;\n            }\n        }\n        ThreadContext.bind(this);\n    }\n\n    public boolean isAuthenticated() {\n        return authenticated;\n    }\n\n    public Session getSession() {\n        return getSession(true);\n    }\n\n    public Session getSession(boolean create) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"attempting to get session; create = \" + create + \"; session is null = \" + (this.session == null) + \"; session has id = \" + (this.session != null && session.getId() != null));\n        }\n        if (this.session == null && create) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"starting session for address [\" + getInetAddress() + \"]\");\n            }\n            Session target = securityManager.start(getInetAddress());\n            this.session = new StoppingAwareProxiedSession(target, this);\n        }\n        return this.session;\n    }\n\n    public void logout() {\n        try {\n            this.securityManager.logout(getPrincipals());\n        } finally {\n            this.session = null;\n            this.principals = null;\n            this.authenticated = false;\n            this.inetAddress = null;\n            this.securityManager = null;\n        }\n    }\n\n    private void sessionStopped() {\n        this.session = null;\n    }\n\n    private class StoppingAwareProxiedSession extends ProxiedSession {\n\n        private final DelegatingSubject owner;\n\n        private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {\n            super(target);\n            owner = owningSubject;\n        }\n\n        public void stop() throws InvalidSessionException {\n            super.stop();\n            owner.sessionStopped();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/DelegatingSubjectTest9.java",
		"test_prompt": "// DelegatingSubjectTest9.java\npackage org.jsecurity.subject;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.AuthenticationException;\nimport org.jsecurity.authc.AuthenticationToken;\nimport org.jsecurity.authc.InetAuthenticationToken;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.UnauthenticatedException;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSubject}.\n* It contains ten unit test cases for the {@link DelegatingSubject#isAuthenticated()} method.\n*/\nclass DelegatingSubjectTest9 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest0.java",
		"test_prompt": "// SimplePrincipalCollectionTest0.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#oneByType(Class)} method.\n*/\nclass SimplePrincipalCollectionTest0 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest1.java",
		"test_prompt": "// SimplePrincipalCollectionTest1.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#byType(Class)} method.\n*/\nclass SimplePrincipalCollectionTest1 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest2.java",
		"test_prompt": "// SimplePrincipalCollectionTest2.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#asList()} method.\n*/\nclass SimplePrincipalCollectionTest2 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest3.java",
		"test_prompt": "// SimplePrincipalCollectionTest3.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#asSet()} method.\n*/\nclass SimplePrincipalCollectionTest3 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest4.java",
		"test_prompt": "// SimplePrincipalCollectionTest4.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#fromRealm(String)} method.\n*/\nclass SimplePrincipalCollectionTest4 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest5.java",
		"test_prompt": "// SimplePrincipalCollectionTest5.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#isEmpty()} method.\n*/\nclass SimplePrincipalCollectionTest5 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest6.java",
		"test_prompt": "// SimplePrincipalCollectionTest6.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#iterator()} method.\n*/\nclass SimplePrincipalCollectionTest6 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest7.java",
		"test_prompt": "// SimplePrincipalCollectionTest7.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#equals(Object)} method.\n*/\nclass SimplePrincipalCollectionTest7 {"
	},
	{
		"original_code": "// SimplePrincipalCollection.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.subject;\n\nimport java.util.*;\n\n/**\n * A simple implementation of the {@link MutablePrincipalCollection} interface that tracks principals internally\n * by storing them in a {@link LinkedHashMap}.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\n@SuppressWarnings({ \"unchecked\" })\npublic class SimplePrincipalCollection implements MutablePrincipalCollection {\n\n    //TODO - complete JavaDoc\n    private Map<String, Set> realmPrincipals;\n\n    public SimplePrincipalCollection() {\n    }\n\n    public SimplePrincipalCollection(Object principal, String realmName) {\n        if (principal instanceof Collection) {\n            addAll((Collection) principal, realmName);\n        } else {\n            add(principal, realmName);\n        }\n    }\n\n    public SimplePrincipalCollection(Collection principals, String realmName) {\n        addAll(principals, realmName);\n    }\n\n    public SimplePrincipalCollection(PrincipalCollection principals) {\n        addAll(principals);\n    }\n\n    protected Collection getPrincipalsLazy(String realmName) {\n        if (realmPrincipals == null) {\n            realmPrincipals = new LinkedHashMap<String, Set>();\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null) {\n            principals = new LinkedHashSet();\n            realmPrincipals.put(realmName, principals);\n        }\n        return principals;\n    }\n\n    public void add(Object principal, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principal == null) {\n            throw new IllegalArgumentException(\"principal argument cannot be null.\");\n        }\n        getPrincipalsLazy(realmName).add(principal);\n    }\n\n    public void addAll(Collection principals, String realmName) {\n        if (realmName == null) {\n            throw new IllegalArgumentException(\"realmName argument cannot be null.\");\n        }\n        if (principals == null) {\n            throw new IllegalArgumentException(\"principals argument cannot be null.\");\n        }\n        if (principals.isEmpty()) {\n            throw new IllegalArgumentException(\"principals argument cannot be an empty collection.\");\n        }\n        getPrincipalsLazy(realmName).addAll(principals);\n    }\n\n    public void addAll(PrincipalCollection principals) {\n        if (principals.getRealmNames() != null) {\n            for (String realmName : principals.getRealmNames()) {\n                for (Object principal : principals.fromRealm(realmName)) {\n                    add(principal, realmName);\n                }\n            }\n        }\n    }\n\n    public <T> T oneByType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return null;\n        }\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    return (T) o;\n                }\n            }\n        }\n        return null;\n    }\n\n    public <T> Collection<T> byType(Class<T> type) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set<T> typed = new LinkedHashSet<T>();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            for (Object o : set) {\n                if (type.isAssignableFrom(o.getClass())) {\n                    typed.add((T) o);\n                }\n            }\n        }\n        if (typed.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(typed);\n    }\n\n    public List asList() {\n        Set all = asSet();\n        if (all.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n        return Collections.unmodifiableList(new ArrayList(all));\n    }\n\n    public Set asSet() {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set aggregated = new LinkedHashSet();\n        Collection<Set> values = realmPrincipals.values();\n        for (Set set : values) {\n            aggregated.addAll(set);\n        }\n        if (aggregated.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(aggregated);\n    }\n\n    public Collection fromRealm(String realmName) {\n        if (realmPrincipals == null || realmPrincipals.isEmpty()) {\n            return Collections.EMPTY_SET;\n        }\n        Set principals = realmPrincipals.get(realmName);\n        if (principals == null || principals.isEmpty()) {\n            principals = Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(principals);\n    }\n\n    public Set<String> getRealmNames() {\n        if (realmPrincipals == null) {\n            return null;\n        } else {\n            return realmPrincipals.keySet();\n        }\n    }\n\n    public boolean isEmpty() {\n        return realmPrincipals == null || realmPrincipals.isEmpty();\n    }\n\n    public void clear() {\n        if (realmPrincipals != null) {\n            realmPrincipals.clear();\n            realmPrincipals = null;\n        }\n    }\n\n    public Iterator iterator() {\n        return asSet().iterator();\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimplePrincipalCollection) {\n            SimplePrincipalCollection other = (SimplePrincipalCollection) o;\n            return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {\n            return realmPrincipals.hashCode();\n        }\n        return super.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/subject/SimplePrincipalCollectionTest8.java",
		"test_prompt": "// SimplePrincipalCollectionTest8.java\npackage org.jsecurity.subject;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimplePrincipalCollection}.\n* It contains ten unit test cases for the {@link SimplePrincipalCollection#hashCode()} method.\n*/\nclass SimplePrincipalCollectionTest8 {"
	},
	{
		"original_code": "// SecurityUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * Accesses the currently accessible <tt>Subject</tt> for the calling code depending on runtime environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class SecurityUtils {\n\n    /**\n     * ONLY used as a 'backup' in VM Singleton environments (that is, standalone environments), since the\n     * ThreadContext should always be the primary source for Subject instances when possible.\n     */\n    private static SecurityManager securityManager;\n\n    /**\n     * Returns the currently accessible <tt>Subject</tt> available to the calling code depending on\n     * runtime environment.\n     *\n     * <p>This method is provided as a way of obtaining a <tt>Subject</tt> without having to resort to\n     * implementation-specific methods.  It also allows the JSecurity team to change the underlying implementation of\n     * this method in the future depending on requirements/updates without affecting your code that uses it.\n     *\n     * @return the currently accessible <tt>Subject</tt> accessible to the calling code.\n     */\n    public static Subject getSubject() {\n        Subject subject;\n        SecurityManager securityManager = ThreadContext.getSecurityManager();\n        if (securityManager != null) {\n            subject = securityManager.getSubject();\n        } else {\n            subject = ThreadContext.getSubject();\n            if (subject == null && SecurityUtils.securityManager != null) {\n                //fall back to the VM singleton if one exists:\n                subject = SecurityUtils.securityManager.getSubject();\n            }\n        }\n        return subject;\n    }\n\n    /**\n     * Sets a VM (static) singleton SecurityManager, specifically for transparent use in the\n     * {@link #getSubject() getSubject()} implementation.\n     *\n     * <p><b>This method call exists mainly for framework development support.  Application developers should rarely,\n     * if ever, need to call this method.</b></p>\n     *\n     * <p>The JSecurity development team prefers that SecurityManager instances are non-static application singletons\n     * and <em>not</em> VM static singletons.  Application singletons that do not use static memory require some sort\n     * of application configuration framework to maintain the application-wide SecurityManager instance for you\n     * (for example, Spring or EJB3 environments) such that the object reference does not need to be static.\n     *\n     * <p>In these environments, JSecurity acquires Subject data based on the currently executing Thread via its own\n     * framework integration code, and this is the preferred way to use JSecurity.</p>\n     *\n     * <p>However in some environments, such as a standalone desktop application or Applets that do not use Spring or\n     * EJB or similar config frameworks, a VM-singleton might make more sense (although the former is still preferred).</p>\n     * In these environments, setting the SecurityManager via this method will automatically enable the\n     * {@link #getSubject() getSubject()} call to function with little configuration.</p>\n     *\n     * <p>For example, in these environments, this will work:</p>\n     *\n     * <code>DefaultSecurityManager securityManager = new {@link org.jsecurity.mgt.DefaultSecurityManager DefaultSecurityManager}();<br/>\n     * securityManager.setRealms( ... ); //one or more Realms<br/>\n     * <b>SecurityUtils.setSecurityManager( securityManager );</b></code>\n     *\n     * <p>And then anywhere in the application code, the following call will return the application's Subject:</p>\n     *\n     * <p><code>Subject currentUser = SecurityUtils.getSubject()</code></p>\n     *\n     * <p>by calling the VM static {@link org.jsecurity.mgt.SecurityManager#getSubject() securityManager.getSubject()}\n     * method.  Note that the underlying injected SecurityManager still needs to know how to acquire a Subject\n     * instance for the calling code, which might mean from static memory, or a config file, or other\n     * environment-specific means.</p>\n     *\n     * @param securityManager\n     */\n    public static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the VM (static) singleton SecurityManager.\n     *\n     * <p>This method is <b>only used in rare occasions</b>.  Please read the {@link #setSecurityManager setSecurityManager}\n     * JavaDoc for usage patterns.\n     *\n     * @return the VM (static) singleton SecurityManager, used only on rare occasions.\n     */\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.securityManager;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/SecurityUtilsTest0.java",
		"test_prompt": "// SecurityUtilsTest0.java\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SecurityUtils}.\n* It contains ten unit test cases for the {@link SecurityUtils#getSubject()} method.\n*/\nclass SecurityUtilsTest0 {"
	},
	{
		"original_code": "// SecurityUtils.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\n\n/**\n * Accesses the currently accessible <tt>Subject</tt> for the calling code depending on runtime environment.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class SecurityUtils {\n\n    /**\n     * ONLY used as a 'backup' in VM Singleton environments (that is, standalone environments), since the\n     * ThreadContext should always be the primary source for Subject instances when possible.\n     */\n    private static SecurityManager securityManager;\n\n    /**\n     * Returns the currently accessible <tt>Subject</tt> available to the calling code depending on\n     * runtime environment.\n     *\n     * <p>This method is provided as a way of obtaining a <tt>Subject</tt> without having to resort to\n     * implementation-specific methods.  It also allows the JSecurity team to change the underlying implementation of\n     * this method in the future depending on requirements/updates without affecting your code that uses it.\n     *\n     * @return the currently accessible <tt>Subject</tt> accessible to the calling code.\n     */\n    public static Subject getSubject() {\n        Subject subject;\n        SecurityManager securityManager = ThreadContext.getSecurityManager();\n        if (securityManager != null) {\n            subject = securityManager.getSubject();\n        } else {\n            subject = ThreadContext.getSubject();\n            if (subject == null && SecurityUtils.securityManager != null) {\n                //fall back to the VM singleton if one exists:\n                subject = SecurityUtils.securityManager.getSubject();\n            }\n        }\n        return subject;\n    }\n\n    /**\n     * Sets a VM (static) singleton SecurityManager, specifically for transparent use in the\n     * {@link #getSubject() getSubject()} implementation.\n     *\n     * <p><b>This method call exists mainly for framework development support.  Application developers should rarely,\n     * if ever, need to call this method.</b></p>\n     *\n     * <p>The JSecurity development team prefers that SecurityManager instances are non-static application singletons\n     * and <em>not</em> VM static singletons.  Application singletons that do not use static memory require some sort\n     * of application configuration framework to maintain the application-wide SecurityManager instance for you\n     * (for example, Spring or EJB3 environments) such that the object reference does not need to be static.\n     *\n     * <p>In these environments, JSecurity acquires Subject data based on the currently executing Thread via its own\n     * framework integration code, and this is the preferred way to use JSecurity.</p>\n     *\n     * <p>However in some environments, such as a standalone desktop application or Applets that do not use Spring or\n     * EJB or similar config frameworks, a VM-singleton might make more sense (although the former is still preferred).</p>\n     * In these environments, setting the SecurityManager via this method will automatically enable the\n     * {@link #getSubject() getSubject()} call to function with little configuration.</p>\n     *\n     * <p>For example, in these environments, this will work:</p>\n     *\n     * <code>DefaultSecurityManager securityManager = new {@link org.jsecurity.mgt.DefaultSecurityManager DefaultSecurityManager}();<br/>\n     * securityManager.setRealms( ... ); //one or more Realms<br/>\n     * <b>SecurityUtils.setSecurityManager( securityManager );</b></code>\n     *\n     * <p>And then anywhere in the application code, the following call will return the application's Subject:</p>\n     *\n     * <p><code>Subject currentUser = SecurityUtils.getSubject()</code></p>\n     *\n     * <p>by calling the VM static {@link org.jsecurity.mgt.SecurityManager#getSubject() securityManager.getSubject()}\n     * method.  Note that the underlying injected SecurityManager still needs to know how to acquire a Subject\n     * instance for the calling code, which might mean from static memory, or a config file, or other\n     * environment-specific means.</p>\n     *\n     * @param securityManager\n     */\n    public static void setSecurityManager(SecurityManager securityManager) {\n        SecurityUtils.securityManager = securityManager;\n    }\n\n    /**\n     * Returns the VM (static) singleton SecurityManager.\n     *\n     * <p>This method is <b>only used in rare occasions</b>.  Please read the {@link #setSecurityManager setSecurityManager}\n     * JavaDoc for usage patterns.\n     *\n     * @return the VM (static) singleton SecurityManager, used only on rare occasions.\n     */\n    public static SecurityManager getSecurityManager() {\n        return SecurityUtils.securityManager;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/SecurityUtilsTest1.java",
		"test_prompt": "// SecurityUtilsTest1.java\npackage org.jsecurity;\n\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SecurityUtils}.\n* It contains ten unit test cases for the {@link SecurityUtils#getSecurityManager()} method.\n*/\nclass SecurityUtilsTest1 {"
	},
	{
		"original_code": "// AnnotationMethodInterceptor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.aop;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\n/**\n * MethodInterceptor that inspects a specific annotation on the method invocation before continuing\n * its execution.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AnnotationMethodInterceptor extends MethodInterceptorSupport {\n\n    private AnnotationHandler handler;\n\n    /**\n     * Constructs an <code>AnnotationMethodInterceptor</code> with the\n     * {@link AnnotationHandler AnnotationHandler} that will be used to process annotations of a corresponding\n     * type.\n     *\n     * @param handler the handler to delegate to for processing the annotation.\n     */\n    public AnnotationMethodInterceptor(AnnotationHandler handler) {\n        setHandler(handler);\n    }\n\n    public AnnotationHandler getHandler() {\n        return handler;\n    }\n\n    public void setHandler(AnnotationHandler handler) {\n        this.handler = handler;\n    }\n\n    /**\n     * Returns <code>true</code> if this interceptor supports, that is, should inspect, the specified\n     * <code>MethodInvocation</code>, <code>false</code> otherwise.\n     * <p/>\n     * The default implementation simply does the following:\n     * <p/>\n     * <code>return {@link #getAnnotation(MethodInvocation) getAnnotation(mi)} != null</code>\n     *\n     * @param mi the <code>MethodInvocation</code> for the method being invoked.\n     * @return <code>true</code> if this interceptor supports, that is, should inspect, the specified\n     *         <code>MethodInvocation</code>, <code>false</code> otherwise.\n     */\n    public boolean supports(MethodInvocation mi) {\n        return getAnnotation(mi) != null;\n    }\n\n    /**\n     * Returns the Annotation that this interceptor will process for the specified method invocation.\n     * <p/>\n     * The default implementation merely gets the underlying {@link Method Method} from the supplied\n     * <code>MethodInvocation</code> argument, and returns:\n     * <p/>\n     * <code>mi.{@link Method#getAnnotation(Class) getAnnotation}({@link AnnotationHandler#getAnnotationClass() handler.getAnnotationClass()});</code>\n     *\n     * @param mi the MethodInvocation wrapping the Method from which the Annotation will be acquired.\n     * @return the Annotation that this interceptor will process for the specified method invocation.\n     * @throws IllegalArgumentException if the supplied <code>MethodInvocation</code> argument is <code>null</code> or\n     *                                  its underlying <code>Method</code> is <code>null</code>.\n     */\n    protected Annotation getAnnotation(MethodInvocation mi) throws IllegalArgumentException {\n        if (mi == null) {\n            throw new IllegalArgumentException(\"method argument cannot be null\");\n        }\n        Method m = mi.getMethod();\n        if (m == null) {\n            String msg = MethodInvocation.class.getName() + \" parameter incorrectly \" + \"constructed.  getMethod() returned null\";\n            throw new IllegalArgumentException(msg);\n        }\n        return m.getAnnotation(getHandler().getAnnotationClass());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/aop/AnnotationMethodInterceptorTest.java",
		"test_prompt": "// AnnotationMethodInterceptorTest.java\npackage org.jsecurity.aop;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnnotationMethodInterceptor}.\n* It contains ten unit test cases for the {@link AnnotationMethodInterceptor#supports(MethodInvocation)} method.\n*/\nclass AnnotationMethodInterceptorTest {"
	},
	{
		"original_code": "// AuthenticatingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.pam.ModularAuthenticationStrategy;\nimport org.jsecurity.authc.pam.ModularRealmAuthenticator;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authentication operations to a wrapped {@link Authenticator Authenticator} instance.  That is, this class\n * implements all the <tt>Authenticator</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authenticator</tt> instance.\n *\n * <p>All other <tt>SecurityManager</tt> (authorization, session, etc) methods are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies are created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthenticatingSecurityManager extends RealmSecurityManager implements AuthenticationListenerRegistrar {\n\n    /**\n     * The internal <code>Authenticator</code> delegate instance that this SecurityManager instance will use\n     * to perform all authentication operations.\n     */\n    private Authenticator authenticator;\n\n    /**\n     * Default no-arg constructor that initializes its internal\n     * <code>authenticator</code> instance to be a {@link ModularRealmAuthenticator ModularRealmAuthenticator}.\n     */\n    public AuthenticatingSecurityManager() {\n        this.authenticator = new ModularRealmAuthenticator();\n    }\n\n    /**\n     * Returns the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.  Unless overridden by the\n     * {@link #setAuthenticator(org.jsecurity.authc.Authenticator) setAuthenticator}, the default instance is a\n     * {@link org.jsecurity.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.\n     * @return the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.\n     */\n    public Authenticator getAuthenticator() {\n        return authenticator;\n    }\n\n    /**\n     * Sets the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.  Unless overridden by this method, the default instance is a\n     * {@link org.jsecurity.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.\n     * @param authenticator the delegate <code>Authenticator</code> instance that this SecurityManager will use to\n     * perform all authentication operations.\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    public void setAuthenticator(Authenticator authenticator) throws IllegalArgumentException {\n        if (authenticator == null) {\n            String msg = \"Authenticator argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authenticator = authenticator;\n    }\n\n    /**\n     * Sets the {@link org.jsecurity.authc.pam.ModularAuthenticationStrategy ModularAuthenticationStrategy} to use\n     * in multi-realm environments.\n     *\n     * @param strategy the <code>ModularAuthenticationStrategy</code> to use in multi-realm environments.\n     */\n    public void setModularAuthenticationStrategy(ModularAuthenticationStrategy strategy) {\n        if (!(this.authenticator instanceof ModularRealmAuthenticator)) {\n            String msg = \"Configuring a ModularAuthenticationStrategy is only applicable when the underlying \" + \"Authenticator implementation is a \" + ModularRealmAuthenticator.class.getName() + \" implementation.  This SecurityManager has been configured with an Authenticator of type \" + this.authenticator.getClass().getName();\n            throw new IllegalStateException(msg);\n        }\n        ((ModularRealmAuthenticator) this.authenticator).setModularAuthenticationStrategy(strategy);\n    }\n\n    /**\n     * This is a convenience method that allows registration of AuthenticationListeners with the underlying\n     * delegate Authenticator instance.\n     *\n     * <p>This is more convenient than having to configure your own Authenticator instance, inject the listeners on\n     * it, and then set that Authenticator instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager</tt>'s default initialization logic to create the Authenticator instance for you\n     * and then apply these <tt>AuthenticationListener</tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying Authenticator delegate must implement the\n     * {@link org.jsecurity.authc.AuthenticationListenerRegistrar AuthenticationListenerRegistrar}\n     * interface in order for these listeners to be applied.  If it does not implement this interface, it is\n     * considered a configuration error and an exception will be thrown.\n     *\n     * <p>All of JSecurity's <tt>Authenticator</tt> implementations implement the\n     * <tt>AuthenticationListenerRegistrar</tt> interface, so you would only need\n     * to worry about an exception being thrown if you provided your own Authenticator instance and did not\n     * implement it.\n     *\n     * @param listeners the <tt>AuthenticationListener</tt>s to register with the underlying delegate\n     *                  <tt>Authenticator</tt>.\n     */\n    public void setAuthenticationListeners(Collection<AuthenticationListener> listeners) {\n        assertAuthenticatorListenerSupport();\n        if (!(this.authenticator instanceof AuthenticationListenerRegistrar)) {\n            String msg = \"Configuring a ModularAuthenticationStrategy is only applicable when the underlying \" + \"Authenticator implementation is a \" + AuthenticationListenerRegistrar.class.getName() + \" implementation.  This SecurityManager has been configured with an Authenticator of type \" + this.authenticator.getClass().getName() + \", which does not implement that interface.\";\n            throw new IllegalStateException(msg);\n        }\n        ((AuthenticationListenerRegistrar) this.authenticator).setAuthenticationListeners(listeners);\n    }\n\n    /**\n     * Ensures that <code>this.authenticator</code> implements the\n     * {@link org.jsecurity.authc.AuthenticationListenerRegistrar AuthenticationListenerRegistrar} interface to ensure\n     * listeners can be registered.\n     */\n    private void assertAuthenticatorListenerSupport() {\n        if (!(this.authenticator instanceof AuthenticationListenerRegistrar)) {\n            String msg = \"AuthenticationListener registration failed:  The underlying Authenticator instance of \" + \"type [\" + this.authenticator.getClass().getName() + \"] does not implement the \" + AuthenticationListenerRegistrar.class.getName() + \" interface and therefore cannot support \" + \"runtime registration of AuthenticationListeners.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    public void add(AuthenticationListener listener) {\n        assertAuthenticatorListenerSupport();\n        Authenticator authc = getAuthenticator();\n        ((AuthenticationListenerRegistrar) authc).add(listener);\n    }\n\n    public boolean remove(AuthenticationListener listener) {\n        Authenticator authc = getAuthenticator();\n        return (authc instanceof AuthenticationListenerRegistrar) && ((AuthenticationListenerRegistrar) authc).remove(listener);\n    }\n\n    /**\n     * Immediately calls {@link RealmSecurityManager#setRealms(java.util.Collection) super.setRealms} and then\n     * additionally passes on those realms to the internal delegate <code>Authenticator</code> instance so\n     * that it may use them during authentication attempts.\n     * @param realms realms the realms managed by this <tt>SecurityManager</tt> instance and subsequently the internal\n     * delegate <code>Authenticator</code> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        if (this.authenticator instanceof ModularRealmAuthenticator) {\n            ((ModularRealmAuthenticator) this.authenticator).setRealms(realms);\n        }\n    }\n\n    /**\n     * Lifecycle cleanup method that first calls {@link #beforeAuthenticatorDestroyed() beforeAuthenticatorDestroyed()}\n     * to allow subclass cleanup and then calls {@link #destroyAuthenticator() destroyAuthenticator()} to actually\n     * clean up the internal delegate instance.\n     */\n    protected void beforeRealmsDestroyed() {\n        beforeAuthenticatorDestroyed();\n        destroyAuthenticator();\n    }\n\n    /**\n     * Template hook to allow subclass cleanup when the SecurityManager is being shut down.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n    }\n\n    /**\n     * Cleans up ('destroys') the internal delegate <code>Authenticator</code> instance.  Called during shut down.\n     */\n    protected void destroyAuthenticator() {\n        LifecycleUtils.destroy(getAuthenticator());\n    }\n\n    /**\n     * Delegates to the wrapped {@link Authenticator Authenticator} for authentication.\n     */\n    public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {\n        ensureRealms();\n        return this.authenticator.authenticate(token);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthenticatingSecurityManagerTest0.java",
		"test_prompt": "// AuthenticatingSecurityManagerTest0.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.pam.ModularAuthenticationStrategy;\nimport org.jsecurity.authc.pam.ModularRealmAuthenticator;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticatingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthenticatingSecurityManager#remove(AuthenticationListener)} method.\n*/\nclass AuthenticatingSecurityManagerTest0 {"
	},
	{
		"original_code": "// AuthenticatingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.pam.ModularAuthenticationStrategy;\nimport org.jsecurity.authc.pam.ModularRealmAuthenticator;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authentication operations to a wrapped {@link Authenticator Authenticator} instance.  That is, this class\n * implements all the <tt>Authenticator</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authenticator</tt> instance.\n *\n * <p>All other <tt>SecurityManager</tt> (authorization, session, etc) methods are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies are created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthenticatingSecurityManager extends RealmSecurityManager implements AuthenticationListenerRegistrar {\n\n    /**\n     * The internal <code>Authenticator</code> delegate instance that this SecurityManager instance will use\n     * to perform all authentication operations.\n     */\n    private Authenticator authenticator;\n\n    /**\n     * Default no-arg constructor that initializes its internal\n     * <code>authenticator</code> instance to be a {@link ModularRealmAuthenticator ModularRealmAuthenticator}.\n     */\n    public AuthenticatingSecurityManager() {\n        this.authenticator = new ModularRealmAuthenticator();\n    }\n\n    /**\n     * Returns the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.  Unless overridden by the\n     * {@link #setAuthenticator(org.jsecurity.authc.Authenticator) setAuthenticator}, the default instance is a\n     * {@link org.jsecurity.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.\n     * @return the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.\n     */\n    public Authenticator getAuthenticator() {\n        return authenticator;\n    }\n\n    /**\n     * Sets the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all\n     * authentication operations.  Unless overridden by this method, the default instance is a\n     * {@link org.jsecurity.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.\n     * @param authenticator the delegate <code>Authenticator</code> instance that this SecurityManager will use to\n     * perform all authentication operations.\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    public void setAuthenticator(Authenticator authenticator) throws IllegalArgumentException {\n        if (authenticator == null) {\n            String msg = \"Authenticator argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authenticator = authenticator;\n    }\n\n    /**\n     * Sets the {@link org.jsecurity.authc.pam.ModularAuthenticationStrategy ModularAuthenticationStrategy} to use\n     * in multi-realm environments.\n     *\n     * @param strategy the <code>ModularAuthenticationStrategy</code> to use in multi-realm environments.\n     */\n    public void setModularAuthenticationStrategy(ModularAuthenticationStrategy strategy) {\n        if (!(this.authenticator instanceof ModularRealmAuthenticator)) {\n            String msg = \"Configuring a ModularAuthenticationStrategy is only applicable when the underlying \" + \"Authenticator implementation is a \" + ModularRealmAuthenticator.class.getName() + \" implementation.  This SecurityManager has been configured with an Authenticator of type \" + this.authenticator.getClass().getName();\n            throw new IllegalStateException(msg);\n        }\n        ((ModularRealmAuthenticator) this.authenticator).setModularAuthenticationStrategy(strategy);\n    }\n\n    /**\n     * This is a convenience method that allows registration of AuthenticationListeners with the underlying\n     * delegate Authenticator instance.\n     *\n     * <p>This is more convenient than having to configure your own Authenticator instance, inject the listeners on\n     * it, and then set that Authenticator instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager</tt>'s default initialization logic to create the Authenticator instance for you\n     * and then apply these <tt>AuthenticationListener</tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying Authenticator delegate must implement the\n     * {@link org.jsecurity.authc.AuthenticationListenerRegistrar AuthenticationListenerRegistrar}\n     * interface in order for these listeners to be applied.  If it does not implement this interface, it is\n     * considered a configuration error and an exception will be thrown.\n     *\n     * <p>All of JSecurity's <tt>Authenticator</tt> implementations implement the\n     * <tt>AuthenticationListenerRegistrar</tt> interface, so you would only need\n     * to worry about an exception being thrown if you provided your own Authenticator instance and did not\n     * implement it.\n     *\n     * @param listeners the <tt>AuthenticationListener</tt>s to register with the underlying delegate\n     *                  <tt>Authenticator</tt>.\n     */\n    public void setAuthenticationListeners(Collection<AuthenticationListener> listeners) {\n        assertAuthenticatorListenerSupport();\n        if (!(this.authenticator instanceof AuthenticationListenerRegistrar)) {\n            String msg = \"Configuring a ModularAuthenticationStrategy is only applicable when the underlying \" + \"Authenticator implementation is a \" + AuthenticationListenerRegistrar.class.getName() + \" implementation.  This SecurityManager has been configured with an Authenticator of type \" + this.authenticator.getClass().getName() + \", which does not implement that interface.\";\n            throw new IllegalStateException(msg);\n        }\n        ((AuthenticationListenerRegistrar) this.authenticator).setAuthenticationListeners(listeners);\n    }\n\n    /**\n     * Ensures that <code>this.authenticator</code> implements the\n     * {@link org.jsecurity.authc.AuthenticationListenerRegistrar AuthenticationListenerRegistrar} interface to ensure\n     * listeners can be registered.\n     */\n    private void assertAuthenticatorListenerSupport() {\n        if (!(this.authenticator instanceof AuthenticationListenerRegistrar)) {\n            String msg = \"AuthenticationListener registration failed:  The underlying Authenticator instance of \" + \"type [\" + this.authenticator.getClass().getName() + \"] does not implement the \" + AuthenticationListenerRegistrar.class.getName() + \" interface and therefore cannot support \" + \"runtime registration of AuthenticationListeners.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    public void add(AuthenticationListener listener) {\n        assertAuthenticatorListenerSupport();\n        Authenticator authc = getAuthenticator();\n        ((AuthenticationListenerRegistrar) authc).add(listener);\n    }\n\n    public boolean remove(AuthenticationListener listener) {\n        Authenticator authc = getAuthenticator();\n        return (authc instanceof AuthenticationListenerRegistrar) && ((AuthenticationListenerRegistrar) authc).remove(listener);\n    }\n\n    /**\n     * Immediately calls {@link RealmSecurityManager#setRealms(java.util.Collection) super.setRealms} and then\n     * additionally passes on those realms to the internal delegate <code>Authenticator</code> instance so\n     * that it may use them during authentication attempts.\n     * @param realms realms the realms managed by this <tt>SecurityManager</tt> instance and subsequently the internal\n     * delegate <code>Authenticator</code> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        if (this.authenticator instanceof ModularRealmAuthenticator) {\n            ((ModularRealmAuthenticator) this.authenticator).setRealms(realms);\n        }\n    }\n\n    /**\n     * Lifecycle cleanup method that first calls {@link #beforeAuthenticatorDestroyed() beforeAuthenticatorDestroyed()}\n     * to allow subclass cleanup and then calls {@link #destroyAuthenticator() destroyAuthenticator()} to actually\n     * clean up the internal delegate instance.\n     */\n    protected void beforeRealmsDestroyed() {\n        beforeAuthenticatorDestroyed();\n        destroyAuthenticator();\n    }\n\n    /**\n     * Template hook to allow subclass cleanup when the SecurityManager is being shut down.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n    }\n\n    /**\n     * Cleans up ('destroys') the internal delegate <code>Authenticator</code> instance.  Called during shut down.\n     */\n    protected void destroyAuthenticator() {\n        LifecycleUtils.destroy(getAuthenticator());\n    }\n\n    /**\n     * Delegates to the wrapped {@link Authenticator Authenticator} for authentication.\n     */\n    public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {\n        ensureRealms();\n        return this.authenticator.authenticate(token);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthenticatingSecurityManagerTest1.java",
		"test_prompt": "// AuthenticatingSecurityManagerTest1.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.pam.ModularAuthenticationStrategy;\nimport org.jsecurity.authc.pam.ModularRealmAuthenticator;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticatingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthenticatingSecurityManager#authenticate(AuthenticationToken)} method.\n*/\nclass AuthenticatingSecurityManagerTest1 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest0.java",
		"test_prompt": "// AuthorizingSecurityManagerTest0.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermitted(PrincipalCollection, String)} method.\n*/\nclass AuthorizingSecurityManagerTest0 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest1.java",
		"test_prompt": "// AuthorizingSecurityManagerTest1.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermitted(PrincipalCollection, Permission)} method.\n*/\nclass AuthorizingSecurityManagerTest1 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest2.java",
		"test_prompt": "// AuthorizingSecurityManagerTest2.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermitted(PrincipalCollection, String[])} method.\n*/\nclass AuthorizingSecurityManagerTest2 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest3.java",
		"test_prompt": "// AuthorizingSecurityManagerTest3.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermitted(PrincipalCollection, List)} method.\n*/\nclass AuthorizingSecurityManagerTest3 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest4.java",
		"test_prompt": "// AuthorizingSecurityManagerTest4.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermittedAll(PrincipalCollection, String[])} method.\n*/\nclass AuthorizingSecurityManagerTest4 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest5.java",
		"test_prompt": "// AuthorizingSecurityManagerTest5.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#isPermittedAll(PrincipalCollection, Collection)} method.\n*/\nclass AuthorizingSecurityManagerTest5 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest6.java",
		"test_prompt": "// AuthorizingSecurityManagerTest6.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#hasRole(PrincipalCollection, String)} method.\n*/\nclass AuthorizingSecurityManagerTest6 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest7.java",
		"test_prompt": "// AuthorizingSecurityManagerTest7.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#hasRoles(PrincipalCollection, List)} method.\n*/\nclass AuthorizingSecurityManagerTest7 {"
	},
	{
		"original_code": "// AuthorizingSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,\n * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}\n * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'\n * <tt>Authorizer</tt> instance.\n *\n * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)\n * are left to be implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager implements PermissionResolverAware {\n\n    /**\n     * The wrapped instance to which all of this <tt>SecurityManager</tt> authorization calls are delegated.\n     */\n    protected Authorizer authorizer;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public AuthorizingSecurityManager() {\n        ensureAuthorizer();\n    }\n\n    /**\n     * Returns the underlying wrapped <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt>\n     * implementation delegates all of its authorization calls.\n     *\n     * @return the wrapped <tt>Authorizer</tt> used by this <tt>SecurityManager</tt> implementation.\n     */\n    public Authorizer getAuthorizer() {\n        return authorizer;\n    }\n\n    /**\n     * Sets the underlying <tt>Authorizer</tt> instance to which this <tt>SecurityManager</tt> implementation will\n     * delegate all of its authorization calls.\n     *\n     * @param authorizer the <tt>Authorizer</tt> this <tt>SecurityManager</tt> should wrap and delegate all of its\n     *                   authorization calls to.\n     */\n    public void setAuthorizer(Authorizer authorizer) {\n        if (authorizer == null) {\n            String msg = \"Authorizer argument cannot be null.\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.authorizer = authorizer;\n    }\n\n    /**\n     * Ensures that this instance's {@link Authorizer Authorizer} has been\n     * set, and if not, lazily creates one via the {@link #createAuthorizer() createAuthorizer()} method and then\n     * immediately sets it via the {@link #setAuthorizer(org.jsecurity.authz.Authorizer) setAuthorizer} method.\n     */\n    protected void ensureAuthorizer() {\n        Authorizer authorizer = getAuthorizer();\n        if (authorizer == null) {\n            authorizer = createAuthorizer();\n            setAuthorizer(authorizer);\n        }\n    }\n\n    /**\n     * Creates a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     * <p/>\n     * This default implementation merely returns\n     * <code>new {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}()</code>\n     * @return a new {@link Authorizer Authorizer} instance to be used by this <code>AuthorizingSecurityManager</code> instance.\n     */\n    protected Authorizer createAuthorizer() {\n        return new ModularRealmAuthorizer();\n    }\n\n    /**\n     * Sets the <tt>PermissionResolver</tt> instance that will be passed on to the underlying default wrapped\n     * {@link Authorizer Authorizer}.\n     *\n     * <p>This is a convenience method:  it allows you to configure an application-wide\n     * <tt>PermissionResolver</tt> on the <tt>SecurityManager</tt> instance, and it will trickle its way down to the\n     * 'real' authorizer and/or underlying Realms.  This is easier to configure at the <tt>SecurityManager</tt> level\n     * than constructing your own object graph just to configure a <tt>PermissionResolver</tt> instance on objects\n     * deep in the graph.\n     *\n     * @param permissionResolver the <tt>PermissionResolver</tt> instance to set on the wrapped <tt>Authorizer</tt>\n     * @throws IllegalStateException if the underlying <code>Authorizer</code> does not implement the\n     *                               {@link PermissionResolverAware PermissionResolverAware} interface, which ensures that the resolver can be registered.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof PermissionResolverAware) {\n            ((PermissionResolverAware) authz).setPermissionResolver(permissionResolver);\n        } else {\n            String msg = \"Underlying Authorizer instance does not implement the \" + PermissionResolverAware.class.getName() + \" interface.  This is required to support \" + \"passthrough configuration of a PermissionResolver.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * First calls <code>super.realms</code> and then sets these same <code>Realm</code> objects on this instance's\n     * {@link Authorizer Authorizer}.\n     * <p/>\n     * The setting on the Authorizer will only occur if it is an instance of\n     * {@link org.jsecurity.authz.ModularRealmAuthorizer ModularRealmAuthorizer}, that is:\n     * <pre>       Authorizer authz = getAuthorizer();\n     * if ( authz instanceof ModularRealmAuthorizer ) {\n     *     ((ModularRealmAuthorizer)authz).setRealms(realms);\n     * }</pre>\n     * @param realms the realms managed by this <tt>SecurityManager</tt> instance.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        super.setRealms(realms);\n        Authorizer authz = getAuthorizer();\n        if (authz instanceof ModularRealmAuthorizer) {\n            ((ModularRealmAuthorizer) authz).setRealms(realms);\n        }\n    }\n\n    /**\n     * Template hook for subclasses to implement destruction/cleanup logic.  This will be called before this\n     * instance's <tt>Authorizer</tt> instance will be cleaned up.\n     */\n    protected void beforeAuthorizerDestroyed() {\n    }\n\n    /**\n     * Cleanup method that destroys/cleans up the wrapped {@link #getAuthorizer Authorizer} instance.\n     * <p/>\n     * The default implementation merely delegates to\n     * <code>{@link LifecycleUtils#destroy LifecycleUtils.destroy}({@link #getAuthorizer getAuthorizer()})</code>.\n     */\n    protected void destroyAuthorizer() {\n        LifecycleUtils.destroy(getAuthorizer());\n    }\n\n    /**\n     * Implementation of parent class's template hook for destruction/cleanup logic.\n     *\n     * <p>This implementation ensures subclasses are cleaned up first by calling\n     * {@link #beforeAuthorizerDestroyed() beforeAuthorizerDestroyed()} and then actually cleans up the\n     * wrapped <tt>Authorizer</tt> via the {@link #destroyAuthorizer() desroyAuthorizer()} method.\n     */\n    protected void beforeAuthenticatorDestroyed() {\n        beforeAuthorizerDestroyed();\n        destroyAuthorizer();\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permissionString) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissionString);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permission);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermitted(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        ensureRealms();\n        return getAuthorizer().isPermittedAll(principals, permissions);\n    }\n\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermission(principals, permission);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkPermissions(principals, permissions);\n    }\n\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        ensureRealms();\n        return getAuthorizer().hasRole(principals, roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasRoles(principals, roleIdentifiers);\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        ensureRealms();\n        return getAuthorizer().hasAllRoles(principals, roleIdentifiers);\n    }\n\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRole(principals, role);\n    }\n\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        ensureRealms();\n        getAuthorizer().checkRoles(principals, roles);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/AuthorizingSecurityManagerTest8.java",
		"test_prompt": "// AuthorizingSecurityManagerTest8.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.authz.ModularRealmAuthorizer;\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingSecurityManager}.\n* It contains ten unit test cases for the {@link AuthorizingSecurityManager#hasAllRoles(PrincipalCollection, Collection)} method.\n*/\nclass AuthorizingSecurityManagerTest8 {"
	},
	{
		"original_code": "// SessionsSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionListener;\nimport org.jsecurity.session.SessionListenerRegistrar;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * {@link org.jsecurity.session.Session session} operations to a wrapped {@link SessionManager SessionManager}\n * instance.  That is, this class implements the methods in the\n * {@link SessionManager SessionManager} interface, but in reality, those methods are merely passthrough calls to\n * the underlying 'real' <tt>SessionManager</tt> instance.\n *\n * <p>The remaining <tt>SecurityManager</tt> methods not implemented by this class or its parents are left to be\n * implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class SessionsSecurityManager extends AuthorizingSecurityManager implements SessionListenerRegistrar {\n\n    /**\n     * The internal delegate <code>SessionManager</code> used by this security manager that manages all the\n     * application's {@link Session Session}s.\n     */\n    protected SessionManager sessionManager;\n\n    /**\n     * Default no-arg constructor, internally creates a suitable default {@link SessionManager SessionManager} delegate\n     * instance via the {@link #ensureSessionManager() ensureSessionManager()} method.\n     */\n    public SessionsSecurityManager() {\n        ensureSessionManager();\n    }\n\n    /**\n     * Sets the underlying delegate {@link SessionManager} instance that will be used to support this implementation's\n     * <tt>SessionManager</tt> method calls.\n     *\n     * <p>This <tt>SecurityManager</tt> implementation does not provide logic to support the inherited\n     * <tt>SessionManager</tt> interface, but instead delegates these calls to an internal\n     * <tt>SessionManager</tt> instance.\n     *\n     * <p>If a <tt>SessionManager</tt> instance is not set, a default one will be automatically created and\n     * initialized appropriately for the the existing runtime environment.\n     *\n     * @param sessionManager delegate instance to use to support this manager's <tt>SessionManager</tt> method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    /**\n     * Returns this security manager's internal delegate {@link SessionManager SessionManager}.\n     * @return this security manager's internal delegate {@link SessionManager SessionManager}.\n     * @see #setSessionManager(org.jsecurity.session.mgt.SessionManager) setSessionManager\n     */\n    public SessionManager getSessionManager() {\n        return this.sessionManager;\n    }\n\n    /**\n     * Ensures that the internal delegate <code>SessionManager</code> exists, and if not, calls\n     * {@link #createSessionManager createSessionManager} and sets the resulting instance via the\n     * {@link #setSessionManager(org.jsecurity.session.mgt.SessionManager) setSessionManager} method.\n     */\n    protected void ensureSessionManager() {\n        SessionManager sessionManager = getSessionManager();\n        if (sessionManager == null) {\n            sessionManager = createSessionManager();\n            setSessionManager(sessionManager);\n        }\n    }\n\n    /**\n     * Constructs a new <code>SessionManager</code> instance to be used as the internal delegate for this security\n     * manager.  After creation via the {@link #newSessionManagerInstance() newSessionManagerInstance()} call, the\n     * internal {@link #getCacheManager CacheManager} is set on it if the session manager instance implements the\n     * {@link CacheManagerAware CacheManagerAware} interface to allow it to utilize the cache manager for its own\n     * internal caching needs.\n     *\n     * @return a new initialized {@link SessionManager SessionManager} to use as this security manager's internal\n     * delegate.\n     */\n    protected SessionManager createSessionManager() {\n        SessionManager sm = newSessionManagerInstance();\n        CacheManager cm = getCacheManager();\n        if (cm != null) {\n            if (sm instanceof CacheManagerAware) {\n                ((CacheManagerAware) sm).setCacheManager(cm);\n            }\n        }\n        return sm;\n    }\n\n    /**\n     * Merely instantiates (but does not initalize) the default <code>SessionManager</code> implementation.  This method\n     * merely returns <code>new {@link DefaultSessionManager DefaultSessionManager}()</code>.\n     * @return a new, uninitialized {@link SessionManager SessionManager} instance.\n     */\n    protected SessionManager newSessionManagerInstance() {\n        return new DefaultSessionManager();\n    }\n\n    /**\n     * Calls {@link AuthorizingSecurityManager#afterCacheManagerSet() super.afterCacheManagerSet()} and then immediately calls\n     * {@link #applyCacheManagerToSessionManager() applyCacheManagerToSessionManager()} to ensure the\n     * <code>CacheManager</code> is applied to the SessionManager as necessary.\n     */\n    protected void afterCacheManagerSet() {\n        super.afterCacheManagerSet();\n        applyCacheManagerToSessionManager();\n    }\n\n    /**\n     * Ensures the internal delegate <code>SessionManager</code> is injected with the newly set\n     * {@link #setCacheManager CacheManager} so it may use it for its internal caching needs.\n     * <p/>\n     * Note:  This implementation only injects the CacheManager into the SessionManager if the SessionManager\n     * instance implements the {@link CacheManagerAware CacheManagerAware} interface.\n     */\n    protected void applyCacheManagerToSessionManager() {\n        SessionManager sm = getSessionManager();\n        if (sm instanceof CacheManagerAware) {\n            ((CacheManagerAware) sm).setCacheManager(cacheManager);\n        }\n    }\n\n    /**\n     * This is a convenience method that allows registration of SessionListeners with the underlying delegate\n     * SessionManager at startup.\n     *\n     * <p>This is more convenient than having to configure your own SessionManager instance, inject the listeners on\n     * it, and then set that SessionManager instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager</tt> to apply these <tt>SessionListener</tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying SessionManager delegate must implement the\n     * {@link SessionListenerRegistrar SessionListenerRegistrar} interface in order for these listeners to\n     * be applied.  If it does not implement this interface, it is considered a configuration error and an exception\n     * will be thrown.\n     *\n     * @param sessionListeners the <tt>SessionListener</tt>s to register with the underlying delegate\n     *                         <tt>SessionManager</tt> at startup.\n     */\n    public void setSessionListeners(Collection<SessionListener> sessionListeners) {\n        assertSessionListenerSupport();\n        ((SessionListenerRegistrar) this.sessionManager).setSessionListeners(sessionListeners);\n    }\n\n    /**\n     * Ensures the internal SessionManager instance is an <code>instanceof</code>\n     * {@link org.jsecurity.session.SessionListenerRegistrar SessionListenerRegistrar} to ensure that any\n     * listeners attempting to be registered can actually do so with the internal delegate instance.\n     * @throws IllegalStateException if the internal delegate SessionManager instance does not implement the\n     * <code>SessionListenerRegistrar</code> interface.\n     */\n    private void assertSessionListenerSupport() throws IllegalStateException {\n        if (!(this.sessionManager instanceof SessionListenerRegistrar)) {\n            String msg = \"SessionListener registration failed:  The underlying SessionManager instance of \" + \"type [\" + sessionManager.getClass().getName() + \"] does not implement the \" + SessionListenerRegistrar.class.getName() + \" interface and therefore cannot support \" + \"session notifications.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Asserts the internal delegate <code>SessionManager</code> instance\n     * {@link #assertSessionListenerSupport() supports session listener registration} and then\n     * {@link SessionListenerRegistrar#add adds} the listener to the\n     * delegate instance.\n     * @param listener the <code>SessionListener</code> to register for session events.\n     */\n    public void add(SessionListener listener) {\n        assertSessionListenerSupport();\n        SessionManager sm = getSessionManager();\n        ((SessionListenerRegistrar) sm).add(listener);\n    }\n\n    /**\n     * Removes the specified listener from receiving session events from the internal delegate\n     * {@link SessionManager} instance.\n     *\n     * @param listener the listener to remove that no longer wishes to be notified of session events.\n     * @return <code>true</code> if the listener was removed from the internal delegate <code>SessionManager</code>\n     * instance, <code>false</code> otherwise.\n     */\n    public boolean remove(SessionListener listener) {\n        SessionManager sm = getSessionManager();\n        return (sm instanceof SessionListenerRegistrar) && ((SessionListenerRegistrar) sm).remove(listener);\n    }\n\n    /**\n     * Template hook for subclasses that wish to perform clean up behavior during shutdown.\n     */\n    protected void beforeSessionManagerDestroyed() {\n    }\n\n    /**\n     * Cleans up ('destroys') the internal delegate <code>SessionManager</code> by calling\n     * {@link LifecycleUtils#destroy LifecycleUtils.destroy(getSessionManager())}.\n     */\n    protected void destroySessionManager() {\n        LifecycleUtils.destroy(getSessionManager());\n    }\n\n    /**\n     * Calls {@link #beforeSessionManagerDestroyed() beforeSessionManagerDestroyed()} to allow subclass clean up and\n     * then immediatley calls {@link #destroySessionManager() destroySessionManager()} to clean up the internal\n     * delegate instance.\n     */\n    protected void beforeAuthorizerDestroyed() {\n        beforeSessionManagerDestroyed();\n        destroySessionManager();\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        SessionManager sm = getSessionManager();\n        Serializable sessionId = sm.start(hostAddress);\n        return new DelegatingSession(sm, sessionId);\n    }\n\n    public Session getSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        SessionManager sm = getSessionManager();\n        if (!sm.isValid(sessionId)) {\n            String msg = \"Specified id [\" + sessionId + \"] does not correspond to a valid Session  It either \" + \"does not exist or the corresponding session has been stopped or expired.\";\n            throw new InvalidSessionException(msg, sessionId);\n        }\n        return new DelegatingSession(sm, sessionId);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/SessionsSecurityManagerTest0.java",
		"test_prompt": "// SessionsSecurityManagerTest0.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionListener;\nimport org.jsecurity.session.SessionListenerRegistrar;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SessionsSecurityManager}.\n* It contains ten unit test cases for the {@link SessionsSecurityManager#remove(SessionListener)} method.\n*/\nclass SessionsSecurityManagerTest0 {"
	},
	{
		"original_code": "// SessionsSecurityManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionListener;\nimport org.jsecurity.session.SessionListenerRegistrar;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * JSecurity support of a {@link SecurityManager} class hierarchy that delegates all\n * {@link org.jsecurity.session.Session session} operations to a wrapped {@link SessionManager SessionManager}\n * instance.  That is, this class implements the methods in the\n * {@link SessionManager SessionManager} interface, but in reality, those methods are merely passthrough calls to\n * the underlying 'real' <tt>SessionManager</tt> instance.\n *\n * <p>The remaining <tt>SecurityManager</tt> methods not implemented by this class or its parents are left to be\n * implemented by subclasses.\n *\n * <p>In keeping with the other classes in this hierarchy and JSecurity's desire to minimize configuration whenever\n * possible, suitable default instances for all dependencies will be created upon instantiation.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class SessionsSecurityManager extends AuthorizingSecurityManager implements SessionListenerRegistrar {\n\n    /**\n     * The internal delegate <code>SessionManager</code> used by this security manager that manages all the\n     * application's {@link Session Session}s.\n     */\n    protected SessionManager sessionManager;\n\n    /**\n     * Default no-arg constructor, internally creates a suitable default {@link SessionManager SessionManager} delegate\n     * instance via the {@link #ensureSessionManager() ensureSessionManager()} method.\n     */\n    public SessionsSecurityManager() {\n        ensureSessionManager();\n    }\n\n    /**\n     * Sets the underlying delegate {@link SessionManager} instance that will be used to support this implementation's\n     * <tt>SessionManager</tt> method calls.\n     *\n     * <p>This <tt>SecurityManager</tt> implementation does not provide logic to support the inherited\n     * <tt>SessionManager</tt> interface, but instead delegates these calls to an internal\n     * <tt>SessionManager</tt> instance.\n     *\n     * <p>If a <tt>SessionManager</tt> instance is not set, a default one will be automatically created and\n     * initialized appropriately for the the existing runtime environment.\n     *\n     * @param sessionManager delegate instance to use to support this manager's <tt>SessionManager</tt> method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    /**\n     * Returns this security manager's internal delegate {@link SessionManager SessionManager}.\n     * @return this security manager's internal delegate {@link SessionManager SessionManager}.\n     * @see #setSessionManager(org.jsecurity.session.mgt.SessionManager) setSessionManager\n     */\n    public SessionManager getSessionManager() {\n        return this.sessionManager;\n    }\n\n    /**\n     * Ensures that the internal delegate <code>SessionManager</code> exists, and if not, calls\n     * {@link #createSessionManager createSessionManager} and sets the resulting instance via the\n     * {@link #setSessionManager(org.jsecurity.session.mgt.SessionManager) setSessionManager} method.\n     */\n    protected void ensureSessionManager() {\n        SessionManager sessionManager = getSessionManager();\n        if (sessionManager == null) {\n            sessionManager = createSessionManager();\n            setSessionManager(sessionManager);\n        }\n    }\n\n    /**\n     * Constructs a new <code>SessionManager</code> instance to be used as the internal delegate for this security\n     * manager.  After creation via the {@link #newSessionManagerInstance() newSessionManagerInstance()} call, the\n     * internal {@link #getCacheManager CacheManager} is set on it if the session manager instance implements the\n     * {@link CacheManagerAware CacheManagerAware} interface to allow it to utilize the cache manager for its own\n     * internal caching needs.\n     *\n     * @return a new initialized {@link SessionManager SessionManager} to use as this security manager's internal\n     * delegate.\n     */\n    protected SessionManager createSessionManager() {\n        SessionManager sm = newSessionManagerInstance();\n        CacheManager cm = getCacheManager();\n        if (cm != null) {\n            if (sm instanceof CacheManagerAware) {\n                ((CacheManagerAware) sm).setCacheManager(cm);\n            }\n        }\n        return sm;\n    }\n\n    /**\n     * Merely instantiates (but does not initalize) the default <code>SessionManager</code> implementation.  This method\n     * merely returns <code>new {@link DefaultSessionManager DefaultSessionManager}()</code>.\n     * @return a new, uninitialized {@link SessionManager SessionManager} instance.\n     */\n    protected SessionManager newSessionManagerInstance() {\n        return new DefaultSessionManager();\n    }\n\n    /**\n     * Calls {@link AuthorizingSecurityManager#afterCacheManagerSet() super.afterCacheManagerSet()} and then immediately calls\n     * {@link #applyCacheManagerToSessionManager() applyCacheManagerToSessionManager()} to ensure the\n     * <code>CacheManager</code> is applied to the SessionManager as necessary.\n     */\n    protected void afterCacheManagerSet() {\n        super.afterCacheManagerSet();\n        applyCacheManagerToSessionManager();\n    }\n\n    /**\n     * Ensures the internal delegate <code>SessionManager</code> is injected with the newly set\n     * {@link #setCacheManager CacheManager} so it may use it for its internal caching needs.\n     * <p/>\n     * Note:  This implementation only injects the CacheManager into the SessionManager if the SessionManager\n     * instance implements the {@link CacheManagerAware CacheManagerAware} interface.\n     */\n    protected void applyCacheManagerToSessionManager() {\n        SessionManager sm = getSessionManager();\n        if (sm instanceof CacheManagerAware) {\n            ((CacheManagerAware) sm).setCacheManager(cacheManager);\n        }\n    }\n\n    /**\n     * This is a convenience method that allows registration of SessionListeners with the underlying delegate\n     * SessionManager at startup.\n     *\n     * <p>This is more convenient than having to configure your own SessionManager instance, inject the listeners on\n     * it, and then set that SessionManager instance as an attribute of this class.  Instead, you can just rely\n     * on the <tt>SecurityManager</tt> to apply these <tt>SessionListener</tt>s on your behalf.\n     *\n     * <p>One notice however: The underlying SessionManager delegate must implement the\n     * {@link SessionListenerRegistrar SessionListenerRegistrar} interface in order for these listeners to\n     * be applied.  If it does not implement this interface, it is considered a configuration error and an exception\n     * will be thrown.\n     *\n     * @param sessionListeners the <tt>SessionListener</tt>s to register with the underlying delegate\n     *                         <tt>SessionManager</tt> at startup.\n     */\n    public void setSessionListeners(Collection<SessionListener> sessionListeners) {\n        assertSessionListenerSupport();\n        ((SessionListenerRegistrar) this.sessionManager).setSessionListeners(sessionListeners);\n    }\n\n    /**\n     * Ensures the internal SessionManager instance is an <code>instanceof</code>\n     * {@link org.jsecurity.session.SessionListenerRegistrar SessionListenerRegistrar} to ensure that any\n     * listeners attempting to be registered can actually do so with the internal delegate instance.\n     * @throws IllegalStateException if the internal delegate SessionManager instance does not implement the\n     * <code>SessionListenerRegistrar</code> interface.\n     */\n    private void assertSessionListenerSupport() throws IllegalStateException {\n        if (!(this.sessionManager instanceof SessionListenerRegistrar)) {\n            String msg = \"SessionListener registration failed:  The underlying SessionManager instance of \" + \"type [\" + sessionManager.getClass().getName() + \"] does not implement the \" + SessionListenerRegistrar.class.getName() + \" interface and therefore cannot support \" + \"session notifications.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Asserts the internal delegate <code>SessionManager</code> instance\n     * {@link #assertSessionListenerSupport() supports session listener registration} and then\n     * {@link SessionListenerRegistrar#add adds} the listener to the\n     * delegate instance.\n     * @param listener the <code>SessionListener</code> to register for session events.\n     */\n    public void add(SessionListener listener) {\n        assertSessionListenerSupport();\n        SessionManager sm = getSessionManager();\n        ((SessionListenerRegistrar) sm).add(listener);\n    }\n\n    /**\n     * Removes the specified listener from receiving session events from the internal delegate\n     * {@link SessionManager} instance.\n     *\n     * @param listener the listener to remove that no longer wishes to be notified of session events.\n     * @return <code>true</code> if the listener was removed from the internal delegate <code>SessionManager</code>\n     * instance, <code>false</code> otherwise.\n     */\n    public boolean remove(SessionListener listener) {\n        SessionManager sm = getSessionManager();\n        return (sm instanceof SessionListenerRegistrar) && ((SessionListenerRegistrar) sm).remove(listener);\n    }\n\n    /**\n     * Template hook for subclasses that wish to perform clean up behavior during shutdown.\n     */\n    protected void beforeSessionManagerDestroyed() {\n    }\n\n    /**\n     * Cleans up ('destroys') the internal delegate <code>SessionManager</code> by calling\n     * {@link LifecycleUtils#destroy LifecycleUtils.destroy(getSessionManager())}.\n     */\n    protected void destroySessionManager() {\n        LifecycleUtils.destroy(getSessionManager());\n    }\n\n    /**\n     * Calls {@link #beforeSessionManagerDestroyed() beforeSessionManagerDestroyed()} to allow subclass clean up and\n     * then immediatley calls {@link #destroySessionManager() destroySessionManager()} to clean up the internal\n     * delegate instance.\n     */\n    protected void beforeAuthorizerDestroyed() {\n        beforeSessionManagerDestroyed();\n        destroySessionManager();\n    }\n\n    public Session start(InetAddress hostAddress) throws HostUnauthorizedException, IllegalArgumentException {\n        SessionManager sm = getSessionManager();\n        Serializable sessionId = sm.start(hostAddress);\n        return new DelegatingSession(sm, sessionId);\n    }\n\n    public Session getSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {\n        SessionManager sm = getSessionManager();\n        if (!sm.isValid(sessionId)) {\n            String msg = \"Specified id [\" + sessionId + \"] does not correspond to a valid Session  It either \" + \"does not exist or the corresponding session has been stopped or expired.\";\n            throw new InvalidSessionException(msg, sessionId);\n        }\n        return new DelegatingSession(sm, sessionId);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/SessionsSecurityManagerTest1.java",
		"test_prompt": "// SessionsSecurityManagerTest1.java\npackage org.jsecurity.mgt;\n\nimport org.jsecurity.authz.AuthorizationException;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.SessionListener;\nimport org.jsecurity.session.SessionListenerRegistrar;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.DelegatingSession;\nimport org.jsecurity.session.mgt.SessionManager;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SessionsSecurityManager}.\n* It contains ten unit test cases for the {@link SessionsSecurityManager#start(InetAddress)} method.\n*/\nclass SessionsSecurityManagerTest1 {"
	},
	{
		"original_code": "// DefaultSecurityManager.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.mgt;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.authc.*;\r\nimport org.jsecurity.authz.Authorizer;\r\nimport org.jsecurity.crypto.Cipher;\r\nimport org.jsecurity.realm.Realm;\r\nimport org.jsecurity.session.InvalidSessionException;\r\nimport org.jsecurity.session.Session;\r\nimport org.jsecurity.subject.*;\r\nimport org.jsecurity.util.ThreadContext;\r\nimport java.net.InetAddress;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * <p>The JSecurity framework's default concrete implementation of the {@link SecurityManager} interface,\r\n * based around a collection of {@link org.jsecurity.realm.Realm}s.  This implementation delegates its\r\n * authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and\r\n * {@link org.jsecurity.session.mgt.SessionManager SessionManager} instances respectively via superclass\r\n * implementation.</p>\r\n *\r\n * <p>To greatly reduce and simplify configuration, this implementation (and its superclasses) will\r\n * create suitable defaults for <em>all</em> of its required dependencies.  Therefore, you only need to override\r\n * attributes for custom behavior.  But, note the following:</p>\r\n *\r\n * <p>Unless you're happy with the default simple {@link org.jsecurity.realm.text.PropertiesRealm properties file}-based realm, which may or\r\n * may not be flexible enough for enterprise applications, you might want to specify at least one custom\r\n * <tt>Realm</tt> implementation that 'knows' about your application's data/security model\r\n * (via {@link #setRealm} or one of the overloaded constructors).  All other attributes in this class hierarchy\r\n * will have suitable defaults for most enterprise applications.</p>\r\n *\r\n * <p><b>RememberMe notice</b>: This class supports the ability to configure a\r\n * {@link #setRememberMeManager RememberMeManager}\r\n * for <tt>RememberMe</tt> identity services for login/logout, BUT, a default instance <em>will not</em> be created\r\n * for this attribute at startup.\r\n *\r\n * <p>Because RememberMe services are inherently client tier-specific and\r\n * therefore aplication-dependent, if you want <tt>RememberMe</tt> services enabled, you will have to specify an\r\n * instance yourself via the {@link #setRememberMeManager(org.jsecurity.subject.RememberMeManager) setRememberMeManager}\r\n * mutator.  However if you're reading this JavaDoc with the\r\n * expectation of operating in a Web environment, take a look at the\r\n * {@link org.jsecurity.web.DefaultWebSecurityManager DefaultWebSecurityManager} implementation, which\r\n * <em>does</em> support <tt>RememberMe</tt> services by default at startup.\r\n *\r\n * @author Les Hazlewood\r\n * @author Jeremy Haile\r\n * @see org.jsecurity.web.DefaultWebSecurityManager\r\n * @since 0.2\r\n */\r\npublic class DefaultSecurityManager extends SessionsSecurityManager {\r\n\r\n    //TODO - complete JavaDoc\r\n    private static final Log log = LogFactory.getLog(DefaultSecurityManager.class);\r\n\r\n    protected RememberMeManager rememberMeManager;\r\n\r\n    /**\r\n     * Default no-arg constructor.\r\n     */\r\n    public DefaultSecurityManager() {\r\n    }\r\n\r\n    /**\r\n     * Supporting constructor for a single-realm application.\r\n     *\r\n     * @param singleRealm the single realm used by this SecurityManager.\r\n     */\r\n    public DefaultSecurityManager(Realm singleRealm) {\r\n        setRealm(singleRealm);\r\n    }\r\n\r\n    /**\r\n     * Supporting constructor for multiple {@link #setRealms realms}.\r\n     *\r\n     * @param realms the realm instances backing this SecurityManager.\r\n     */\r\n    public DefaultSecurityManager(Collection<Realm> realms) {\r\n        setRealms(realms);\r\n    }\r\n\r\n    public RememberMeManager getRememberMeManager() {\r\n        return rememberMeManager;\r\n    }\r\n\r\n    public void setRememberMeManager(RememberMeManager rememberMeManager) {\r\n        this.rememberMeManager = rememberMeManager;\r\n    }\r\n\r\n    private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\r\n        RememberMeManager rmm = getRememberMeManager();\r\n        if (!(rmm instanceof AbstractRememberMeManager)) {\r\n            String msg = \"The convenience passthrough methods for setting remember me cipher attributes \" + \"are only available when the underlying RememberMeManager implementation is a subclass of \" + AbstractRememberMeManager.class.getName() + \".\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n        return (AbstractRememberMeManager) rmm;\r\n    }\r\n\r\n    public void setRememberMeCipher(Cipher cipher) {\r\n        getRememberMeManagerForCipherAttributes().setCipher(cipher);\r\n    }\r\n\r\n    public void setRememberMeCipherKey(byte[] bytes) {\r\n        getRememberMeManagerForCipherAttributes().setCipherKey(bytes);\r\n    }\r\n\r\n    public void setRememberMeCipherKeyHex(String hex) {\r\n        getRememberMeManagerForCipherAttributes().setCipherKeyHex(hex);\r\n    }\r\n\r\n    public void setRememberMeCipherKeyBase64(String base64) {\r\n        getRememberMeManagerForCipherAttributes().setCipherKeyBase64(base64);\r\n    }\r\n\r\n    public void setRememberMeEncryptionCipherKey(byte[] bytes) {\r\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKey(bytes);\r\n    }\r\n\r\n    public void setRememberMeEncryptionCipherKeyHex(String hex) {\r\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyHex(hex);\r\n    }\r\n\r\n    public void setRememberMeEncryptionCipherKeyBase64(String base64) {\r\n        getRememberMeManagerForCipherAttributes().setEncryptionCipherKeyBase64(base64);\r\n    }\r\n\r\n    public void setRememberMeDecryptionCipherKey(byte[] bytes) {\r\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKey(bytes);\r\n    }\r\n\r\n    public void setRememberMeDecryptionCipherKeyHex(String hex) {\r\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyHex(hex);\r\n    }\r\n\r\n    public void setRememberMeDecryptionCipherKeyBase64(String base64) {\r\n        getRememberMeManagerForCipherAttributes().setDecryptionCipherKeyBase64(base64);\r\n    }\r\n\r\n    private void assertPrincipals(AuthenticationInfo info) {\r\n        PrincipalCollection principals = info.getPrincipals();\r\n        if (principals == null || principals.isEmpty()) {\r\n            String msg = \"Authentication info returned from Authenticator must have non null and non empty principals.\";\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n    }\r\n\r\n    protected Subject createSubject() {\r\n        PrincipalCollection principals = getRememberedIdentity();\r\n        return createSubject(principals);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection subjectPrincipals) {\r\n        return createSubject(subjectPrincipals, null);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, Session existing) {\r\n        return createSubject(principals, existing, false);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, Session existing, boolean authenticated) {\r\n        return createSubject(principals, existing, authenticated, null);\r\n    }\r\n\r\n    protected Subject createSubject(PrincipalCollection principals, Session existing, boolean authenticated, InetAddress inetAddress) {\r\n        return new DelegatingSubject(principals, authenticated, inetAddress, existing, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a <tt>Subject</tt> instance for the user represented by the given method arguments.\r\n     *\r\n     * @param token the <tt>AuthenticationToken</tt> submitted for the successful authentication.\r\n     * @param info  the <tt>AuthenticationInfo</tt> of a newly authenticated user.\r\n     * @return the <tt>Subject</tt> instance that represents the user and session data for the newly\r\n     *         authenticated user.\r\n     */\r\n    protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {\r\n        assertPrincipals(info);\r\n        //get any existing session that may exist - we don't want to lose it:\r\n        Subject subject = getSubject(false);\r\n        Session session = null;\r\n        if (subject != null) {\r\n            session = subject.getSession(false);\r\n        }\r\n        InetAddress authcSourceIP = null;\r\n        if (token instanceof InetAuthenticationToken) {\r\n            authcSourceIP = ((InetAuthenticationToken) token).getInetAddress();\r\n        }\r\n        if (authcSourceIP == null) {\r\n            //try the thread local:\r\n            authcSourceIP = ThreadContext.getInetAddress();\r\n        }\r\n        return createSubject(info.getPrincipals(), session, true, authcSourceIP);\r\n    }\r\n\r\n    /**\r\n     * Binds a <tt>Subject</tt> instance created after authentication to the application for later use.\r\n     *\r\n     * <p>The default implementation merely binds the argument to the thread local via the {@link ThreadContext}.\r\n     * Should be overridden by subclasses for environment-specific binding (e.g. web environment, etc).\r\n     *\r\n     * @param subject the <tt>Subject</tt> instance created after authentication to be bound to the application\r\n     *                for later use.\r\n     */\r\n    protected void bind(Subject subject) {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Binding Subject [\" + subject + \"] to a thread local...\");\r\n        }\r\n        ThreadContext.bind(subject);\r\n    }\r\n\r\n    private void assertCreation(Subject subject) throws IllegalStateException {\r\n        if (subject == null) {\r\n            String msg = \"Programming error - please verify that you have overridden the \" + getClass().getName() + \".createSubject( AuthenticationInfo info ) method to return \" + \"a non-null Subject instance\";\r\n            throw new IllegalStateException(msg);\r\n        }\r\n    }\r\n\r\n    protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\r\n        RememberMeManager rmm = getRememberMeManager();\r\n        if (rmm != null) {\r\n            try {\r\n                rmm.onSuccessfulLogin(token, info);\r\n            } catch (Exception e) {\r\n                if (log.isWarnEnabled()) {\r\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() + \"] threw an exception during onSuccessfulLogin.  RememberMe services will not be \" + \"performed for account [\" + info + \"].\";\r\n                    log.warn(msg, e);\r\n                }\r\n            }\r\n        } else {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"This \" + getClass().getName() + \" instance does not have a \" + \"[\" + RememberMeManager.class.getName() + \"] instance configured.  RememberMe services \" + \"will not be performed for account [\" + info + \"].\");\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex) {\r\n        RememberMeManager rmm = getRememberMeManager();\r\n        if (rmm != null) {\r\n            try {\r\n                rmm.onFailedLogin(token, ex);\r\n            } catch (Exception e) {\r\n                if (log.isWarnEnabled()) {\r\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() + \"] threw an exception during onFailedLogin for AuthenticationToken [\" + token + \"].\";\r\n                    log.warn(msg, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void rememberMeLogout(PrincipalCollection subjectPrincipals) {\r\n        RememberMeManager rmm = getRememberMeManager();\r\n        if (rmm != null) {\r\n            try {\r\n                rmm.onLogout(subjectPrincipals);\r\n            } catch (Exception e) {\r\n                if (log.isWarnEnabled()) {\r\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() + \"] threw an exception during onLogout for subject with principals [\" + subjectPrincipals + \"]\";\r\n                    log.warn(msg, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * First authenticates the <tt>AuthenticationToken</tt> argument, and if successful, constructs a\r\n     * <tt>Subject</tt> instance representing the authenticated account's identity.\r\n     *\r\n     * <p>Once constructed, the <tt>Subject</tt> instance is then {@link #bind bound} to the application for\r\n     * subsequent access before being returned to the caller.\r\n     *\r\n     * @param token the authenticationToken to process for the login attempt.\r\n     * @return a Subject representing the authenticated user.\r\n     * @throws AuthenticationException if there is a problem authenticating the specified <tt>token</tt>.\r\n     */\r\n    public Subject login(AuthenticationToken token) throws AuthenticationException {\r\n        AuthenticationInfo info;\r\n        try {\r\n            info = authenticate(token);\r\n            onSuccessfulLogin(token, info);\r\n        } catch (AuthenticationException ae) {\r\n            try {\r\n                onFailedLogin(token, ae);\r\n            } catch (Exception e) {\r\n                if (log.isInfoEnabled()) {\r\n                    log.info(\"onFailedLogin(AuthenticationToken,AuthenticationException) method threw an \" + \"exception.  Logging and propagating original AuthenticationException.\", e);\r\n                }\r\n            }\r\n            //propagate\r\n            throw ae;\r\n        }\r\n        Subject subject = createSubject(token, info);\r\n        assertCreation(subject);\r\n        bind(subject);\r\n        return subject;\r\n    }\r\n\r\n    protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info) {\r\n        rememberMeSuccessfulLogin(token, info);\r\n    }\r\n\r\n    protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae) {\r\n        rememberMeFailedLogin(token, ae);\r\n    }\r\n\r\n    protected void beforeLogout(PrincipalCollection subjectIdentifier) {\r\n        rememberMeLogout(subjectIdentifier);\r\n    }\r\n\r\n    public void logout(PrincipalCollection principals) {\r\n        if (principals != null) {\r\n            beforeLogout(principals);\r\n            Authenticator authc = getAuthenticator();\r\n            if (authc instanceof LogoutAware) {\r\n                ((LogoutAware) authc).onLogout(principals);\r\n            }\r\n        }\r\n        //Method arg is ignored - get the Subject from the environment if it exists:\r\n        Subject subject = getSubject(false);\r\n        if (subject != null) {\r\n            try {\r\n                stopSession(subject);\r\n            } catch (Exception e) {\r\n                if (log.isDebugEnabled()) {\r\n                    String msg = \"Unable to cleanly stop Session for Subject [\" + subject.getPrincipal() + \"] \" + \"Ignoring (logging out).\";\r\n                    log.debug(msg, e);\r\n                }\r\n            }\r\n            try {\r\n                unbind(subject);\r\n            } catch (Exception e) {\r\n                if (log.isDebugEnabled()) {\r\n                    String msg = \"Unable to cleanly unbind Subject.  Ignoring (logging out).\";\r\n                    log.debug(msg, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void stopSession(Subject subject) {\r\n        Session s = subject.getSession(false);\r\n        if (s != null) {\r\n            try {\r\n                s.stop();\r\n            } catch (InvalidSessionException ise) {\r\n                //ignored - we're invalidating, and have no further need of the session anyway\r\n                //log just in case someone wants to know:\r\n                if (log.isTraceEnabled()) {\r\n                    log.trace(\"Session has already been invalidated for subject [\" + subject.getPrincipal() + \"].  Ignoring and continuing logout ...\", ise);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void unbind(Subject subject) {\r\n        ThreadContext.unbindSubject();\r\n    }\r\n\r\n    protected PrincipalCollection getRememberedIdentity() {\r\n        RememberMeManager rmm = getRememberMeManager();\r\n        if (rmm != null) {\r\n            try {\r\n                return rmm.getRememberedPrincipals();\r\n            } catch (Exception e) {\r\n                if (log.isWarnEnabled()) {\r\n                    String msg = \"Delegate RememberMeManager instance of type [\" + rmm.getClass().getName() + \"] threw an exception during getRememberedPrincipals().\";\r\n                    log.warn(msg, e);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected Subject getSubject(boolean create) {\r\n        Subject subject = ThreadContext.getSubject();\r\n        if (subject == null && create) {\r\n            subject = createSubject();\r\n            bind(subject);\r\n        }\r\n        return subject;\r\n    }\r\n\r\n    public Subject getSubject() {\r\n        return getSubject(true);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/mgt/DefaultSecurityManagerTest.java",
		"test_prompt": "// DefaultSecurityManagerTest.java\npackage org.jsecurity.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authz.Authorizer;\nimport org.jsecurity.crypto.Cipher;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.*;\nimport org.jsecurity.util.ThreadContext;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultSecurityManager}.\n* It contains ten unit test cases for the {@link DefaultSecurityManager#login(AuthenticationToken)} method.\n*/\nclass DefaultSecurityManagerTest {"
	},
	{
		"original_code": "// JndiLocator.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.jndi;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport javax.naming.NamingException;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Convenient superclass for JNDI accessors, providing \"jndiTemplate\"\r\n * and \"jndiEnvironment\" bean properties.\r\n *\r\n * <p>Note that this implementation is an almost exact combined copy of the Spring Framework's 'JndiAccessor' and\r\n * 'JndiLocatorSupport' classes from their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require\r\n * a full dependency on the Spring framework, nor does Spring make available only its JNDI classes in a small jar, or\r\n * we would have used that. Since JSecurity is also Apache 2.0 licensed, all regular licenses and conditions and\r\n * authors have remained in tact.\r\n *\r\n * @author Juergen Hoeller\r\n * @see #setJndiTemplate\r\n * @see #setJndiEnvironment\r\n * @see #setResourceRef\r\n * @since 1.1\r\n */\r\npublic class JndiLocator {\r\n\r\n    /**\r\n     * Private class log.\r\n     */\r\n    private static final Log log = LogFactory.getLog(JndiLocator.class);\r\n\r\n    /**\r\n     * JNDI prefix used in a J2EE container\r\n     */\r\n    public static final String CONTAINER_PREFIX = \"java:comp/env/\";\r\n\r\n    private boolean resourceRef = false;\r\n\r\n    private JndiTemplate jndiTemplate = new JndiTemplate();\r\n\r\n    /**\r\n     * Set the JNDI template to use for JNDI lookups.\r\n     * <p>You can also specify JNDI environment settings via \"jndiEnvironment\".\r\n     *\r\n     * @see #setJndiEnvironment\r\n     */\r\n    public void setJndiTemplate(JndiTemplate jndiTemplate) {\r\n        this.jndiTemplate = (jndiTemplate != null ? jndiTemplate : new JndiTemplate());\r\n    }\r\n\r\n    /**\r\n     * Return the JNDI template to use for JNDI lookups.\r\n     */\r\n    public JndiTemplate getJndiTemplate() {\r\n        return this.jndiTemplate;\r\n    }\r\n\r\n    /**\r\n     * Set the JNDI environment to use for JNDI lookups.\r\n     * <p>Creates a JndiTemplate with the given environment settings.\r\n     *\r\n     * @see #setJndiTemplate\r\n     */\r\n    public void setJndiEnvironment(Properties jndiEnvironment) {\r\n        this.jndiTemplate = new JndiTemplate(jndiEnvironment);\r\n    }\r\n\r\n    /**\r\n     * Return the JNDI environment to use for JNDI lookups.\r\n     */\r\n    public Properties getJndiEnvironment() {\r\n        return this.jndiTemplate.getEnvironment();\r\n    }\r\n\r\n    /**\r\n     * Set whether the lookup occurs in a J2EE container, i.e. if the prefix\r\n     * \"java:comp/env/\" needs to be added if the JNDI name doesn't already\r\n     * contain it. Default is \"false\".\r\n     * <p>Note: Will only get applied if no other scheme (e.g. \"java:\") is given.\r\n     */\r\n    public void setResourceRef(boolean resourceRef) {\r\n        this.resourceRef = resourceRef;\r\n    }\r\n\r\n    /**\r\n     * Return whether the lookup occurs in a J2EE container.\r\n     */\r\n    public boolean isResourceRef() {\r\n        return this.resourceRef;\r\n    }\r\n\r\n    /**\r\n     * Perform an actual JNDI lookup for the given name via the JndiTemplate.\r\n     * <p>If the name doesn't begin with \"java:comp/env/\", this prefix is added\r\n     * if \"resourceRef\" is set to \"true\".\r\n     *\r\n     * @param jndiName the JNDI name to look up\r\n     * @return the obtained object\r\n     * @throws javax.naming.NamingException if the JNDI lookup failed\r\n     * @see #setResourceRef\r\n     */\r\n    protected Object lookup(String jndiName) throws NamingException {\r\n        return lookup(jndiName, null);\r\n    }\r\n\r\n    /**\r\n     * Perform an actual JNDI lookup for the given name via the JndiTemplate.\r\n     * <p>If the name doesn't begin with \"java:comp/env/\", this prefix is added\r\n     * if \"resourceRef\" is set to \"true\".\r\n     *\r\n     * @param jndiName     the JNDI name to look up\r\n     * @param requiredType the required type of the object\r\n     * @return the obtained object\r\n     * @throws NamingException if the JNDI lookup failed\r\n     * @see #setResourceRef\r\n     */\r\n    protected Object lookup(String jndiName, Class requiredType) throws NamingException {\r\n        if (jndiName == null) {\r\n            throw new IllegalArgumentException(\"jndiName argument must not be null\");\r\n        }\r\n        String convertedName = convertJndiName(jndiName);\r\n        Object jndiObject;\r\n        try {\r\n            jndiObject = getJndiTemplate().lookup(convertedName, requiredType);\r\n        } catch (NamingException ex) {\r\n            if (!convertedName.equals(jndiName)) {\r\n                // Try fallback to originally specified name...\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Converted JNDI name [\" + convertedName + \"] not found - trying original name [\" + jndiName + \"]. \" + ex);\r\n                }\r\n                jndiObject = getJndiTemplate().lookup(jndiName, requiredType);\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Located object with JNDI name [\" + convertedName + \"]\");\r\n        }\r\n        return jndiObject;\r\n    }\r\n\r\n    /**\r\n     * Convert the given JNDI name into the actual JNDI name to use.\r\n     * <p>The default implementation applies the \"java:comp/env/\" prefix if\r\n     * \"resourceRef\" is \"true\" and no other scheme (e.g. \"java:\") is given.\r\n     *\r\n     * @param jndiName the original JNDI name\r\n     * @return the JNDI name to use\r\n     * @see #CONTAINER_PREFIX\r\n     * @see #setResourceRef\r\n     */\r\n    protected String convertJndiName(String jndiName) {\r\n        // Prepend container prefix if not already specified and no other scheme given.\r\n        if (isResourceRef() && !jndiName.startsWith(CONTAINER_PREFIX) && jndiName.indexOf(':') == -1) {\r\n            jndiName = CONTAINER_PREFIX + jndiName;\r\n        }\r\n        return jndiName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/jndi/JndiLocatorTest.java",
		"test_prompt": "// JndiLocatorTest.java\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.NamingException;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JndiLocator}.\n* It contains ten unit test cases for the {@link JndiLocator#isResourceRef()} method.\n*/\nclass JndiLocatorTest {"
	},
	{
		"original_code": "// JndiTemplate.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\n\n/**\n * Helper class that simplifies JNDI operations. It provides methods to lookup and\n * bind objects, and allows implementations of the {@link JndiCallback} interface\n * to perform any operation they like with a JNDI naming context provided.\n *\n * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from\n * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the\n * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.\n * Since JSecurity is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see JndiCallback\n * @see #execute\n */\npublic class JndiTemplate {\n\n    private static final Log log = LogFactory.getLog(JndiTemplate.class);\n\n    private Properties environment;\n\n    /**\n     * Create a new JndiTemplate instance.\n     */\n    public JndiTemplate() {\n    }\n\n    /**\n     * Create a new JndiTemplate instance, using the given environment.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public JndiTemplate(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Set the environment for the JNDI InitialContext.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public void setEnvironment(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     *\n     * @return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     */\n    public Properties getEnvironment() {\n        return this.environment;\n    }\n\n    /**\n     * Execute the given JNDI context callback implementation.\n     *\n     * @param contextCallback JndiCallback implementation\n     * @return a result object returned by the callback, or <code>null</code>\n     * @throws NamingException thrown by the callback implementation\n     * @see #createInitialContext\n     */\n    public Object execute(JndiCallback contextCallback) throws NamingException {\n        Context ctx = createInitialContext();\n        try {\n            return contextCallback.doInContext(ctx);\n        } finally {\n            try {\n                ctx.close();\n            } catch (NamingException ex) {\n                log.debug(\"Could not close JNDI InitialContext\", ex);\n            }\n        }\n    }\n\n    /**\n     * Create a new JNDI initial context. Invoked by {@link #execute}.\n     * <p>The default implementation use this template's environment settings.\n     * Can be subclassed for custom contexts, e.g. for testing.\n     *\n     * @return the initial Context instance\n     * @throws NamingException in case of initialization errors\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    protected Context createInitialContext() throws NamingException {\n        Properties env = getEnvironment();\n        Hashtable icEnv = null;\n        if (env != null) {\n            icEnv = new Hashtable(env.size());\n            for (Enumeration en = env.propertyNames(); en.hasMoreElements(); ) {\n                String key = (String) en.nextElement();\n                icEnv.put(key, env.getProperty(key));\n            }\n        }\n        return new InitialContext(icEnv);\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Looking up JNDI object with name [\" + name + \"]\");\n        }\n        return execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                Object located = ctx.lookup(name);\n                if (located == null) {\n                    throw new NameNotFoundException(\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\");\n                }\n                return located;\n            }\n        });\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name         the JNDI name of the object\n     * @param requiredType type the JNDI object must match. Can be an interface or\n     *                     superclass of the actual class, or <code>null</code> for any match. For example,\n     *                     if the value is <code>Object.class</code>, this method will succeed whatever\n     *                     the class of the returned instance.\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(String name, Class requiredType) throws NamingException {\n        Object jndiObject = lookup(name);\n        if (requiredType != null && !requiredType.isInstance(jndiObject)) {\n            String msg = \"Jndi object acquired under name '\" + name + \"' is of type [\" + jndiObject.getClass().getName() + \"] and not assignable to the required type [\" + requiredType.getName() + \"].\";\n            throw new NamingException(msg);\n        }\n        return jndiObject;\n    }\n\n    /**\n     * Bind the given object to the current JNDI context, using the given name.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to bind\n     * @throws NamingException thrown by JNDI, mostly name already bound\n     */\n    public void bind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Binding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.bind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Rebind the given object to the current JNDI context, using the given name.\n     * Overwrites any existing binding.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to rebind\n     * @throws NamingException thrown by JNDI\n     */\n    public void rebind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.rebind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Remove the binding for the given name from the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @throws NamingException thrown by JNDI, mostly name not found\n     */\n    public void unbind(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Unbinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.unbind(name);\n                return null;\n            }\n        });\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/jndi/JndiTemplateTest0.java",
		"test_prompt": "// JndiTemplateTest0.java\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JndiTemplate}.\n* It contains ten unit test cases for the {@link JndiTemplate#execute(JndiCallback)} method.\n*/\nclass JndiTemplateTest0 {"
	},
	{
		"original_code": "// JndiTemplate.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\n\n/**\n * Helper class that simplifies JNDI operations. It provides methods to lookup and\n * bind objects, and allows implementations of the {@link JndiCallback} interface\n * to perform any operation they like with a JNDI naming context provided.\n *\n * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from\n * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the\n * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.\n * Since JSecurity is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see JndiCallback\n * @see #execute\n */\npublic class JndiTemplate {\n\n    private static final Log log = LogFactory.getLog(JndiTemplate.class);\n\n    private Properties environment;\n\n    /**\n     * Create a new JndiTemplate instance.\n     */\n    public JndiTemplate() {\n    }\n\n    /**\n     * Create a new JndiTemplate instance, using the given environment.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public JndiTemplate(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Set the environment for the JNDI InitialContext.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public void setEnvironment(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     *\n     * @return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     */\n    public Properties getEnvironment() {\n        return this.environment;\n    }\n\n    /**\n     * Execute the given JNDI context callback implementation.\n     *\n     * @param contextCallback JndiCallback implementation\n     * @return a result object returned by the callback, or <code>null</code>\n     * @throws NamingException thrown by the callback implementation\n     * @see #createInitialContext\n     */\n    public Object execute(JndiCallback contextCallback) throws NamingException {\n        Context ctx = createInitialContext();\n        try {\n            return contextCallback.doInContext(ctx);\n        } finally {\n            try {\n                ctx.close();\n            } catch (NamingException ex) {\n                log.debug(\"Could not close JNDI InitialContext\", ex);\n            }\n        }\n    }\n\n    /**\n     * Create a new JNDI initial context. Invoked by {@link #execute}.\n     * <p>The default implementation use this template's environment settings.\n     * Can be subclassed for custom contexts, e.g. for testing.\n     *\n     * @return the initial Context instance\n     * @throws NamingException in case of initialization errors\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    protected Context createInitialContext() throws NamingException {\n        Properties env = getEnvironment();\n        Hashtable icEnv = null;\n        if (env != null) {\n            icEnv = new Hashtable(env.size());\n            for (Enumeration en = env.propertyNames(); en.hasMoreElements(); ) {\n                String key = (String) en.nextElement();\n                icEnv.put(key, env.getProperty(key));\n            }\n        }\n        return new InitialContext(icEnv);\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Looking up JNDI object with name [\" + name + \"]\");\n        }\n        return execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                Object located = ctx.lookup(name);\n                if (located == null) {\n                    throw new NameNotFoundException(\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\");\n                }\n                return located;\n            }\n        });\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name         the JNDI name of the object\n     * @param requiredType type the JNDI object must match. Can be an interface or\n     *                     superclass of the actual class, or <code>null</code> for any match. For example,\n     *                     if the value is <code>Object.class</code>, this method will succeed whatever\n     *                     the class of the returned instance.\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(String name, Class requiredType) throws NamingException {\n        Object jndiObject = lookup(name);\n        if (requiredType != null && !requiredType.isInstance(jndiObject)) {\n            String msg = \"Jndi object acquired under name '\" + name + \"' is of type [\" + jndiObject.getClass().getName() + \"] and not assignable to the required type [\" + requiredType.getName() + \"].\";\n            throw new NamingException(msg);\n        }\n        return jndiObject;\n    }\n\n    /**\n     * Bind the given object to the current JNDI context, using the given name.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to bind\n     * @throws NamingException thrown by JNDI, mostly name already bound\n     */\n    public void bind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Binding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.bind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Rebind the given object to the current JNDI context, using the given name.\n     * Overwrites any existing binding.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to rebind\n     * @throws NamingException thrown by JNDI\n     */\n    public void rebind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.rebind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Remove the binding for the given name from the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @throws NamingException thrown by JNDI, mostly name not found\n     */\n    public void unbind(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Unbinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.unbind(name);\n                return null;\n            }\n        });\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/jndi/JndiTemplateTest1.java",
		"test_prompt": "// JndiTemplateTest1.java\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JndiTemplate}.\n* It contains ten unit test cases for the {@link JndiTemplate#lookup(String)} method.\n*/\nclass JndiTemplateTest1 {"
	},
	{
		"original_code": "// JndiTemplate.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\n\n/**\n * Helper class that simplifies JNDI operations. It provides methods to lookup and\n * bind objects, and allows implementations of the {@link JndiCallback} interface\n * to perform any operation they like with a JNDI naming context provided.\n *\n * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from\n * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the\n * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.\n * Since JSecurity is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see JndiCallback\n * @see #execute\n */\npublic class JndiTemplate {\n\n    private static final Log log = LogFactory.getLog(JndiTemplate.class);\n\n    private Properties environment;\n\n    /**\n     * Create a new JndiTemplate instance.\n     */\n    public JndiTemplate() {\n    }\n\n    /**\n     * Create a new JndiTemplate instance, using the given environment.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public JndiTemplate(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Set the environment for the JNDI InitialContext.\n     *\n     * @param environment the Properties to initialize with\n     */\n    public void setEnvironment(Properties environment) {\n        this.environment = environment;\n    }\n\n    /**\n     * Return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     *\n     * @return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.\n     */\n    public Properties getEnvironment() {\n        return this.environment;\n    }\n\n    /**\n     * Execute the given JNDI context callback implementation.\n     *\n     * @param contextCallback JndiCallback implementation\n     * @return a result object returned by the callback, or <code>null</code>\n     * @throws NamingException thrown by the callback implementation\n     * @see #createInitialContext\n     */\n    public Object execute(JndiCallback contextCallback) throws NamingException {\n        Context ctx = createInitialContext();\n        try {\n            return contextCallback.doInContext(ctx);\n        } finally {\n            try {\n                ctx.close();\n            } catch (NamingException ex) {\n                log.debug(\"Could not close JNDI InitialContext\", ex);\n            }\n        }\n    }\n\n    /**\n     * Create a new JNDI initial context. Invoked by {@link #execute}.\n     * <p>The default implementation use this template's environment settings.\n     * Can be subclassed for custom contexts, e.g. for testing.\n     *\n     * @return the initial Context instance\n     * @throws NamingException in case of initialization errors\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    protected Context createInitialContext() throws NamingException {\n        Properties env = getEnvironment();\n        Hashtable icEnv = null;\n        if (env != null) {\n            icEnv = new Hashtable(env.size());\n            for (Enumeration en = env.propertyNames(); en.hasMoreElements(); ) {\n                String key = (String) en.nextElement();\n                icEnv.put(key, env.getProperty(key));\n            }\n        }\n        return new InitialContext(icEnv);\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Looking up JNDI object with name [\" + name + \"]\");\n        }\n        return execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                Object located = ctx.lookup(name);\n                if (located == null) {\n                    throw new NameNotFoundException(\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\");\n                }\n                return located;\n            }\n        });\n    }\n\n    /**\n     * Look up the object with the given name in the current JNDI context.\n     *\n     * @param name         the JNDI name of the object\n     * @param requiredType type the JNDI object must match. Can be an interface or\n     *                     superclass of the actual class, or <code>null</code> for any match. For example,\n     *                     if the value is <code>Object.class</code>, this method will succeed whatever\n     *                     the class of the returned instance.\n     * @return object found (cannot be <code>null</code>; if a not so well-behaved\n     *         JNDI implementations returns null, a NamingException gets thrown)\n     * @throws NamingException if there is no object with the given\n     *                         name bound to JNDI\n     */\n    public Object lookup(String name, Class requiredType) throws NamingException {\n        Object jndiObject = lookup(name);\n        if (requiredType != null && !requiredType.isInstance(jndiObject)) {\n            String msg = \"Jndi object acquired under name '\" + name + \"' is of type [\" + jndiObject.getClass().getName() + \"] and not assignable to the required type [\" + requiredType.getName() + \"].\";\n            throw new NamingException(msg);\n        }\n        return jndiObject;\n    }\n\n    /**\n     * Bind the given object to the current JNDI context, using the given name.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to bind\n     * @throws NamingException thrown by JNDI, mostly name already bound\n     */\n    public void bind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Binding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.bind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Rebind the given object to the current JNDI context, using the given name.\n     * Overwrites any existing binding.\n     *\n     * @param name   the JNDI name of the object\n     * @param object the object to rebind\n     * @throws NamingException thrown by JNDI\n     */\n    public void rebind(final String name, final Object object) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.rebind(name, object);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Remove the binding for the given name from the current JNDI context.\n     *\n     * @param name the JNDI name of the object\n     * @throws NamingException thrown by JNDI, mostly name not found\n     */\n    public void unbind(final String name) throws NamingException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Unbinding JNDI object with name [\" + name + \"]\");\n        }\n        execute(new JndiCallback() {\n\n            public Object doInContext(Context ctx) throws NamingException {\n                ctx.unbind(name);\n                return null;\n            }\n        });\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/jndi/JndiTemplateTest2.java",
		"test_prompt": "// JndiTemplateTest2.java\npackage org.jsecurity.jndi;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NamingException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JndiTemplate}.\n* It contains ten unit test cases for the {@link JndiTemplate#lookup(String, Class)} method.\n*/\nclass JndiTemplateTest2 {"
	},
	{
		"original_code": "// SimpleRole.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * A simple representation of a security role that has a name and a collection of permissions.  This object can be\n * used internally by Realms to maintain authorization state.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SimpleRole implements Serializable {\n\n    protected String name = null;\n\n    protected Set<Permission> permissions;\n\n    public SimpleRole() {\n    }\n\n    public SimpleRole(String name) {\n        setName(name);\n    }\n\n    public SimpleRole(String name, Set<Permission> permissions) {\n        setName(name);\n        setPermissions(permissions);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Set<Permission> getPermissions() {\n        return permissions;\n    }\n\n    public void setPermissions(Set<Permission> permissions) {\n        this.permissions = permissions;\n    }\n\n    public void add(Permission permission) {\n        Set<Permission> permissions = getPermissions();\n        if (permissions == null) {\n            permissions = new LinkedHashSet<Permission>();\n            setPermissions(permissions);\n        }\n        permissions.add(permission);\n    }\n\n    public void addAll(Collection<Permission> perms) {\n        if (perms != null && !perms.isEmpty()) {\n            Set<Permission> permissions = getPermissions();\n            if (permissions == null) {\n                permissions = new LinkedHashSet<Permission>(perms.size());\n                setPermissions(permissions);\n            }\n            permissions.addAll(perms);\n        }\n    }\n\n    public boolean isPermitted(Permission p) {\n        Collection<Permission> perms = getPermissions();\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(p)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        return (getName() != null ? getName().hashCode() : 0);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleRole) {\n            SimpleRole sr = (SimpleRole) o;\n            //only check name, since role names should be unique across an entire application:\n            return (getName() != null ? getName().equals(sr.getName()) : sr.getName() == null);\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getName();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleRoleTest0.java",
		"test_prompt": "// SimpleRoleTest0.java\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleRole}.\n* It contains ten unit test cases for the {@link SimpleRole#isPermitted(Permission)} method.\n*/\nclass SimpleRoleTest0 {"
	},
	{
		"original_code": "// SimpleRole.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * A simple representation of a security role that has a name and a collection of permissions.  This object can be\n * used internally by Realms to maintain authorization state.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SimpleRole implements Serializable {\n\n    protected String name = null;\n\n    protected Set<Permission> permissions;\n\n    public SimpleRole() {\n    }\n\n    public SimpleRole(String name) {\n        setName(name);\n    }\n\n    public SimpleRole(String name, Set<Permission> permissions) {\n        setName(name);\n        setPermissions(permissions);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Set<Permission> getPermissions() {\n        return permissions;\n    }\n\n    public void setPermissions(Set<Permission> permissions) {\n        this.permissions = permissions;\n    }\n\n    public void add(Permission permission) {\n        Set<Permission> permissions = getPermissions();\n        if (permissions == null) {\n            permissions = new LinkedHashSet<Permission>();\n            setPermissions(permissions);\n        }\n        permissions.add(permission);\n    }\n\n    public void addAll(Collection<Permission> perms) {\n        if (perms != null && !perms.isEmpty()) {\n            Set<Permission> permissions = getPermissions();\n            if (permissions == null) {\n                permissions = new LinkedHashSet<Permission>(perms.size());\n                setPermissions(permissions);\n            }\n            permissions.addAll(perms);\n        }\n    }\n\n    public boolean isPermitted(Permission p) {\n        Collection<Permission> perms = getPermissions();\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(p)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        return (getName() != null ? getName().hashCode() : 0);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleRole) {\n            SimpleRole sr = (SimpleRole) o;\n            //only check name, since role names should be unique across an entire application:\n            return (getName() != null ? getName().equals(sr.getName()) : sr.getName() == null);\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getName();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleRoleTest1.java",
		"test_prompt": "// SimpleRoleTest1.java\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleRole}.\n* It contains ten unit test cases for the {@link SimpleRole#hashCode()} method.\n*/\nclass SimpleRoleTest1 {"
	},
	{
		"original_code": "// SimpleRole.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * A simple representation of a security role that has a name and a collection of permissions.  This object can be\n * used internally by Realms to maintain authorization state.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class SimpleRole implements Serializable {\n\n    protected String name = null;\n\n    protected Set<Permission> permissions;\n\n    public SimpleRole() {\n    }\n\n    public SimpleRole(String name) {\n        setName(name);\n    }\n\n    public SimpleRole(String name, Set<Permission> permissions) {\n        setName(name);\n        setPermissions(permissions);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Set<Permission> getPermissions() {\n        return permissions;\n    }\n\n    public void setPermissions(Set<Permission> permissions) {\n        this.permissions = permissions;\n    }\n\n    public void add(Permission permission) {\n        Set<Permission> permissions = getPermissions();\n        if (permissions == null) {\n            permissions = new LinkedHashSet<Permission>();\n            setPermissions(permissions);\n        }\n        permissions.add(permission);\n    }\n\n    public void addAll(Collection<Permission> perms) {\n        if (perms != null && !perms.isEmpty()) {\n            Set<Permission> permissions = getPermissions();\n            if (permissions == null) {\n                permissions = new LinkedHashSet<Permission>(perms.size());\n                setPermissions(permissions);\n            }\n            permissions.addAll(perms);\n        }\n    }\n\n    public boolean isPermitted(Permission p) {\n        Collection<Permission> perms = getPermissions();\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(p)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        return (getName() != null ? getName().hashCode() : 0);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof SimpleRole) {\n            SimpleRole sr = (SimpleRole) o;\n            //only check name, since role names should be unique across an entire application:\n            return (getName() != null ? getName().equals(sr.getName()) : sr.getName() == null);\n        }\n        return false;\n    }\n\n    public String toString() {\n        return getName();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleRoleTest2.java",
		"test_prompt": "// SimpleRoleTest2.java\npackage org.jsecurity.authz;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleRole}.\n* It contains ten unit test cases for the {@link SimpleRole#equals(Object)} method.\n*/\nclass SimpleRoleTest2 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest0.java",
		"test_prompt": "// SimpleAuthorizingAccountTest0.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#hasRole(String)} method.\n*/\nclass SimpleAuthorizingAccountTest0 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest1.java",
		"test_prompt": "// SimpleAuthorizingAccountTest1.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#isPermitted(Permission)} method.\n*/\nclass SimpleAuthorizingAccountTest1 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest2.java",
		"test_prompt": "// SimpleAuthorizingAccountTest2.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#hasRoles(List)} method.\n*/\nclass SimpleAuthorizingAccountTest2 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest3.java",
		"test_prompt": "// SimpleAuthorizingAccountTest3.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#hasAllRoles(Collection)} method.\n*/\nclass SimpleAuthorizingAccountTest3 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest4.java",
		"test_prompt": "// SimpleAuthorizingAccountTest4.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#isPermitted(List)} method.\n*/\nclass SimpleAuthorizingAccountTest4 {"
	},
	{
		"original_code": "// SimpleAuthorizingAccount.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.authz;\r\n\r\nimport org.jsecurity.authc.Account;\r\nimport org.jsecurity.authc.SimpleAccount;\r\nimport org.jsecurity.subject.PrincipalCollection;\r\nimport java.util.*;\r\n\r\n/**\r\n * <p>A simple implementation of the {@link AuthorizingAccount} interface that is useful\r\n * for many realms.  This implementation caches an internal collection of roles and permissions\r\n * in order to perform authorization checks for a particular user.</p>\r\n *\r\n * <p>See {@link AuthorizingAccount} interface for reasons why this class is deprecated.</p>\r\n *\r\n * @author Jeremy Haile\r\n * @author Les Hazlewood\r\n * @deprecated\r\n * @since 0.2\r\n */\r\npublic class SimpleAuthorizingAccount extends SimpleAccount implements AuthorizingAccount {\r\n\r\n    protected Set<SimpleRole> simpleRoles;\r\n\r\n    /*--------------------------------------------\r\n    |         C O N S T R U C T O R S           |\r\n    ============================================*/\r\n    public SimpleAuthorizingAccount() {\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName) {\r\n        super(principal, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName) {\r\n        super(principals, credentials, realmName);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials) {\r\n        super(principals, credentials);\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Object principal, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principal, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(Collection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    public SimpleAuthorizingAccount(PrincipalCollection principals, Object credentials, String realmName, Set<String> roleNames, Set<Permission> permissions) {\r\n        this(principals, credentials, realmName);\r\n        addRoles(roleNames);\r\n        //only create a private role if there are permissions:\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            addPrivateRole(getPrincipals(), permissions);\r\n        }\r\n    }\r\n\r\n    /*--------------------------------------------\r\n    |               M E T H O D S               |\r\n    ============================================*/\r\n    @SuppressWarnings({ \"unchecked\" })\r\n    public void merge(Account otherAccount) {\r\n        super.merge(otherAccount);\r\n        if (otherAccount instanceof SimpleAuthorizingAccount) {\r\n            SimpleAuthorizingAccount other = (SimpleAuthorizingAccount) otherAccount;\r\n            Set<SimpleRole> otherRoles = other.getSimpleRoles();\r\n            if (otherRoles != null && !otherRoles.isEmpty()) {\r\n                for (SimpleRole otherRole : otherRoles) {\r\n                    merge(otherRole);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void merge(SimpleRole role) {\r\n        SimpleRole existing = getRole(role.getName());\r\n        if (existing != null) {\r\n            Set<Permission> rolePerms = role.getPermissions();\r\n            if (rolePerms != null && !rolePerms.isEmpty()) {\r\n                existing.addAll(rolePerms);\r\n            }\r\n        } else {\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    protected void addPrivateRole(PrincipalCollection principals, Collection<Permission> perms) {\r\n        SimpleRole privateRole = createPrivateRole(principals);\r\n        if (perms != null && !perms.isEmpty()) {\r\n            privateRole.addAll(perms);\r\n        }\r\n        add(privateRole);\r\n    }\r\n\r\n    protected String getPrivateRoleName(PrincipalCollection principals) {\r\n        return getClass().getName() + \"_PRIVATE_ROLE_\" + PrincipalCollection.class.getName();\r\n    }\r\n\r\n    protected SimpleRole createPrivateRole(PrincipalCollection principals) {\r\n        String privateRoleName = getPrivateRoleName(principals);\r\n        return new SimpleRole(privateRoleName);\r\n    }\r\n\r\n    public Set<SimpleRole> getSimpleRoles() {\r\n        return simpleRoles;\r\n    }\r\n\r\n    public void setSimpleRoles(Set<SimpleRole> simpleRoles) {\r\n        this.simpleRoles = simpleRoles;\r\n    }\r\n\r\n    public SimpleRole getRole(String name) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.getName().equals(name)) {\r\n                    return role;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Set<Permission> getPermissions() {\r\n        Set<Permission> permissions = new HashSet<Permission>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            permissions.addAll(role.getPermissions());\r\n        }\r\n        return permissions;\r\n    }\r\n\r\n    public Set<String> getRolenames() {\r\n        Set<String> rolenames = new HashSet<String>();\r\n        for (SimpleRole role : simpleRoles) {\r\n            rolenames.add(role.getName());\r\n        }\r\n        return rolenames;\r\n    }\r\n\r\n    public void addRole(String roleName) {\r\n        SimpleRole existing = getRole(roleName);\r\n        if (existing == null) {\r\n            SimpleRole role = new SimpleRole(roleName);\r\n            add(role);\r\n        }\r\n    }\r\n\r\n    public void add(SimpleRole role) {\r\n        Set<SimpleRole> roles = getSimpleRoles();\r\n        if (roles == null) {\r\n            roles = new LinkedHashSet<SimpleRole>();\r\n            setSimpleRoles(roles);\r\n        }\r\n        roles.add(role);\r\n    }\r\n\r\n    public void addRoles(Set<String> roleNames) {\r\n        if (roleNames != null && !roleNames.isEmpty()) {\r\n            for (String name : roleNames) {\r\n                addRole(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addAll(Collection<SimpleRole> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            Set<SimpleRole> existingRoles = getSimpleRoles();\r\n            if (existingRoles == null) {\r\n                existingRoles = new LinkedHashSet<SimpleRole>(roles.size());\r\n                setSimpleRoles(existingRoles);\r\n            }\r\n            existingRoles.addAll(roles);\r\n        }\r\n    }\r\n\r\n    public boolean hasRole(String roleName) {\r\n        return getRole(roleName) != null;\r\n    }\r\n\r\n    public boolean isPermitted(Permission permission) {\r\n        Collection<SimpleRole> roles = getSimpleRoles();\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (SimpleRole role : roles) {\r\n                if (role.isPermitted(permission)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean[] hasRoles(List<String> roleIdentifiers) {\r\n        boolean[] result;\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            int size = roleIdentifiers.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (String roleName : roleIdentifiers) {\r\n                result[i++] = hasRole(roleName);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean hasAllRoles(Collection<String> roleIdentifiers) {\r\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\r\n            for (String roleName : roleIdentifiers) {\r\n                if (!hasRole(roleName)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean[] isPermitted(List<Permission> permissions) {\r\n        boolean[] result;\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            int size = permissions.size();\r\n            result = new boolean[size];\r\n            int i = 0;\r\n            for (Permission p : permissions) {\r\n                result[i++] = isPermitted(p);\r\n            }\r\n        } else {\r\n            result = new boolean[0];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean isPermittedAll(Collection<Permission> permissions) {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                if (!isPermitted(p)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void checkPermission(Permission permission) throws AuthorizationException {\r\n        if (!isPermitted(permission)) {\r\n            String msg = \"User is not permitted [\" + permission + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException {\r\n        if (permissions != null && !permissions.isEmpty()) {\r\n            for (Permission p : permissions) {\r\n                checkPermission(p);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void checkRole(String role) {\r\n        if (!hasRole(role)) {\r\n            String msg = \"User does not have role [\" + role + \"]\";\r\n            throw new UnauthorizedException(msg);\r\n        }\r\n    }\r\n\r\n    public void checkRoles(Collection<String> roles) {\r\n        if (roles != null && !roles.isEmpty()) {\r\n            for (String roleName : roles) {\r\n                checkRole(roleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/SimpleAuthorizingAccountTest5.java",
		"test_prompt": "// SimpleAuthorizingAccountTest5.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authc.Account;\nimport org.jsecurity.authc.SimpleAccount;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAuthorizingAccount}.\n* It contains ten unit test cases for the {@link SimpleAuthorizingAccount#isPermittedAll(Collection)} method.\n*/\nclass SimpleAuthorizingAccountTest5 {"
	},
	{
		"original_code": "// AuthorizingMethodInterceptor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz.aop;\n\nimport org.jsecurity.aop.MethodInterceptorSupport;\nimport org.jsecurity.aop.MethodInvocation;\nimport org.jsecurity.authz.AuthorizationException;\n\n/**\n * Basic abstract class to support intercepting methods that perform authorization (access control) checks.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic abstract class AuthorizingMethodInterceptor extends MethodInterceptorSupport {\n\n    /**\n     * Invokes the specified method (<code>methodInvocation.{@link org.jsecurity.aop.MethodInvocation#proceed proceed}()</code>\n     * if authorization is allowed by first\n     * calling {@link #assertAuthorized(org.jsecurity.aop.MethodInvocation) assertAuthorized}.\n     */\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        assertAuthorized(methodInvocation);\n        return methodInvocation.proceed();\n    }\n\n    /**\n     * Asserts that the specified MethodInvocation is allowed to continue by performing any necessary authorization\n     * (access control) checks first.\n     * @param methodInvocation the <code>MethodInvocation</code> to invoke.\n     * @throws AuthorizationException if the <code>methodInvocation</code> should not be allowed to continue/execute.\n     */\n    protected abstract void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/aop/AuthorizingMethodInterceptorTest.java",
		"test_prompt": "// AuthorizingMethodInterceptorTest.java\npackage org.jsecurity.authz.aop;\n\nimport org.jsecurity.aop.MethodInterceptorSupport;\nimport org.jsecurity.aop.MethodInvocation;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingMethodInterceptor}.\n* It contains ten unit test cases for the {@link AuthorizingMethodInterceptor#invoke(MethodInvocation)} method.\n*/\nclass AuthorizingMethodInterceptorTest {"
	},
	{
		"original_code": "// AuthorizingAnnotationMethodInterceptor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz.aop;\n\nimport org.jsecurity.aop.AnnotationMethodInterceptor;\nimport org.jsecurity.aop.MethodInvocation;\nimport org.jsecurity.authz.AuthorizationException;\n\n/**\n * An <tt>AnnotationMethodInterceptor</tt> that asserts the calling code is authorized to execute the method\n * before allowing the invocation to continue by inspecting code annotations to perform an access control check.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AuthorizingAnnotationMethodInterceptor extends AnnotationMethodInterceptor {\n\n    /**\n     * Constructor that ensures the internal <code>handler</code> is set which will be used to perform the\n     * authorization assertion checks when a supported annotation is encountered.\n     * @param handler the internal <code>handler</code> used to perform authorization assertion checks when a\n     * supported annotation is encountered.\n     */\n    public AuthorizingAnnotationMethodInterceptor(AuthorizingAnnotationHandler handler) {\n        super(handler);\n    }\n\n    /**\n     * Ensures the <code>methodInvocation</code> is allowed to execute first before proceeding by calling the\n     * {@link #assertAuthorized(org.jsecurity.aop.MethodInvocation) assertAuthorized} method first.\n     *\n     * @param methodInvocation the method invocation to check for authorization prior to allowing it to proceed/execute.\n     * @return the return value from the method invocation (the value of {@link org.jsecurity.aop.MethodInvocation#proceed() MethodInvocation.proceed()}).\n     * @throws AuthorizationException if the <code>MethodInvocation</code> is not allowed to proceed.\n     * @throws Throwable if any other error occurs.\n     */\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        assertAuthorized(methodInvocation);\n        return methodInvocation.proceed();\n    }\n\n    /**\n     * Ensures the calling Subject is authorized to execute the specified <code>MethodInvocation</code>.\n     * <p/>\n     * As this is an AnnotationMethodInterceptor, this implementation merely delegates to the internal\n     * {@link AuthorizingAnnotationHandler AuthorizingAnnotationHandler} by first acquiring the annotation by\n     * calling {@link #getAnnotation(MethodInvocation) getAnnotation(methodInvocation)} and then calls\n     * {@link AuthorizingAnnotationHandler#assertAuthorized(java.lang.annotation.Annotation) handler.assertAuthorized(annotation)}.\n     *\n     * @param mi the <code>MethodInvocation</code> to check to see if it is allowed to proceed/execute.\n     * @throws AuthorizationException if the method invocation is not allowed to continue/execute.\n     */\n    public void assertAuthorized(MethodInvocation mi) throws AuthorizationException {\n        ((AuthorizingAnnotationHandler) getHandler()).assertAuthorized(getAnnotation(mi));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/aop/AuthorizingAnnotationMethodInterceptorTest.java",
		"test_prompt": "// AuthorizingAnnotationMethodInterceptorTest.java\npackage org.jsecurity.authz.aop;\n\nimport org.jsecurity.aop.AnnotationMethodInterceptor;\nimport org.jsecurity.aop.MethodInvocation;\nimport org.jsecurity.authz.AuthorizationException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingAnnotationMethodInterceptor}.\n* It contains ten unit test cases for the {@link AuthorizingAnnotationMethodInterceptor#invoke(MethodInvocation)} method.\n*/\nclass AuthorizingAnnotationMethodInterceptorTest {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest0.java",
		"test_prompt": "// ModularRealmAuthorizerTest0.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermitted(PrincipalCollection, String)} method.\n*/\nclass ModularRealmAuthorizerTest0 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest1.java",
		"test_prompt": "// ModularRealmAuthorizerTest1.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermitted(PrincipalCollection, Permission)} method.\n*/\nclass ModularRealmAuthorizerTest1 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest2.java",
		"test_prompt": "// ModularRealmAuthorizerTest2.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermitted(PrincipalCollection, String[])} method.\n*/\nclass ModularRealmAuthorizerTest2 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest3.java",
		"test_prompt": "// ModularRealmAuthorizerTest3.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermitted(PrincipalCollection, List)} method.\n*/\nclass ModularRealmAuthorizerTest3 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest4.java",
		"test_prompt": "// ModularRealmAuthorizerTest4.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermittedAll(PrincipalCollection, String[])} method.\n*/\nclass ModularRealmAuthorizerTest4 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest5.java",
		"test_prompt": "// ModularRealmAuthorizerTest5.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#isPermittedAll(PrincipalCollection, Collection)} method.\n*/\nclass ModularRealmAuthorizerTest5 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest6.java",
		"test_prompt": "// ModularRealmAuthorizerTest6.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#hasRole(PrincipalCollection, String)} method.\n*/\nclass ModularRealmAuthorizerTest6 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest7.java",
		"test_prompt": "// ModularRealmAuthorizerTest7.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#hasRoles(PrincipalCollection, List)} method.\n*/\nclass ModularRealmAuthorizerTest7 {"
	},
	{
		"original_code": "// ModularRealmAuthorizer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * A <tt>ModularRealmAuthorizer</tt> is an <tt>Authorizer</tt> implementation that consults one or more configured\n * {@link Realm Realm}s during an authorization operation.\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware {\n\n    /**\n     * The realms to consult during any authorization check.\n     */\n    protected Collection<Realm> realms;\n\n    /**\n     * Default no-argument constructor, does nothing.\n     */\n    public ModularRealmAuthorizer() {\n    }\n\n    /**\n     * Constructor that accepts the <code>Realm</code>s to consult during an authorization check.  Immediately calls\n     * {@link #setRealms setRealms(realms)}.\n     * @param realms the realms to consult during an authorization check.\n     */\n    public ModularRealmAuthorizer(Collection<Realm> realms) {\n        setRealms(realms);\n    }\n\n    /**\n     * Returns the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @return the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public Collection<Realm> getRealms() {\n        return this.realms;\n    }\n\n    /**\n     * Sets the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     * @param realms the realms wrapped by this <code>Authorizer</code> which are consulted during an authorization check.\n     */\n    public void setRealms(Collection<Realm> realms) {\n        this.realms = realms;\n    }\n\n    /**\n     * Used by the {@link Authorizer Authorizer} implementation methods to ensure that the {@link #setRealms realms}\n     * has been set.  The default implementation ensures the property is not null and not empty.\n     *\n     * @throws IllegalStateException if the <tt>realms</tt> property is configured incorrectly.\n     */\n    protected void assertRealmsConfigured() throws IllegalStateException {\n        Collection<Realm> realms = getRealms();\n        if (realms == null || realms.isEmpty()) {\n            String msg = \"Configuration error:  No realms have been configured!  One or more realms must be \" + \"present to execute an authorization operation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Sets the specified {@link PermissionResolver PermissionResolver} on any of the wrapped realms that implement\n     * the {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     *\n     * @param permissionResolver the permissionResolver to set on all of the wrapped realms that implement the\n     * {@link org.jsecurity.authz.permission.PermissionResolverAware PermissionResolverAware} interface.\n     */\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        Collection<Realm> realms = getRealms();\n        if (realms != null && !realms.isEmpty()) {\n            for (Realm realm : realms) {\n                if (realm instanceof PermissionResolverAware) {\n                    ((PermissionResolverAware) realm).setPermissionResolver(permissionResolver);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.isPermitted(principals, permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String[])} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            boolean[] isPermitted = new boolean[permissions.length];\n            for (int i = 0; i < permissions.length; i++) {\n                isPermitted[i] = isPermitted(principals, permissions[i]);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, List)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            boolean[] isPermitted = new boolean[permissions.size()];\n            int i = 0;\n            for (Permission p : permissions) {\n                isPermitted[i++] = isPermitted(principals, p);\n            }\n            return isPermitted;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>\n     * for <em>all</em> of the specified string permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                if (!isPermitted(principals, perm)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#isPermitted(org.jsecurity.subject.PrincipalCollection, Permission)} call returns <code>true</code>\n     * for <em>all</em> of the specified Permissions, <code>false</code> otherwise.\n     */\n    public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions) {\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission permission : permissions) {\n                if (!isPermitted(principals, permission)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException {\n        if (!isPermitted(principals, permission)) {\n            throw new UnauthorizedException(\"Subject does not have permission [\" + permission + \"]\");\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, String[]) isPermitted(permission)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException {\n        if (permissions != null && permissions.length > 0) {\n            for (String perm : permissions) {\n                checkPermission(principals, perm);\n            }\n        }\n    }\n\n    /**\n     * If !{@link #isPermitted(org.jsecurity.subject.PrincipalCollection, Permission) isPermitted(permission)} for\n     * <em>all</em> the given Permissions, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (Permission permission : permissions) {\n                checkPermission(principals, permission);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code>,\n     * <code>false</code> otherwise.\n     */\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n        assertRealmsConfigured();\n        for (Realm realm : getRealms()) {\n            if (realm.hasRole(principals, roleIdentifier)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calls {@link #hasRole(org.jsecurity.subject.PrincipalCollection, String)} for each role name in the specified\n     * collection and places the return value from each call at the respective location in the returned array.\n     */\n    public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers) {\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            boolean[] hasRoles = new boolean[roleIdentifiers.size()];\n            int i = 0;\n            for (String roleId : roleIdentifiers) {\n                hasRoles[i++] = hasRole(principals, roleId);\n            }\n            return hasRoles;\n        }\n        return new boolean[0];\n    }\n\n    /**\n     * Returns <code>true</code> iff any of the configured realms'\n     * {@link Realm#hasRole(org.jsecurity.subject.PrincipalCollection, String)} call returns <code>true</code> for\n     * <em>all</em> roles specified, <code>false</code> otherwise.\n     */\n    public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers) {\n        for (String roleIdentifier : roleIdentifiers) {\n            if (!hasRole(principals, roleIdentifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If !{@link #hasRole(org.jsecurity.subject.PrincipalCollection, String) hasRole(role)}, throws\n     * an <code>UnauthorizedException</code> otherwise returns quietly.\n     */\n    public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException {\n        if (!hasRole(principals, role)) {\n            throw new UnauthorizedException(\"Subject does not have role [\" + role + \"]\");\n        }\n    }\n\n    /**\n     * Calls {@link #checkRole(org.jsecurity.subject.PrincipalCollection, String) checkRole} for each role specified.\n     */\n    public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException {\n        if (roles != null) {\n            for (String role : roles) {\n                checkRole(principals, role);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/ModularRealmAuthorizerTest8.java",
		"test_prompt": "// ModularRealmAuthorizerTest8.java\npackage org.jsecurity.authz;\n\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.realm.Realm;\nimport org.jsecurity.subject.PrincipalCollection;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModularRealmAuthorizer}.\n* It contains ten unit test cases for the {@link ModularRealmAuthorizer#hasAllRoles(PrincipalCollection, Collection)} method.\n*/\nclass ModularRealmAuthorizerTest8 {"
	},
	{
		"original_code": "// AllPermission.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\nimport java.io.Serializable;\n\n/**\n * An all <tt>AllPermission</tt> instance is one that always implies any other permission; that is, its\n * {@link #implies implies} method always returns <tt>true</tt>.\n *\n * <p>You should be very careful about the users, roles, and/or groups to which this permission is assigned since\n * those respective entities will have the ability to do anything.  As such, an instance of this class\n * is typically only assigned only to \"root\" or \"administrator\" users or roles.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class AllPermission implements Permission, Serializable {\n\n    /**\n     * Always returns <tt>true</tt>, indicating any Subject granted this permission can do anything.\n     *\n     * @param p the Permission to check for implies logic.\n     * @return <tt>true</tt> always, indicating any Subject grated this permission can do anything.\n     */\n    public boolean implies(Permission p) {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/permission/AllPermissionTest.java",
		"test_prompt": "// AllPermissionTest.java\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AllPermission}.\n* It contains ten unit test cases for the {@link AllPermission#implies(Permission)} method.\n*/\nclass AllPermissionTest {"
	},
	{
		"original_code": "// WildcardPermissionResolver.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\n\n/**\n * <tt>PermissionResolver</tt> implementation that returns a new {@link WildcardPermission WildcardPermission}\n * based on the input string.\n *\n * @author Jeremy Haile\n * @since 0.9\n */\npublic class WildcardPermissionResolver implements PermissionResolver {\n\n    /**\n     * Returns a new {@link WildcardPermission WildcardPermission} instance constructed based on the specified\n     * <tt>permissionString</tt>.\n     *\n     * @param permissionString the permission string to convert to a {@link Permission Permission} instance.\n     * @return a new {@link WildcardPermission WildcardPermission} instance constructed based on the specified\n     *         <tt>permissionString</tt>\n     */\n    public Permission resolvePermission(String permissionString) {\n        return new WildcardPermission(permissionString);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/permission/WildcardPermissionResolverTest.java",
		"test_prompt": "// WildcardPermissionResolverTest.java\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WildcardPermissionResolver}.\n* It contains ten unit test cases for the {@link WildcardPermissionResolver#resolvePermission(String)} method.\n*/\nclass WildcardPermissionResolverTest {"
	},
	{
		"original_code": "// WildcardPermission.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.util.CollectionUtils;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * A <code>WildcardPermission</code> is a very flexible permission construct supporting multiple levels of\n * permission matching. However, most people will probably follow some standard conventions as explained below.\n *\n * <h3>Simple Usage</h3>\n *\n * In the simplest form, <code>WildcardPermission</code> can be used as a simple permission string. You could grant a\n * user an &quot;editNewsletter&quot; permission and then check to see if the user has the editNewsletter\n * permission by calling\n * <p/>\n * <code>subject.isPermitted(&quot;editNewsletter&quot;)</code>\n * <p/>\n * This is (mostly) equivalent to\n * <p/>\n * <code>subject.isPermitted( new WildcardPermission(&quot;editNewsletter&quot;) )</code>\n * <p/>\n * but more on that later.\n * <p/>\n * The simple permission string may work for simple applications, but it requires you to have permissions like\n * <code>&quot;viewNewsletter&quot;</code>, <code>&quot;deleteNewsletter&quot;</code>,\n * <code>&quot;createNewsletter&quot;</code>, etc. You can also grant a user <code>&quot;*&quot;</code> permissions\n * using the wildcard character (giving this class its name), which means they have <em>all</em> permissions. But\n * using this approach there's no way to just say a user has &quot;all newsletter permissions&quot;.\n * <p/>\n * For this reason, <code>WildcardPermission</code> supports multiple <em>levels</em> of permissioning.\n *\n * <h3>Multiple Levels</h3>\n *\n * WildcardPermission</code> also supports the concept of multiple <em>levels</em>.  For example, you could\n * restructure the previous simple example by granting a user the permission <code>&quot;newsletter:edit&quot;</code>.\n * The colon in this example is a special character used by the <code>WildcardPermission</code> that delimits the\n * next token in the permission.\n * <p/>\n * In this example, the first token is the <em>domain</em> that is being operated on\n * and the second token is the <em>action</em> being performed. Each level can contain multiple values.  So you\n * could simply grant a user the permission <code>&quot;newsletter:view,edit,create&quot;</code> which gives them\n * access to perform <code>view</code>, <code>edit</code>, and <code>create</code> actions in the <code>newsletter</code>\n * <em>domain</em>. Then you could check to see if the user has the <code>&quot;newsletter:create&quot;</code>\n * permission by calling\n * <p/>\n * <code>subject.isPermitted(&quot;newsletter:create&quot;)</code>\n * <p/>\n * (which would return true).\n * <p/>\n * In addition to granting multiple permissions via a single string, you can grant all permission for a particular\n * level. So if you wanted to grant a user all actions in the <code>newsletter</code> domain, you could simply give\n * them <code>&quot;newsletter:*&quot;</code>. Now, any permission check for <code>&quot;newsletter:XXX&quot;</code>\n * will return <code>true</code>. It is also possible to use the wildcard token at the domain level (or both): so you\n * could grant a user the <code>&quot;view&quot;</code> action across all domains <code>&quot;*:view&quot;</code>.\n *\n * <h3>Instance-level Access Control</h3>\n *\n * Another common usage of the <code>WildcardPermission</code> is to model instance-level Access Control Lists.\n * In this scenario you use three tokens - the first is the <em>domain</em>, the second is the <em>action</em>, and\n * the third is the <em>instance</em> you are acting on.\n * <p/>\n * So for example you could grant a user <code>&quot;newsletter:edit:12,13,18&quot;</code>.  In this example, assume\n * that the third token is the system's ID of the newsletter. That would allow the user to edit newsletters\n * <code>12</code>, <code>13</code>, and <code>18</code>. This is an extremely powerful way to express permissions,\n * since you can now say things like <code>&quot;newsletter:*:13&quot;</code> (grant a user all actions for newsletter\n * <code>13</code>), <code>&quot;newsletter:view,create,edit:*&quot;</code> (allow the user to\n * <code>view</code>, <code>create</code>, or <code>edit</code> <em>any</em> newsletter), or\n * <code>&quot;newsletter:*:*</code> (allow the user to perform <em>any</em> action on <em>any</em> newsletter).\n * <p/>\n * To perform checks against these instance-level permissions, the application should include the instance ID in the\n * permission check like so:\n * <p/>\n * <code>subject.isPermitted( &quot;newsletter:edit:13&quot; )</code>\n * <p/>\n * There is no limit to the number of tokens that can be used, so it is up to your imagination in terms of ways that\n * this could be used in your application.  However, the JSecurity team likes to standardize some common usages shown\n * above to help people get started and provide consistency in the JSecurity community.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class WildcardPermission implements Permission, Serializable {\n\n    //TODO - JavaDoc methods\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    protected static final String WILDCARD_TOKEN = \"*\";\n\n    protected static final String PART_DIVIDER_TOKEN = \":\";\n\n    protected static final String SUBPART_DIVIDER_TOKEN = \",\";\n\n    protected static final boolean DEFAULT_CASE_SENSITIVE = false;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private List<Set<String>> parts;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public WildcardPermission(String wildcardString) {\n        this(wildcardString, DEFAULT_CASE_SENSITIVE);\n    }\n\n    public WildcardPermission(String wildcardString, boolean caseSensitive) {\n        if (wildcardString == null || wildcardString.trim().length() == 0) {\n            throw new IllegalArgumentException(\"Wildcard string cannot be null or empty. Make sure permission strings are properly formatted.\");\n        }\n        wildcardString = wildcardString.trim();\n        List<String> parts = CollectionUtils.asList(wildcardString.split(PART_DIVIDER_TOKEN));\n        this.parts = new ArrayList<Set<String>>();\n        for (String part : parts) {\n            Set<String> subparts = CollectionUtils.asSet(part.split(SUBPART_DIVIDER_TOKEN));\n            if (!caseSensitive) {\n                subparts = lowercase(subparts);\n            }\n            if (subparts.isEmpty()) {\n                throw new IllegalArgumentException(\"Wildcard string cannot contain parts with only dividers. Make sure permission strings are properly formatted.\");\n            }\n            this.parts.add(subparts);\n        }\n        if (this.parts.isEmpty()) {\n            throw new IllegalArgumentException(\"Wildcard string cannot contain only dividers. Make sure permission strings are properly formatted.\");\n        }\n    }\n\n    private Set<String> lowercase(Set<String> subparts) {\n        Set<String> lowerCasedSubparts = new LinkedHashSet<String>(subparts.size());\n        for (String subpart : subparts) {\n            lowerCasedSubparts.add(subpart.toLowerCase());\n        }\n        return lowerCasedSubparts;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    protected List<Set<String>> getParts() {\n        return this.parts;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    public boolean implies(Permission p) {\n        // By default only supports comparisons with other WildcardPermissions\n        if (!(p instanceof WildcardPermission)) {\n            return false;\n        }\n        WildcardPermission wp = (WildcardPermission) p;\n        List<Set<String>> otherParts = wp.getParts();\n        int i = 0;\n        for (Set<String> otherPart : otherParts) {\n            // If this permission has less parts than the other permission, everything after the number of parts contained\n            // in this permission is automatically implied, so return true\n            if (getParts().size() - 1 < i) {\n                return true;\n            } else {\n                Set<String> part = getParts().get(i);\n                if (!part.contains(WILDCARD_TOKEN) && !part.containsAll(otherPart)) {\n                    return false;\n                }\n                i++;\n            }\n        }\n        // If this permission has more parts than the other parts, only imply it if all of the other parts are wildcards\n        for (; i < getParts().size(); i++) {\n            Set<String> part = getParts().get(i);\n            if (!part.contains(WILDCARD_TOKEN)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/authz/permission/WildcardPermissionTest.java",
		"test_prompt": "// WildcardPermissionTest.java\npackage org.jsecurity.authz.permission;\n\nimport org.jsecurity.authz.Permission;\nimport org.jsecurity.util.CollectionUtils;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WildcardPermission}.\n* It contains ten unit test cases for the {@link WildcardPermission#implies(Permission)} method.\n*/\nclass WildcardPermissionTest {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest0.java",
		"test_prompt": "// AuthorizingRealmTest0.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermitted(PrincipalCollection, String)} method.\n*/\nclass AuthorizingRealmTest0 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest1.java",
		"test_prompt": "// AuthorizingRealmTest1.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermitted(PrincipalCollection, Permission)} method.\n*/\nclass AuthorizingRealmTest1 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest2.java",
		"test_prompt": "// AuthorizingRealmTest2.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermitted(PrincipalCollection, String[])} method.\n*/\nclass AuthorizingRealmTest2 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest3.java",
		"test_prompt": "// AuthorizingRealmTest3.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermitted(PrincipalCollection, List)} method.\n*/\nclass AuthorizingRealmTest3 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest4.java",
		"test_prompt": "// AuthorizingRealmTest4.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermittedAll(PrincipalCollection, String[])} method.\n*/\nclass AuthorizingRealmTest4 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest5.java",
		"test_prompt": "// AuthorizingRealmTest5.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#isPermittedAll(PrincipalCollection, Collection)} method.\n*/\nclass AuthorizingRealmTest5 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest6.java",
		"test_prompt": "// AuthorizingRealmTest6.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#hasRole(PrincipalCollection, String)} method.\n*/\nclass AuthorizingRealmTest6 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest7.java",
		"test_prompt": "// AuthorizingRealmTest7.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#hasRoles(PrincipalCollection, List)} method.\n*/\nclass AuthorizingRealmTest7 {"
	},
	{
		"original_code": "// AuthorizingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\n\n/**\n * An <tt>AuthorizingRealm</tt> extends the <tt>AuthenticatingRealm</tt>'s capabilities by adding Authorization\n * (access control) support.\n *\n * <p>This implementation will perform all role and permission checks automatically (and subclasses do not have to\n * write this logic) as long as the\n * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection)} method returns an\n * {@link AuthorizationInfo}.  Please see that method's JavaDoc for an in-depth explanation.\n *\n * <p>If you find that you do not want to utilize the {@link AuthorizationInfo AuthorizationInfo} construct,\n * you are of course free to subclass the {@link AuthenticatingRealm AuthenticatingRealm} directly instead and\n * implement the remaining Realm interface methods directly.  You might do this if you want have better control\n * over how the Role and Permission checks occur for your specific data source.  However, using AuthorizationInfo\n * (and its default implementation {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}) is sufficient in the large\n * majority of Realm cases.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @see SimpleAuthorizationInfo\n * @since 0.2\n */\npublic abstract class AuthorizingRealm extends AuthenticatingRealm implements Initializable, PermissionResolverAware {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(AuthorizingRealm.class);\n\n    /**\n     * The default postfix appended to the realm name for caching AuthorizationInfos.\n     */\n    private static final String DEFAULT_AUTHORIZATION_CACHE_POSTFIX = \"-authorization\";\n\n    private static int INSTANCE_COUNT = 0;\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    /**\n     * The cache used by this realm to store AuthorizationInfos associated with individual Subject principals.\n     */\n    private Cache authorizationCache = null;\n\n    private String authorizationCacheName = null;\n\n    private PermissionResolver permissionResolver = new WildcardPermissionResolver();\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthorizingRealm() {\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager) {\n        super(cacheManager);\n    }\n\n    public AuthorizingRealm(CredentialsMatcher matcher) {\n        super(matcher);\n    }\n\n    public AuthorizingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        super(cacheManager, matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setAuthorizationCache(Cache authorizationCache) {\n        this.authorizationCache = authorizationCache;\n        if (this.authorizationCache != null) {\n            afterAuthorizationCacheSet();\n        }\n    }\n\n    public Cache getAuthorizationCache() {\n        return this.authorizationCache;\n    }\n\n    public String getAuthorizationCacheName() {\n        return authorizationCacheName;\n    }\n\n    public void setAuthorizationCacheName(String authorizationCacheName) {\n        this.authorizationCacheName = authorizationCacheName;\n    }\n\n    public PermissionResolver getPermissionResolver() {\n        return permissionResolver;\n    }\n\n    public void setPermissionResolver(PermissionResolver permissionResolver) {\n        this.permissionResolver = permissionResolver;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Initializes this realm and potentially enables a cache, depending on configuration.\n     *\n     * <p>When this method is called, the following logic is executed:\n     * <ol>\n     * <li>If the {@link #setAuthorizationCache cache} property has been set, it will be\n     * used to cache the AuthorizationInfo objects returned from {@link #getAuthorizationInfo}\n     * method invocations.\n     * All future calls to <tt>getAuthorizationInfo</tt> will attempt to use this cache first\n     * to alleviate any potentially unnecessary calls to an underlying data store.</li>\n     * <li>If the {@link #setAuthorizationCache cache} property has <b>not</b> been set,\n     * the {@link #setCacheManager cacheManager} property will be checked.\n     * If a <tt>cacheManager</tt> has been set, it will be used to create an authorization\n     * <tt>cache</tt>, and this newly created cache which will be used as specified in #1.</li>\n     * <li>If neither the {@link #setAuthorizationCache (org.jsecurity.cache.Cache) cache}\n     * or {@link #setCacheManager(org.jsecurity.cache.CacheManager) cacheManager}\n     * properties are set, caching will be disabled and authorization lookups will be delegated to\n     * subclass implementations for each authorization check.</li>\n     * </ol>\n     */\n    public final void init() {\n        initAuthorizationCache();\n    }\n\n    protected void afterCacheManagerSet() {\n        this.authorizationCache = null;\n        initAuthorizationCache();\n    }\n\n    protected void afterAuthorizationCacheSet() {\n    }\n\n    public void initAuthorizationCache() {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Initializing authorization cache.\");\n        }\n        Cache cache = getAuthorizationCache();\n        if (cache == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No cache implementation set.  Checking cacheManager...\");\n            }\n            CacheManager cacheManager = getCacheManager();\n            if (cacheManager != null) {\n                String cacheName = getAuthorizationCacheName();\n                if (cacheName == null) {\n                    //Simple default in case they didn't provide one:\n                    cacheName = getClass().getName() + \"-\" + INSTANCE_COUNT++ + DEFAULT_AUTHORIZATION_CACHE_POSTFIX;\n                    setAuthorizationCacheName(cacheName);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"CacheManager [\" + cacheManager + \"] has been configured.  Building \" + \"authorization cache named [\" + cacheName + \"]\");\n                }\n                cache = cacheManager.getCache(cacheName);\n                setAuthorizationCache(cache);\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"No cache or cacheManager properties have been set.  Authorization caching is \" + \"disabled.\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an account's authorization-specific information for the specified <code>principals</code>,\n     * or <tt>null</tt> if no account could be found.  The resulting <code>AuthorizationInfo</code> object is used\n     * by the other method implementations in this class to automatically perform access control checks for the\n     * corresponding <code>Subject</code>.\n     *\n     * <p>This implementation obtains the actual <code>AuthorizationInfo</code> object from the subclass's\n     * implementation of\n     * {@link #doGetAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) doGetAuthorizationInfo}, and then\n     * caches it for efficient reuse if caching is enabled (see below).\n     *\n     * <p>Invocations of this method should be thought of as completely orthogonal to acquiring\n     * {@link #getAuthenticationInfo(org.jsecurity.authc.AuthenticationToken) authenticationInfo}, since either could\n     * occur in any order.\n     *\n     * <p>For example, in &quot;Remember Me&quot; scenarios, the user identity is remembered (and\n     * assumed) for their current session and an authentication attempt during that session might never occur.\n     * But because their identity would be remembered, that is sufficient enough information to call this method to\n     * execute any necessary authorization checks.  For this reason, authentication and authorization should be\n     * loosely coupled and not depend on each other.\n     *\n     * <h4>Caching</h4>\n     *\n     * <p>The <code>AuthorizationInfo</code> values returned from this method are cached for performant reuse\n     * if caching is enabled.  Caching is enabled automatically when a <code>CacheManager</code> has been\n     * {@link #setCacheManager injected} and then the realm is {@link #init initialized}.  It can also be enabled by explictly\n     * calling {@link #initAuthorizationCache() initAuthorizationCache()}.\n     *\n     * <p>If caching is enabled, the authorization cache will be checked first and if found, will return the cached\n     * <code>AuthorizationInfo</code> immediately.  If caching is disabled, or there is a cache miss from the cache\n     * lookup, the authorization info will be looked up from the underlying data store via the\n     * {@link #doGetAuthorizationInfo(PrincipalCollection)} method, which must be implemented by subclasses.\n     *\n     * <p><b>Please note:</b>  If caching is enabled and if any authorization data for an account is changed at\n     * runtime, such as adding or removing roles and/or permissions, the subclass imlementation should clear the\n     * cached AuthorizationInfo for that account via the\n     * {@link #clearCachedAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) clearCachedAuthorizationInfo}\n     * method.  This ensures that the next call to <code>getAuthorizationInfo(PrincipalCollection)</code> will\n     * acquire the account's fresh authorization data, where it will then be cached for efficient reuse.  This\n     * ensures that stale authorization data will not be reused.\n     *\n     * @param principals the corresponding Subject's identifying principals with which to look up the Subject's\n     *                   <code>AuthorizationInfo</code>.\n     * @return the authorization information for the account associated with the specified <code>principals</code>,\n     *         or <tt>null</tt> if no account could be found.\n     */\n    public AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return null;\n        }\n        AuthorizationInfo info = null;\n        if (log.isTraceEnabled()) {\n            log.trace(\"Retrieving AuthorizationInfo for principals [\" + principals + \"]\");\n        }\n        Cache authzCache = getAuthorizationCache();\n        if (authzCache != null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to retrieve the AuthorizationIfno from cache.\");\n            }\n            Object key = getAuthorizationCacheKey(principals);\n            info = (AuthorizationInfo) authzCache.get(key);\n            if (log.isTraceEnabled()) {\n                if (info == null) {\n                    log.trace(\"No AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                } else {\n                    log.trace(\"AuthorizationInfo found in cache for principals [\" + principals + \"]\");\n                }\n            }\n        }\n        if (info == null) {\n            // Call template method if tbe info was not found in a cache\n            info = doGetAuthorizationInfo(principals);\n            // If the info is not null and the cache has been created, then cache the authorization info.\n            if (info != null && authzCache != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Caching authorization info for principals: [\" + principals + \"].\");\n                }\n                Object key = getAuthorizationCacheKey(principals);\n                authzCache.put(key, info);\n            }\n        }\n        return info;\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        return principals;\n    }\n\n    /**\n     * Clears out the AuthorizationInfo cache entry for the specified account.\n     * <p/>\n     * This method is provided as a convenience to subclasses so they can invalidate a cache entry when they\n     * change an account's authorization data (add/remove roles or permissions) during runtime.  Because an account's\n     * AuthorizationInfo can be cached, there needs to be a way to invalidate the cache for only that account so that\n     * subsequent authorization operations don't used the (old) cached value if account data changes.\n     * <p/>\n     * After this method is called, the next authorization check for that same account will result in a call to\n     * {@link #getAuthorizationInfo(org.jsecurity.subject.PrincipalCollection) getAuthorizationInfo}, and the\n     * resulting return value will be cached before being returned so it can be reused for later authorization checks.\n     *\n     * @param principals the principals of the account for which to clear the cached AuthorizationInfo.\n     */\n    protected void clearCachedAuthorizationInfo(PrincipalCollection principals) {\n        if (principals == null) {\n            return;\n        }\n        Cache cache = getAuthorizationCache();\n        //cache instance will be non-null if caching is enabled:\n        if (cache != null) {\n            Object key = getAuthorizationCacheKey(principals);\n            cache.remove(key);\n        }\n    }\n\n    /**\n     * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n     * an instance from this method, you might want to consider using an instance of\n     * {@link SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n     *\n     * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n     * @return the AuthorizationInfo associated with this principals.\n     * @see SimpleAuthorizationInfo\n     */\n    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n\n    @SuppressWarnings({ \"unchecked\" })\n    private Collection<Permission> getPermissions(AuthorizationInfo info) {\n        Set<Permission> permissions = new HashSet<Permission>();\n        if (info != null) {\n            if (info.getObjectPermissions() != null) {\n                permissions.addAll(info.getObjectPermissions());\n            }\n            if (info.getStringPermissions() != null) {\n                for (String strPermission : info.getStringPermissions()) {\n                    Permission permission = getPermissionResolver().resolvePermission(strPermission);\n                    permissions.add(permission);\n                }\n            }\n        }\n        if (permissions.isEmpty()) {\n            return Collections.EMPTY_SET;\n        } else {\n            return Collections.unmodifiableSet(permissions);\n        }\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, String permission) {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        return isPermitted(principals, p);\n    }\n\n    public boolean isPermitted(PrincipalCollection principals, Permission permission) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean isPermitted(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permission);\n        }\n        Collection<Permission> perms = getPermissions(info);\n        if (perms != null && !perms.isEmpty()) {\n            for (Permission perm : perms) {\n                if (perm.implies(permission)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions) {\n        List<Permission> perms = new ArrayList<Permission>(permissions.length);\n        for (String permString : permissions) {\n            perms.add(getPermissionResolver().resolvePermission(permString));\n        }\n        return isPermitted(subjectIdentifier, perms);\n    }\n\n    public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principals);\n        return isPermitted(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermitted(permissions);\n        }\n        boolean[] result;\n        if (permissions != null && !permissions.isEmpty()) {\n            int size = permissions.size();\n            result = new boolean[size];\n            int i = 0;\n            for (Permission p : permissions) {\n                result[i++] = isPermitted(p, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions) {\n        if (permissions != null && permissions.length > 0) {\n            Collection<Permission> perms = new ArrayList<Permission>(permissions.length);\n            for (String permString : permissions) {\n                perms.add(getPermissionResolver().resolvePermission(permString));\n            }\n            return isPermittedAll(subjectIdentifier, perms);\n        }\n        return false;\n    }\n\n    public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && isPermittedAll(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).isPermittedAll(permissions);\n        }\n        if (permissions != null && !permissions.isEmpty()) {\n            for (Permission p : permissions) {\n                if (!isPermitted(p, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException {\n        Permission p = getPermissionResolver().resolvePermission(permission);\n        checkPermission(subjectIdentifier, p);\n    }\n\n    public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermission(permission, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermission(Permission permission, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermission(permission);\n        } else {\n            if (!isPermitted(permission, info)) {\n                String msg = \"User is not permitted [\" + permission + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException {\n        if (permissions != null) {\n            for (String permString : permissions) {\n                checkPermission(subjectIdentifier, permString);\n            }\n        }\n    }\n\n    public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkPermissions(permissions, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkPermissions(permissions);\n        } else {\n            if (permissions != null && !permissions.isEmpty()) {\n                for (Permission p : permissions) {\n                    checkPermission(p, info);\n                }\n            }\n        }\n    }\n\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return hasRole(roleIdentifier, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRole(roleIdentifier);\n        }\n        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n\n    public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];\n        if (info != null) {\n            result = hasRoles(roleIdentifiers, info);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasRoles(roleIdentifiers);\n        }\n        boolean[] result;\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            int size = roleIdentifiers.size();\n            result = new boolean[size];\n            int i = 0;\n            for (String roleName : roleIdentifiers) {\n                result[i++] = hasRole(roleName, info);\n            }\n        } else {\n            result = new boolean[0];\n        }\n        return result;\n    }\n\n    public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers) {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        return info != null && hasAllRoles(roleIdentifiers, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            return ((AuthorizingAccount) info).hasAllRoles(roleIdentifiers);\n        }\n        if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {\n            for (String roleName : roleIdentifiers) {\n                if (!hasRole(roleName, info)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRole(role, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRole(String role, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRole(role);\n        } else {\n            if (!hasRole(role, info)) {\n                String msg = \"User does not have role [\" + role + \"]\";\n                throw new UnauthorizedException(msg);\n            }\n        }\n    }\n\n    public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException {\n        AuthorizationInfo info = getAuthorizationInfo(principal);\n        checkRoles(roles, info);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected void checkRoles(Collection<String> roles, AuthorizationInfo info) {\n        //todo Remove this once AuthorizingAccount class is deleted\n        if (info instanceof AuthorizingAccount) {\n            ((AuthorizingAccount) info).checkRoles(roles);\n        } else {\n            if (roles != null && !roles.isEmpty()) {\n                for (String roleName : roles) {\n                    checkRole(roleName, info);\n                }\n            }\n        }\n    }\n\n    /**\n     * If authorization caching is enabled, this will remove the AuthorizationInfo from the cache.\n     * Subclasses are free to override for additional behavior, but be sure to call <tt>super.onLogout</tt>\n     * to ensure cache cleanup.\n     *\n     * @param principals the application-specific Subject/user identifier.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        clearCachedAuthorizationInfo(principals);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthorizingRealmTest8.java",
		"test_prompt": "// AuthorizingRealmTest8.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authz.*;\nimport org.jsecurity.authz.permission.PermissionResolver;\nimport org.jsecurity.authz.permission.PermissionResolverAware;\nimport org.jsecurity.authz.permission.WildcardPermissionResolver;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.Initializable;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizingRealm}.\n* It contains ten unit test cases for the {@link AuthorizingRealm#hasAllRoles(PrincipalCollection, Collection)} method.\n*/\nclass AuthorizingRealmTest8 {"
	},
	{
		"original_code": "// LdapUtils.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.realm.ldap;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport javax.naming.NamingEnumeration;\r\nimport javax.naming.NamingException;\r\nimport javax.naming.directory.Attribute;\r\nimport javax.naming.ldap.LdapContext;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Utility class providing static methods to make working with LDAP\r\n * easier.\r\n *\r\n * @author Jeremy Haile\r\n * @since 0.2\r\n */\r\npublic class LdapUtils {\r\n\r\n    /**\r\n     * Private internal log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(LdapUtils.class);\r\n\r\n    /**\r\n     * Private constructor to prevent instantiation\r\n     */\r\n    private LdapUtils() {\r\n    }\r\n\r\n    /**\r\n     * Closes an LDAP context, logging any errors, but not throwing\r\n     * an exception if there is a failure.\r\n     *\r\n     * @param ctx the LDAP context to close.\r\n     */\r\n    public static void closeContext(LdapContext ctx) {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.close();\r\n            }\r\n        } catch (NamingException e) {\r\n            if (log.isErrorEnabled()) {\r\n                log.error(\"Exception while closing LDAP context. \", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method used to retrieve all attribute values from a particular context attribute.\r\n     *\r\n     * @param attr the LDAP attribute.\r\n     * @return the values of the attribute.\r\n     * @throws javax.naming.NamingException if there is an LDAP error while reading the values.\r\n     */\r\n    public static Collection<String> getAllAttributeValues(Attribute attr) throws NamingException {\r\n        Set<String> values = new HashSet<String>();\r\n        for (NamingEnumeration e = attr.getAll(); e.hasMore(); ) {\r\n            String value = (String) e.next();\r\n            values.add(value);\r\n        }\r\n        return values;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/ldap/LdapUtilsTest.java",
		"test_prompt": "// LdapUtilsTest.java\npackage org.jsecurity.realm.ldap;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.ldap.LdapContext;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LdapUtils}.\n* It contains ten unit test cases for the {@link LdapUtils#getAllAttributeValues(Attribute)} method.\n*/\nclass LdapUtilsTest {"
	},
	{
		"original_code": "// AuthenticatingRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authc.credential.SimpleCredentialsMatcher;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\n\n/**\n * A top-level abstract implementation of the <tt>Realm</tt> interface that only implements authentication support\n * (log-in) operations and leaves authorization (access control) behavior to subclasses.\n *\n * <p>Since a Realm provides both authentication <em>and</em> authorization operations, the implementation approach for\n * this class could have been reversed.  That is, authorization support could have been implemented here and\n * authentication support left to subclasses.\n *\n * <p>The reason the existing implementation is in place though\n * (authentication support) is that most authentication operations are fairly common across the large majority of\n * applications, whereas authorization operations are more so heavily dependent upon the application's data model, which\n * can vary widely.\n *\n * <p>By providing the most common authentication operations here and leaving data-model specific authorization checks\n * to subclasses, a top-level abstract class for most common authentication behavior is more useful as an extension\n * point for most applications.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.2\n */\npublic abstract class AuthenticatingRealm extends CachingRealm implements LogoutAware {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(AuthenticatingRealm.class);\n\n    /**\n     * Password matcher used to determine if the provided password matches\n     * the password stored in the data store.\n     */\n    private CredentialsMatcher credentialsMatcher = new SimpleCredentialsMatcher();\n\n    /**\n     * The class that this realm supports for authentication tokens.  This is used by the\n     * default implementation of the {@link Realm#supports(org.jsecurity.authc.AuthenticationToken)} method to\n     * determine whether or not the given authentication token is supported by this realm.\n     */\n    private Class<? extends AuthenticationToken> authenticationTokenClass = UsernamePasswordToken.class;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    public AuthenticatingRealm() {\n    }\n\n    public AuthenticatingRealm(CacheManager cacheManager) {\n        setCacheManager(cacheManager);\n    }\n\n    public AuthenticatingRealm(CredentialsMatcher matcher) {\n        setCredentialsMatcher(matcher);\n    }\n\n    public AuthenticatingRealm(CacheManager cacheManager, CredentialsMatcher matcher) {\n        setCacheManager(cacheManager);\n        setCredentialsMatcher(matcher);\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    /**\n     * Returns the <code>CredentialsMatcher</code> used during an authentication attempt to verify submitted\n     * credentials with those stored in the system.\n     *\n     * <p>Unless overridden by the {@link #setCredentialsMatcher setCredentialsMatcher} method, the default\n     * value is a {@link org.jsecurity.authc.credential.SimpleCredentialsMatcher SimpleCredentialsMatcher} instance.\n     *\n     * @return the <code>CredentialsMatcher</code> used during an authentication attempt to verify submitted\n     *         credentials with those stored in the system.\n     */\n    public CredentialsMatcher getCredentialsMatcher() {\n        return credentialsMatcher;\n    }\n\n    /**\n     * Sets the CrendialsMatcher used during an authentication attempt to verify submitted credentials with those\n     * stored in the system.  The implementation of this matcher can be switched via configuration to\n     * support any number of schemes, including plain text comparisons, hashing comparisons, and others.\n     *\n     * <p>Unless overridden by this method, the default value is a\n     * {@link org.jsecurity.authc.credential.SimpleCredentialsMatcher} instance.\n     *\n     * @param credentialsMatcher the matcher to use.\n     */\n    public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) {\n        this.credentialsMatcher = credentialsMatcher;\n    }\n\n    /**\n     * Returns the authenticationToken class supported by this realm.\n     *\n     * <p>The default value is <tt>{@link UsernamePasswordToken UsernamePasswordToken.class}</tt>, since\n     * about 90% of realms use username/password authentication, regardless of their protocol (e.g. over jdbc, ldap,\n     * kerberos, http, etc).\n     *\n     * <p>If subclasses haven't already overridden the {@link Realm#supports Realm.supports(AuthenticationToken)} method,\n     * they must {@link #setAuthenticationTokenClass(Class) set a new class} if they won't support\n     * <tt>UsernamePasswordToken</tt> authentication token submissions.\n     *\n     * @return the authenticationToken class supported by this realm.\n     * @see #setAuthenticationTokenClass\n     */\n    public Class getAuthenticationTokenClass() {\n        return authenticationTokenClass;\n    }\n\n    /**\n     * Sets the authenticationToken class supported by this realm.\n     *\n     * <p>Unless overridden by this method, the default value is\n     * {@link UsernamePasswordToken UsernamePasswordToken.class} to support the majority of applications.\n     *\n     * @param authenticationTokenClass the class of authentication token instances supported by this realm.\n     * @see #getAuthenticationTokenClass getAuthenticationTokenClass() for more explanation.\n     */\n    public void setAuthenticationTokenClass(Class<? extends AuthenticationToken> authenticationTokenClass) {\n        this.authenticationTokenClass = authenticationTokenClass;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Convenience implementation that returns\n     * <tt>getAuthenticationTokenClass().isAssignableFrom( token.getClass() );</tt>.  Can be overridden\n     * by subclasses for more complex token checking.\n     * <p>Most configurations will only need to set a different class via\n     * {@link #setAuthenticationTokenClass}, as opposed to overriding this method.\n     *\n     * @param token the token being submitted for authentication.\n     * @return true if this authentication realm can process the submitted token instance of the class, false otherwise.\n     */\n    public boolean supports(AuthenticationToken token) {\n        return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());\n    }\n\n    public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo info = doGetAuthenticationInfo(token);\n        if (info == null) {\n            if (log.isDebugEnabled()) {\n                String msg = \"No authentication information found for submitted authentication token [\" + token + \"].  \" + \"Returning null.\";\n                log.debug(msg);\n            }\n            return null;\n        }\n        CredentialsMatcher cm = getCredentialsMatcher();\n        if (cm != null) {\n            if (!cm.doCredentialsMatch(token, info)) {\n                String msg = \"The credentials provided for account [\" + token + \"] did not match the expected credentials.\";\n                throw new IncorrectCredentialsException(msg);\n            }\n        } else {\n            throw new AuthenticationException(\"A CredentialsMatcher must be configured in order to verify \" + \"credentials during authentication.  If you do not wish for credentials to be examined, you \" + \"can configure an \" + AllowAllCredentialsMatcher.class.getName() + \" instance.\");\n        }\n        return info;\n    }\n\n    /**\n     * Retrieves authentication data from an implementation-specific datasource (RDBMS, LDAP, etc) for the given\n     * authentication token.\n     *\n     * <p>For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing\n     * more and letting JSecurity do the rest.  But in some systems, this method could actually perform EIS specific\n     * log-in logic in addition to just retrieving data - it is up to the Realm implementation.\n     *\n     * <p>A <tt>null</tt> return value means that no account could be associated with the specified token.\n     *\n     * @param token the authentication token containing the user's principal and credentials.\n     * @return an {@link AuthenticationInfo} object containing account data resulting from the\n     *         authentication ONLY if the lookup is successful (i.e. account exists and is valid, etc.)\n     * @throws org.jsecurity.authc.AuthenticationException\n     *          if there is an error acquiring data or performing\n     *          realm-specific authentication logic for the specified <tt>token</tt>\n     */\n    protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;\n\n    /**\n     * Default implementation that does nothing (no-op) and exists as a convenience mechanism in case subclasses\n     * wish to override it to implement realm-specific logout logic for the given user account logging out.</p>\n     * <p/>\n     * In a single-realm JSecurity configuration (most applications), the <code>principals</code> method\n     * argument will be the same as that which is contained in the <code>AuthenticationInfo</code> object returned by the\n     * {@link #doGetAuthenticationInfo} method (that is, {@link AuthenticationInfo#getPrincipals info.getPrincipals()}).\n     * <p/>\n     * In a multi-realm JSecurity configuration, the given <code>principals</code> method\n     * argument could contain principals returned by many realms.  Therefore the subclass implementation would need\n     * to know how to extract the principal(s) relevant to only itself and ignore other realms' principals.  This is\n     * usually done by calling {@link PrincipalCollection#fromRealm(String) principals.fromRealm(name)},\n     * using the realm's own {@link org.jsecurity.realm.Realm#getName() name}.\n     *\n     * @param principals the application-specific Subject/user identifier that is logging out.\n     */\n    public void onLogout(PrincipalCollection principals) {\n        //no-op, here for subclass override if desired.\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/AuthenticatingRealmTest.java",
		"test_prompt": "// AuthenticatingRealmTest.java\npackage org.jsecurity.realm;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authc.credential.AllowAllCredentialsMatcher;\nimport org.jsecurity.authc.credential.CredentialsMatcher;\nimport org.jsecurity.authc.credential.SimpleCredentialsMatcher;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticatingRealm}.\n* It contains ten unit test cases for the {@link AuthenticatingRealm#supports(AuthenticationToken)} method.\n*/\nclass AuthenticatingRealmTest {"
	},
	{
		"original_code": "// SimpleAccountRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.CollectionUtils;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.</p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm {\n\n    //TODO - complete JavaDoc\n    protected Map<String, SimpleRole> roles = null;\n\n    public SimpleAccountRealm() {\n        init();\n    }\n\n    public SimpleAccountRealm(String name) {\n        setName(name);\n        init();\n    }\n\n    public void afterAuthorizationCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet() {\n    }\n\n    protected void initRoleCache() {\n        if (getAuthorizationCache() == null) {\n            initAuthorizationCache();\n        }\n        this.roles = new HashMap<String, SimpleRole>();\n        accountAndRoleCachesCreated();\n    }\n\n    protected SimpleAccount getUser(String username) {\n        return (SimpleAccount) getAuthorizationCache().get(username);\n    }\n\n    public boolean accountExists(String username) {\n        return getUser(username) != null;\n    }\n\n    public void addAccount(String username, String password) {\n        addAccount(username, password, (String[]) null);\n    }\n\n    public void addAccount(String username, String password, String... roles) {\n        Set<String> roleNames = CollectionUtils.asSet(roles);\n        SimpleAccount account = new SimpleAuthorizingAccount(username, password, getName(), roleNames, null);\n        add(account);\n    }\n\n    protected void add(SimpleAccount account) {\n        Object key = getAuthorizationCacheKey(account.getPrincipals());\n        getAuthorizationCache().put(key, account);\n    }\n\n    protected SimpleRole getRole(String rolename) {\n        return roles.get(rolename);\n    }\n\n    public boolean roleExists(String name) {\n        return getRole(name) != null;\n    }\n\n    public void addRole(String name) {\n        add(new SimpleRole(name));\n    }\n\n    protected void add(SimpleRole role) {\n        roles.put(role.getName(), role);\n    }\n\n    protected static Set<String> toSet(String delimited, String delimiter) {\n        if (delimited == null || delimited.trim().equals(\"\")) {\n            return null;\n        }\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split(delimiter);\n        for (String s : rolenamesArray) {\n            String trimmed = s.trim();\n            if (trimmed.length() > 0) {\n                values.add(trimmed);\n            }\n        }\n        return values;\n    }\n\n    protected void accountAndRoleCachesCreated() {\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        SimpleAccount account = (SimpleAccount) getAuthorizationCache().get(upToken.getUsername());\n        if (account.isLocked()) {\n            throw new LockedAccountException(\"Account [\" + account + \"] is locked.\");\n        }\n        if (account.isCredentialsExpired()) {\n            String msg = \"The credentials for account [\" + account + \"] are expired\";\n            throw new ExpiredCredentialsException(msg);\n        }\n        return account;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        return (Account) getAuthorizationCache().get(getAuthorizationCacheKey(principals));\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        //returns the username\n        return principals.fromRealm(getName()).iterator().next();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/SimpleAccountRealmTest0.java",
		"test_prompt": "// SimpleAccountRealmTest0.java\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.CollectionUtils;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccountRealm}.\n* It contains ten unit test cases for the {@link SimpleAccountRealm#accountExists(String)} method.\n*/\nclass SimpleAccountRealmTest0 {"
	},
	{
		"original_code": "// SimpleAccountRealm.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.CollectionUtils;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * <p>A simple implementation of the {@link org.jsecurity.realm.Realm Realm} interface that\n * uses a set of configured user accounts and roles to support authentication and authorization.  Each account entry\n * specifies the username, password, and roles for a user.  Roles can also be mapped\n * to permissions and associated with users.</p>\n *\n * <p>User accounts and roles are stored in two {@link Cache cache}s, so it is the Cache manager implementation that\n * determines if this class stores all data in memory or spools to disk or clusters it, etc based on the\n * Caches it creates.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleAccountRealm extends AuthorizingRealm {\n\n    //TODO - complete JavaDoc\n    protected Map<String, SimpleRole> roles = null;\n\n    public SimpleAccountRealm() {\n        init();\n    }\n\n    public SimpleAccountRealm(String name) {\n        setName(name);\n        init();\n    }\n\n    public void afterAuthorizationCacheSet() {\n        initRoleCache();\n        afterRoleCacheSet();\n    }\n\n    public void afterRoleCacheSet() {\n    }\n\n    protected void initRoleCache() {\n        if (getAuthorizationCache() == null) {\n            initAuthorizationCache();\n        }\n        this.roles = new HashMap<String, SimpleRole>();\n        accountAndRoleCachesCreated();\n    }\n\n    protected SimpleAccount getUser(String username) {\n        return (SimpleAccount) getAuthorizationCache().get(username);\n    }\n\n    public boolean accountExists(String username) {\n        return getUser(username) != null;\n    }\n\n    public void addAccount(String username, String password) {\n        addAccount(username, password, (String[]) null);\n    }\n\n    public void addAccount(String username, String password, String... roles) {\n        Set<String> roleNames = CollectionUtils.asSet(roles);\n        SimpleAccount account = new SimpleAuthorizingAccount(username, password, getName(), roleNames, null);\n        add(account);\n    }\n\n    protected void add(SimpleAccount account) {\n        Object key = getAuthorizationCacheKey(account.getPrincipals());\n        getAuthorizationCache().put(key, account);\n    }\n\n    protected SimpleRole getRole(String rolename) {\n        return roles.get(rolename);\n    }\n\n    public boolean roleExists(String name) {\n        return getRole(name) != null;\n    }\n\n    public void addRole(String name) {\n        add(new SimpleRole(name));\n    }\n\n    protected void add(SimpleRole role) {\n        roles.put(role.getName(), role);\n    }\n\n    protected static Set<String> toSet(String delimited, String delimiter) {\n        if (delimited == null || delimited.trim().equals(\"\")) {\n            return null;\n        }\n        Set<String> values = new HashSet<String>();\n        String[] rolenamesArray = delimited.split(delimiter);\n        for (String s : rolenamesArray) {\n            String trimmed = s.trim();\n            if (trimmed.length() > 0) {\n                values.add(trimmed);\n            }\n        }\n        return values;\n    }\n\n    protected void accountAndRoleCachesCreated() {\n    }\n\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n        SimpleAccount account = (SimpleAccount) getAuthorizationCache().get(upToken.getUsername());\n        if (account.isLocked()) {\n            throw new LockedAccountException(\"Account [\" + account + \"] is locked.\");\n        }\n        if (account.isCredentialsExpired()) {\n            String msg = \"The credentials for account [\" + account + \"] are expired\";\n            throw new ExpiredCredentialsException(msg);\n        }\n        return account;\n    }\n\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        return (Account) getAuthorizationCache().get(getAuthorizationCacheKey(principals));\n    }\n\n    protected Object getAuthorizationCacheKey(PrincipalCollection principals) {\n        //returns the username\n        return principals.fromRealm(getName()).iterator().next();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/realm/SimpleAccountRealmTest1.java",
		"test_prompt": "// SimpleAccountRealmTest1.java\npackage org.jsecurity.realm;\n\nimport org.jsecurity.authc.*;\nimport org.jsecurity.authz.AuthorizationInfo;\nimport org.jsecurity.authz.SimpleAuthorizingAccount;\nimport org.jsecurity.authz.SimpleRole;\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.util.CollectionUtils;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleAccountRealm}.\n* It contains ten unit test cases for the {@link SimpleAccountRealm#roleExists(String)} method.\n*/\nclass SimpleAccountRealmTest1 {"
	},
	{
		"original_code": "// SecureRemoteInvocationExecutor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.DelegatingSubject;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}\n * that binds the correct {@link Session} and {@link org.jsecurity.subject.Subject} to the\n * remote invocation thread during a remote execution.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SecureRemoteInvocationExecutor extends DefaultRemoteInvocationExecutor {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(SecureRemoteInvocationExecutor.class);\n\n    /**\n     * The SecurityManager used to retrieve realms that should be associated with the\n     * created <tt>Subject</tt>s upon remote invocation.\n     */\n    private SecurityManager securityManager;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    public void setSecurityManager(org.jsecurity.mgt.SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    protected InetAddress getInetAddress(RemoteInvocation invocation, Object targetObject) {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n\n    protected PrincipalCollection getPrincipals(RemoteInvocation invocation, Object targetObject, Session session) {\n        return (PrincipalCollection) session.getAttribute(DefaultWebSecurityManager.PRINCIPALS_SESSION_KEY);\n    }\n\n    protected boolean isAuthenticated(RemoteInvocation invocation, Object targetObject, Session session, PrincipalCollection principals) {\n        if (principals != null) {\n            Boolean authc = (Boolean) session.getAttribute(DefaultWebSecurityManager.AUTHENTICATED_SESSION_KEY);\n            return authc != null && authc;\n        }\n        return false;\n    }\n\n    @SuppressWarnings({ \"unchecked\" })\n    public Object invoke(RemoteInvocation invocation, Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        try {\n            PrincipalCollection principals = null;\n            boolean authenticated = false;\n            InetAddress inetAddress = getInetAddress(invocation, targetObject);\n            Session session = null;\n            Serializable sessionId = invocation.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY);\n            if (sessionId != null) {\n                session = securityManager.getSession(sessionId);\n                principals = getPrincipals(invocation, targetObject, session);\n                authenticated = isAuthenticated(invocation, targetObject, session, principals);\n            } else {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"RemoteInvocation object did not contain a JSecurity Session id under \" + \"attribute name [\" + SecureRemoteInvocationFactory.SESSION_ID_KEY + \"].  A Session will not \" + \"be available to the method.  Ensure that clients are using a \" + \"SecureRemoteInvocationFactory to prevent this problem.\");\n                }\n            }\n            Subject subject = new DelegatingSubject(principals, authenticated, inetAddress, session, securityManager);\n            ThreadContext.bind(securityManager);\n            ThreadContext.bind(subject);\n            return super.invoke(invocation, targetObject);\n        } catch (NoSuchMethodException nsme) {\n            throw nsme;\n        } catch (IllegalAccessException iae) {\n            throw iae;\n        } catch (InvocationTargetException ite) {\n            throw ite;\n        } catch (Throwable t) {\n            throw new InvocationTargetException(t);\n        } finally {\n            ThreadContext.clear();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/remoting/SecureRemoteInvocationExecutorTest.java",
		"test_prompt": "// SecureRemoteInvocationExecutorTest.java\npackage org.jsecurity.spring.remoting;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.subject.DelegatingSubject;\nimport org.jsecurity.subject.PrincipalCollection;\nimport org.jsecurity.subject.Subject;\nimport org.jsecurity.util.ThreadContext;\nimport org.jsecurity.web.DefaultWebSecurityManager;\nimport org.springframework.remoting.support.DefaultRemoteInvocationExecutor;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SecureRemoteInvocationExecutor}.\n* It contains ten unit test cases for the {@link SecureRemoteInvocationExecutor#invoke(RemoteInvocation, Object)} method.\n*/\nclass SecureRemoteInvocationExecutorTest {"
	},
	{
		"original_code": "// SecureRemoteInvocationFactory.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.spring.remoting;\n\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.jsecurity.session.Session;\nimport org.springframework.remoting.support.DefaultRemoteInvocationFactory;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationFactory;\n\n/**\n * A {@link RemoteInvocationFactory} that passes the session ID to the server via a\n * {@link RemoteInvocation} {@link RemoteInvocation#getAttribute(String) attribute}.\n * This factory is the client-side part of\n * the JSecurity Spring remoting invocation.  A {@link SecureRemoteInvocationExecutor} should\n * be used to export the server-side remote services to ensure that the appropriate\n * Subject and Session are bound to the remote thread during execution.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SecureRemoteInvocationFactory extends DefaultRemoteInvocationFactory {\n\n    //TODO - complete JavaDoc\n    public static final String SESSION_ID_KEY = Session.class.getName() + \"_ID_KEY\";\n\n    private static final String SESSION_ID_SYSTEM_PROPERTY_NAME = \"jsecurity.session.id\";\n\n    /**\n     * Creates a {@link RemoteInvocation} with the current session ID as an\n     * {@link RemoteInvocation#getAttribute(String) attribute}.\n     *\n     * @param methodInvocation the method invocation that the remote invocation should\n     *                         be based on.\n     * @return a remote invocation object containing the current session ID as an attribute.\n     */\n    public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {\n        String sessionId = System.getProperty(SESSION_ID_SYSTEM_PROPERTY_NAME);\n        if (sessionId == null) {\n            throw new IllegalStateException(\"System property [\" + SESSION_ID_SYSTEM_PROPERTY_NAME + \"] is not set.  \" + \"This property must be set to the JSecurity session ID for remote calls to function.\");\n        }\n        RemoteInvocation ri = new RemoteInvocation(methodInvocation);\n        ri.addAttribute(SESSION_ID_KEY, sessionId);\n        return ri;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/remoting/SecureRemoteInvocationFactoryTest.java",
		"test_prompt": "// SecureRemoteInvocationFactoryTest.java\npackage org.jsecurity.spring.remoting;\n\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.jsecurity.session.Session;\nimport org.springframework.remoting.support.DefaultRemoteInvocationFactory;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SecureRemoteInvocationFactory}.\n* It contains ten unit test cases for the {@link SecureRemoteInvocationFactory#createRemoteInvocation(MethodInvocation)} method.\n*/\nclass SecureRemoteInvocationFactoryTest {"
	},
	{
		"original_code": "// AopAllianceAnnotationsAuthorizingMethodInterceptor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.spring.security.interceptor;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.jsecurity.authz.aop.AnnotationsAuthorizingMethodInterceptor;\nimport java.lang.reflect.Method;\n\n/**\n * Allows JSecurity Annotations to work in any <a href=\"http://aopalliance.sourceforge.net/\">AOP Alliance</a>\n * specific implementation environment (for example, Spring).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic class AopAllianceAnnotationsAuthorizingMethodInterceptor extends AnnotationsAuthorizingMethodInterceptor implements MethodInterceptor {\n\n    /**\n     * Creates a {@link MethodInvocation MethodInvocation} that wraps an\n     * {@link org.aopalliance.intercept.MethodInvocation org.aopalliance.intercept.MethodInvocation} instance,\n     * enabling JSecurity Annotations in <a href=\"http://aopalliance.sourceforge.net/\">AOP Alliance</a> environments\n     * (Spring, etc).\n     *\n     * @param implSpecificMethodInvocation AOP Alliance {@link org.aopalliance.intercept.MethodInvocation MethodInvocation}\n     * @return a JSecurity {@link MethodInvocation MethodInvocation} instance that wraps the AOP Alliance instance.\n     */\n    protected org.jsecurity.aop.MethodInvocation createMethodInvocation(Object implSpecificMethodInvocation) {\n        final MethodInvocation mi = (MethodInvocation) implSpecificMethodInvocation;\n        return new org.jsecurity.aop.MethodInvocation() {\n\n            public Method getMethod() {\n                return mi.getMethod();\n            }\n\n            public Object[] getArguments() {\n                return mi.getArguments();\n            }\n\n            public String toString() {\n                return \"Method invocation [\" + mi.getMethod() + \"]\";\n            }\n\n            public Object proceed() throws Throwable {\n                return mi.proceed();\n            }\n        };\n    }\n\n    /**\n     * Simply casts the method argument to an\n     * {@link org.aopalliance.intercept.MethodInvocation org.aopalliance.intercept.MethodInvocation} and then\n     * calls <code>methodInvocation.{@link org.aopalliance.intercept.MethodInvocation#proceed proceed}()</code>\n     * @param aopAllianceMethodInvocation the {@link org.aopalliance.intercept.MethodInvocation org.aopalliance.intercept.MethodInvocation}\n     * @return the {@link org.aopalliance.intercept.MethodInvocation#proceed() org.aopalliance.intercept.MethodInvocation.proceed()} method call result.\n     * @throws Throwable if the underlying AOP Alliance <code>proceed()</code> call throws a <code>Throwable</code>.\n     */\n    protected Object continueInvocation(Object aopAllianceMethodInvocation) throws Throwable {\n        MethodInvocation mi = (MethodInvocation) aopAllianceMethodInvocation;\n        return mi.proceed();\n    }\n\n    /**\n     * Creates a JSecurity {@link MethodInvocation MethodInvocation} instance and then immediately calls\n     * {@link org.jsecurity.authz.aop.AuthorizingMethodInterceptor#invoke super.invoke}.\n     *\n     * @param methodInvocation the AOP Alliance-specific <code>methodInvocation</code> instance.\n     * @return the return value from invoking the method invocation.\n     * @throws Throwable if the underlying AOP Alliance method invocation throws a <code>Throwable</code>.\n     */\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        org.jsecurity.aop.MethodInvocation mi = createMethodInvocation(methodInvocation);\n        return super.invoke(mi);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/security/interceptor/AopAllianceAnnotationsAuthorizingMethodInterceptorTest.java",
		"test_prompt": "// AopAllianceAnnotationsAuthorizingMethodInterceptorTest.java\npackage org.jsecurity.spring.security.interceptor;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.jsecurity.authz.aop.AnnotationsAuthorizingMethodInterceptor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AopAllianceAnnotationsAuthorizingMethodInterceptor}.\n* It contains ten unit test cases for the {@link AopAllianceAnnotationsAuthorizingMethodInterceptor#invoke(MethodInvocation)} method.\n*/\nclass AopAllianceAnnotationsAuthorizingMethodInterceptorTest {"
	},
	{
		"original_code": "// AuthorizationAttributeSourceAdvisor.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.spring.security.interceptor;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.annotation.*;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor;\nimport org.springframework.beans.factory.InitializingBean;\nimport java.lang.reflect.Method;\n\n/**\n * TODO - complete JavaDoc\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class AuthorizationAttributeSourceAdvisor extends StaticMethodMatcherPointcutAdvisor implements InitializingBean {\n\n    private static final Log log = LogFactory.getLog(AuthorizationAttributeSourceAdvisor.class);\n\n    protected SecurityManager securityManager = null;\n\n    /**\n     * Create a new AuthorizationAttributeSourceAdvisor.\n     */\n    public AuthorizationAttributeSourceAdvisor() {\n    }\n\n    public SecurityManager getSecurityManager() {\n        return securityManager;\n    }\n\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    /**\n     * Returns <tt>true</tt> if the method has any JSecurity annotations, false otherwise.\n     * The annotations inspected are:\n     * <ul>\n     * <li>{@link org.jsecurity.authz.annotation.RequiresAuthentication RequiresAuthentication}</li>\n     * <li>{@link org.jsecurity.authz.annotation.RequiresUser RequiresUser}</li>\n     * <li>{@link org.jsecurity.authz.annotation.RequiresGuest RequiresGuest}</li>\n     * <li>{@link org.jsecurity.authz.annotation.RequiresRoles RequiresRoles}</li>\n     * <li>{@link org.jsecurity.authz.annotation.RequiresPermissions RequiresPermissions}</li>\n     * </ul>\n     *\n     * @param method      the method to check for a JSecurity annotation\n     * @param targetClass the class potentially declaring JSecurity annotations\n     * @return <tt>true</tt> if the method has a JSecurity annotation, false otherwise.\n     * @see org.springframework.aop.MethodMatcher#matches(java.lang.reflect.Method, Class)\n     */\n    public boolean matches(Method method, Class targetClass) {\n        return ((method.getAnnotation(RequiresPermissions.class) != null) || (method.getAnnotation(RequiresRoles.class) != null) || (method.getAnnotation(RequiresUser.class) != null) || (method.getAnnotation(RequiresGuest.class) != null) || (method.getAnnotation(RequiresAuthentication.class) != null));\n    }\n\n    public void afterPropertiesSet() throws Exception {\n        if (getAdvice() == null) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No authorization advice explicitly configured via the 'advice' \" + \"property.  Attempting to set \" + \"default instance of type [\" + AopAllianceAnnotationsAuthorizingMethodInterceptor.class.getName() + \"]\");\n            }\n            AopAllianceAnnotationsAuthorizingMethodInterceptor interceptor = new AopAllianceAnnotationsAuthorizingMethodInterceptor();\n            setAdvice(interceptor);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/security/interceptor/AuthorizationAttributeSourceAdvisorTest.java",
		"test_prompt": "// AuthorizationAttributeSourceAdvisorTest.java\npackage org.jsecurity.spring.security.interceptor;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.annotation.*;\nimport org.jsecurity.mgt.SecurityManager;\nimport org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor;\nimport org.springframework.beans.factory.InitializingBean;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthorizationAttributeSourceAdvisor}.\n* It contains ten unit test cases for the {@link AuthorizationAttributeSourceAdvisor#matches(Method, Class)} method.\n*/\nclass AuthorizationAttributeSourceAdvisorTest {"
	},
	{
		"original_code": "// LifecycleBeanPostProcessor.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.spring;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.util.Destroyable;\r\nimport org.jsecurity.util.Initializable;\r\nimport org.springframework.beans.BeansException;\r\nimport org.springframework.beans.FatalBeanException;\r\nimport org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;\r\n\r\n/**\r\n * <p>Bean post processor for Spring that automatically calls the <tt>init()</tt> and/or\r\n * <tt>destroy()</tt> methods on JSecurity objects that implement the {@link org.jsecurity.util.Initializable}\r\n * or {@link org.jsecurity.util.Destroyable} interfaces, respectfully.  This post processor makes it easier\r\n * to configure JSecurity beans in Spring, since the user never has to worry about whether or not if they\r\n * have to specify init-method and destroy-method bean attributes.</p>\r\n *\r\n * <p><b>Warning: This post processor has no way to determine if <tt>init()</tt> or <tt>destroy()</tt> have\r\n * already been called, so if you define this post processor in your applicationContext, do not also call these\r\n * methods manually or via Spring's <tt>init-method</tt> or <tt>destroy-method</tt> bean attributes.</b></p>\r\n *\r\n * @author Jeremy Haile\r\n * @since 0.2\r\n */\r\npublic class LifecycleBeanPostProcessor implements DestructionAwareBeanPostProcessor {\r\n\r\n    /**\r\n     * Private internal class log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(LifecycleBeanPostProcessor.class);\r\n\r\n    /**\r\n     * Calls the <tt>init()</tt> methods on the bean if it implements {@link org.jsecurity.util.Initializable}\r\n     *\r\n     * @param object the object being initialized.\r\n     * @param name   the name of the bean being initialized.\r\n     * @return the initialized bean.\r\n     * @throws BeansException if any exception is thrown during initialization.\r\n     */\r\n    public Object postProcessBeforeInitialization(Object object, String name) throws BeansException {\r\n        if (object instanceof Initializable) {\r\n            try {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Initializing bean [\" + name + \"]...\");\r\n                }\r\n                ((Initializable) object).init();\r\n            } catch (Exception e) {\r\n                throw new FatalBeanException(\"Error initializing bean [\" + name + \"]\", e);\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n\r\n    /**\r\n     * Does nothing - merely returns the object argument immediately.\r\n     */\r\n    public Object postProcessAfterInitialization(Object object, String name) throws BeansException {\r\n        // Does nothing after initialization\r\n        return object;\r\n    }\r\n\r\n    /**\r\n     * Calls the <tt>destroy()</tt> methods on the bean if it implements {@link org.jsecurity.util.Destroyable}\r\n     *\r\n     * @param object the object being initialized.\r\n     * @param name   the name of the bean being initialized.\r\n     * @throws BeansException if any exception is thrown during initialization.\r\n     */\r\n    public void postProcessBeforeDestruction(Object object, String name) throws BeansException {\r\n        if (object instanceof Destroyable) {\r\n            try {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Destroying bean [\" + name + \"]...\");\r\n                }\r\n                ((Destroyable) object).destroy();\r\n            } catch (Exception e) {\r\n                throw new FatalBeanException(\"Error destroying bean [\" + name + \"]\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/LifecycleBeanPostProcessorTest0.java",
		"test_prompt": "// LifecycleBeanPostProcessorTest0.java\npackage org.jsecurity.spring;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.FatalBeanException;\nimport org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LifecycleBeanPostProcessor}.\n* It contains ten unit test cases for the {@link LifecycleBeanPostProcessor#postProcessBeforeInitialization(Object, String)} method.\n*/\nclass LifecycleBeanPostProcessorTest0 {"
	},
	{
		"original_code": "// LifecycleBeanPostProcessor.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.spring;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.jsecurity.util.Destroyable;\r\nimport org.jsecurity.util.Initializable;\r\nimport org.springframework.beans.BeansException;\r\nimport org.springframework.beans.FatalBeanException;\r\nimport org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;\r\n\r\n/**\r\n * <p>Bean post processor for Spring that automatically calls the <tt>init()</tt> and/or\r\n * <tt>destroy()</tt> methods on JSecurity objects that implement the {@link org.jsecurity.util.Initializable}\r\n * or {@link org.jsecurity.util.Destroyable} interfaces, respectfully.  This post processor makes it easier\r\n * to configure JSecurity beans in Spring, since the user never has to worry about whether or not if they\r\n * have to specify init-method and destroy-method bean attributes.</p>\r\n *\r\n * <p><b>Warning: This post processor has no way to determine if <tt>init()</tt> or <tt>destroy()</tt> have\r\n * already been called, so if you define this post processor in your applicationContext, do not also call these\r\n * methods manually or via Spring's <tt>init-method</tt> or <tt>destroy-method</tt> bean attributes.</b></p>\r\n *\r\n * @author Jeremy Haile\r\n * @since 0.2\r\n */\r\npublic class LifecycleBeanPostProcessor implements DestructionAwareBeanPostProcessor {\r\n\r\n    /**\r\n     * Private internal class log instance.\r\n     */\r\n    private static final Log log = LogFactory.getLog(LifecycleBeanPostProcessor.class);\r\n\r\n    /**\r\n     * Calls the <tt>init()</tt> methods on the bean if it implements {@link org.jsecurity.util.Initializable}\r\n     *\r\n     * @param object the object being initialized.\r\n     * @param name   the name of the bean being initialized.\r\n     * @return the initialized bean.\r\n     * @throws BeansException if any exception is thrown during initialization.\r\n     */\r\n    public Object postProcessBeforeInitialization(Object object, String name) throws BeansException {\r\n        if (object instanceof Initializable) {\r\n            try {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Initializing bean [\" + name + \"]...\");\r\n                }\r\n                ((Initializable) object).init();\r\n            } catch (Exception e) {\r\n                throw new FatalBeanException(\"Error initializing bean [\" + name + \"]\", e);\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n\r\n    /**\r\n     * Does nothing - merely returns the object argument immediately.\r\n     */\r\n    public Object postProcessAfterInitialization(Object object, String name) throws BeansException {\r\n        // Does nothing after initialization\r\n        return object;\r\n    }\r\n\r\n    /**\r\n     * Calls the <tt>destroy()</tt> methods on the bean if it implements {@link org.jsecurity.util.Destroyable}\r\n     *\r\n     * @param object the object being initialized.\r\n     * @param name   the name of the bean being initialized.\r\n     * @throws BeansException if any exception is thrown during initialization.\r\n     */\r\n    public void postProcessBeforeDestruction(Object object, String name) throws BeansException {\r\n        if (object instanceof Destroyable) {\r\n            try {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Destroying bean [\" + name + \"]...\");\r\n                }\r\n                ((Destroyable) object).destroy();\r\n            } catch (Exception e) {\r\n                throw new FatalBeanException(\"Error destroying bean [\" + name + \"]\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/spring/LifecycleBeanPostProcessorTest1.java",
		"test_prompt": "// LifecycleBeanPostProcessorTest1.java\npackage org.jsecurity.spring;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.Initializable;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.FatalBeanException;\nimport org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LifecycleBeanPostProcessor}.\n* It contains ten unit test cases for the {@link LifecycleBeanPostProcessor#postProcessAfterInitialization(Object, String)} method.\n*/\nclass LifecycleBeanPostProcessorTest1 {"
	},
	{
		"original_code": "// AbstractSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * TODO - complete JavaDoc\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    private static final Log log = LogFactory.getLog(AbstractSessionManager.class);\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener</code>s for notification\n     * that the session has been invalidated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session</code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session</code> object being invalidated.\n     * @return the <code>Session</code> instance to use to pass to registered <code>SessionListener</code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    public boolean isValid(Serializable sessionId) {\n        try {\n            getSession(sessionId);\n        } catch (InvalidSessionException e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/AbstractSessionManagerTest0.java",
		"test_prompt": "// AbstractSessionManagerTest0.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractSessionManager}.\n* It contains ten unit test cases for the {@link AbstractSessionManager#remove(SessionListener)} method.\n*/\nclass AbstractSessionManagerTest0 {"
	},
	{
		"original_code": "// AbstractSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * TODO - complete JavaDoc\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    private static final Log log = LogFactory.getLog(AbstractSessionManager.class);\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener</code>s for notification\n     * that the session has been invalidated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session</code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session</code> object being invalidated.\n     * @return the <code>Session</code> instance to use to pass to registered <code>SessionListener</code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    public boolean isValid(Serializable sessionId) {\n        try {\n            getSession(sessionId);\n        } catch (InvalidSessionException e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/AbstractSessionManagerTest1.java",
		"test_prompt": "// AbstractSessionManagerTest1.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractSessionManager}.\n* It contains ten unit test cases for the {@link AbstractSessionManager#start(InetAddress)} method.\n*/\nclass AbstractSessionManagerTest1 {"
	},
	{
		"original_code": "// AbstractSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * TODO - complete JavaDoc\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    private static final Log log = LogFactory.getLog(AbstractSessionManager.class);\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener</code>s for notification\n     * that the session has been invalidated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session</code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session</code> object being invalidated.\n     * @return the <code>Session</code> instance to use to pass to registered <code>SessionListener</code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    public boolean isValid(Serializable sessionId) {\n        try {\n            getSession(sessionId);\n        } catch (InvalidSessionException e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/AbstractSessionManagerTest2.java",
		"test_prompt": "// AbstractSessionManagerTest2.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractSessionManager}.\n* It contains ten unit test cases for the {@link AbstractSessionManager#removeAttribute(Serializable, Object)} method.\n*/\nclass AbstractSessionManagerTest2 {"
	},
	{
		"original_code": "// AbstractSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * TODO - complete JavaDoc\n * @author Les Hazlewood\n * @since 0.1\n */\npublic abstract class AbstractSessionManager implements SessionManager, SessionListenerRegistrar {\n\n    private static final Log log = LogFactory.getLog(AbstractSessionManager.class);\n\n    protected Collection<SessionListener> listeners = new ArrayList<SessionListener>();\n\n    public AbstractSessionManager() {\n    }\n\n    public void setSessionListeners(Collection<SessionListener> listeners) {\n        if (listeners == null) {\n            this.listeners = new ArrayList<SessionListener>();\n        } else {\n            this.listeners = listeners;\n        }\n    }\n\n    public void add(SessionListener listener) {\n        this.listeners.add(listener);\n    }\n\n    public boolean remove(SessionListener listener) {\n        return this.listeners.remove(listener);\n    }\n\n    public Serializable start(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        Session session = createSession(originatingHost);\n        notifyStart(session);\n        return session.getId();\n    }\n\n    /**\n     * Returns the session instance to use to pass to registered <code>SessionListener</code>s for notification\n     * that the session has been invalidated (stopped or expired).\n     * <p/>\n     * The default implementation returns an\n     * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure\n     * that the specified <code>session</code> argument is not modified by any listeners.\n     *\n     * @param session the <code>Session</code> object being invalidated.\n     * @return the <code>Session</code> instance to use to pass to registered <code>SessionListener</code>s for\n     *         notification.\n     */\n    protected Session beforeInvalidNotification(Session session) {\n        return new ImmutableProxiedSession(session);\n    }\n\n    protected void notifyStart(Session session) {\n        for (SessionListener listener : this.listeners) {\n            listener.onStart(session);\n        }\n    }\n\n    protected void notifyStop(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onStop(forNotification);\n        }\n    }\n\n    protected void notifyExpiration(Session session) {\n        Session forNotification = beforeInvalidNotification(session);\n        for (SessionListener listener : this.listeners) {\n            listener.onExpiration(forNotification);\n        }\n    }\n\n    public Date getStartTimestamp(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public Date getLastAccessTime(Serializable sessionId) {\n        return getSession(sessionId).getStartTimestamp();\n    }\n\n    public long getTimeout(Serializable sessionId) throws InvalidSessionException {\n        return getSession(sessionId).getTimeout();\n    }\n\n    public void setTimeout(Serializable sessionId, long maxIdleTimeInMillis) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.setTimeout(maxIdleTimeInMillis);\n        onChange(s);\n    }\n\n    public void touch(Serializable sessionId) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        s.touch();\n        onChange(s);\n    }\n\n    public InetAddress getHostAddress(Serializable sessionId) {\n        return getSession(sessionId).getHostAddress();\n    }\n\n    public void stop(Serializable sessionId) throws InvalidSessionException {\n        Session session = getSession(sessionId);\n        stop(session);\n    }\n\n    protected void stop(Session session) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping session with id [\" + session.getId() + \"]\");\n        }\n        notifyStop(session);\n        session.stop();\n        onStop(session);\n    }\n\n    protected void onStop(Session session) {\n        onChange(session);\n    }\n\n    protected void onExpiration(Session session) {\n        onChange(session);\n    }\n\n    public Collection<Object> getAttributeKeys(Serializable sessionId) {\n        return getSession(sessionId).getAttributeKeys();\n    }\n\n    public Object getAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        return getSession(sessionId).getAttribute(key);\n    }\n\n    public void setAttribute(Serializable sessionId, Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(sessionId, key);\n        } else {\n            Session s = getSession(sessionId);\n            s.setAttribute(key, value);\n            onChange(s);\n        }\n    }\n\n    public Object removeAttribute(Serializable sessionId, Object key) throws InvalidSessionException {\n        Session s = getSession(sessionId);\n        Object removed = s.removeAttribute(key);\n        if (removed != null) {\n            onChange(s);\n        }\n        return removed;\n    }\n\n    protected Session getSession(Serializable sessionId) throws InvalidSessionException {\n        Session session = doGetSession(sessionId);\n        if (session == null) {\n            String msg = \"There is no session with id [\" + sessionId + \"]\";\n            throw new UnknownSessionException(msg);\n        }\n        return session;\n    }\n\n    public boolean isValid(Serializable sessionId) {\n        try {\n            getSession(sessionId);\n        } catch (InvalidSessionException e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected void onChange(Session s) {\n    }\n\n    protected abstract Session doGetSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected abstract Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/AbstractSessionManagerTest3.java",
		"test_prompt": "// AbstractSessionManagerTest3.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.*;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractSessionManager}.\n* It contains ten unit test cases for the {@link AbstractSessionManager#isValid(Serializable)} method.\n*/\nclass AbstractSessionManagerTest3 {"
	},
	{
		"original_code": "// AbstractValidatingSessionManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\n\n/**\n * Default business-tier implementation of the {@link ValidatingSessionManager} interface.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic abstract class AbstractValidatingSessionManager extends AbstractSessionManager implements ValidatingSessionManager, Destroyable {\n\n    //TODO - complete JavaDoc\n    private static final Log log = LogFactory.getLog(AbstractValidatingSessionManager.class);\n\n    protected static final long MILLIS_PER_SECOND = 1000;\n\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    /**\n     * Default main session timeout value (30 * 60 * 1000 milliseconds = 30 minutes).\n     */\n    public static final long DEFAULT_GLOBAL_SESSION_TIMEOUT = 30 * MILLIS_PER_MINUTE;\n\n    /**\n     * The default interval at which sessions will be validated (1 hour);\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    public static final long DEFAULT_SESSION_VALIDATION_INTERVAL = MILLIS_PER_HOUR;\n\n    //default\n    protected boolean sessionValidationSchedulerEnabled = true;\n\n    /**\n     * Scheduler used to validate sessions on a regular basis.\n     */\n    protected SessionValidationScheduler sessionValidationScheduler = null;\n\n    protected long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    protected long globalSessionTimeout = DEFAULT_GLOBAL_SESSION_TIMEOUT;\n\n    public AbstractValidatingSessionManager() {\n    }\n\n    public boolean isSessionValidationSchedulerEnabled() {\n        return sessionValidationSchedulerEnabled;\n    }\n\n    public void setSessionValidationSchedulerEnabled(boolean sessionValidationSchedulerEnabled) {\n        this.sessionValidationSchedulerEnabled = sessionValidationSchedulerEnabled;\n    }\n\n    public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler) {\n        this.sessionValidationScheduler = sessionValidationScheduler;\n    }\n\n    public SessionValidationScheduler getSessionValidationScheduler() {\n        return sessionValidationScheduler;\n    }\n\n    public void enableSessionValidationIfNecessary() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if (isSessionValidationSchedulerEnabled() && (scheduler == null || !scheduler.isEnabled())) {\n            enableSessionValidation();\n        }\n    }\n\n    /**\n     * Returns the time in milliseconds that any session may remain idle before expiring.  This\n     * value is just a main default for all sessions and may be overridden by subclasses on a\n     * <em>per-session</em> basis by overriding the {@link #getTimeout(Session)} method if\n     * so desired.\n     *\n     * <ul>\n     * <li>A negative return value means sessions never expire.</li>\n     * <li>A non-negative return value (0 or greater) means session timeout will occur as expected.</li>\n     * </ul>\n     *\n     * <p>Unless overridden via the {@link #setGlobalSessionTimeout} method, the default value is\n     * {@link #DEFAULT_GLOBAL_SESSION_TIMEOUT}.\n     *\n     * @return the time in milliseconds that any session may remain idle before expiring.\n     */\n    public long getGlobalSessionTimeout() {\n        return globalSessionTimeout;\n    }\n\n    /**\n     * Sets the time in milliseconds that any session may remain idle before expiring.  This\n     * value is just a main default for all sessions.  Subclasses may override the\n     * {@link #getTimeout} method to determine time-out values on a <em>per-session</em> basis.\n     *\n     * @param globalSessionTimeout the time in milliseconds any session may remain idle before\n     *                             expiring.\n     */\n    public void setGlobalSessionTimeout(int globalSessionTimeout) {\n        this.globalSessionTimeout = globalSessionTimeout;\n    }\n\n    /**\n     * If using the underlying default <tt>SessionValidationScheduler</tt> (that is, the\n     * {@link #setSessionValidationScheduler(SessionValidationScheduler) setSessionValidationScheduler} method is\n     * never called) , this method allows one to specify how\n     * frequently session should be validated (to check for orphans).  The default value is\n     * {@link #DEFAULT_SESSION_VALIDATION_INTERVAL}.\n     *\n     * <p>If you override the default scheduler, it is assumed that overriding instance 'knows' how often to\n     * validate sessions, and this attribute will be ignored.\n     *\n     * <p>Unless this method is called, the default value is {@link #DEFAULT_SESSION_VALIDATION_INTERVAL}.\n     *\n     * @param sessionValidationInterval the time in milliseconds between checking for valid sessions to reap orphans.\n     */\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n    public long getSessionValidationInterval() {\n        return sessionValidationInterval;\n    }\n\n    protected final Session doGetSession(Serializable sessionId) throws InvalidSessionException {\n        enableSessionValidationIfNecessary();\n        return retrieveSession(sessionId);\n    }\n\n    protected abstract Session retrieveSession(Serializable sessionId) throws InvalidSessionException;\n\n    protected final Session createSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException {\n        enableSessionValidationIfNecessary();\n        return doCreateSession(originatingHost);\n    }\n\n    protected abstract Session doCreateSession(InetAddress originatingHost) throws HostUnauthorizedException, IllegalArgumentException;\n\n    protected void validate(Session session) throws InvalidSessionException {\n        if (session instanceof ValidatingSession) {\n            try {\n                ((ValidatingSession) session).validate();\n            } catch (ExpiredSessionException ese) {\n                notifyExpiration(session);\n                onExpiration(session);\n                //propagate to caller:\n                throw ese;\n            }\n        } else {\n            String msg = \"The \" + getClass().getName() + \" implementation only supports validating \" + \"Session implementations of the \" + ValidatingSession.class.getName() + \" interface.  \" + \"Please either implement this interface in your session implementation or override the \" + getClass().getName() + \".validate(Session) method to perform validation.\";\n            throw new IllegalStateException(msg);\n        }\n    }\n\n    /**\n     * Subclass template hook in case per-session timeout is not based on\n     * {@link org.jsecurity.session.Session#getTimeout()}.\n     *\n     * <p>This implementation merely returns {@link org.jsecurity.session.Session#getTimeout()}</p>\n     *\n     * @param session the session for which to determine session timeout.\n     * @return the time in milliseconds the specified session may remain idle before expiring.\n     */\n    protected long getTimeout(Session session) {\n        return session.getTimeout();\n    }\n\n    protected SessionValidationScheduler createSessionValidationScheduler() {\n        SessionValidationScheduler scheduler;\n        if (log.isDebugEnabled()) {\n            log.debug(\"No sessionValidationScheduler set.  Attempting to create default instance.\");\n        }\n        scheduler = new ExecutorServiceSessionValidationScheduler(this);\n        ((ExecutorServiceSessionValidationScheduler) scheduler).setInterval(getSessionValidationInterval());\n        if (log.isTraceEnabled()) {\n            log.trace(\"Created default SessionValidationScheduler instance of type [\" + scheduler.getClass().getName() + \"].\");\n        }\n        return scheduler;\n    }\n\n    protected void enableSessionValidation() {\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if (scheduler == null) {\n            scheduler = createSessionValidationScheduler();\n            setSessionValidationScheduler(scheduler);\n        }\n        if (log.isInfoEnabled()) {\n            log.info(\"Enabling session validation scheduler...\");\n        }\n        scheduler.enableSessionValidation();\n        afterSessionValidationEnabled();\n    }\n\n    protected void afterSessionValidationEnabled() {\n    }\n\n    protected void disableSessionValidation() {\n        beforeSessionValidationDisabled();\n        SessionValidationScheduler scheduler = getSessionValidationScheduler();\n        if (scheduler != null) {\n            try {\n                scheduler.disableSessionValidation();\n                if (log.isInfoEnabled()) {\n                    log.info(\"Disabled session validation scheduler.\");\n                }\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    String msg = \"Unable to disable SessionValidationScheduler.  Ignoring (shutting down)...\";\n                    log.debug(msg, e);\n                }\n            }\n            LifecycleUtils.destroy(scheduler);\n            setSessionValidationScheduler(null);\n        }\n    }\n\n    protected void beforeSessionValidationDisabled() {\n    }\n\n    public void destroy() {\n        disableSessionValidation();\n    }\n\n    /**\n     * @see ValidatingSessionManager#validateSessions()\n     */\n    public void validateSessions() {\n        if (log.isInfoEnabled()) {\n            log.info(\"Validating all active sessions...\");\n        }\n        int invalidCount = 0;\n        Collection<Session> activeSessions = getActiveSessions();\n        if (activeSessions != null && !activeSessions.isEmpty()) {\n            for (Session s : activeSessions) {\n                try {\n                    validate(s);\n                } catch (InvalidSessionException e) {\n                    if (log.isDebugEnabled()) {\n                        boolean expired = (e instanceof ExpiredSessionException);\n                        String msg = \"Invalidated session with id [\" + s.getId() + \"]\" + (expired ? \" (expired)\" : \" (stopped)\");\n                        log.debug(msg);\n                    }\n                    invalidCount++;\n                }\n            }\n        }\n        if (log.isInfoEnabled()) {\n            String msg = \"Finished session validation.\";\n            if (invalidCount > 0) {\n                msg += \"  [\" + invalidCount + \"] sessions were stopped.\";\n            } else {\n                msg += \"  No sessions were stopped.\";\n            }\n            log.info(msg);\n        }\n    }\n\n    protected abstract Collection<Session> getActiveSessions();\n\n    public void validateSession(Serializable sessionId) {\n        //standard getSession call will validate, so just call the method:\n        getSession(sessionId);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/AbstractValidatingSessionManagerTest.java",
		"test_prompt": "// AbstractValidatingSessionManagerTest.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.authz.HostUnauthorizedException;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.util.Destroyable;\nimport org.jsecurity.util.LifecycleUtils;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractValidatingSessionManager}.\n* It contains ten unit test cases for the {@link AbstractValidatingSessionManager#isSessionValidationSchedulerEnabled()} method.\n*/\nclass AbstractValidatingSessionManagerTest {"
	},
	{
		"original_code": "// ImmutableProxiedSession.java\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\npackage org.jsecurity.session.mgt;\r\n\r\nimport org.jsecurity.session.InvalidSessionException;\r\nimport org.jsecurity.session.ProxiedSession;\r\nimport org.jsecurity.session.Session;\r\n\r\n/**\r\n * Implementation of the {@link Session Session} interface that proxies another <code>Session</code>, but does not\r\n * allow any 'write' operations to the underlying session. It allows 'read' operations only.\r\n * <p/>\r\n * The <code>Session</code> write operations are defined as follows.  A call to any of these methods on this\r\n * proxy will immediately result in an {@link InvalidSessionException} being thrown:\r\n *\r\n * <ul>\r\n * <li>{@link Session#setTimeout(long) Session.setTimeout(long)}</li>\r\n * <li>{@link Session#touch() Session.touch()}</li>\r\n * <li>{@link Session#stop() Session.stop()}</li>\r\n * <li>{@link Session#setAttribute(Object, Object) Session.setAttribute(key,value)}</li>\r\n * <li>{@link Session#removeAttribute(Object) Session.removeAttribute(key)}</li>\r\n * </ul>\r\n *\r\n * <p/>\r\n * Any other method invocation not listed above will result in a corresponding call to the underlying <code>Session</code>.\r\n *\r\n * @author Les Hazlewood\r\n * @since 0.9\r\n */\r\npublic class ImmutableProxiedSession extends ProxiedSession {\r\n\r\n    /**\r\n     * Constructs a new instance of this class proxying the specified <code>Session</code>.\r\n     *\r\n     * @param target the target <code>Session</code> to proxy.\r\n     */\r\n    public ImmutableProxiedSession(Session target) {\r\n        super(target);\r\n    }\r\n\r\n    /**\r\n     * Simply throws an <code>InvalidSessionException</code> indicating that this proxy is immutable.  Used\r\n     * only in the Session's 'write' methods documented in the top class-level JavaDoc.\r\n     *\r\n     * @throws InvalidSessionException in all cases - used by the Session 'write' method implementations.\r\n     */\r\n    protected void throwImmutableException() throws InvalidSessionException {\r\n        String msg = \"This session is immutable and read-only - it cannot be altered.  This is usually because \" + \"the session has been stopped or expired already.\";\r\n        throw new InvalidSessionException(msg);\r\n    }\r\n\r\n    /**\r\n     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all\r\n     * cases because this proxy is immutable.\r\n     */\r\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\r\n        throwImmutableException();\r\n    }\r\n\r\n    /**\r\n     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all\r\n     * cases because this proxy is immutable.\r\n     */\r\n    public void touch() throws InvalidSessionException {\r\n        throwImmutableException();\r\n    }\r\n\r\n    /**\r\n     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all\r\n     * cases because this proxy is immutable.\r\n     */\r\n    public void stop() throws InvalidSessionException {\r\n        throwImmutableException();\r\n    }\r\n\r\n    /**\r\n     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all\r\n     * cases because this proxy is immutable.\r\n     */\r\n    public void setAttribute(Object key, Object value) throws InvalidSessionException {\r\n        throwImmutableException();\r\n    }\r\n\r\n    /**\r\n     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all\r\n     * cases because this proxy is immutable.\r\n     */\r\n    public Object removeAttribute(Object key) throws InvalidSessionException {\r\n        throwImmutableException();\r\n        //we should never ever reach this point due to the exception being thrown.\r\n        throw new InternalError(\"This code should never execute - please report this as a bug!\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/ImmutableProxiedSessionTest.java",
		"test_prompt": "// ImmutableProxiedSessionTest.java\npackage org.jsecurity.session.mgt;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.ProxiedSession;\nimport org.jsecurity.session.Session;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ImmutableProxiedSession}.\n* It contains ten unit test cases for the {@link ImmutableProxiedSession#removeAttribute(Object)} method.\n*/\nclass ImmutableProxiedSessionTest {"
	},
	{
		"original_code": "// CachingSessionDAO.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.session.mgt.ValidatingSession;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO</tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware {\n\n    /**\n     * The default active sessions cache name, equal to <code>jsecurity-activeSessionCache</code>.\n     */\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    /**\n     * The CacheManager to use to acquire the Session cache.\n     */\n    private CacheManager cacheManager;\n\n    /**\n     * The Cache instance responsible for caching Sessions.\n     */\n    private Cache activeSessions;\n\n    /**\n     * The name of the session cache, defaults to {@link #ACTIVE_SESSION_CACHE_NAME}.\n     */\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n        //force cache reload:\n        this.activeSessions = null;\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    /**\n     * Returns the name of the actives sessions cache to be returned by the <code>CacheManager</code>.  Unless\n     * overridden by {@link #setActiveSessionsCacheName(String)}, defaults to {@link #ACTIVE_SESSION_CACHE_NAME}.\n     * @return the name of the active sessions cache.\n     */\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    /**\n     * Sets the name of the active sessions cache to be returned by the <code>CacheManager</code>.  Defaults to\n     * {@link #ACTIVE_SESSION_CACHE_NAME}.\n     * @param activeSessionsCacheName the name of the active sessions cache to be returned by the <code>CacheManager</code>.\n     */\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    /**\n     * Returns the cache instance to use for storing active sessions.\n     * @return the cache instance to use for storing active sessions.\n     */\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    /**\n     * Returns the active sessions cache, but if that cache instance is null, first lazily creates the cache instance\n     * via the {@link #createActiveSessionsCache()} method and then returns the instance.\n     * <p/>\n     * Note that this method will only return a non-null value code if the <code>CacheManager</code> has been set.  If\n     * not set, there will be no cache.\n     *\n     * @return the active sessions cache instance.\n     */\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    /**\n     * Sets the cache instance to use for storing active sessions.\n     * @param cache the cache instance to use for storing active sessions.\n     */\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    /**\n     * Creates a cache instance used to store active sessions.  Creation is done by first\n     * {@link #getCacheManager() acquiring} the <code>CacheManager</code>.  If the cache manager is not null, the\n     * cache returned is that resulting from the following call:\n     * <pre>       String name = {@link #getActiveSessionsCacheName() getActiveSessionsCacheName()};\n     * cacheManager.getCache(name);</pre>\n     * @return a cache instance used to store active sessions, or <em>null</code> if the <code>CacheManager</code> has\n     * not been set.\n     */\n    protected Cache createActiveSessionsCache() {\n        Cache cache = null;\n        CacheManager mgr = getCacheManager();\n        if (mgr != null) {\n            String name = getActiveSessionsCacheName();\n            cache = mgr.getCache(name);\n        }\n        return cache;\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        cacheValidSession(session, sessionId);\n        return sessionId;\n    }\n\n    /**\n     * Returns the cached session with the corresponding <code>sessionId</code> or <code>null</code> if there is\n     * no session cached under that id (or if there is no Cache).\n     *\n     * @param sessionId the id of the cached session to acquire.\n     * @return the cached session with the corresponding <code>sessionId</code>, or <code>null</code> if the session\n     * does not exist or is not cached.\n     */\n    protected Session getCachedSession(Serializable sessionId) {\n        Session cached = null;\n        if (sessionId != null) {\n            Cache cache = getActiveSessionsCacheLazy();\n            if (cache != null) {\n                cached = getCachedSession(sessionId, cache);\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Returns the Session with the specified id from the specified cache.  This method simply calls\n     * <code>cache.get(sessionId)</code> and can be overridden by subclasses for custom acquisition behavior.\n     * @param sessionId the id of the session to acquire.\n     * @param cache the cache to acquire the session from\n     * @return the cached session, or <code>null</code> if the session wasn't in the cache.\n     */\n    protected Session getCachedSession(Serializable sessionId, Cache cache) {\n        return (Session) cache.get(sessionId);\n    }\n\n    /**\n     * Caches the specified session under the key <code>sessionId</code>.  If the Session is an instance of\n     * {@link org.jsecurity.session.mgt.ValidatingSession ValidatingSession}, it will only be cached if the\n     * session is {@link org.jsecurity.session.mgt.ValidatingSession#isValid() valid}.\n     *\n     * @param session the session to cache\n     * @param sessionId the id of the session, to be used as the cache key.\n     */\n    protected void cacheValidSession(Session session, Serializable sessionId) {\n        if (session == null || sessionId == null) {\n            return;\n        }\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache == null) {\n            return;\n        }\n        if (session instanceof ValidatingSession && !((ValidatingSession) session).isValid()) {\n            uncache(session);\n        } else {\n            cache(session, sessionId, cache);\n        }\n    }\n\n    /**\n     * Caches the specified session in the given cache under the key of <code>sessionId</code>.  This implementation\n     * simply calls <code>cache.put(sessionId, session)</code> and can be overridden for custom behavior.\n     *\n     * @param session the session to cache\n     * @param sessionId the id of the session, expected to be the cache key.\n     * @param cache the cache to store the session\n     */\n    protected void cache(Session session, Serializable sessionId, Cache cache) {\n        cache.put(sessionId, session);\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId</tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" + sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session</tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId</tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId</tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = getCachedSession(sessionId);\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (s != null) {\n                cacheValidSession(s, sessionId);\n            }\n        }\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session</tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId</tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now invalid,\n     * it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n        doUpdate(session);\n        cacheValidSession(session, session.getId());\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session</tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        doDelete(session);\n        uncache(session);\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Removes the specified Session from the cache.\n     *\n     * @param session the session to remove from the cache.\n     */\n    protected void uncache(Session session) {\n        if (session == null) {\n            return;\n        }\n        Serializable id = session.getId();\n        if (id == null) {\n            return;\n        }\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/eis/CachingSessionDAOTest0.java",
		"test_prompt": "// CachingSessionDAOTest0.java\npackage org.jsecurity.session.mgt.eis;\n\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.session.mgt.ValidatingSession;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CachingSessionDAO}.\n* It contains ten unit test cases for the {@link CachingSessionDAO#create(Session)} method.\n*/\nclass CachingSessionDAOTest0 {"
	},
	{
		"original_code": "// CachingSessionDAO.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.eis;\n\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.session.mgt.ValidatingSession;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that\n * use it and the underlying EIS (Enterprise Information System) for enhanced performance.\n *\n * <p>This implementation caches all active sessions in a cache created by a\n * {@link org.jsecurity.cache.CacheManager}.  All <tt>SessionDAO</tt> methods are implemented by this class to employ\n * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by\n * subclasses (doCreate, doRead, etc).\n *\n * @author Les Hazlewood\n * @since 0.2\n */\npublic abstract class CachingSessionDAO implements SessionDAO, CacheManagerAware {\n\n    /**\n     * The default active sessions cache name, equal to <code>jsecurity-activeSessionCache</code>.\n     */\n    public static final String ACTIVE_SESSION_CACHE_NAME = \"jsecurity-activeSessionCache\";\n\n    /**\n     * The CacheManager to use to acquire the Session cache.\n     */\n    private CacheManager cacheManager;\n\n    /**\n     * The Cache instance responsible for caching Sessions.\n     */\n    private Cache activeSessions;\n\n    /**\n     * The name of the session cache, defaults to {@link #ACTIVE_SESSION_CACHE_NAME}.\n     */\n    private String activeSessionsCacheName = ACTIVE_SESSION_CACHE_NAME;\n\n    /**\n     * Default no-arg constructor.\n     */\n    public CachingSessionDAO() {\n    }\n\n    /**\n     * Sets the cacheManager to use for constructing the session cache.\n     *\n     * @param cacheManager the manager to use for constructing the session cache.\n     */\n    public void setCacheManager(CacheManager cacheManager) {\n        this.cacheManager = cacheManager;\n        //force cache reload:\n        this.activeSessions = null;\n    }\n\n    /**\n     * Returns the CacheManager used by the implementation that creates the activeSessions Cache.\n     *\n     * @return the CacheManager used by the implementation that creates the activeSessions Cache.\n     */\n    public CacheManager getCacheManager() {\n        return cacheManager;\n    }\n\n    /**\n     * Returns the name of the actives sessions cache to be returned by the <code>CacheManager</code>.  Unless\n     * overridden by {@link #setActiveSessionsCacheName(String)}, defaults to {@link #ACTIVE_SESSION_CACHE_NAME}.\n     * @return the name of the active sessions cache.\n     */\n    public String getActiveSessionsCacheName() {\n        return activeSessionsCacheName;\n    }\n\n    /**\n     * Sets the name of the active sessions cache to be returned by the <code>CacheManager</code>.  Defaults to\n     * {@link #ACTIVE_SESSION_CACHE_NAME}.\n     * @param activeSessionsCacheName the name of the active sessions cache to be returned by the <code>CacheManager</code>.\n     */\n    public void setActiveSessionsCacheName(String activeSessionsCacheName) {\n        this.activeSessionsCacheName = activeSessionsCacheName;\n    }\n\n    /**\n     * Returns the cache instance to use for storing active sessions.\n     * @return the cache instance to use for storing active sessions.\n     */\n    public Cache getActiveSessionsCache() {\n        return this.activeSessions;\n    }\n\n    /**\n     * Returns the active sessions cache, but if that cache instance is null, first lazily creates the cache instance\n     * via the {@link #createActiveSessionsCache()} method and then returns the instance.\n     * <p/>\n     * Note that this method will only return a non-null value code if the <code>CacheManager</code> has been set.  If\n     * not set, there will be no cache.\n     *\n     * @return the active sessions cache instance.\n     */\n    protected Cache getActiveSessionsCacheLazy() {\n        if (this.activeSessions == null) {\n            this.activeSessions = createActiveSessionsCache();\n        }\n        return this.activeSessions;\n    }\n\n    /**\n     * Sets the cache instance to use for storing active sessions.\n     * @param cache the cache instance to use for storing active sessions.\n     */\n    public void setActiveSessionsCache(Cache cache) {\n        this.activeSessions = cache;\n    }\n\n    /**\n     * Creates a cache instance used to store active sessions.  Creation is done by first\n     * {@link #getCacheManager() acquiring} the <code>CacheManager</code>.  If the cache manager is not null, the\n     * cache returned is that resulting from the following call:\n     * <pre>       String name = {@link #getActiveSessionsCacheName() getActiveSessionsCacheName()};\n     * cacheManager.getCache(name);</pre>\n     * @return a cache instance used to store active sessions, or <em>null</code> if the <code>CacheManager</code> has\n     * not been set.\n     */\n    protected Cache createActiveSessionsCache() {\n        Cache cache = null;\n        CacheManager mgr = getCacheManager();\n        if (mgr != null) {\n            String name = getActiveSessionsCacheName();\n            cache = mgr.getCache(name);\n        }\n        return cache;\n    }\n\n    /**\n     * Creates the session by delegating EIS creation to subclasses via the {@link #doCreate} method, and then\n     * caches the session.\n     *\n     * @param session Session object to create in the EIS and then cache.\n     */\n    public Serializable create(Session session) {\n        Serializable sessionId = doCreate(session);\n        verifySessionId(sessionId);\n        cacheValidSession(session, sessionId);\n        return sessionId;\n    }\n\n    /**\n     * Returns the cached session with the corresponding <code>sessionId</code> or <code>null</code> if there is\n     * no session cached under that id (or if there is no Cache).\n     *\n     * @param sessionId the id of the cached session to acquire.\n     * @return the cached session with the corresponding <code>sessionId</code>, or <code>null</code> if the session\n     * does not exist or is not cached.\n     */\n    protected Session getCachedSession(Serializable sessionId) {\n        Session cached = null;\n        if (sessionId != null) {\n            Cache cache = getActiveSessionsCacheLazy();\n            if (cache != null) {\n                cached = getCachedSession(sessionId, cache);\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Returns the Session with the specified id from the specified cache.  This method simply calls\n     * <code>cache.get(sessionId)</code> and can be overridden by subclasses for custom acquisition behavior.\n     * @param sessionId the id of the session to acquire.\n     * @param cache the cache to acquire the session from\n     * @return the cached session, or <code>null</code> if the session wasn't in the cache.\n     */\n    protected Session getCachedSession(Serializable sessionId, Cache cache) {\n        return (Session) cache.get(sessionId);\n    }\n\n    /**\n     * Caches the specified session under the key <code>sessionId</code>.  If the Session is an instance of\n     * {@link org.jsecurity.session.mgt.ValidatingSession ValidatingSession}, it will only be cached if the\n     * session is {@link org.jsecurity.session.mgt.ValidatingSession#isValid() valid}.\n     *\n     * @param session the session to cache\n     * @param sessionId the id of the session, to be used as the cache key.\n     */\n    protected void cacheValidSession(Session session, Serializable sessionId) {\n        if (session == null || sessionId == null) {\n            return;\n        }\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache == null) {\n            return;\n        }\n        if (session instanceof ValidatingSession && !((ValidatingSession) session).isValid()) {\n            uncache(session);\n        } else {\n            cache(session, sessionId, cache);\n        }\n    }\n\n    /**\n     * Caches the specified session in the given cache under the key of <code>sessionId</code>.  This implementation\n     * simply calls <code>cache.put(sessionId, session)</code> and can be overridden for custom behavior.\n     *\n     * @param session the session to cache\n     * @param sessionId the id of the session, expected to be the cache key.\n     * @param cache the cache to store the session\n     */\n    protected void cache(Session session, Serializable sessionId, Cache cache) {\n        cache.put(sessionId, session);\n    }\n\n    /**\n     * Ensures the sessionId returned from the subclass implementation of {@link #doCreate} is not null and not\n     * already in use.\n     *\n     * @param sessionId session id returned from the subclass implementation of {@link #doCreate}\n     */\n    protected void verifySessionId(Serializable sessionId) {\n        if (sessionId == null) {\n            String msg = \"sessionId returned from doCreate implementation is null.  Please verify the implementation.\";\n            throw new IllegalStateException(msg);\n        }\n        ensureUncached(sessionId);\n    }\n\n    /**\n     * Ensures that there is no cache entry already in place for a session with id of <tt>sessionId</tt>.  Used by\n     * the {@link #verifySessionId} implementation.\n     *\n     * @param sessionId the session id to check for non-existence in the cache.\n     */\n    protected void ensureUncached(Serializable sessionId) {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null && cache.get(sessionId) != null) {\n            String msg = \"There is an existing session already created with session id [\" + sessionId + \"].  Session ID's must be unique.\";\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /**\n     * Subclass hook to actually persist the given <tt>Session</tt> instance to the underlying EIS.\n     *\n     * @param session the Session instance to persist to the EIS.\n     * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the\n     *         value returned from {@link org.jsecurity.session.Session#getId() Session.getId()}.\n     */\n    protected abstract Serializable doCreate(Session session);\n\n    /**\n     * Retrieves the Session object from the underlying EIS identified by <tt>sessionId</tt>.\n     *\n     * <p>Upon receiving the Session object from the subclass's {@link #doReadSession} implementation, it will be\n     * cached first and then returned to the caller.\n     *\n     * @param sessionId the id of the session to retrieve from the EIS.\n     * @return the session identified by <tt>sessionId</tt> in the EIS.\n     * @throws UnknownSessionException if the id specified does not correspond to any session in the cache or EIS.\n     */\n    public Session readSession(Serializable sessionId) throws UnknownSessionException {\n        Session s = getCachedSession(sessionId);\n        if (s == null) {\n            s = doReadSession(sessionId);\n            if (s != null) {\n                cacheValidSession(s, sessionId);\n            }\n        }\n        if (s == null) {\n            throw new UnknownSessionException(\"There is no session with id [\" + sessionId + \"]\");\n        }\n        return s;\n    }\n\n    /**\n     * Subclass implmentation hook to actually retrieve the Session object from the underlying EIS.\n     *\n     * @param sessionId the id of the <tt>Session</tt> to retrieve.\n     * @return the Session in the EIS identified by <tt>sessionId</tt>\n     */\n    protected abstract Session doReadSession(Serializable sessionId);\n\n    /**\n     * Updates the state of the given session to the EIS.\n     *\n     * <p>If the specified session was previously cached, and the session is now invalid,\n     * it will be removed from the cache.\n     *\n     * <p>If the specified session is not stopped or expired, and was not yet in the cache, it will be added to the\n     * cache.\n     *\n     * <p>Finally, this method calls {@link #doUpdate} for the subclass to actually push the object state to the EIS.\n     *\n     * @param session the session object to update in the EIS.\n     * @throws UnknownSessionException if no existing EIS session record exists with the\n     *                                 identifier of {@link Session#getId() session.getId()}\n     */\n    public void update(Session session) throws UnknownSessionException {\n        doUpdate(session);\n        cacheValidSession(session, session.getId());\n    }\n\n    /**\n     * Subclass implementation hook to actually persist the <tt>Session</tt>'s state to the underlying EIS.\n     *\n     * @param session the session object whose state will be propagated to the EIS.\n     */\n    protected abstract void doUpdate(Session session);\n\n    /**\n     * Removes the specified session from any cache and then permanently deletes the session from the EIS by\n     * delegating to {@link #doDelete}.\n     *\n     * @param session the session to remove from caches and permanently delete from the EIS.\n     */\n    public void delete(Session session) {\n        doDelete(session);\n        uncache(session);\n    }\n\n    /**\n     * Subclass implementation hook to permanently delete the given Session from the underlying EIS.\n     *\n     * @param session the session instance to permanently delete from the EIS.\n     */\n    protected abstract void doDelete(Session session);\n\n    /**\n     * Removes the specified Session from the cache.\n     *\n     * @param session the session to remove from the cache.\n     */\n    protected void uncache(Session session) {\n        if (session == null) {\n            return;\n        }\n        Serializable id = session.getId();\n        if (id == null) {\n            return;\n        }\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            cache.remove(id);\n        }\n    }\n\n    /**\n     * Returns all active sessions in the system.\n     *\n     * <p>This implementation merely returns the sessions found in the activeSessions cache.  Subclass implementations\n     * may wish to override this method to retrieve them in a different way, perhaps by an RDBMS query or by other\n     * means.\n     *\n     * @return the sessions found in the activeSessions cache.\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    public Collection<Session> getActiveSessions() {\n        Cache cache = getActiveSessionsCacheLazy();\n        if (cache != null) {\n            return cache.values();\n        } else {\n            return Collections.EMPTY_LIST;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/eis/CachingSessionDAOTest1.java",
		"test_prompt": "// CachingSessionDAOTest1.java\npackage org.jsecurity.session.mgt.eis;\n\nimport org.jsecurity.cache.Cache;\nimport org.jsecurity.cache.CacheManager;\nimport org.jsecurity.cache.CacheManagerAware;\nimport org.jsecurity.session.Session;\nimport org.jsecurity.session.UnknownSessionException;\nimport org.jsecurity.session.mgt.ValidatingSession;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CachingSessionDAO}.\n* It contains ten unit test cases for the {@link CachingSessionDAO#readSession(Serializable)} method.\n*/\nclass CachingSessionDAOTest1 {"
	},
	{
		"original_code": "// ExecutorServiceSessionValidationScheduler.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * SessionValidationScheduler implementation that uses a\n * {@link ScheduledExecutorService} to call {@link ValidatingSessionManager#validateSessions()} every\n * <em>{@link #getInterval interval}</em> milliseconds.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class ExecutorServiceSessionValidationScheduler implements SessionValidationScheduler, Runnable {\n\n    //TODO - complete JavaDoc\n    /**\n     * Private internal log instance.\n     */\n    private static final Log log = LogFactory.getLog(ExecutorServiceSessionValidationScheduler.class);\n\n    ValidatingSessionManager sessionManager;\n\n    private ScheduledExecutorService service;\n\n    private long interval = DefaultSessionManager.DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    private boolean enabled = false;\n\n    public ExecutorServiceSessionValidationScheduler() {\n        super();\n    }\n\n    public ExecutorServiceSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    public ValidatingSessionManager getSessionManager() {\n        return sessionManager;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    public long getInterval() {\n        return interval;\n    }\n\n    public void setInterval(long interval) {\n        this.interval = interval;\n    }\n\n    public boolean isEnabled() {\n        return this.enabled;\n    }\n\n    public void enableSessionValidation() {\n        if (this.interval > 0l) {\n            this.service = Executors.newSingleThreadScheduledExecutor();\n            this.service.scheduleAtFixedRate(this, interval, interval, TimeUnit.MILLISECONDS);\n            this.enabled = true;\n        }\n    }\n\n    public void run() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Executing session validation...\");\n        }\n        long startTime = System.currentTimeMillis();\n        this.sessionManager.validateSessions();\n        long stopTime = System.currentTimeMillis();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Session validation completed successfully in \" + (stopTime - startTime) + \" milliseconds.\");\n        }\n    }\n\n    public void disableSessionValidation() {\n        this.service.shutdownNow();\n        this.enabled = false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/ExecutorServiceSessionValidationSchedulerTest.java",
		"test_prompt": "// ExecutorServiceSessionValidationSchedulerTest.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExecutorServiceSessionValidationScheduler}.\n* It contains ten unit test cases for the {@link ExecutorServiceSessionValidationScheduler#isEnabled()} method.\n*/\nclass ExecutorServiceSessionValidationSchedulerTest {"
	},
	{
		"original_code": "// DelegatingSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * A DelegatingSession is a client-tier representation of a server side\n * {@link org.jsecurity.session.Session Session}.\n * This implementation is basically a proxy to a server-side {@link SessionManager SessionManager},\n * which will return the proper results for each method call.\n *\n * <p>A <tt>DelegatingSession</tt> will cache data when appropriate to avoid a remote method invocation,\n * only communicating with the server when necessary.\n *\n * <p>Of course, if used in-process with a SessionManager business POJO, as might be the case in a\n * web-based application where the web classes and server-side business pojos exist in the same\n * JVM, a remote method call will not be incurred.\n *\n * @author Les Hazlewood\n * @author Jeremy Haile\n * @since 0.1\n */\npublic class DelegatingSession implements Session {\n\n    //TODO - complete JavaDoc\n    private Serializable id = null;\n\n    //cached fields to avoid a server-side method call if out-of-process:\n    private Date startTimestamp = null;\n\n    private InetAddress hostAddress = null;\n\n    /**\n     * Handle to a server-side SessionManager.  See {@link #setSessionManager} for details.\n     */\n    private SessionManager sessionManager = null;\n\n    public DelegatingSession() {\n    }\n\n    public DelegatingSession(SessionManager sessionManager, Serializable id) {\n        this.sessionManager = sessionManager;\n        this.id = id;\n    }\n\n    /**\n     * Returns the {@link SessionManager SessionManager} used by this handle to invoke\n     * all session-related methods.\n     *\n     * @return the {@link SessionManager SessionManager} used by this handle to invoke\n     *         all session-related methods.\n     */\n    public SessionManager getSessionManager() {\n        return sessionManager;\n    }\n\n    /**\n     * Sets the {@link SessionManager SessionManager} to which this <tt>DelegatingSession</tt> will\n     * delegate its method calls.  In a rich client environment, this <tt>SessionManager</tt> will\n     * probably be a remoting proxy which executes remote method invocations.  In a single-process\n     * environment (e.g. a web  application deployed in the same JVM of the application server),\n     * the <tt>SessionManager</tt> can be the actual business POJO implementation.\n     *\n     * <p>You'll notice the {@link Session Session} interface and the {@link SessionManager}\n     * interface are nearly identical.  This is to ensure the SessionManager can support\n     * most method calls in the Session interface, via this handle/proxy technique.  The session\n     * manager is implementated as a stateless business POJO, with the handle passing the\n     * session id as necessary.\n     *\n     * @param sessionManager the <tt>SessionManager</tt> this handle will use when delegating\n     *                       method calls.\n     */\n    public void setSessionManager(SessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    /**\n     * Sets the sessionId used by this handle for all future {@link SessionManager SessionManager}\n     * method invocations.\n     *\n     * @param id the <tt>sessionId</tt> to use for all <tt>SessionManager</tt> invocations.\n     * @see #setSessionManager(SessionManager sessionManager)\n     */\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    /**\n     * @see Session#getId()\n     */\n    public Serializable getId() {\n        return id;\n    }\n\n    /**\n     * @see Session#getStartTimestamp()\n     */\n    public Date getStartTimestamp() {\n        if (startTimestamp == null) {\n            startTimestamp = sessionManager.getStartTimestamp(id);\n        }\n        return startTimestamp;\n    }\n\n    /**\n     * @see org.jsecurity.session.Session#getLastAccessTime()\n     */\n    public Date getLastAccessTime() {\n        //can't cache - only business pojo knows the accurate time:\n        return sessionManager.getLastAccessTime(id);\n    }\n\n    public long getTimeout() throws InvalidSessionException {\n        return sessionManager.getTimeout(id);\n    }\n\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\n        sessionManager.setTimeout(id, maxIdleTimeInMillis);\n    }\n\n    /**\n     * @see org.jsecurity.session.Session#getHostAddress()\n     */\n    public InetAddress getHostAddress() {\n        if (hostAddress == null) {\n            hostAddress = sessionManager.getHostAddress(id);\n        }\n        return hostAddress;\n    }\n\n    /**\n     * @see org.jsecurity.session.Session#touch()\n     */\n    public void touch() throws InvalidSessionException {\n        sessionManager.touch(id);\n    }\n\n    /**\n     * @see org.jsecurity.session.Session#stop()\n     */\n    public void stop() throws InvalidSessionException {\n        sessionManager.stop(id);\n    }\n\n    /**\n     * @see org.jsecurity.session.Session#getAttributeKeys\n     */\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        return sessionManager.getAttributeKeys(id);\n    }\n\n    /**\n     * @see Session#getAttribute(Object key)\n     */\n    public Object getAttribute(Object key) throws InvalidSessionException {\n        return sessionManager.getAttribute(id, key);\n    }\n\n    /**\n     * @see Session#setAttribute(Object key, Object value)\n     */\n    public void setAttribute(Object key, Object value) throws InvalidSessionException {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            sessionManager.setAttribute(id, key, value);\n        }\n    }\n\n    /**\n     * @see Session#removeAttribute(Object key)\n     */\n    public Object removeAttribute(Object key) throws InvalidSessionException {\n        return sessionManager.removeAttribute(id, key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/DelegatingSessionTest.java",
		"test_prompt": "// DelegatingSessionTest.java\npackage org.jsecurity.session.mgt;\n\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.Session;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelegatingSession}.\n* It contains ten unit test cases for the {@link DelegatingSession#removeAttribute(Object)} method.\n*/\nclass DelegatingSessionTest {"
	},
	{
		"original_code": "// QuartzSessionValidationScheduler.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.SessionValidationScheduler;\nimport org.jsecurity.session.mgt.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\n/**\n * An implementation of the {@link SessionValidationScheduler SessionValidationScheduler} that uses Quartz to schedule a\n * job to call {@link org.jsecurity.session.mgt.ValidatingSessionManager#validateSessions()} on\n * a regular basis.\n *\n * @author Jeremy Haile\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class QuartzSessionValidationScheduler implements SessionValidationScheduler {\n\n    //TODO - complete JavaDoc\n    /*--------------------------------------------\n    |             C O N S T A N T S             |\n    ============================================*/\n    /**\n     * The default interval at which sessions will be validated (1 hour);\n     * This can be overridden by calling {@link #setSessionValidationInterval(long)}\n     */\n    public static final long DEFAULT_SESSION_VALIDATION_INTERVAL = DefaultSessionManager.DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    /**\n     * The name assigned to the quartz job.\n     */\n    private static final String JOB_NAME = \"SessionValidationJob\";\n\n    /*--------------------------------------------\n    |    I N S T A N C E   V A R I A B L E S    |\n    ============================================*/\n    private static final Log log = LogFactory.getLog(QuartzSessionValidationScheduler.class);\n\n    /**\n     * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is\n     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}\n     */\n    private Scheduler scheduler;\n\n    private boolean schedulerImplicitlyCreated = false;\n\n    private boolean enabled = false;\n\n    /**\n     * The session manager used to validate sessions.\n     */\n    private ValidatingSessionManager sessionManager;\n\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |\n    ============================================*/\n    /**\n     * Default constructor.\n     */\n    public QuartzSessionValidationScheduler() {\n    }\n\n    /**\n     * Constructor that specifies the session manager that should be used for validating sessions.\n     *\n     * @param sessionManager the <tt>SessionManager</tt> that should be used to validate sessions.\n     */\n    public QuartzSessionValidationScheduler(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    /*--------------------------------------------\n    |  A C C E S S O R S / M O D I F I E R S    |\n    ============================================*/\n    protected Scheduler getScheduler() throws SchedulerException {\n        if (scheduler == null) {\n            scheduler = StdSchedulerFactory.getDefaultScheduler();\n            schedulerImplicitlyCreated = true;\n        }\n        return scheduler;\n    }\n\n    public void setScheduler(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public void setSessionManager(ValidatingSessionManager sessionManager) {\n        this.sessionManager = sessionManager;\n    }\n\n    public boolean isEnabled() {\n        return this.enabled;\n    }\n\n    /**\n     * Specifies how frequently (in milliseconds) this Scheduler will call the\n     * {@link org.jsecurity.session.mgt.ValidatingSessionManager#validateSessions() ValidatingSessionManager#validateSessions()} method.\n     *\n     * <p>Unless this method is called, the default value is {@link #DEFAULT_SESSION_VALIDATION_INTERVAL}.\n     *\n     * @param sessionValidationInterval\n     */\n    public void setSessionValidationInterval(long sessionValidationInterval) {\n        this.sessionValidationInterval = sessionValidationInterval;\n    }\n\n    /*--------------------------------------------\n    |               M E T H O D S               |\n    ============================================*/\n    /**\n     * Starts session validation by creating a Quartz simple trigger, linking it to\n     * the {@link QuartzSessionValidationJob}, and scheduling it with the Quartz scheduler.\n     */\n    public void enableSessionValidation() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Scheduling session validation job using Quartz with \" + \"session validation interval of [\" + sessionValidationInterval + \"]ms...\");\n        }\n        try {\n            SimpleTrigger trigger = new SimpleTrigger(getClass().getName(), Scheduler.DEFAULT_GROUP, SimpleTrigger.REPEAT_INDEFINITELY, sessionValidationInterval);\n            JobDetail detail = new JobDetail(JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class);\n            detail.getJobDataMap().put(QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager);\n            Scheduler scheduler = getScheduler();\n            scheduler.scheduleJob(detail, trigger);\n            if (schedulerImplicitlyCreated) {\n                scheduler.start();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Successfully started implicitly created Quartz Scheduler instance.\");\n                }\n            }\n            this.enabled = true;\n            if (log.isDebugEnabled()) {\n                log.debug(\"Session validation job successfully scheduled with Quartz.\");\n            }\n        } catch (SchedulerException e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Error starting the Quartz session validation job.  Session validation may not occur.\", e);\n            }\n        }\n    }\n\n    public void disableSessionValidation() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Stopping Quartz session validation job...\");\n        }\n        Scheduler scheduler;\n        try {\n            scheduler = getScheduler();\n            if (scheduler == null) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"getScheduler() method returned a null Quartz scheduler, which is unexpected.  Please \" + \"check your configuration and/or implementation.  Returning quietly since there is no \" + \"validation job to remove (scheduler does not exist).\");\n                }\n                return;\n            }\n        } catch (SchedulerException e) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Unable to acquire Quartz Scheduler.  Ignoring and returning (already stopped?)\", e);\n            }\n            return;\n        }\n        try {\n            scheduler.unscheduleJob(JOB_NAME, Scheduler.DEFAULT_GROUP);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Quartz session validation job stopped successfully.\");\n            }\n        } catch (SchedulerException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Could not cleanly remove SessionValidationJob from Quartz scheduler.  \" + \"Ignoring and stopping.\", e);\n            }\n        }\n        this.enabled = false;\n        if (schedulerImplicitlyCreated) {\n            try {\n                scheduler.shutdown();\n            } catch (SchedulerException e) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Unable to cleanly shutdown implicitly created Quartz Scheduler instance.\", e);\n                }\n            } finally {\n                setScheduler(null);\n                schedulerImplicitlyCreated = false;\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/quartz/QuartzSessionValidationSchedulerTest.java",
		"test_prompt": "// QuartzSessionValidationSchedulerTest.java\npackage org.jsecurity.session.mgt.quartz;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.mgt.DefaultSessionManager;\nimport org.jsecurity.session.mgt.SessionValidationScheduler;\nimport org.jsecurity.session.mgt.ValidatingSessionManager;\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SimpleTrigger;\nimport org.quartz.impl.StdSchedulerFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuartzSessionValidationScheduler}.\n* It contains ten unit test cases for the {@link QuartzSessionValidationScheduler#isEnabled()} method.\n*/\nclass QuartzSessionValidationSchedulerTest {"
	},
	{
		"original_code": "// SimpleSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\n\n/**\n * Simple {@link org.jsecurity.session.Session} POJO implementation, intended to be used on the business/server tier.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    //TODO - complete JavaDoc\n    protected static final long MILLIS_PER_SECOND = 1000;\n\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    private transient static final Log log = LogFactory.getLog(SimpleSession.class);\n\n    private Serializable id = null;\n\n    private Date startTimestamp = null;\n\n    private Date stopTimestamp = null;\n\n    private Date lastAccessTime = null;\n\n    private long timeout = DefaultSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT;\n\n    private boolean expired = false;\n\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n        this(getLocalHost());\n    }\n\n    public SimpleSession(InetAddress hostAddress) {\n        this.startTimestamp = new Date();\n        this.lastAccessTime = startTimestamp;\n        this.hostAddress = hostAddress;\n    }\n\n    private static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public Serializable getId() {\n        return this.id;\n    }\n\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp(Date startTimestamp) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    /**\n     * Returns the time the session was stopped, or <tt>null</tt> if the session is still active.\n     *\n     * <p>A session may become stopped under a number of conditions:\n     * <ul>\n     * <li>If the user logs out of the system, their current session is terminated (released).</li>\n     * <li>If the session expires</li>\n     * <li>The application explicitly calls {@link #stop() destroy()}</li>\n     * <li>If there is an internal system error and the session state can no longer accurately\n     * reflect the user's behavior, such in the case of a system crash</li>\n     * </ul>\n     * </p>\n     *\n     * <p>Once stopped, a session may no longer be used.  It is locked from all further activity.\n     *\n     * @return The time the session was stopped, or <tt>null</tt> if the session is still\n     *         active.\n     */\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp(Date stopTimestamp) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime(Date lastAccessTime) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    /**\n     * Returns true if this session has expired, false otherwise.  If the session has\n     * expired, no further user interaction with the system may be done under this session.\n     *\n     * @return true if this session has expired, false otherwise.\n     */\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired(boolean expired) {\n        this.expired = expired;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress(InetAddress hostAddress) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Map<Object, Object> attributes) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        if (this.stopTimestamp == null) {\n            this.stopTimestamp = new Date();\n        }\n    }\n\n    protected boolean isStopped() {\n        return getStopTimestamp() != null;\n    }\n\n    protected void expire() {\n        stop();\n        if (!this.expired) {\n            this.expired = true;\n        }\n    }\n\n    /**\n     * @since 0.9\n     */\n    public boolean isValid() {\n        return !isStopped() && !isExpired();\n    }\n\n    /**\n     * Determines if this session is expired.\n     *\n     * @return true if the specified session has expired, false otherwise.\n     */\n    protected boolean isTimedOut() {\n        if (isExpired()) {\n            return true;\n        }\n        long timeout = getTimeout();\n        if (timeout >= 0l) {\n            Date lastAccessTime = getLastAccessTime();\n            if (lastAccessTime == null) {\n                String msg = \"session.lastAccessTime for session with id [\" + getId() + \"] is null.  This value must be set at \" + \"least once, preferably at least upon instantiation.  Please check the \" + getClass().getName() + \" implementation and ensure \" + \"this value will be set (perhaps in the constructor?)\";\n                throw new IllegalStateException(msg);\n            }\n            // Calculate at what time a session would have been last accessed\n            // for it to be expired at this point.  In other words, subtract\n            // from the current time the amount of time that a session can\n            // be inactive before expiring.  If the session was last accessed\n            // before this time, it is expired.\n            long expireTimeMillis = System.currentTimeMillis() - timeout;\n            Date expireTime = new Date(expireTimeMillis);\n            return lastAccessTime.before(expireTime);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No timeout for session with id [\" + getId() + \"].  Session is not considered expired.\");\n            }\n        }\n        return false;\n    }\n\n    public void validate() throws InvalidSessionException {\n        //check for stopped:\n        if (isStopped()) {\n            //timestamp is set, so the session is considered stopped:\n            String msg = \"Session with id [\" + getId() + \"] has been \" + \"explicitly stopped.  No further interaction under this session is \" + \"allowed.\";\n            throw new StoppedSessionException(msg, getId());\n        }\n        //check for expiration\n        if (isTimedOut()) {\n            expire();\n            //throw an exception explaining details of why it expired:\n            Date lastAccessTime = getLastAccessTime();\n            long timeout = getTimeout();\n            Serializable sessionId = getId();\n            DateFormat df = DateFormat.getInstance();\n            String msg = \"Session with id [\" + sessionId + \"] has expired. \" + \"Last access time: \" + df.format(lastAccessTime) + \".  Current time: \" + df.format(new Date()) + \".  Session timeout is set to \" + timeout / MILLIS_PER_SECOND + \" seconds (\" + timeout / MILLIS_PER_MINUTE + \" minutes)\";\n            if (log.isTraceEnabled()) {\n                log.trace(msg);\n            }\n            throw new ExpiredSessionException(msg, sessionId);\n        }\n    }\n\n    private Map<Object, Object> getAttributesLazy() {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            attributes = new HashMap<Object, Object>();\n            setAttributes(attributes);\n        }\n        return attributes;\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            //noinspection unchecked\n            return Collections.EMPTY_SET;\n        }\n        return attributes.keySet();\n    }\n\n    public Object getAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        }\n        return attributes.get(key);\n    }\n\n    public void setAttribute(Object key, Object value) {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            getAttributesLazy().put(key, value);\n        }\n    }\n\n    public Object removeAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        } else {\n            return attributes.remove(key);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/SimpleSessionTest0.java",
		"test_prompt": "// SimpleSessionTest0.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSession}.\n* It contains ten unit test cases for the {@link SimpleSession#isExpired()} method.\n*/\nclass SimpleSessionTest0 {"
	},
	{
		"original_code": "// SimpleSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\n\n/**\n * Simple {@link org.jsecurity.session.Session} POJO implementation, intended to be used on the business/server tier.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    //TODO - complete JavaDoc\n    protected static final long MILLIS_PER_SECOND = 1000;\n\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    private transient static final Log log = LogFactory.getLog(SimpleSession.class);\n\n    private Serializable id = null;\n\n    private Date startTimestamp = null;\n\n    private Date stopTimestamp = null;\n\n    private Date lastAccessTime = null;\n\n    private long timeout = DefaultSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT;\n\n    private boolean expired = false;\n\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n        this(getLocalHost());\n    }\n\n    public SimpleSession(InetAddress hostAddress) {\n        this.startTimestamp = new Date();\n        this.lastAccessTime = startTimestamp;\n        this.hostAddress = hostAddress;\n    }\n\n    private static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public Serializable getId() {\n        return this.id;\n    }\n\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp(Date startTimestamp) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    /**\n     * Returns the time the session was stopped, or <tt>null</tt> if the session is still active.\n     *\n     * <p>A session may become stopped under a number of conditions:\n     * <ul>\n     * <li>If the user logs out of the system, their current session is terminated (released).</li>\n     * <li>If the session expires</li>\n     * <li>The application explicitly calls {@link #stop() destroy()}</li>\n     * <li>If there is an internal system error and the session state can no longer accurately\n     * reflect the user's behavior, such in the case of a system crash</li>\n     * </ul>\n     * </p>\n     *\n     * <p>Once stopped, a session may no longer be used.  It is locked from all further activity.\n     *\n     * @return The time the session was stopped, or <tt>null</tt> if the session is still\n     *         active.\n     */\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp(Date stopTimestamp) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime(Date lastAccessTime) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    /**\n     * Returns true if this session has expired, false otherwise.  If the session has\n     * expired, no further user interaction with the system may be done under this session.\n     *\n     * @return true if this session has expired, false otherwise.\n     */\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired(boolean expired) {\n        this.expired = expired;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress(InetAddress hostAddress) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Map<Object, Object> attributes) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        if (this.stopTimestamp == null) {\n            this.stopTimestamp = new Date();\n        }\n    }\n\n    protected boolean isStopped() {\n        return getStopTimestamp() != null;\n    }\n\n    protected void expire() {\n        stop();\n        if (!this.expired) {\n            this.expired = true;\n        }\n    }\n\n    /**\n     * @since 0.9\n     */\n    public boolean isValid() {\n        return !isStopped() && !isExpired();\n    }\n\n    /**\n     * Determines if this session is expired.\n     *\n     * @return true if the specified session has expired, false otherwise.\n     */\n    protected boolean isTimedOut() {\n        if (isExpired()) {\n            return true;\n        }\n        long timeout = getTimeout();\n        if (timeout >= 0l) {\n            Date lastAccessTime = getLastAccessTime();\n            if (lastAccessTime == null) {\n                String msg = \"session.lastAccessTime for session with id [\" + getId() + \"] is null.  This value must be set at \" + \"least once, preferably at least upon instantiation.  Please check the \" + getClass().getName() + \" implementation and ensure \" + \"this value will be set (perhaps in the constructor?)\";\n                throw new IllegalStateException(msg);\n            }\n            // Calculate at what time a session would have been last accessed\n            // for it to be expired at this point.  In other words, subtract\n            // from the current time the amount of time that a session can\n            // be inactive before expiring.  If the session was last accessed\n            // before this time, it is expired.\n            long expireTimeMillis = System.currentTimeMillis() - timeout;\n            Date expireTime = new Date(expireTimeMillis);\n            return lastAccessTime.before(expireTime);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No timeout for session with id [\" + getId() + \"].  Session is not considered expired.\");\n            }\n        }\n        return false;\n    }\n\n    public void validate() throws InvalidSessionException {\n        //check for stopped:\n        if (isStopped()) {\n            //timestamp is set, so the session is considered stopped:\n            String msg = \"Session with id [\" + getId() + \"] has been \" + \"explicitly stopped.  No further interaction under this session is \" + \"allowed.\";\n            throw new StoppedSessionException(msg, getId());\n        }\n        //check for expiration\n        if (isTimedOut()) {\n            expire();\n            //throw an exception explaining details of why it expired:\n            Date lastAccessTime = getLastAccessTime();\n            long timeout = getTimeout();\n            Serializable sessionId = getId();\n            DateFormat df = DateFormat.getInstance();\n            String msg = \"Session with id [\" + sessionId + \"] has expired. \" + \"Last access time: \" + df.format(lastAccessTime) + \".  Current time: \" + df.format(new Date()) + \".  Session timeout is set to \" + timeout / MILLIS_PER_SECOND + \" seconds (\" + timeout / MILLIS_PER_MINUTE + \" minutes)\";\n            if (log.isTraceEnabled()) {\n                log.trace(msg);\n            }\n            throw new ExpiredSessionException(msg, sessionId);\n        }\n    }\n\n    private Map<Object, Object> getAttributesLazy() {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            attributes = new HashMap<Object, Object>();\n            setAttributes(attributes);\n        }\n        return attributes;\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            //noinspection unchecked\n            return Collections.EMPTY_SET;\n        }\n        return attributes.keySet();\n    }\n\n    public Object getAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        }\n        return attributes.get(key);\n    }\n\n    public void setAttribute(Object key, Object value) {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            getAttributesLazy().put(key, value);\n        }\n    }\n\n    public Object removeAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        } else {\n            return attributes.remove(key);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/SimpleSessionTest1.java",
		"test_prompt": "// SimpleSessionTest1.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSession}.\n* It contains ten unit test cases for the {@link SimpleSession#isValid()} method.\n*/\nclass SimpleSessionTest1 {"
	},
	{
		"original_code": "// SimpleSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\n\n/**\n * Simple {@link org.jsecurity.session.Session} POJO implementation, intended to be used on the business/server tier.\n *\n * @author Les Hazlewood\n * @since 0.1\n */\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    //TODO - complete JavaDoc\n    protected static final long MILLIS_PER_SECOND = 1000;\n\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    private transient static final Log log = LogFactory.getLog(SimpleSession.class);\n\n    private Serializable id = null;\n\n    private Date startTimestamp = null;\n\n    private Date stopTimestamp = null;\n\n    private Date lastAccessTime = null;\n\n    private long timeout = DefaultSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT;\n\n    private boolean expired = false;\n\n    private InetAddress hostAddress = null;\n\n    private Map<Object, Object> attributes = null;\n\n    public SimpleSession() {\n        this(getLocalHost());\n    }\n\n    public SimpleSession(InetAddress hostAddress) {\n        this.startTimestamp = new Date();\n        this.lastAccessTime = startTimestamp;\n        this.hostAddress = hostAddress;\n    }\n\n    private static InetAddress getLocalHost() {\n        try {\n            return InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public Serializable getId() {\n        return this.id;\n    }\n\n    public void setId(Serializable id) {\n        this.id = id;\n    }\n\n    public Date getStartTimestamp() {\n        return startTimestamp;\n    }\n\n    public void setStartTimestamp(Date startTimestamp) {\n        this.startTimestamp = startTimestamp;\n    }\n\n    /**\n     * Returns the time the session was stopped, or <tt>null</tt> if the session is still active.\n     *\n     * <p>A session may become stopped under a number of conditions:\n     * <ul>\n     * <li>If the user logs out of the system, their current session is terminated (released).</li>\n     * <li>If the session expires</li>\n     * <li>The application explicitly calls {@link #stop() destroy()}</li>\n     * <li>If there is an internal system error and the session state can no longer accurately\n     * reflect the user's behavior, such in the case of a system crash</li>\n     * </ul>\n     * </p>\n     *\n     * <p>Once stopped, a session may no longer be used.  It is locked from all further activity.\n     *\n     * @return The time the session was stopped, or <tt>null</tt> if the session is still\n     *         active.\n     */\n    public Date getStopTimestamp() {\n        return stopTimestamp;\n    }\n\n    public void setStopTimestamp(Date stopTimestamp) {\n        this.stopTimestamp = stopTimestamp;\n    }\n\n    public Date getLastAccessTime() {\n        return lastAccessTime;\n    }\n\n    public void setLastAccessTime(Date lastAccessTime) {\n        this.lastAccessTime = lastAccessTime;\n    }\n\n    /**\n     * Returns true if this session has expired, false otherwise.  If the session has\n     * expired, no further user interaction with the system may be done under this session.\n     *\n     * @return true if this session has expired, false otherwise.\n     */\n    public boolean isExpired() {\n        return expired;\n    }\n\n    public void setExpired(boolean expired) {\n        this.expired = expired;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    public InetAddress getHostAddress() {\n        return hostAddress;\n    }\n\n    public void setHostAddress(InetAddress hostAddress) {\n        this.hostAddress = hostAddress;\n    }\n\n    public Map<Object, Object> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Map<Object, Object> attributes) {\n        this.attributes = attributes;\n    }\n\n    public void touch() {\n        this.lastAccessTime = new Date();\n    }\n\n    public void stop() {\n        if (this.stopTimestamp == null) {\n            this.stopTimestamp = new Date();\n        }\n    }\n\n    protected boolean isStopped() {\n        return getStopTimestamp() != null;\n    }\n\n    protected void expire() {\n        stop();\n        if (!this.expired) {\n            this.expired = true;\n        }\n    }\n\n    /**\n     * @since 0.9\n     */\n    public boolean isValid() {\n        return !isStopped() && !isExpired();\n    }\n\n    /**\n     * Determines if this session is expired.\n     *\n     * @return true if the specified session has expired, false otherwise.\n     */\n    protected boolean isTimedOut() {\n        if (isExpired()) {\n            return true;\n        }\n        long timeout = getTimeout();\n        if (timeout >= 0l) {\n            Date lastAccessTime = getLastAccessTime();\n            if (lastAccessTime == null) {\n                String msg = \"session.lastAccessTime for session with id [\" + getId() + \"] is null.  This value must be set at \" + \"least once, preferably at least upon instantiation.  Please check the \" + getClass().getName() + \" implementation and ensure \" + \"this value will be set (perhaps in the constructor?)\";\n                throw new IllegalStateException(msg);\n            }\n            // Calculate at what time a session would have been last accessed\n            // for it to be expired at this point.  In other words, subtract\n            // from the current time the amount of time that a session can\n            // be inactive before expiring.  If the session was last accessed\n            // before this time, it is expired.\n            long expireTimeMillis = System.currentTimeMillis() - timeout;\n            Date expireTime = new Date(expireTimeMillis);\n            return lastAccessTime.before(expireTime);\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"No timeout for session with id [\" + getId() + \"].  Session is not considered expired.\");\n            }\n        }\n        return false;\n    }\n\n    public void validate() throws InvalidSessionException {\n        //check for stopped:\n        if (isStopped()) {\n            //timestamp is set, so the session is considered stopped:\n            String msg = \"Session with id [\" + getId() + \"] has been \" + \"explicitly stopped.  No further interaction under this session is \" + \"allowed.\";\n            throw new StoppedSessionException(msg, getId());\n        }\n        //check for expiration\n        if (isTimedOut()) {\n            expire();\n            //throw an exception explaining details of why it expired:\n            Date lastAccessTime = getLastAccessTime();\n            long timeout = getTimeout();\n            Serializable sessionId = getId();\n            DateFormat df = DateFormat.getInstance();\n            String msg = \"Session with id [\" + sessionId + \"] has expired. \" + \"Last access time: \" + df.format(lastAccessTime) + \".  Current time: \" + df.format(new Date()) + \".  Session timeout is set to \" + timeout / MILLIS_PER_SECOND + \" seconds (\" + timeout / MILLIS_PER_MINUTE + \" minutes)\";\n            if (log.isTraceEnabled()) {\n                log.trace(msg);\n            }\n            throw new ExpiredSessionException(msg, sessionId);\n        }\n    }\n\n    private Map<Object, Object> getAttributesLazy() {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            attributes = new HashMap<Object, Object>();\n            setAttributes(attributes);\n        }\n        return attributes;\n    }\n\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            //noinspection unchecked\n            return Collections.EMPTY_SET;\n        }\n        return attributes.keySet();\n    }\n\n    public Object getAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        }\n        return attributes.get(key);\n    }\n\n    public void setAttribute(Object key, Object value) {\n        if (value == null) {\n            removeAttribute(key);\n        } else {\n            getAttributesLazy().put(key, value);\n        }\n    }\n\n    public Object removeAttribute(Object key) {\n        Map<Object, Object> attributes = getAttributes();\n        if (attributes == null) {\n            return null;\n        } else {\n            return attributes.remove(key);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/mgt/SimpleSessionTest2.java",
		"test_prompt": "// SimpleSessionTest2.java\npackage org.jsecurity.session.mgt;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jsecurity.session.ExpiredSessionException;\nimport org.jsecurity.session.InvalidSessionException;\nimport org.jsecurity.session.StoppedSessionException;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSession}.\n* It contains ten unit test cases for the {@link SimpleSession#removeAttribute(Object)} method.\n*/\nclass SimpleSessionTest2 {"
	},
	{
		"original_code": "// ProxiedSession.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\n\n/**\n * Simple <code>Session</code> implementation that immediately delegates all corresponding calls to an\n * underlying proxied session instance.\n * <p/>\n * This class is mostly useful for framework subclassing to intercept certain <code>Session</code> calls\n * and perform additional logic.\n *\n * @author Les Hazlewood\n * @since 0.9\n */\npublic class ProxiedSession implements Session {\n\n    /**\n     * The proxied instance\n     */\n    protected final Session proxy;\n\n    /**\n     * Constructs an instance that proxies the specified <code>target</code>.  Subclasses may access this\n     * target via the <code>protected final 'proxy'</code> attribute, i.e. <code>this.proxy</code>.\n     *\n     * @param target the specified target <code>Session</code> to proxy.\n     */\n    public ProxiedSession(Session target) {\n        if (target == null) {\n            throw new IllegalArgumentException(\"Target session to proxy cannot be null.\");\n        }\n        proxy = target;\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Serializable getId() {\n        return proxy.getId();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Date getStartTimestamp() {\n        return proxy.getStartTimestamp();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Date getLastAccessTime() {\n        return proxy.getLastAccessTime();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public long getTimeout() throws InvalidSessionException {\n        return proxy.getTimeout();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {\n        proxy.setTimeout(maxIdleTimeInMillis);\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public InetAddress getHostAddress() {\n        return proxy.getHostAddress();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public void touch() throws InvalidSessionException {\n        proxy.touch();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public void stop() throws InvalidSessionException {\n        proxy.stop();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Collection<Object> getAttributeKeys() throws InvalidSessionException {\n        return proxy.getAttributeKeys();\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Object getAttribute(Object key) throws InvalidSessionException {\n        return proxy.getAttribute(key);\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public void setAttribute(Object key, Object value) throws InvalidSessionException {\n        proxy.setAttribute(key, value);\n    }\n\n    /**\n     * Immediately delegates to the underlying proxied session.\n     */\n    public Object removeAttribute(Object key) throws InvalidSessionException {\n        return proxy.removeAttribute(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/18_jsecurity/src/main/java/org/jsecurity/session/ProxiedSessionTest.java",
		"test_prompt": "// ProxiedSessionTest.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jsecurity.session;\n\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.util.Collection;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProxiedSession}.\n* It contains ten unit test cases for the {@link ProxiedSession#removeAttribute(Object)} method.\n*/\nclass ProxiedSessionTest {"
	}
]