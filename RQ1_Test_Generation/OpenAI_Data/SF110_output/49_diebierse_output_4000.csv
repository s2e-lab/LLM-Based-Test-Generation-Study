ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
721e72a5-92c6-4dc8-aa9a-2bc79e85de91,/EvoSuiteBenchmark/49_diebierse/src/main/java/bierse/model/Drink_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8659 tokens (4659 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Drink.java
/**
 */
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;

/**
 * @author Rainer Friesen
 */
public class Drink {

    public static final String DRINKS_FOLDER = Model.CONFIG_FOLDER + ""drinks/"";

    public static final String NEW_DRINK_NAME = ""Neues Getr�nk"";

    /**
     * Name of the drink
     */
    private String name;

    /**
     * Minimum price(Cent) for what the drink is sold.
     */
    private int minPrice = 70;

    /**
     * Maximum price(Cent) for what the drink is sold,
     */
    private int maxPrice = 130;

    /**
     * Current price(Cent) of the drink.
     */
    private int currentPrice = 0;

    /**
     * Start price for this drink
     */
    private int startPrice = 100;

    /**
     * Amount of drinks sold in the last iteration
     */
    private int lastSold = 0;

    /**
     * The total amount of drinks sold
     */
    private int totalSold = 0;

    /**
     * The average amount of drinks sold in an iteration. Used to calculate the new price.
     */
    private float averageAmount = 0;

    /**
     * The average price in cent
     */
    private float averagePrice = 0;

    /**
     * The average price (Cent) for what the drink is sold
     */
    private float averageSoldPrice = 0;

    /**
     * The maximum difference between two prices in one iteration
     */
    private int maxStep = 20;

    /**
     * The target amount of drinks to keep the price stable
     */
    private int targetAmount = 20;

    /**
     * The delta to calculate the step width. If the targetAmount - delta is not reached
     * the price is decreased by the maximum step. If the targetAmount + delta is reached
     * the price is increased by the maximum step.
     */
    private int deltaAmount = 15;

    /**
     * Show if the drink is used currently
     */
    private boolean used = true;

    /**
     * Key used to indicate the sell of a drink
     */
    private int key = KeyEvent.VK_F1;

    /**
     * Show if the price is lower (-1), equal(0) or higher(1) than during the last iteration
     */
    private int trend = 0;

    /**
     * Keep the price and do no new calculation
     */
    private boolean keepPrice = false;

    /**
     * Set the new price directly without calculating
     */
    private int directPrice = 0;

    /**
     * Model that uses the drink
     */
    Model model;

    /**
     * *******************************************************************************************************************************************
     *  Constructor
     * *******************************************************************************************************************************************
     */
    public Drink(String name, Model model) {
        this.name = name;
        this.model = model;
        load();
        currentPrice = startPrice;
    }

    public Drink(String name, Model model, int startPrice) {
        this(name, model);
        currentPrice = startPrice;
    }

    /**
     * *******************************************************************************************************************************************
     *  Methods
     * *******************************************************************************************************************************************
     */
    /**
     * Sell the amount of drinks
     *
     * @param amount Amount of drinks sold
     */
    public synchronized void sell(int amount) {
        lastSold += amount;
        model.informModelChangedListeners(Model.EVENT_DRINK_SOLD);
    }

    public void setDirectPrice(int directPrice) {
        this.directPrice = directPrice;
        model.informModelChangedListeners(Model.EVENT_DRINK_LIST_CHANGED);
    }

    /**
     * Recalculate the current price for this drink
     */
    public int recalculate() {
        //Calculate new average values
        totalSold += lastSold;
        averageAmount = (float) totalSold / model.getIteration();
        averagePrice = ((averagePrice * (model.getIteration() - 1)) + currentPrice) / model.getIteration();
        if (totalSold > 0) {
            averageSoldPrice = ((averageSoldPrice * (totalSold - lastSold)) + (currentPrice * lastSold)) / totalSold;
        }
        int newPrice;
        if (directPrice != 0) {
            // If a direct price was set, use it
            newPrice = directPrice;
            directPrice = 0;
        } else if (keepPrice) {
            // Keep the price
            newPrice = currentPrice;
        } else {
            // Calculate the new price
            double diffSold = lastSold - targetAmount;
            double factor = diffSold / deltaAmount;
            double change = factor * maxStep;
            int priceSteps = model.getSettings().getPriceSteps();
            double rest = Math.floor(Math.abs(change % priceSteps));
            double full = Math.floor(Math.abs(change / priceSteps));
            int priceChange = 0;
            if (rest >= priceSteps / 2) {
                priceChange = priceSteps;
            }
            priceChange += full * priceSteps;
            // Check that the change of the price is not more than the max step
            if (priceChange > maxStep) {
                priceChange = maxStep;
            }
            if (model.getSettings().isStandardLogic()) {
                if (factor >= 0) {
                    newPrice = currentPrice + priceChange;
                } else {
                    newPrice = currentPrice - priceChange;
                }
            } else {
                // Inverse logic
                if (factor >= 0) {
                    newPrice = currentPrice - priceChange;
                } else {
                    newPrice = currentPrice + priceChange;
                }
            }
        }
        // Check that the new price is not above the max price or below the min price
        if (newPrice > maxPrice) {
            newPrice = maxPrice;
        } else if (newPrice < minPrice) {
            newPrice = minPrice;
        }
        // Calculate the trend
        if (newPrice > currentPrice) {
            trend = 1;
        } else if (newPrice < currentPrice) {
            trend = -1;
        } else {
            trend = 0;
        }
        currentPrice = newPrice;
        //Debug output
        model.getLog().debug(""Recalculating drink: "" + name + "" for iteration: "" + model.getIteration());
        model.getLog().debug(""Last sold: "" + lastSold);
        model.getLog().debug(""Total sold:"" + totalSold);
        model.getLog().debug(""Average sold: "" + averageAmount);
        model.getLog().debug(""Average price: "" + averagePrice);
        model.getLog().debug(""Average sold price: "" + averageSoldPrice);
        model.getLog().debug(""New price: "" + currentPrice);
        // Reset values for the next iteration
        lastSold = 0;
        return currentPrice;
    }

    /**
     * Save the drink description to a XML file
     */
    public File save() {
        if (!NEW_DRINK_NAME.equals(name)) {
            model.getLog().debug(""Save drink: "" + name);
            // Build JDOM document representing the settings
            Element root = new Element(""drink"");
            Element minPriceElem = new Element(""minPrice"");
            minPriceElem.setText(String.valueOf(minPrice));
            root.addContent(minPriceElem);
            Element maxPriceElem = new Element(""maxPrice"");
            maxPriceElem.setText(String.valueOf(maxPrice));
            root.addContent(maxPriceElem);
            Element startPriceElem = new Element(""startPrice"");
            startPriceElem.setText(String.valueOf(startPrice));
            root.addContent(startPriceElem);
            Element targetAmountElem = new Element(""targetAmount"");
            targetAmountElem.setText(String.valueOf(targetAmount));
            root.addContent(targetAmountElem);
            Element deltaAmountElem = new Element(""deltaAmount"");
            deltaAmountElem.setText(String.valueOf(deltaAmount));
            root.addContent(deltaAmountElem);
            Element maxStepElem = new Element(""maxStep"");
            maxStepElem.setText(String.valueOf(maxStep));
            root.addContent(maxStepElem);
            Element usedElem = new Element(""used"");
            usedElem.setText(String.valueOf(used));
            root.addContent(usedElem);
            Element keyElem = new Element(""key"");
            keyElem.setText(String.valueOf(key));
            root.addContent(keyElem);
            Document settingsDoc = new Document(root);
            // Save JDOM document to file system
            File folder = new File(DRINKS_FOLDER);
            File file = new File(DRINKS_FOLDER + name + "".xml"");
            try {
                if (!folder.exists()) {
                    folder.mkdirs();
                }
                model.getLog().debug(""File for Drink: "" + file.getAbsolutePath());
                if (file.exists()) {
                    file.delete();
                }
                file.createNewFile();
                FileOutputStream fos = new FileOutputStream(file);
                XMLOutputter serializer = new XMLOutputter();
                serializer.output(settingsDoc, fos);
                fos.flush();
                fos.close();
            } catch (Exception e) {
                model.getLog().error(this, e);
            }
            return file;
        }
        return null;
    }

    /**
     * Load the description from a XML file
     */
    public void load() {
        model.getLog().debug(""Load drink: "" + name);
        try {
            File file = new File(DRINKS_FOLDER + name + "".xml"");
            model.getLog().debug(""File for Drink: "" + file.getAbsolutePath());
            if (file.exists()) {
                SAXBuilder builder = new SAXBuilder();
                Document doc = builder.build(file);
                Element root = doc.getRootElement();
                minPrice = Integer.valueOf(root.getChildText(""minPrice""));
                maxPrice = Integer.valueOf(root.getChildText(""maxPrice""));
                startPrice = Integer.valueOf(root.getChildText(""startPrice""));
                targetAmount = Integer.valueOf(root.getChildText(""targetAmount""));
                deltaAmount = Integer.valueOf(root.getChildText(""deltaAmount""));
                maxStep = Integer.valueOf(root.getChildText(""maxStep""));
                used = Boolean.parseBoolean(root.getChildText(""used""));
                key = Integer.valueOf(root.getChildText(""key""));
            }
        } catch (Exception e1) {
            model.getLog().error(this, e1);
        }
    }

    public String toString() {
        return name;
    }

    public static String getDataHeaderString() {
        return ""NAME;MIN_PRICE;START_PRICE;MAX_PRICE;AVG_AMOUNT;AVG_PRICE;AVG_SOLD_PRICE;TOTAL_SOLD"";
    }

    public String getDataString() {
        StringBuilder result = new StringBuilder();
        result.append(name);
        result.append(Model.DELIMITER);
        result.append(minPrice);
        result.append(Model.DELIMITER);
        result.append(startPrice);
        result.append(Model.DELIMITER);
        result.append(maxPrice);
        result.append(Model.DELIMITER);
        result.append(averageAmount);
        result.append(Model.DELIMITER);
        result.append(averagePrice);
        result.append(Model.DELIMITER);
        result.append(averageSoldPrice);
        result.append(Model.DELIMITER);
        result.append(totalSold);
        return result.toString();
    }

    /**
     * *******************************************************************************************************************************************
     *  Getters and Setters
     * *******************************************************************************************************************************************
     */
    public int getMinPrice() {
        return minPrice;
    }

    public void setMinPrice(int minPrice) {
        this.minPrice = minPrice;
    }

    public int getMaxPrice() {
        return maxPrice;
    }

    public void setMaxPrice(int maxPrice) {
        this.maxPrice = maxPrice;
    }

    public int getCurrentPrice() {
        return currentPrice;
    }

    public void setCurrentPrice(int currentPrice) {
        this.currentPrice = currentPrice;
    }

    public int getLastSold() {
        return lastSold;
    }

    public void setLastSold(int lastSold) {
        this.lastSold = lastSold;
    }

    public int getTotalSold() {
        return totalSold;
    }

    public void setTotalSold(int totalSold) {
        this.totalSold = totalSold;
    }

    public float getAverageAmount() {
        return averageAmount;
    }

    public void setAverageAmount(float averageAmount) {
        this.averageAmount = averageAmount;
    }

    public float getAveragePrice() {
        return averagePrice;
    }

    public void setAveragePrice(float averagePrice) {
        this.averagePrice = averagePrice;
    }

    public float getAverageSoldPrice() {
        return averageSoldPrice;
    }

    public void setAverageSoldPrice(float averageSoldPrice) {
        this.averageSoldPrice = averageSoldPrice;
    }

    public int getMaxStep() {
        return maxStep;
    }

    public void setMaxStep(int maxStep) {
        this.maxStep = maxStep;
    }

    public int getTargetAmount() {
        return targetAmount;
    }

    public void setTargetAmount(int targetAmount) {
        this.targetAmount = targetAmount;
    }

    public int getDeltaAmount() {
        return deltaAmount;
    }

    public void setDeltaAmount(int deltaAmount) {
        this.deltaAmount = deltaAmount;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getStartPrice() {
        return startPrice;
    }

    public void setStartPrice(int startPrice) {
        this.startPrice = startPrice;
    }

    public boolean isUsed() {
        return used;
    }

    public void setUsed(boolean used) {
        this.used = used;
    }

    public int getKey() {
        return key;
    }

    public void setKey(int key) {
        this.key = key;
    }

    public int getTrend() {
        return trend;
    }

    public boolean isKeepPrice() {
        return keepPrice;
    }

    public void setKeepPrice(boolean keepPrice) {
        this.keepPrice = keepPrice;
    }

    public int getDirectPrice() {
        return directPrice;
    }

    @Override
    public boolean equals(Object obj) {
        Drink drink = (Drink) obj;
        if (name == null && drink.getName() == null) {
            return true;
        } else if (name != null && drink.getName() != null) {
            return name.equals(((Drink) obj).getName());
        } else {
            return false;
        }
    }
}
","// Drink_0Test.java
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Drink}.
* It contains ten unit test cases for the {@link Drink#recalculate()} method.
*/
class Drink_0Test {","// Drink_0Test.java
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Drink}.
* It contains ten unit test cases for the {@link Drink#recalculate()} method.
*/
class Drink_0Test {
"
833dcc70-937e-43d8-872a-9bfd465e45dd,/EvoSuiteBenchmark/49_diebierse/src/main/java/bierse/model/Drink_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8656 tokens (4656 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Drink.java
/**
 */
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;

/**
 * @author Rainer Friesen
 */
public class Drink {

    public static final String DRINKS_FOLDER = Model.CONFIG_FOLDER + ""drinks/"";

    public static final String NEW_DRINK_NAME = ""Neues Getr�nk"";

    /**
     * Name of the drink
     */
    private String name;

    /**
     * Minimum price(Cent) for what the drink is sold.
     */
    private int minPrice = 70;

    /**
     * Maximum price(Cent) for what the drink is sold,
     */
    private int maxPrice = 130;

    /**
     * Current price(Cent) of the drink.
     */
    private int currentPrice = 0;

    /**
     * Start price for this drink
     */
    private int startPrice = 100;

    /**
     * Amount of drinks sold in the last iteration
     */
    private int lastSold = 0;

    /**
     * The total amount of drinks sold
     */
    private int totalSold = 0;

    /**
     * The average amount of drinks sold in an iteration. Used to calculate the new price.
     */
    private float averageAmount = 0;

    /**
     * The average price in cent
     */
    private float averagePrice = 0;

    /**
     * The average price (Cent) for what the drink is sold
     */
    private float averageSoldPrice = 0;

    /**
     * The maximum difference between two prices in one iteration
     */
    private int maxStep = 20;

    /**
     * The target amount of drinks to keep the price stable
     */
    private int targetAmount = 20;

    /**
     * The delta to calculate the step width. If the targetAmount - delta is not reached
     * the price is decreased by the maximum step. If the targetAmount + delta is reached
     * the price is increased by the maximum step.
     */
    private int deltaAmount = 15;

    /**
     * Show if the drink is used currently
     */
    private boolean used = true;

    /**
     * Key used to indicate the sell of a drink
     */
    private int key = KeyEvent.VK_F1;

    /**
     * Show if the price is lower (-1), equal(0) or higher(1) than during the last iteration
     */
    private int trend = 0;

    /**
     * Keep the price and do no new calculation
     */
    private boolean keepPrice = false;

    /**
     * Set the new price directly without calculating
     */
    private int directPrice = 0;

    /**
     * Model that uses the drink
     */
    Model model;

    /**
     * *******************************************************************************************************************************************
     *  Constructor
     * *******************************************************************************************************************************************
     */
    public Drink(String name, Model model) {
        this.name = name;
        this.model = model;
        load();
        currentPrice = startPrice;
    }

    public Drink(String name, Model model, int startPrice) {
        this(name, model);
        currentPrice = startPrice;
    }

    /**
     * *******************************************************************************************************************************************
     *  Methods
     * *******************************************************************************************************************************************
     */
    /**
     * Sell the amount of drinks
     *
     * @param amount Amount of drinks sold
     */
    public synchronized void sell(int amount) {
        lastSold += amount;
        model.informModelChangedListeners(Model.EVENT_DRINK_SOLD);
    }

    public void setDirectPrice(int directPrice) {
        this.directPrice = directPrice;
        model.informModelChangedListeners(Model.EVENT_DRINK_LIST_CHANGED);
    }

    /**
     * Recalculate the current price for this drink
     */
    public int recalculate() {
        //Calculate new average values
        totalSold += lastSold;
        averageAmount = (float) totalSold / model.getIteration();
        averagePrice = ((averagePrice * (model.getIteration() - 1)) + currentPrice) / model.getIteration();
        if (totalSold > 0) {
            averageSoldPrice = ((averageSoldPrice * (totalSold - lastSold)) + (currentPrice * lastSold)) / totalSold;
        }
        int newPrice;
        if (directPrice != 0) {
            // If a direct price was set, use it
            newPrice = directPrice;
            directPrice = 0;
        } else if (keepPrice) {
            // Keep the price
            newPrice = currentPrice;
        } else {
            // Calculate the new price
            double diffSold = lastSold - targetAmount;
            double factor = diffSold / deltaAmount;
            double change = factor * maxStep;
            int priceSteps = model.getSettings().getPriceSteps();
            double rest = Math.floor(Math.abs(change % priceSteps));
            double full = Math.floor(Math.abs(change / priceSteps));
            int priceChange = 0;
            if (rest >= priceSteps / 2) {
                priceChange = priceSteps;
            }
            priceChange += full * priceSteps;
            // Check that the change of the price is not more than the max step
            if (priceChange > maxStep) {
                priceChange = maxStep;
            }
            if (model.getSettings().isStandardLogic()) {
                if (factor >= 0) {
                    newPrice = currentPrice + priceChange;
                } else {
                    newPrice = currentPrice - priceChange;
                }
            } else {
                // Inverse logic
                if (factor >= 0) {
                    newPrice = currentPrice - priceChange;
                } else {
                    newPrice = currentPrice + priceChange;
                }
            }
        }
        // Check that the new price is not above the max price or below the min price
        if (newPrice > maxPrice) {
            newPrice = maxPrice;
        } else if (newPrice < minPrice) {
            newPrice = minPrice;
        }
        // Calculate the trend
        if (newPrice > currentPrice) {
            trend = 1;
        } else if (newPrice < currentPrice) {
            trend = -1;
        } else {
            trend = 0;
        }
        currentPrice = newPrice;
        //Debug output
        model.getLog().debug(""Recalculating drink: "" + name + "" for iteration: "" + model.getIteration());
        model.getLog().debug(""Last sold: "" + lastSold);
        model.getLog().debug(""Total sold:"" + totalSold);
        model.getLog().debug(""Average sold: "" + averageAmount);
        model.getLog().debug(""Average price: "" + averagePrice);
        model.getLog().debug(""Average sold price: "" + averageSoldPrice);
        model.getLog().debug(""New price: "" + currentPrice);
        // Reset values for the next iteration
        lastSold = 0;
        return currentPrice;
    }

    /**
     * Save the drink description to a XML file
     */
    public File save() {
        if (!NEW_DRINK_NAME.equals(name)) {
            model.getLog().debug(""Save drink: "" + name);
            // Build JDOM document representing the settings
            Element root = new Element(""drink"");
            Element minPriceElem = new Element(""minPrice"");
            minPriceElem.setText(String.valueOf(minPrice));
            root.addContent(minPriceElem);
            Element maxPriceElem = new Element(""maxPrice"");
            maxPriceElem.setText(String.valueOf(maxPrice));
            root.addContent(maxPriceElem);
            Element startPriceElem = new Element(""startPrice"");
            startPriceElem.setText(String.valueOf(startPrice));
            root.addContent(startPriceElem);
            Element targetAmountElem = new Element(""targetAmount"");
            targetAmountElem.setText(String.valueOf(targetAmount));
            root.addContent(targetAmountElem);
            Element deltaAmountElem = new Element(""deltaAmount"");
            deltaAmountElem.setText(String.valueOf(deltaAmount));
            root.addContent(deltaAmountElem);
            Element maxStepElem = new Element(""maxStep"");
            maxStepElem.setText(String.valueOf(maxStep));
            root.addContent(maxStepElem);
            Element usedElem = new Element(""used"");
            usedElem.setText(String.valueOf(used));
            root.addContent(usedElem);
            Element keyElem = new Element(""key"");
            keyElem.setText(String.valueOf(key));
            root.addContent(keyElem);
            Document settingsDoc = new Document(root);
            // Save JDOM document to file system
            File folder = new File(DRINKS_FOLDER);
            File file = new File(DRINKS_FOLDER + name + "".xml"");
            try {
                if (!folder.exists()) {
                    folder.mkdirs();
                }
                model.getLog().debug(""File for Drink: "" + file.getAbsolutePath());
                if (file.exists()) {
                    file.delete();
                }
                file.createNewFile();
                FileOutputStream fos = new FileOutputStream(file);
                XMLOutputter serializer = new XMLOutputter();
                serializer.output(settingsDoc, fos);
                fos.flush();
                fos.close();
            } catch (Exception e) {
                model.getLog().error(this, e);
            }
            return file;
        }
        return null;
    }

    /**
     * Load the description from a XML file
     */
    public void load() {
        model.getLog().debug(""Load drink: "" + name);
        try {
            File file = new File(DRINKS_FOLDER + name + "".xml"");
            model.getLog().debug(""File for Drink: "" + file.getAbsolutePath());
            if (file.exists()) {
                SAXBuilder builder = new SAXBuilder();
                Document doc = builder.build(file);
                Element root = doc.getRootElement();
                minPrice = Integer.valueOf(root.getChildText(""minPrice""));
                maxPrice = Integer.valueOf(root.getChildText(""maxPrice""));
                startPrice = Integer.valueOf(root.getChildText(""startPrice""));
                targetAmount = Integer.valueOf(root.getChildText(""targetAmount""));
                deltaAmount = Integer.valueOf(root.getChildText(""deltaAmount""));
                maxStep = Integer.valueOf(root.getChildText(""maxStep""));
                used = Boolean.parseBoolean(root.getChildText(""used""));
                key = Integer.valueOf(root.getChildText(""key""));
            }
        } catch (Exception e1) {
            model.getLog().error(this, e1);
        }
    }

    public String toString() {
        return name;
    }

    public static String getDataHeaderString() {
        return ""NAME;MIN_PRICE;START_PRICE;MAX_PRICE;AVG_AMOUNT;AVG_PRICE;AVG_SOLD_PRICE;TOTAL_SOLD"";
    }

    public String getDataString() {
        StringBuilder result = new StringBuilder();
        result.append(name);
        result.append(Model.DELIMITER);
        result.append(minPrice);
        result.append(Model.DELIMITER);
        result.append(startPrice);
        result.append(Model.DELIMITER);
        result.append(maxPrice);
        result.append(Model.DELIMITER);
        result.append(averageAmount);
        result.append(Model.DELIMITER);
        result.append(averagePrice);
        result.append(Model.DELIMITER);
        result.append(averageSoldPrice);
        result.append(Model.DELIMITER);
        result.append(totalSold);
        return result.toString();
    }

    /**
     * *******************************************************************************************************************************************
     *  Getters and Setters
     * *******************************************************************************************************************************************
     */
    public int getMinPrice() {
        return minPrice;
    }

    public void setMinPrice(int minPrice) {
        this.minPrice = minPrice;
    }

    public int getMaxPrice() {
        return maxPrice;
    }

    public void setMaxPrice(int maxPrice) {
        this.maxPrice = maxPrice;
    }

    public int getCurrentPrice() {
        return currentPrice;
    }

    public void setCurrentPrice(int currentPrice) {
        this.currentPrice = currentPrice;
    }

    public int getLastSold() {
        return lastSold;
    }

    public void setLastSold(int lastSold) {
        this.lastSold = lastSold;
    }

    public int getTotalSold() {
        return totalSold;
    }

    public void setTotalSold(int totalSold) {
        this.totalSold = totalSold;
    }

    public float getAverageAmount() {
        return averageAmount;
    }

    public void setAverageAmount(float averageAmount) {
        this.averageAmount = averageAmount;
    }

    public float getAveragePrice() {
        return averagePrice;
    }

    public void setAveragePrice(float averagePrice) {
        this.averagePrice = averagePrice;
    }

    public float getAverageSoldPrice() {
        return averageSoldPrice;
    }

    public void setAverageSoldPrice(float averageSoldPrice) {
        this.averageSoldPrice = averageSoldPrice;
    }

    public int getMaxStep() {
        return maxStep;
    }

    public void setMaxStep(int maxStep) {
        this.maxStep = maxStep;
    }

    public int getTargetAmount() {
        return targetAmount;
    }

    public void setTargetAmount(int targetAmount) {
        this.targetAmount = targetAmount;
    }

    public int getDeltaAmount() {
        return deltaAmount;
    }

    public void setDeltaAmount(int deltaAmount) {
        this.deltaAmount = deltaAmount;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getStartPrice() {
        return startPrice;
    }

    public void setStartPrice(int startPrice) {
        this.startPrice = startPrice;
    }

    public boolean isUsed() {
        return used;
    }

    public void setUsed(boolean used) {
        this.used = used;
    }

    public int getKey() {
        return key;
    }

    public void setKey(int key) {
        this.key = key;
    }

    public int getTrend() {
        return trend;
    }

    public boolean isKeepPrice() {
        return keepPrice;
    }

    public void setKeepPrice(boolean keepPrice) {
        this.keepPrice = keepPrice;
    }

    public int getDirectPrice() {
        return directPrice;
    }

    @Override
    public boolean equals(Object obj) {
        Drink drink = (Drink) obj;
        if (name == null && drink.getName() == null) {
            return true;
        } else if (name != null && drink.getName() != null) {
            return name.equals(((Drink) obj).getName());
        } else {
            return false;
        }
    }
}
","// Drink_1Test.java
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Drink}.
* It contains ten unit test cases for the {@link Drink#save()} method.
*/
class Drink_1Test {","// Drink_1Test.java
package bierse.model;

import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import bierse.view.MyKeyMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Drink}.
* It contains ten unit test cases for the {@link Drink#save()} method.
*/
class Drink_1Test {
"
cmpl-6tyXDTmn6CDCjcsziEWZuCsp6wc19,/EvoSuiteBenchmark/49_diebierse/src/main/java/bierse/model/Settings.java,12.281706809997559,stop,"// Settings.java
package bierse.model;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;

public class Settings {

    private static final String DOM_SETTINGS_ROOT = ""settings"";

    private static final String DOM_TIME_INTERVAL = ""timeInterval"";

    private static final String DOM_PRICE_STEPS = ""priceSteps"";

    private static final String DOM_CURRENCY = ""currency"";

    private static final String DOM_BACKGROUND_IMG = ""backgound"";

    private static final String DOM_STANDARD_LOGIC = ""standardLogic"";

    private static final String DOM_MESSAGE = ""message"";

    private static final String DOM_MESSAGE_SPEED = ""messageSpeed"";

    private static final String DOM_YES = ""y"";

    private static final String DOM_NO = ""n"";

    public static final String SETTINGS_FOLDER = Model.CONFIG_FOLDER + ""settings/"";

    /**
     * Time interval(seconds) in which the current prices are recalculated.
     */
    private int timeInterval = 10;

    /**
     * The steps that are available for the prices, e.g. 10, 20 or 50 cents
     */
    private int priceSteps = 10;

    /**
     * The currency symbol used
     */
    private java.lang.String currency = ""�"";

    private boolean standardLogic = true;

    private String backgroundImagePath = null;

    private String message = ""Das ist eine Standard-Nachrichtf�r das Laufband!"";

    private int messageSpeed = 10;

    /**
     * Model that uses these settings
     */
    private Model model;

    public Settings(Model m) {
        model = m;
        File f = new File(getClass().getResource(""/img/background.jpg"").getPath());
        backgroundImagePath = f.getAbsolutePath();
        backgroundImagePath = backgroundImagePath.replace(""%20"", "" "");
    }

    /**
     * Save the settings
     */
    public File save() {
        // Build JDOM document representing the settings
        Element settingsRoot = new Element(DOM_SETTINGS_ROOT);
        Element timeIntervalElem = new Element(DOM_TIME_INTERVAL);
        timeIntervalElem.setText(String.valueOf(timeInterval));
        settingsRoot.addContent(timeIntervalElem);
        Element priceStepsElem = new Element(DOM_PRICE_STEPS);
        priceStepsElem.setText(String.valueOf(priceSteps));
        settingsRoot.addContent(priceStepsElem);
        Element currencyElem = new Element(DOM_CURRENCY);
        currencyElem.setText(currency);
        settingsRoot.addContent(currencyElem);
        Element backgroundElem = new Element(DOM_BACKGROUND_IMG);
        backgroundElem.addContent(backgroundImagePath);
        settingsRoot.addContent(backgroundElem);
        Element standardLogicElem = new Element(DOM_STANDARD_LOGIC);
        if (standardLogic) {
            standardLogicElem.addContent(DOM_YES);
        } else {
            standardLogicElem.addContent(DOM_NO);
        }
        settingsRoot.addContent(standardLogicElem);
        Element messageElem = new Element(DOM_MESSAGE);
        messageElem.addContent(message);
        settingsRoot.addContent(messageElem);
        Element messageSpeedElem = new Element(DOM_MESSAGE_SPEED);
        messageSpeedElem.addContent(new Integer(messageSpeed).toString());
        settingsRoot.addContent(messageSpeedElem);
        Document settingsDoc = new Document(settingsRoot);
        // Save JDOM document to file system
        File file = new File(SETTINGS_FOLDER + ""settings.xml"");
        try {
            File folder = new File(SETTINGS_FOLDER);
            if (!folder.exists()) {
                folder.mkdirs();
            }
            if (file.exists()) {
                file.delete();
            }
            file.createNewFile();
            FileOutputStream fos = new FileOutputStream(file);
            XMLOutputter serializer = new XMLOutputter();
            serializer.output(settingsDoc, fos);
            fos.flush();
            fos.close();
        } catch (Exception e) {
            model.getLog().error(this, e);
        }
        return file;
    }

    /**
     * Load the settings
     */
    public void load() {
        try {
            File settingsFile = new File(SETTINGS_FOLDER + ""settings.xml"");
            if (settingsFile.exists()) {
                SAXBuilder builder = new SAXBuilder();
                Document settingsDoc = builder.build(settingsFile);
                Element settingsRoot = settingsDoc.getRootElement();
                timeInterval = Integer.valueOf(settingsRoot.getChildText(DOM_TIME_INTERVAL));
                model.setTimeLeft(timeInterval);
                priceSteps = Integer.valueOf(settingsRoot.getChildText(DOM_PRICE_STEPS));
                currency = settingsRoot.getChildText(DOM_CURRENCY);
                backgroundImagePath = settingsRoot.getChildText(DOM_BACKGROUND_IMG);
                String standardLogicValue = settingsRoot.getChildText(DOM_STANDARD_LOGIC);
                if (DOM_NO.equals(standardLogicValue)) {
                    standardLogic = false;
                } else {
                    standardLogic = true;
                }
                message = settingsRoot.getChildText(DOM_MESSAGE);
                setMessageSpeed(new Integer(settingsRoot.getChildText(DOM_MESSAGE_SPEED)).intValue());
            }
        } catch (Exception e1) {
            model.getLog().error(this, e1);
        }
    }

    public int getTimeInterval() {
        return timeInterval;
    }

    public void setTimeInterval(int timeInterval) {
        this.timeInterval = timeInterval;
    }

    public int getPriceSteps() {
        return priceSteps;
    }

    public void setPriceSteps(int priceSteps) {
        this.priceSteps = priceSteps;
    }

    public java.lang.String getCurrency() {
        return currency;
    }

    public void setCurrency(java.lang.String currency) {
        this.currency = currency;
    }

    public boolean isStandardLogic() {
        return standardLogic;
    }

    public void setStandardLogic(boolean standardLogic) {
        this.standardLogic = standardLogic;
    }

    public String getBackgroundImagePath() {
        return backgroundImagePath;
    }

    public void setBackgroundImagePath(String backgroundImagePath) {
        this.backgroundImagePath = backgroundImagePath;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public int getMessageSpeed() {
        return messageSpeed;
    }

    public void setMessageSpeed(int messageSpeed) {
        this.messageSpeed = messageSpeed;
    }
}
","// SettingsTest.java
package bierse.model;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Settings}.
* It contains ten unit test cases for the {@link Settings#save()} method.
*/
class SettingsTest {","// SettingsTest.java
package bierse.model;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Settings}.
* It contains ten unit test cases for the {@link Settings#save()} method.
*/
class SettingsTest {

	/**
	* Test case for {@link Settings#save()}
	* 
	* @throws IOException
	*/
	@Test
	void testSave() throws IOException {
		// Build JDOM document representing the settings
		Element settingsRoot = new Element(DOM_SETTINGS_ROOT);
		Element timeIntervalElem = new Element(DOM_TIME_INTERVAL);
		timeIntervalElem.setText(String.valueOf(timeInterval));
		settingsRoot.addContent(timeIntervalElem);
		Element priceStepsElem = new Element(DOM_PRICE_STEPS);
		priceStepsElem.setText(String.valueOf(priceSteps));
		settingsRoot.addContent(priceStepsElem);
		Element currencyElem = new Element(DOM_CURRENCY);
		currencyElem.setText(currency);
		settingsRoot.addContent(currencyElem);
		Element backgroundElem = new Element(DOM_BACKGROUND_IMG);
		backgroundElem.addContent(backgroundImagePath);
		settingsRoot.addContent(backgroundElem);
		Element standardLogicElem = new Element(DOM_STANDARD_LOGIC);
		if (standardLogic) {
			standardLogicElem.addContent(DOM_YES);
		} else {
			standardLogicElem.addContent(DOM_NO);
		}
		settingsRoot.addContent(standardLogicElem);
		Element messageElem = new Element(DOM_MESSAGE);
		messageElem.addContent(message);
		settingsRoot.addContent(messageElem);
		Element messageSpeedElem = new Element(DOM_MESSAGE_SPEED);
		messageSpeedElem.addContent(new Integer(messageSpeed).toString());
		settingsRoot.addContent(messageSpeedElem);
		Document settingsDoc = new Document(settingsRoot);
		// Save JDOM document to file system
		File file = new File(SETTINGS_FOLDER + ""settings.xml"");
		try {
			File folder = new File(SETTINGS_FOLDER);
			if (!folder.exists()) {
				folder.mkdirs();
			}
			if (file.exists()) {
				file.delete();
			}
			file.createNewFile();
			FileOutputStream fos = new FileOutputStream(file);
			XMLOutputter serializer = new XMLOutputter();
			serializer.output(settingsDoc, fos);
			fos.flush();
			fos.close();
		} catch (Exception e) {
			model.getLog().error(this, e);
		}
		return file;
	}
}</code></pre>
</div>
</div>

</code>
"
