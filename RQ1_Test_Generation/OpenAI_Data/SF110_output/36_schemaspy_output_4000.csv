ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
50907e56-0525-4c4a-a826-5210f82dc519,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20205 tokens (16205 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_1Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#getLoadedFromJar()} method.
*/
class Config_1Test {","// Config_1Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#getLoadedFromJar()} method.
*/
class Config_1Test {
"
48cba1e5-ddc9-4748-90c8-f3219e05c516,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20203 tokens (16203 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_2Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#hasOrphans()} method.
*/
class Config_2Test {","// Config_2Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#hasOrphans()} method.
*/
class Config_2Test {
"
af088200-3a8e-4473-8f54-5f95204616ee,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20204 tokens (16204 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_3Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#hasRoutines()} method.
*/
class Config_3Test {","// Config_3Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#hasRoutines()} method.
*/
class Config_3Test {
"
f9af4ed6-23e6-4612-bdf1-6a798748515a,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20207 tokens (16207 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_4Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#determineDbProperties(String)} method.
*/
class Config_4Test {","// Config_4Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#determineDbProperties(String)} method.
*/
class Config_4Test {
"
042ebce3-71b5-4cda-8939-4809882f5bf8,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20206 tokens (16206 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_5Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#asProperties(ResourceBundle)} method.
*/
class Config_5Test {","// Config_5Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#asProperties(ResourceBundle)} method.
*/
class Config_5Test {
"
c69ea7ed-44ab-4f76-9d11-87aed154c6e6,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20203 tokens (16203 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_7Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#getParam(String)} method.
*/
class Config_7Test {","// Config_7Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#getParam(String)} method.
*/
class Config_7Test {
"
940abed2-109f-4440-963f-c8c54ac26a4b,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/Config_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20202 tokens (16202 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Config.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;

/**
 * Configuration of a SchemaSpy run
 *
 * @author John Currier
 */
public class Config {

    private static Config instance;

    private final List<String> options;

    private Map<String, String> dbSpecificOptions;

    private Map<String, String> originalDbSpecificOptions;

    private boolean helpRequired;

    private boolean dbHelpRequired;

    private File outputDir;

    private File graphvizDir;

    private String dbType;

    private String catalog;

    private String schema;

    private List<String> schemas;

    private String user;

    private Boolean singleSignOn;

    private Boolean noSchema;

    private String password;

    private Boolean promptForPassword;

    private String db;

    private String host;

    private Integer port;

    private String server;

    private String meta;

    private Pattern tableInclusions;

    private Pattern tableExclusions;

    private Pattern columnExclusions;

    private Pattern indirectColumnExclusions;

    private String userConnectionPropertiesFile;

    private Properties userConnectionProperties;

    private Integer maxDbThreads;

    private Integer maxDetailedTables;

    private String driverPath;

    private String css;

    private String charset;

    private String font;

    private Integer fontSize;

    private String description;

    private Properties dbProperties;

    private String dbPropertiesLoadedFrom;

    private Level logLevel;

    private SqlFormatter sqlFormatter;

    private String sqlFormatterClass;

    private Boolean generateHtml;

    private Boolean includeImpliedConstraints;

    private Boolean logoEnabled;

    private Boolean rankDirBugEnabled;

    private Boolean encodeCommentsEnabled;

    private Boolean numRowsEnabled;

    private Boolean viewsEnabled;

    private Boolean meterEnabled;

    private Boolean railsEnabled;

    private Boolean evaluteAll;

    private Boolean highQuality;

    private Boolean lowQuality;

    // used in conjunction with evaluateAll
    private String schemaSpec;

    private boolean hasOrphans = false;

    private boolean hasRoutines = false;

    private boolean populating = false;

    private List<String> columnDetails;

    public static final String DOT_CHARSET = ""UTF-8"";

    private static final String ESCAPED_EQUALS = ""\\="";

    // match everything
    private static final String DEFAULT_TABLE_INCLUSION = "".*"";

    // match nothing
    private static final String DEFAULT_TABLE_EXCLUSION = """";

    // match nothing
    private static final String DEFAULT_COLUMN_EXCLUSION = ""[^.]"";

    /**
     * Default constructor. Intended for when you want to inject properties
     * independently (i.e. not from a command line interface).
     */
    public Config() {
        if (instance == null)
            setInstance(this);
        options = new ArrayList<String>();
    }

    /**
     * Construct a configuration from an array of options (e.g. from a command
     * line interface).
     *
     * @param options
     */
    public Config(String[] argv) {
        setInstance(this);
        options = fixupArgs(Arrays.asList(argv));
        helpRequired = options.remove(""-?"") || options.remove(""/?"") || options.remove(""?"") || options.remove(""-h"") || options.remove(""-help"") || options.remove(""--help"");
        dbHelpRequired = options.remove(""-dbHelp"") || options.remove(""-dbhelp"");
    }

    public static Config getInstance() {
        if (instance == null)
            instance = new Config();
        return instance;
    }

    /**
     * Sets the global instance.
     *
     * Useful for things like selecting a specific configuration in a UI.
     *
     * @param config
     */
    public static void setInstance(Config config) {
        instance = config;
    }

    public void setHtmlGenerationEnabled(boolean generateHtml) {
        this.generateHtml = generateHtml;
    }

    public boolean isHtmlGenerationEnabled() {
        if (generateHtml == null)
            generateHtml = !options.remove(""-nohtml"");
        return generateHtml;
    }

    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {
        this.includeImpliedConstraints = includeImpliedConstraints;
    }

    public boolean isImpliedConstraintsEnabled() {
        if (includeImpliedConstraints == null)
            includeImpliedConstraints = !options.remove(""-noimplied"");
        return includeImpliedConstraints;
    }

    public void setOutputDir(String outputDirName) {
        if (outputDirName.endsWith(""\""""))
            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);
        setOutputDir(new File(outputDirName));
    }

    public void setOutputDir(File outputDir) {
        this.outputDir = outputDir;
    }

    public File getOutputDir() {
        if (outputDir == null) {
            setOutputDir(pullRequiredParam(""-o""));
        }
        return outputDir;
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(String graphvizDir) {
        if (graphvizDir.endsWith(""\""""))
            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);
        setGraphvizDir(new File(graphvizDir));
    }

    /**
     * Set the path to Graphviz so we can find dot to generate ER diagrams
     *
     * @param graphvizDir
     */
    public void setGraphvizDir(File graphvizDir) {
        this.graphvizDir = graphvizDir;
    }

    /**
     * Return the path to Graphviz (used to find the dot executable to run to
     * generate ER diagrams).<p/>
     *
     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path
     * was not specified.
     *
     * @return
     */
    public File getGraphvizDir() {
        if (graphvizDir == null) {
            String gv = pullParam(""-gv"");
            if (gv != null) {
                setGraphvizDir(gv);
            } else {
                // expect to find Graphviz's bin directory on the PATH
            }
        }
        return graphvizDir;
    }

    /**
     * Meta files are XML-based files that provide additional metadata
     * about the schema being evaluated.<p>
     * <code>meta</code> is either the name of an individual XML file or
     * the directory that contains meta files.<p>
     * If a directory is specified then it is expected to contain files
     * matching the pattern <code>[schema].meta.xml</code>.
     * For databases that don't have schema substitute database for schema.
     * @param meta
     */
    public void setMeta(String meta) {
        this.meta = meta;
    }

    public String getMeta() {
        if (meta == null)
            meta = pullParam(""-meta"");
        return meta;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbType() {
        if (dbType == null) {
            dbType = pullParam(""-t"");
            if (dbType == null)
                dbType = ""ora"";
        }
        return dbType;
    }

    public void setDb(String db) {
        this.db = db;
    }

    public String getDb() {
        if (db == null)
            db = pullParam(""-db"");
        return db;
    }

    public void setCatalog(String catalog) {
        this.catalog = catalog;
    }

    public String getCatalog() {
        if (catalog == null)
            catalog = pullParam(""-cat"");
        return catalog;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getSchema() {
        if (schema == null)
            schema = pullParam(""-s"");
        return schema;
    }

    /**
     * Some databases types (e.g. older versions of Informix) don't really
     * have the concept of a schema but still return true from
     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.
     * This option lets you ignore that and treat all the tables
     * as if they were in one flat namespace.
     */
    public boolean isSchemaDisabled() {
        if (noSchema == null)
            noSchema = options.remove(""-noschema"");
        return noSchema;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getHost() {
        if (host == null)
            host = pullParam(""-host"");
        return host;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Integer getPort() {
        if (port == null)
            try {
                port = Integer.valueOf(pullParam(""-port""));
            } catch (Exception notSpecified) {
            }
        return port;
    }

    public void setServer(String server) {
        this.server = server;
    }

    public String getServer() {
        if (server == null) {
            server = pullParam(""-server"");
        }
        return server;
    }

    public void setUser(String user) {
        this.user = user;
    }

    /**
     * User used to connect to the database.
     * Required unless single sign-on is enabled
     * (see {@link #setSingleSignOn(boolean)}).
     * @return
     */
    public String getUser() {
        if (user == null) {
            if (!isSingleSignOn())
                user = pullRequiredParam(""-u"");
            else
                user = pullParam(""-u"");
        }
        return user;
    }

    /**
     * By default a ""user"" (as specified with -u) is required.
     * This option allows disabling of that requirement for
     * single sign-on environments.
     *
     * @param enabled defaults to <code>false</code>
     */
    public void setSingleSignOn(boolean enabled) {
        singleSignOn = enabled;
    }

    /**
     * @see #setSingleSignOn(boolean)
     */
    public boolean isSingleSignOn() {
        if (singleSignOn == null)
            singleSignOn = options.remove(""-sso"");
        return singleSignOn;
    }

    /**
     * Set the password used to connect to the database.
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * @see #setPassword(String)
     * @return
     */
    public String getPassword() {
        if (password == null)
            password = pullParam(""-p"");
        if (password == null && isPromptForPasswordEnabled())
            password = new String(PasswordReader.getInstance().readPassword(""Password: ""));
        if (password == null) {
            // if -pfp is enabled when analyzing multiple schemas then
            // we don't want to send the password on the command line,
            // so see if it was passed in the environment (not ideal, but safer)
            password = System.getenv(""schemaspy.pw"");
        }
        return password;
    }

    /**
     * Set to <code>true</code> to prompt for the password
     * @param promptForPassword
     */
    public void setPromptForPasswordEnabled(boolean promptForPassword) {
        this.promptForPassword = promptForPassword;
    }

    /**
     * @see #setPromptForPasswordEnabled(boolean)
     * @return
     */
    public boolean isPromptForPasswordEnabled() {
        if (promptForPassword == null) {
            promptForPassword = options.remove(""-pfp"");
        }
        return promptForPassword;
    }

    public void setMaxDetailedTabled(int maxDetailedTables) {
        this.maxDetailedTables = new Integer(maxDetailedTables);
    }

    public int getMaxDetailedTables() {
        if (maxDetailedTables == null) {
            // default
            int max = 300;
            try {
                max = Integer.parseInt(pullParam(""-maxdet""));
            } catch (Exception notSpecified) {
            }
            maxDetailedTables = new Integer(max);
        }
        return maxDetailedTables.intValue();
    }

    public String getConnectionPropertiesFile() {
        return userConnectionPropertiesFile;
    }

    /**
     * Properties from this file (in key=value pair format) are passed to the
     * database connection.<br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.
     * @param propertiesFilename
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {
        if (userConnectionProperties == null)
            userConnectionProperties = new Properties();
        userConnectionProperties.load(new FileInputStream(propertiesFilename));
        userConnectionPropertiesFile = propertiesFilename;
    }

    /**
     * Returns a {@link Properties} populated either from the properties file specified
     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by
     * {@link #setConnectionProperties(String)} or not populated.
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Properties getConnectionProperties() throws FileNotFoundException, IOException {
        if (userConnectionProperties == null) {
            String props = pullParam(""-connprops"");
            if (props != null) {
                if (props.indexOf(ESCAPED_EQUALS) != -1) {
                    setConnectionProperties(props);
                } else {
                    setConnectionPropertiesFile(props);
                }
            } else {
                userConnectionProperties = new Properties();
            }
        }
        return userConnectionProperties;
    }

    /**
     * Specifies connection properties to use in the format:
     * <code>key1\=value1;key2\=value2</code><br>
     * user (from -u) and password (from -p) will be passed in the
     * connection properties if specified.<p>
     * This is an alternative form of passing connection properties than by file
     * (see {@link #setConnectionPropertiesFile(String)})
     *
     * @param properties
     */
    public void setConnectionProperties(String properties) {
        userConnectionProperties = new Properties();
        StringTokenizer tokenizer = new StringTokenizer(properties, "";"");
        while (tokenizer.hasMoreElements()) {
            String pair = tokenizer.nextToken();
            int index = pair.indexOf(ESCAPED_EQUALS);
            if (index != -1) {
                String key = pair.substring(0, index);
                String value = pair.substring(index + ESCAPED_EQUALS.length());
                userConnectionProperties.put(key, value);
            }
        }
    }

    public void setDriverPath(String driverPath) {
        this.driverPath = driverPath;
    }

    public String getDriverPath() {
        if (driverPath == null)
            driverPath = pullParam(""-dp"");
        // was previously -cp:
        if (driverPath == null)
            driverPath = pullParam(""-cp"");
        return driverPath;
    }

    /**
     * The filename of the cascading style sheet to use.
     * Note that this file is parsed and used to determine characteristics
     * of the generated diagrams, so it must contain specific settings that
     * are documented within schemaSpy.css.<p>
     *
     * Defaults to <code>""schemaSpy.css""</code>.
     *
     * @param css
     */
    public void setCss(String css) {
        this.css = css;
    }

    public String getCss() {
        if (css == null) {
            css = pullParam(""-css"");
            if (css == null)
                css = ""schemaSpy.css"";
        }
        return css;
    }

    /**
     * The font to use within diagrams.  Modify the .css to specify HTML fonts.
     *
     * @param font
     */
    public void setFont(String font) {
        this.font = font;
    }

    /**
     * @see #setFont(String)
     */
    public String getFont() {
        if (font == null) {
            font = pullParam(""-font"");
            if (font == null)
                font = ""Helvetica"";
        }
        return font;
    }

    /**
     * The font size to use within diagrams.  This is the size of the font used for
     * 'large' (e.g. not 'compact') diagrams.<p>
     *
     * Modify the .css to specify HTML font sizes.<p>
     *
     * Defaults to 11.
     *
     * @param fontSize
     */
    public void setFontSize(int fontSize) {
        this.fontSize = new Integer(fontSize);
    }

    /**
     * @see #setFontSize(int)
     * @return
     */
    public int getFontSize() {
        if (fontSize == null) {
            // default
            int size = 11;
            try {
                size = Integer.parseInt(pullParam(""-fontsize""));
            } catch (Exception notSpecified) {
            }
            fontSize = new Integer(size);
        }
        return fontSize.intValue();
    }

    /**
     * The character set to use within HTML pages (defaults to <code>""ISO-8859-1""</code>).
     *
     * @param charset
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * @see #setCharset(String)
     */
    public String getCharset() {
        if (charset == null) {
            charset = pullParam(""-charset"");
            if (charset == null)
                charset = ""ISO-8859-1"";
        }
        return charset;
    }

    /**
     * Description of schema that gets display on main pages.
     *
     * @param description
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @see #setDescription(String)
     */
    public String getDescription() {
        if (description == null)
            description = pullParam(""-desc"");
        return description;
    }

    /**
     * Maximum number of threads to use when querying database metadata information.
     *
     * @param maxDbThreads
     */
    public void setMaxDbThreads(int maxDbThreads) {
        this.maxDbThreads = new Integer(maxDbThreads);
    }

    /**
     * @see #setMaxDbThreads(int)
     * @throws InvalidConfigurationException if unable to load properties
     */
    public int getMaxDbThreads() throws InvalidConfigurationException {
        if (maxDbThreads == null) {
            Properties properties;
            try {
                properties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(""Failed to load properties for "" + getDbType() + "": "" + exc).setParamName(""-type"");
            }
            // not scientifically derived
            final int defaultMax = 15;
            int max = defaultMax;
            String threads = properties.getProperty(""dbThreads"");
            if (threads == null)
                threads = properties.getProperty(""dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            threads = pullParam(""-dbThreads"");
            if (threads == null)
                threads = pullParam(""-dbthreads"");
            if (threads != null)
                max = Integer.parseInt(threads);
            if (max < 0)
                max = defaultMax;
            else if (max == 0)
                max = 1;
            maxDbThreads = new Integer(max);
        }
        return maxDbThreads.intValue();
    }

    public boolean isLogoEnabled() {
        if (logoEnabled == null)
            logoEnabled = !options.remove(""-nologo"");
        return logoEnabled;
    }

    /**
     * Don't use this unless absolutely necessary as it screws up the layout
     *
     * @param enabled
     */
    public void setRankDirBugEnabled(boolean enabled) {
        rankDirBugEnabled = enabled;
    }

    /**
     * @see #setRankDirBugEnabled(boolean)
     */
    public boolean isRankDirBugEnabled() {
        if (rankDirBugEnabled == null)
            rankDirBugEnabled = options.remove(""-rankdirbug"");
        return rankDirBugEnabled;
    }

    /**
     * Look for Ruby on Rails-based naming conventions in
     * relationships between logical foreign keys and primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * @param enabled
     */
    public void setRailsEnabled(boolean enabled) {
        railsEnabled = enabled;
    }

    /**
     * @see #setRailsEnabled(boolean)
     *
     * @return
     */
    public boolean isRailsEnabled() {
        if (railsEnabled == null)
            railsEnabled = options.remove(""-rails"");
        return railsEnabled;
    }

    /**
     * Allow Html In Comments - encode them unless otherwise specified
     */
    public void setEncodeCommentsEnabled(boolean enabled) {
        encodeCommentsEnabled = enabled;
    }

    /**
     * @see #setEncodeCommentsEnabled(boolean)
     */
    public boolean isEncodeCommentsEnabled() {
        if (encodeCommentsEnabled == null)
            encodeCommentsEnabled = !options.remove(""-ahic"");
        return encodeCommentsEnabled;
    }

    /**
     * If enabled we'll attempt to query/render the number of rows that
     * each table contains.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setNumRowsEnabled(boolean enabled) {
        numRowsEnabled = enabled;
    }

    /**
     * @see #setNumRowsEnabled(boolean)
     * @return
     */
    public boolean isNumRowsEnabled() {
        if (numRowsEnabled == null)
            numRowsEnabled = !options.remove(""-norows"");
        return numRowsEnabled;
    }

    /**
     * If enabled we'll include views in the analysis.<p/>
     *
     * Defaults to <code>true</code> (enabled).
     *
     * @param enabled
     */
    public void setViewsEnabled(boolean enabled) {
        viewsEnabled = enabled;
    }

    /**
     * @see #setViewsEnabled(boolean)
     * @return
     */
    public boolean isViewsEnabled() {
        if (viewsEnabled == null)
            viewsEnabled = !options.remove(""-noviews"");
        return viewsEnabled;
    }

    /**
     * Returns <code>true</code> if metering should be embedded in
     * the generated pages.<p/>
     * Defaults to <code>false</code> (disabled).
     * @return
     */
    public boolean isMeterEnabled() {
        if (meterEnabled == null)
            meterEnabled = options.remove(""-meter"");
        return meterEnabled;
    }

    /**
     * Set the columns to exclude from all relationship diagrams.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setColumnExclusions(String columnExclusions) {
        this.columnExclusions = Pattern.compile(columnExclusions);
    }

    /**
     * See {@link #setColumnExclusions(String)}
     * @return
     */
    public Pattern getColumnExclusions() {
        if (columnExclusions == null) {
            String strExclusions = pullParam(""-X"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.columnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            columnExclusions = Pattern.compile(strExclusions);
        }
        return columnExclusions;
    }

    /**
     * Set the columns to exclude from relationship diagrams where the specified
     * columns aren't directly referenced by the focal table.
     *
     * @param columnExclusions regular expression of the columns to
     *        exclude
     */
    public void setIndirectColumnExclusions(String fullColumnExclusions) {
        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);
    }

    /**
     * @see #setIndirectColumnExclusions(String)
     *
     * @return
     */
    public Pattern getIndirectColumnExclusions() {
        if (indirectColumnExclusions == null) {
            String strExclusions = pullParam(""-x"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.indirectColumnExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_COLUMN_EXCLUSION;
            indirectColumnExclusions = Pattern.compile(strExclusions);
        }
        return indirectColumnExclusions;
    }

    /**
     * Set the tables to include as a regular expression
     * @param tableInclusions
     */
    public void setTableInclusions(String tableInclusions) {
        this.tableInclusions = Pattern.compile(tableInclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to include in the analysis.
     *
     * @return
     */
    public Pattern getTableInclusions() {
        if (tableInclusions == null) {
            String strInclusions = pullParam(""-i"");
            if (strInclusions == null)
                strInclusions = System.getenv(""schemaspy.tableInclusions"");
            if (strInclusions == null)
                strInclusions = DEFAULT_TABLE_INCLUSION;
            try {
                tableInclusions = Pattern.compile(strInclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-i"");
            }
        }
        return tableInclusions;
    }

    /**
     * Set the tables to exclude as a regular expression
     * @param tableInclusions
     */
    public void setTableExclusions(String tableExclusions) {
        this.tableExclusions = Pattern.compile(tableExclusions);
    }

    /**
     * Get the regex {@link Pattern} for which tables to exclude from the analysis.
     *
     * @return
     */
    public Pattern getTableExclusions() {
        if (tableExclusions == null) {
            String strExclusions = pullParam(""-I"");
            if (strExclusions == null)
                strExclusions = System.getenv(""schemaspy.tableExclusions"");
            if (strExclusions == null)
                strExclusions = DEFAULT_TABLE_EXCLUSION;
            try {
                tableExclusions = Pattern.compile(strExclusions);
            } catch (PatternSyntaxException badPattern) {
                throw new InvalidConfigurationException(badPattern).setParamName(""-I"");
            }
        }
        return tableExclusions;
    }

    /**
     * @return
     */
    public List<String> getSchemas() {
        if (schemas == null) {
            String tmp = pullParam(""-schemas"");
            if (tmp == null)
                tmp = pullParam(""-schemata"");
            if (tmp != null) {
                schemas = new ArrayList<String>();
                for (String name : tmp.split(""[\\s,'\""]"")) {
                    if (name.length() > 0)
                        schemas.add(name);
                }
                if (schemas.isEmpty())
                    schemas = null;
            }
        }
        return schemas;
    }

    /**
     * Set the name of the {@link SqlFormatter SQL formatter} class to use to
     * format SQL into HTML.<p/>
     * The implementation of the class must be made available to the class
     * loader, typically by specifying the path to its jar with <em>-dp</em>
     * ({@link #setDriverPath(String)}).
     */
    public void setSqlFormatter(String formatterClassName) {
        sqlFormatterClass = formatterClassName;
        sqlFormatter = null;
    }

    /**
     * Set the {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.
     */
    public void setSqlFormatter(SqlFormatter sqlFormatter) {
        this.sqlFormatter = sqlFormatter;
        if (sqlFormatter != null)
            sqlFormatterClass = sqlFormatter.getClass().getName();
    }

    /**
     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format
     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.
     *
     * @return
     * @throws InvalidConfigurationException if unable to instantiate an instance
     */
    @SuppressWarnings(""unchecked"")
    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {
        if (sqlFormatter == null) {
            if (sqlFormatterClass == null) {
                sqlFormatterClass = pullParam(""-sqlFormatter"");
                if (sqlFormatterClass == null)
                    sqlFormatterClass = DefaultSqlFormatter.class.getName();
            }
            try {
                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);
                sqlFormatter = clazz.newInstance();
            } catch (Exception exc) {
                throw new InvalidConfigurationException(""Failed to initialize instance of SQL formatter: "", exc).setParamName(""-sqlFormatter"");
            }
        }
        return sqlFormatter;
    }

    /**
     * Set the details to show on the columns page, where ""details"" are
     * comma and/or space separated.
     *
     * Valid values:
     * <ul>
     * <li>id</li>
     * <li>table</li>
     * <li>column</li>
     * <li>type</li>
     * <li>size</li>
     * <li>nulls</li>
     * <li>auto</li>
     * <li>default</li>
     * <li>children</li>
     * <li>parents</li>
     * </ul>
     *
     * The default details are <code>""table column type size nulls auto default""</code>.
     * Note that ""column"" is the initially displayed detail and must be included.
     *
     * @param columnDetails
     */
    public void setColumnDetails(String columnDetails) {
        this.columnDetails = new ArrayList<String>();
        if (columnDetails == null || columnDetails.length() == 0) {
            // not specified, so use defaults
            columnDetails = ""id table column type size nulls auto default"";
        }
        for (String detail : columnDetails.split(""[\\s,'\""]"")) {
            if (detail.length() > 0) {
                this.columnDetails.add(detail.toLowerCase());
            }
        }
        if (!this.columnDetails.contains(""column""))
            throw new InvalidConfigurationException(""'column' is a required column detail"");
    }

    public void setColumnDetails(List<String> columnDetails) {
        String details = columnDetails == null ? ""[]"" : columnDetails.toString();
        setColumnDetails(details.substring(1, details.length() - 1));
    }

    public List<String> getColumnDetails() {
        if (columnDetails == null) {
            setColumnDetails(pullParam(""-columndetails""));
        }
        return columnDetails;
    }

    public void setEvaluateAllEnabled(boolean enabled) {
        evaluteAll = enabled;
    }

    public boolean isEvaluateAllEnabled() {
        if (evaluteAll == null)
            evaluteAll = options.remove(""-all"");
        return evaluteAll;
    }

    /**
     * Returns true if we're evaluating a bunch of schemas in one go and
     * at this point we're evaluating a specific schema.
     *
     * @return boolean
     */
    public boolean isOneOfMultipleSchemas() {
        // set by MultipleSchemaAnalyzer
        return Boolean.getBoolean(""oneofmultipleschemas"");
    }

    /**
     * When -all (evaluateAll) is specified then this is the regular
     * expression that determines which schemas to evaluate.
     *
     * @param schemaSpec
     */
    public void setSchemaSpec(String schemaSpec) {
        this.schemaSpec = schemaSpec;
    }

    public String getSchemaSpec() {
        if (schemaSpec == null)
            schemaSpec = pullParam(""-schemaSpec"");
        return schemaSpec;
    }

    /**
     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a>.<p>
     * Note that the leading "":"" is required while :formatter is optional.<p>
     * The default renderer is typically GD.<p>
     * Note that using {@link #setHighQuality(boolean)} is the preferred approach
     * over using this method.
     */
    public void setRenderer(String renderer) {
        Dot.getInstance().setRenderer(renderer);
    }

    /**
     * @see #setRenderer(String)
     * @return
     */
    public String getRenderer() {
        String renderer = pullParam(""-renderer"");
        if (renderer != null)
            setRenderer(renderer);
        return Dot.getInstance().getRenderer();
    }

    /**
     * If <code>false</code> then generate output of ""lower quality""
     * than the default.
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.<p>
     * Higher quality output takes longer to generate and results in significantly
     * larger image files (which take longer to download / display), but it generally
     * looks better.
     */
    public void setHighQuality(boolean highQuality) {
        this.highQuality = highQuality;
        lowQuality = !highQuality;
        Dot.getInstance().setHighQuality(highQuality);
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        if (highQuality == null) {
            highQuality = options.remove(""-hq"");
            if (highQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(highQuality);
            }
        }
        highQuality = Dot.getInstance().isHighQuality();
        return highQuality;
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isLowQuality() {
        if (lowQuality == null) {
            lowQuality = options.remove(""-lq"");
            if (lowQuality) {
                // use whatever is the default unless explicitly specified otherwise
                Dot.getInstance().setHighQuality(!lowQuality);
            }
        }
        lowQuality = !Dot.getInstance().isHighQuality();
        return lowQuality;
    }

    /**
     * Set the level of logging to perform.<p/>
     * The levels in descending order are:
     * <ul>
     *  <li><code>severe</code> (highest - least detail)
     *  <li><code>warning</code> (default)
     *  <li><code>info</code>
     *  <li><code>config</code>
     *  <li><code>fine</code>
     *  <li><code>finer</code>
     *  <li><code>finest</code>  (lowest - most detail)
     * </ul>
     *
     * @param logLevel
     */
    public void setLogLevel(String logLevel) {
        if (logLevel == null) {
            this.logLevel = Level.WARNING;
            return;
        }
        Map<String, Level> levels = new LinkedHashMap<String, Level>();
        levels.put(""severe"", Level.SEVERE);
        levels.put(""warning"", Level.WARNING);
        levels.put(""info"", Level.INFO);
        levels.put(""config"", Level.CONFIG);
        levels.put(""fine"", Level.FINE);
        levels.put(""finer"", Level.FINER);
        levels.put(""finest"", Level.FINEST);
        this.logLevel = levels.get(logLevel.toLowerCase());
        if (this.logLevel == null) {
            throw new InvalidConfigurationException(""Invalid logLevel: '"" + logLevel + ""'. Must be one of: "" + levels.keySet());
        }
    }

    /**
     * Returns the level of logging to perform.
     * See {@link #setLogLevel(String)}.
     *
     * @return
     */
    public Level getLogLevel() {
        if (logLevel == null) {
            setLogLevel(pullParam(""-loglevel""));
        }
        return logLevel;
    }

    /**
     * Returns <code>true</code> if the options indicate that the user wants
     * to see some help information.
     *
     * @return
     */
    public boolean isHelpRequired() {
        return helpRequired;
    }

    public boolean isDbHelpRequired() {
        return dbHelpRequired;
    }

    /**
     * Returns the jar that we were loaded from
     *
     * @return
     */
    public static String getLoadedFromJar() {
        String classpath = System.getProperty(""java.class.path"");
        return new StringTokenizer(classpath, File.pathSeparator).nextToken();
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasOrphans(boolean hasOrphans) {
        this.hasOrphans = hasOrphans;
    }

    /**
     * @see #setHasOrphans()
     *
     * @return
     */
    public boolean hasOrphans() {
        return hasOrphans;
    }

    /**
     * Not a true configuration item in that it's determined at runtime
     */
    public void setHasRoutines(boolean hasRoutines) {
        this.hasRoutines = hasRoutines;
    }

    /**
     * @see #setHasRoutines()
     *
     * @return
     */
    public boolean hasRoutines() {
        return hasRoutines;
    }

    /**
     * Returns the database properties to use.
     * These should be determined by calling {@link #determineDbProperties(String)}.
     * @return
     * @throws InvalidConfigurationException
     */
    public Properties getDbProperties() throws InvalidConfigurationException {
        if (dbProperties == null) {
            try {
                dbProperties = determineDbProperties(getDbType());
            } catch (IOException exc) {
                throw new InvalidConfigurationException(exc);
            }
        }
        return dbProperties;
    }

    /**
     * Determines the database properties associated with the specified type.
     * A call to {@link #setDbProperties(Properties)} is expected after determining
     * the complete set of properties.
     *
     * @param type
     * @return
     * @throws IOException
     * @throws InvalidConfigurationException if db properties are incorrectly formed
     */
    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {
        ResourceBundle bundle = null;
        try {
            File propertiesFile = new File(type);
            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {
            try {
                File propertiesFile = new File(type + "".properties"");
                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));
                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();
            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {
                try {
                    bundle = ResourceBundle.getBundle(type);
                    dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]"" + File.separator + type + "".properties"";
                } catch (Exception notInJarWithoutPath) {
                    try {
                        String path = TableOrderer.class.getPackage().getName() + "".dbTypes."" + type;
                        path = path.replace('.', '/');
                        bundle = ResourceBundle.getBundle(path);
                        dbPropertiesLoadedFrom = ""["" + getLoadedFromJar() + ""]/"" + path + "".properties"";
                    } catch (Exception notInJar) {
                        notInJar.printStackTrace();
                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();
                        throw notFoundOnFilesystemWithoutExtension;
                    }
                }
            }
        }
        Properties props = asProperties(bundle);
        bundle = null;
        // keep original thru recursion
        String saveLoadedFrom = dbPropertiesLoadedFrom;
        // bring in key/values pointed to by the include directive
        // example: include.1=mysql::selectRowCountSql
        for (int i = 1; true; ++i) {
            String include = (String) props.remove(""include."" + i);
            if (include == null)
                break;
            int separator = include.indexOf(""::"");
            if (separator == -1)
                throw new InvalidConfigurationException(""include directive in "" + dbPropertiesLoadedFrom + "" must have '::' between dbType and key"");
            String refdType = include.substring(0, separator).trim();
            String refdKey = include.substring(separator + 2).trim();
            // recursively resolve the ref'd properties file and the ref'd key
            Properties refdProps = determineDbProperties(refdType);
            props.put(refdKey, refdProps.getProperty(refdKey));
        }
        // bring in base properties files pointed to by the extends directive
        String baseDbType = (String) props.remove(""extends"");
        if (baseDbType != null) {
            baseDbType = baseDbType.trim();
            Properties baseProps = determineDbProperties(baseDbType);
            // overlay our properties on top of the base's
            baseProps.putAll(props);
            props = baseProps;
        }
        // done with this level of recursion...restore original
        dbPropertiesLoadedFrom = saveLoadedFrom;
        // this won't be correct until the final recursion exits
        dbProperties = props;
        return props;
    }

    protected String getDbPropertiesLoadedFrom() throws IOException {
        if (dbPropertiesLoadedFrom == null)
            determineDbProperties(getDbType());
        return dbPropertiesLoadedFrom;
    }

    public List<String> getRemainingParameters() {
        try {
            populate();
        } catch (IllegalArgumentException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (IllegalAccessException exc) {
            throw new InvalidConfigurationException(exc);
        } catch (InvocationTargetException exc) {
            if (exc.getCause() instanceof InvalidConfigurationException)
                throw (InvalidConfigurationException) exc.getCause();
            throw new InvalidConfigurationException(exc.getCause());
        } catch (IntrospectionException exc) {
            throw new InvalidConfigurationException(exc);
        }
        return options;
    }

    /**
     * Options that are specific to a type of database.  E.g. things like <code>host</code>,
     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.
     *
     * @param dbSpecificOptions
     */
    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {
        this.dbSpecificOptions = dbSpecificOptions;
        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);
    }

    public Map<String, String> getDbSpecificOptions() {
        if (dbSpecificOptions == null)
            dbSpecificOptions = new HashMap<String, String>();
        return dbSpecificOptions;
    }

    /**
     * Returns a {@link Properties} populated with the contents of <code>bundle</code>
     *
     * @param bundle ResourceBundle
     * @return Properties
     */
    public static Properties asProperties(ResourceBundle bundle) {
        Properties props = new Properties();
        Enumeration<String> iter = bundle.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            props.put(key, bundle.getObject(key));
        }
        return props;
    }

    /**
     * 'Pull' the specified parameter from the collection of options. Returns
     * null if the parameter isn't in the list and removes it if it is.
     *
     * @param paramId
     * @return
     */
    private String pullParam(String paramId) {
        return pullParam(paramId, false, false);
    }

    private String pullRequiredParam(String paramId) {
        return pullParam(paramId, true, false);
    }

    /**
     * @param paramId
     * @param required
     * @param dbTypeSpecific
     * @return
     * @throws MissingRequiredParameterException
     */
    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {
        int paramIndex = options.indexOf(paramId);
        if (paramIndex < 0) {
            if (required)
                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);
            return null;
        }
        options.remove(paramIndex);
        String param = options.get(paramIndex).toString();
        options.remove(paramIndex);
        return param;
    }

    /**
     * Thrown to indicate that a required parameter is missing
     */
    public static class MissingRequiredParameterException extends RuntimeException {

        private static final long serialVersionUID = 1L;

        private final boolean dbTypeSpecific;

        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {
            this(paramId, null, dbTypeSpecific);
        }

        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {
            super(""Required parameter '"" + paramId + ""' "" + (description == null ? """" : ""("" + description + "") "") + ""was not specified."" + (dbTypeSpecific ? ""  It is required for this database type."" : """"));
            this.dbTypeSpecific = dbTypeSpecific;
        }

        public boolean isDbTypeSpecific() {
            return dbTypeSpecific;
        }
    }

    /**
     * Allow an equal sign in args...like ""-o=foo.bar"". Useful for things like
     * Ant and Maven.
     *
     * @param args
     *            List
     * @return List
     */
    protected List<String> fixupArgs(List<String> args) {
        List<String> expandedArgs = new ArrayList<String>();
        for (String arg : args) {
            int indexOfEquals = arg.indexOf('=');
            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {
                expandedArgs.add(arg.substring(0, indexOfEquals));
                expandedArgs.add(arg.substring(indexOfEquals + 1));
            } else {
                expandedArgs.add(arg);
            }
        }
        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,
        // so MultipleSchemaAnalyzer has to surround params with double quotes...
        // strip them here for the OSes/JVMs that don't do anything with the params
        List<String> unquotedArgs = new ArrayList<String>();
        for (String arg : expandedArgs) {
            if (// "".*"" becomes .*
            arg.startsWith(""\"""") && arg.endsWith(""\""""))
                arg = arg.substring(1, arg.length() - 1);
            unquotedArgs.add(arg);
        }
        return unquotedArgs;
    }

    /**
     * Call all the getters to populate all the lazy initialized stuff.
     *
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws IntrospectionException
     */
    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {
        if (!populating) {
            // prevent recursion
            populating = true;
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                Method readMethod = props[i].getReadMethod();
                if (readMethod != null)
                    readMethod.invoke(this, (Object[]) null);
            }
            populating = false;
        }
    }

    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {
        Set<String> databaseTypes = new TreeSet<String>();
        JarInputStream jar = null;
        try {
            jar = new JarInputStream(new FileInputStream(loadedFromJar));
            JarEntry entry;
            while ((entry = jar.getNextJarEntry()) != null) {
                String entryName = entry.getName();
                int dotPropsIndex = entryName.indexOf("".properties"");
                if (dotPropsIndex != -1)
                    databaseTypes.add(entryName.substring(0, dotPropsIndex));
            }
        } catch (IOException exc) {
        } finally {
            if (jar != null) {
                try {
                    jar.close();
                } catch (IOException ignore) {
                }
            }
        }
        return databaseTypes;
    }

    protected void dumpUsage(String errorMessage, boolean detailedDb) {
        if (errorMessage != null) {
            System.out.flush();
            System.err.println(""*** "" + errorMessage + "" ***"");
        } else {
            System.out.println(""SchemaSpy generates an HTML representation of a database schema's relationships."");
        }
        System.err.flush();
        System.out.println();
        if (!detailedDb) {
            System.out.println(""Usage:"");
            System.out.println("" java -jar "" + getLoadedFromJar() + "" [options]"");
            System.out.println(""   -t databaseType       type of database - defaults to ora"");
            System.out.println(""                           use -dbhelp for a list of built-in types"");
            System.out.println(""   -u user               connect to the database with this user id"");
            System.out.println(""   -s schema             defaults to the specified user"");
            System.out.println(""   -p password           defaults to no password"");
            System.out.println(""   -o outputDirectory    directory to place the generated output in"");
            System.out.println(""   -dp pathToDrivers     optional - looks for JDBC drivers here before looking"");
            System.out.println(""                           in driverPath in [databaseType].properties."");
            System.out.println(""Go to http://schemaspy.sourceforge.net for a complete list/description"");
            System.out.println("" of additional parameters."");
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""Built-in database types and their required connection parameters:"");
            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {
                new DbSpecificConfig(type).dumpUsage();
            }
            System.out.println();
        }
        if (detailedDb) {
            System.out.println(""You can use your own database types by specifying the filespec of a .properties file with -t."");
            System.out.println(""Grab one out of "" + getLoadedFromJar() + "" and modify it to suit your needs."");
            System.out.println();
        }
        System.out.println(""Sample usage using the default database type (implied -t ora):"");
        System.out.println("" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output"");
        System.out.println();
        System.out.flush();
    }

    /**
     * Get the value of the specified parameter.
     * Used for properties that are common to most db's, but aren't required.
     *
     * @param paramName
     * @return
     */
    public String getParam(String paramName) {
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            for (int i = 0; i < props.length; ++i) {
                PropertyDescriptor prop = props[i];
                if (prop.getName().equalsIgnoreCase(paramName)) {
                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);
                    return result == null ? null : result.toString();
                }
            }
        } catch (Exception failed) {
            failed.printStackTrace();
        }
        return null;
    }

    /**
     * Return all of the configuration options as a List of Strings, with
     * each parameter and its value as a separate element.
     *
     * @return
     * @throws IOException
     */
    public List<String> asList() throws IOException {
        List<String> params = new ArrayList<String>();
        if (originalDbSpecificOptions != null) {
            for (String key : originalDbSpecificOptions.keySet()) {
                String value = originalDbSpecificOptions.get(key);
                if (!key.startsWith(""-""))
                    key = ""-"" + key;
                params.add(key);
                params.add(value);
            }
        }
        if (isEncodeCommentsEnabled())
            params.add(""-ahic"");
        if (isEvaluateAllEnabled())
            params.add(""-all"");
        if (!isHtmlGenerationEnabled())
            params.add(""-nohtml"");
        if (!isImpliedConstraintsEnabled())
            params.add(""-noimplied"");
        if (!isLogoEnabled())
            params.add(""-nologo"");
        if (isMeterEnabled())
            params.add(""-meter"");
        if (!isNumRowsEnabled())
            params.add(""-norows"");
        if (!isViewsEnabled())
            params.add(""-noviews"");
        if (isRankDirBugEnabled())
            params.add(""-rankdirbug"");
        if (isRailsEnabled())
            params.add(""-rails"");
        if (isSingleSignOn())
            params.add(""-sso"");
        if (isSchemaDisabled())
            params.add(""-noschema"");
        String value = getDriverPath();
        if (value != null) {
            params.add(""-dp"");
            params.add(value);
        }
        params.add(""-css"");
        params.add(getCss());
        params.add(""-charset"");
        params.add(getCharset());
        params.add(""-font"");
        params.add(getFont());
        params.add(""-fontsize"");
        params.add(String.valueOf(getFontSize()));
        params.add(""-t"");
        params.add(getDbType());
        // query to set renderer correctly
        isHighQuality();
        // query to set renderer correctly
        isLowQuality();
        // instead of -hq and/or -lq
        params.add(""-renderer"");
        params.add(getRenderer());
        value = getDescription();
        if (value != null) {
            params.add(""-desc"");
            params.add(value);
        }
        value = getPassword();
        if (value != null && !isPromptForPasswordEnabled()) {
            // note that we don't pass -pfp since child processes
            // won't have a console
            params.add(""-p"");
            params.add(value);
        }
        value = getCatalog();
        if (value != null) {
            params.add(""-cat"");
            params.add(value);
        }
        value = getSchema();
        if (value != null) {
            params.add(""-s"");
            params.add(value);
        }
        value = getUser();
        if (value != null) {
            params.add(""-u"");
            params.add(value);
        }
        value = getConnectionPropertiesFile();
        if (value != null) {
            params.add(""-connprops"");
            params.add(value);
        } else {
            Properties props = getConnectionProperties();
            if (!props.isEmpty()) {
                params.add(""-connprops"");
                StringBuilder buf = new StringBuilder();
                for (Entry<Object, Object> entry : props.entrySet()) {
                    buf.append(entry.getKey());
                    buf.append(ESCAPED_EQUALS);
                    buf.append(entry.getValue());
                    buf.append(';');
                }
                params.add(buf.toString());
            }
        }
        value = getDb();
        if (value != null) {
            params.add(""-db"");
            params.add(value);
        }
        value = getHost();
        if (value != null) {
            params.add(""-host"");
            params.add(value);
        }
        if (getPort() != null) {
            params.add(""-port"");
            params.add(getPort().toString());
        }
        value = getServer();
        if (value != null) {
            params.add(""-server"");
            params.add(value);
        }
        value = getMeta();
        if (value != null) {
            params.add(""-meta"");
            params.add(value);
        }
        if (getGraphvizDir() != null) {
            params.add(""-gv"");
            params.add(getGraphvizDir().toString());
        }
        params.add(""-loglevel"");
        params.add(getLogLevel().toString().toLowerCase());
        params.add(""-sqlFormatter"");
        params.add(getSqlFormatter().getClass().getName());
        params.add(""-i"");
        params.add(getTableInclusions().toString());
        params.add(""-I"");
        params.add(getTableExclusions().toString());
        params.add(""-X"");
        params.add(getColumnExclusions().toString());
        params.add(""-x"");
        params.add(getIndirectColumnExclusions().toString());
        params.add(""-dbthreads"");
        params.add(String.valueOf(getMaxDbThreads()));
        params.add(""-maxdet"");
        params.add(String.valueOf(getMaxDetailedTables()));
        params.add(""-o"");
        params.add(getOutputDir().toString());
        return params;
    }
}
","// Config_8Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#asList()} method.
*/
class Config_8Test {","// Config_8Test.java
package net.sourceforge.schemaspy;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.PasswordReader;
import net.sourceforge.schemaspy.view.DefaultSqlFormatter;
import net.sourceforge.schemaspy.view.SqlFormatter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Config}.
* It contains ten unit test cases for the {@link Config#asList()} method.
*/
class Config_8Test {
"
1d545f2e-6acc-477b-a9a5-930795f3786a,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_10Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9043 tokens (5043 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_10Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getDefaultNullStringColumns(Collection)} method.
*/
class DbAnalyzer_10Test {","// DbAnalyzer_10Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getDefaultNullStringColumns(Collection)} method.
*/
class DbAnalyzer_10Test {
"
19d0cbd8-36df-4604-9d62-a2f293452e42,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_11Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9042 tokens (5042 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_11Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getCatalogs(DatabaseMetaData)} method.
*/
class DbAnalyzer_11Test {","// DbAnalyzer_11Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getCatalogs(DatabaseMetaData)} method.
*/
class DbAnalyzer_11Test {
"
8a09b421-46e3-4f7d-b0d0-77ad9ccb0724,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_12Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9042 tokens (5042 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_12Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getSchemas(DatabaseMetaData)} method.
*/
class DbAnalyzer_12Test {","// DbAnalyzer_12Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getSchemas(DatabaseMetaData)} method.
*/
class DbAnalyzer_12Test {
"
693c4f43-93d6-48c4-9d0c-7535180a0a73,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_13Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9044 tokens (5044 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_13Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData)} method.
*/
class DbAnalyzer_13Test {","// DbAnalyzer_13Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData)} method.
*/
class DbAnalyzer_13Test {
"
d852e8b8-1bac-4ef3-89ea-3d2546d5b583,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_14Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9048 tokens (5048 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_14Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData, String, boolean)} method.
*/
class DbAnalyzer_14Test {","// DbAnalyzer_14Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData, String, boolean)} method.
*/
class DbAnalyzer_14Test {
"
335007ff-9636-439f-a946-b43d917c2456,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9043 tokens (5043 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_1Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getRailsConstraints(Map)} method.
*/
class DbAnalyzer_1Test {","// DbAnalyzer_1Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getRailsConstraints(Map)} method.
*/
class DbAnalyzer_1Test {
"
f88a49ef-8bdc-470c-b686-51b5b1664642,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9043 tokens (5043 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_2Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getForeignKeyConstraints(Collection)} method.
*/
class DbAnalyzer_2Test {","// DbAnalyzer_2Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getForeignKeyConstraints(Collection)} method.
*/
class DbAnalyzer_2Test {
"
1613fa58-b514-4c06-a08c-b860a3f6525c,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9045 tokens (5045 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_4Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getMustBeUniqueNullableColumns(Collection)} method.
*/
class DbAnalyzer_4Test {","// DbAnalyzer_4Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getMustBeUniqueNullableColumns(Collection)} method.
*/
class DbAnalyzer_4Test {
"
420352ad-15f3-486a-b6d0-7422d5754e78,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzer_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9043 tokens (5043 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DbAnalyzer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;

public class DbAnalyzer {

    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {
        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();
        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getName().compareToIgnoreCase(column2.getName());
                if (rc == 0)
                    rc = column1.getType().compareToIgnoreCase(column2.getType());
                if (rc == 0)
                    rc = column1.getLength() - column2.getLength();
                return rc;
            }
        });
        int duplicatePrimaries = 0;
        // gather all the primary key columns and columns without parents
        for (Table table : tables) {
            List<TableColumn> tablePrimaries = table.getPrimaryColumns();
            if (tablePrimaries.size() == 1) {
                // can't match up multiples...yet...
                for (TableColumn primary : tablePrimaries) {
                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)
                        ++duplicatePrimaries;
                }
            }
            for (TableColumn column : table.getColumns()) {
                if (!column.isForeignKey() && column.allowsImpliedParents())
                    columnsWithoutParents.add(column);
            }
        }
        // if more than half of the tables have the same primary key then
        // it's most likely a database where primary key names aren't unique
        // (e.g. they all have a primary key named 'ID')
        if (// bizarre logic, but it does approximately what we need
        duplicatePrimaries > allPrimaries.size())
            return new ArrayList<ImpliedForeignKeyConstraint>();
        sortColumnsByTable(columnsWithoutParents);
        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();
        for (TableColumn childColumn : columnsWithoutParents) {
            Table primaryTable = allPrimaries.get(childColumn);
            if (primaryTable != null && primaryTable != childColumn.getTable()) {
                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());
                // make sure the potential child->parent relationships isn't already a
                // parent->child relationship
                if (parentColumn.getParentConstraint(childColumn) == null) {
                    // ok, we've found a potential relationship with a column matches a primary
                    // key column in another table and isn't already related to that column
                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));
                }
            }
        }
        return impliedConstraints;
    }

    /**
     * Ruby on Rails-based databases typically have no real referential integrity
     * constraints.  Instead they have a somewhat unusual way of associating
     * columns to primary keys.<p>
     *
     * Basically all tables have a primary key named <code>ID</code>.
     * All tables are named plural names.
     * The columns that logically reference that <code>ID</code> are the singular
     * form of the table name suffixed with <code>_ID</code>.<p>
     *
     * A side-effect of calling this method is that the returned collection of
     * constraints will be ""tied into"" the associated tables.
     *
     * @param tables
     * @return List of {@link RailsForeignKeyConstraint}s
     */
    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {
        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());
        // iterate thru each column in each table looking for columns that
        // match Rails naming conventions
        for (Table table : tables.values()) {
            for (TableColumn column : table.getColumns()) {
                String columnName = column.getName().toLowerCase();
                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(""_id"")) {
                    String singular = columnName.substring(0, columnName.length() - 3);
                    String primaryTableName = Inflection.pluralize(singular);
                    Table primaryTable = tables.get(primaryTableName);
                    if (primaryTable != null) {
                        TableColumn primaryColumn = primaryTable.getColumn(""ID"");
                        if (primaryColumn != null) {
                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));
                        }
                    }
                }
            }
        }
        return railsConstraints;
    }

    /**
     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s
     * used by the specified tables.
     *
     * @param tables Collection
     * @return List
     */
    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {
        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
        for (Table table : tables) {
            constraints.addAll(table.getForeignKeys());
        }
        return constraints;
    }

    public static List<Table> getOrphans(Collection<Table> tables) {
        List<Table> orphans = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.isOrphan(false)) {
                orphans.add(table);
            }
        }
        return sortTablesByName(orphans);
    }

    /**
     * Return a list of <code>TableColumn</code>s that are both nullable
     * and have an index that specifies that they must be unique (a rather strange combo).
     */
    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {
        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableIndex index : table.getIndexes()) {
                if (index.isUniqueNullable()) {
                    uniqueNullables.addAll(index.getColumns());
                }
            }
        }
        return sortColumnsByTable(uniqueNullables);
    }

    /**
     * Return a list of <code>Table</code>s that have neither an index nor a primary key.
     */
    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {
        List<Table> withoutIndexes = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())
                withoutIndexes.add(table);
        }
        return sortTablesByName(withoutIndexes);
    }

    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {
        List<Table> denormalizedTables = new ArrayList<Table>();
        for (Table table : tables) {
            Map<String, Long> columnPrefixes = new HashMap<String, Long>();
            for (TableColumn column : table.getColumns()) {
                // search for columns that start with the same prefix
                // and end in an incrementing number
                String columnName = column.getName();
                String numbers = null;
                for (int i = columnName.length() - 1; i > 0; --i) {
                    if (Character.isDigit(columnName.charAt(i))) {
                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? """" : numbers);
                    } else {
                        break;
                    }
                }
                // attempt to detect where they had an existing column
                // and added a ""column2"" type of column (we'll call this one ""1"")
                if (numbers == null) {
                    numbers = ""1"";
                    columnName = columnName + numbers;
                }
                // see if we've already found a column with the same prefix
                // that had a numeric suffix +/- 1.
                String prefix = columnName.substring(0, columnName.length() - numbers.length());
                long numeric = Long.parseLong(numbers);
                Long existing = columnPrefixes.get(prefix);
                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {
                    // found one so add it to our list and stop evaluating this table
                    denormalizedTables.add(table);
                    break;
                }
                columnPrefixes.put(prefix, new Long(numeric));
            }
        }
        return sortTablesByName(denormalizedTables);
    }

    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {
        List<Table> singleColumnTables = new ArrayList<Table>();
        for (Table table : tables) {
            if (table.getColumns().size() == 1)
                singleColumnTables.add(table);
        }
        return sortTablesByName(singleColumnTables);
    }

    public static List<Table> sortTablesByName(List<Table> tables) {
        Collections.sort(tables, new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        });
        return tables;
    }

    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {
        Collections.sort(columns, new Comparator<TableColumn>() {

            public int compare(TableColumn column1, TableColumn column2) {
                int rc = column1.getTable().compareTo(column2.getTable());
                if (rc == 0)
                    rc = column1.getName().compareToIgnoreCase(column2.getName());
                return rc;
            }
        });
        return columns;
    }

    /**
     * Returns a list of columns that have the word ""NULL"" or ""null"" as their default value
     * instead of the likely candidate value null.
     *
     * @param tables Collection
     * @return List
     */
    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {
        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();
        for (Table table : tables) {
            for (TableColumn column : table.getColumns()) {
                Object defaultValue = column.getDefaultValue();
                if (defaultValue != null && defaultValue instanceof String) {
                    String defaultString = defaultValue.toString();
                    if (defaultString.trim().equalsIgnoreCase(""'null'"")) {
                        defaultNullStringColumns.add(column);
                    }
                }
            }
        }
        return sortColumnsByTable(defaultNullStringColumns);
    }

    /**
     * getSchemas - returns a List of catalog names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<String> catalogs = new ArrayList<String>();
        ResultSet rs = meta.getCatalogs();
        while (rs.next()) {
            catalogs.add(rs.getString(""TABLE_CAT""));
        }
        rs.close();
        return catalogs;
    }

    /**
     * getSchemas - returns a List of schema names (Strings)
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {
        List<String> schemas = new ArrayList<String>();
        ResultSet rs = meta.getSchemas();
        while (rs.next()) {
            schemas.add(rs.getString(""TABLE_SCHEM""));
        }
        rs.close();
        return schemas;
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {
        return getPopulatedSchemas(meta, "".*"", false);
    }

    /**
     * getSchemas - returns a List of schema names (Strings) that contain tables and
     * match the <code>schemaSpec</code> regular expression
     *
     * @param meta DatabaseMetaData
     */
    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {
        // alpha sorted
        Set<String> schemas = new TreeSet<String>();
        Pattern schemaRegex = Pattern.compile(schemaSpec);
        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());
        boolean logging = logger.isLoggable(Level.FINE);
        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {
            if (schemaRegex.matcher(schema).matches()) {
                ResultSet rs = null;
                try {
                    rs = meta.getTables(null, schema, ""%"", null);
                    if (rs.next()) {
                        if (logging)
                            logger.fine(""Including schema "" + schema + "": matches + \"""" + schemaRegex + ""\"" and contains tables"");
                        schemas.add(schema);
                    } else {
                        if (logging)
                            logger.fine(""Excluding schema "" + schema + "": matches \"""" + schemaRegex + ""\"" but contains no tables"");
                    }
                } catch (SQLException ignore) {
                } finally {
                    if (rs != null)
                        rs.close();
                }
            } else {
                if (logging)
                    logger.fine(""Excluding schema "" + schema + "": doesn't match \"""" + schemaRegex + '""');
            }
        }
        return new ArrayList<String>(schemas);
    }

    /**
     * For debugging/analyzing result sets
     * @param rs ResultSet
     * @throws SQLException
     */
    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int numColumns = meta.getColumnCount();
        System.out.println(numColumns + "" columns of "" + description + "":"");
        for (int i = 1; i <= numColumns; ++i) {
            System.out.print(meta.getColumnLabel(i));
            System.out.print("": "");
            System.out.print(String.valueOf(rs.getString(i)));
            System.out.print(""\t"");
        }
        System.out.println();
    }
}
","// DbAnalyzer_5Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getTablesWithoutIndexes(Collection)} method.
*/
class DbAnalyzer_5Test {","// DbAnalyzer_5Test.java
package net.sourceforge.schemaspy;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;
import net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.Inflection;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbAnalyzer}.
* It contains ten unit test cases for the {@link DbAnalyzer#getTablesWithoutIndexes(Collection)} method.
*/
class DbAnalyzer_5Test {
"
cmpl-6u82VsiAvhkRrjr1jJAfZkIzQluqa,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/TableOrderer.java,103.1339328289032,length,"// TableOrderer.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;

/**
 * Sorts {@link Table}s by their referential integrity constraints.
 * The intent is to have a list of tables in an order that can be used
 * to insert or delete them from a database.
 *
 * @author John Currier
 */
public class TableOrderer {

    /**
     * Returns a list of <code>Table</code>s ordered such that parents are listed first
     * and child tables are listed last.
     *
     * <code>recursiveConstraints</code> gets populated with <code>TableConstraint</code>s
     * that had to be removed to resolve the returned list.
     * @param recursiveConstraints
     * @return
     */
    public List<Table> getTablesOrderedByRI(Collection<Table> tables, Collection<ForeignKeyConstraint> recursiveConstraints) {
        List<Table> heads = new ArrayList<Table>();
        List<Table> tails = new ArrayList<Table>();
        List<Table> remainingTables = new ArrayList<Table>(tables);
        List<Table> unattached = new ArrayList<Table>();
        // first pass to gather the 'low hanging fruit'
        for (Iterator<Table> iter = remainingTables.iterator(); iter.hasNext(); ) {
            Table table = iter.next();
            if (table.isRemote()) {
                // ignore remote tables since there's no way to deal with them
                table.unlinkParents();
                table.unlinkChildren();
                iter.remove();
            } else if (table.isLeaf() && table.isRoot()) {
                // floater, so add it to 'unattached'
                unattached.add(table);
                iter.remove();
            }
        }
        unattached = sortTrimmedLevel(unattached);
        boolean prunedNonReals = false;
        while (!remainingTables.isEmpty()) {
            int tablesLeft = remainingTables.size();
            tails.addAll(0, trimLeaves(remainingTables));
            heads.addAll(trimRoots(remainingTables));
            // if we could't trim anything then there's recursion....
            // resolve it by removing a constraint, one by one, 'till the tables are all trimmed
            if (tablesLeft == remainingTables.size()) {
                if (!prunedNonReals) {
                    // get ride of everything that isn't explicitly specified by the database
                    for (Table table : remainingTables) {
                        table.removeNonRealForeignKeys();
                    }
                    prunedNonReals = true;
                    continue;
                }
                boolean foundSimpleRecursion = false;
                for (Table potentialRecursiveTable : remainingTables) {
                    ForeignKeyConstraint recursiveConstraint = potentialRecursiveTable.removeSelfReferencingConstraint();
                    if (recursiveConstraint != null) {
                        recursiveConstraints.add(recursiveConstraint);
                        foundSimpleRecursion = true;
                    }
                }
                if (!foundSimpleRecursion) {
                    // expensive comparison, but we're down to the end of the tables so it shouldn't really matter
                    Set<Table> byParentChildDelta = new TreeSet<Table>(new Comparator<Table>() {

                        // sort on the delta between number of parents and kids so we can
                        // target the tables with the biggest delta and therefore the most impact
                        // on reducing the smaller of the two
                        public int compare(Table table1, Table table2) {
                            int rc = Math.abs(table2.getNumChildren() - table2.getNumParents()) - Math.abs(table1.getNumChildren() - table1.getNumParents());
                            if (rc == 0)
                                rc = table1.compareTo(table2);
                            return rc;
                        }
                    });
                    byParentChildDelta.addAll(remainingTables);
                    // this one has the largest delta
                    Table recursiveTable = byParentChildDelta.iterator().next();
                    ForeignKeyConstraint removedConstraint = recursiveTable.removeAForeignKeyConstraint();
                    recursiveConstraints.add(removedConstraint);
                }
            }
        }
        // we've gathered all the heads and tails, so combine them here moving 'unattached' tables to the end
        List<Table> ordered = new ArrayList<Table>(heads.size() + tails.size());
        ordered.addAll(heads);
        // allow gc ASAP
        heads = null;
        ordered.addAll(tails);
        // allow gc ASAP
        tails = null;
        ordered.addAll(unattached);
        return ordered;
    }

    /**
     * Remove the root nodes (tables w/o parents)
     *
     * @param tables
     * @return tables removed
     */
    private static List<Table> trimRoots(List<Table> tables) {
        List<Table> roots = new ArrayList<Table>();
        Iterator<Table> iter = tables.iterator();
        while (iter.hasNext()) {
            Table root = iter.next();
            if (root.isRoot()) {
                roots.add(root);
                iter.remove();
            }
        }
        // now sort them so the ones with large numbers of children show up first (not required, but cool)
        roots = sortTrimmedLevel(roots);
        iter = roots.iterator();
        while (iter.hasNext()) {
            // do this after the previous loop to prevent getting roots before they're ready
            // and so we can sort them correctly
            iter.next().unlinkChildren();
        }
        return roots;
    }

    /**
     * Remove the leaf nodes (tables w/o children)
     *
     * @param tables
     * @return tables removed
     */
    private static List<Table> trimLeaves(List<Table> tables) {
        List<Table> leaves = new ArrayList<Table>();
        Iterator<Table> iter = tables.iterator();
        while (iter.hasNext()) {
            Table leaf = iter.next();
            if (leaf.isLeaf()) {
                leaves.add(leaf);
                iter.remove();
            }
        }
        // now sort them so the ones with large numbers of children show up first (not required, but cool)
        leaves = sortTrimmedLevel(leaves);
        iter = leaves.iterator();
        while (iter.hasNext()) {
            // do this after the previous loop to prevent getting leaves before they're ready
            // and so we can sort them correctly
            iter.next().unlinkParents();
        }
        return leaves;
    }

    /**
     * this doesn't change the logical output of the program because all of these (leaves or roots) are at the same logical level
     */
    private static List<Table> sortTrimmedLevel(List<Table> tables) {
        /**
         * order by
         * <ul>
         *  <li>number of kids (descending)
         *  <li>number of parents (ascending)
         *  <li>alpha name (ascending)
         * </ul>
         */
        final class TrimComparator implements Comparator<Table> {

            public int compare(Table table1, Table table2) {
                // have to keep track of and use the 'max' versions because
                // by the time we get here we'll (probably?) have no parents or children
                int rc = table2.getMaxChildren() - table1.getMaxChildren();
                if (rc == 0)
                    rc = table1.getMaxParents() - table2.getMaxParents();
                if (rc == 0)
                    rc = table1.compareTo(table2);
                return rc;
            }
        }
        Set<Table> sorter = new TreeSet<Table>(new TrimComparator());
        sorter.addAll(tables);
        return new ArrayList<Table>(sorter);
    }
}
","// TableOrdererTest.java
package net.sourceforge.schemaspy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableOrderer}.
* It contains ten unit test cases for the {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
*/
class TableOrdererTest {","// TableOrdererTest.java
package net.sourceforge.schemaspy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableOrderer}.
* It contains ten unit test cases for the {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
*/
class TableOrdererTest {

	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection is empty.
	 */
	@Test
	void testGetTablesOrderedByRI_EmptyCollection() {
		Collection<Table> tables = new ArrayList<Table>();
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(0, orderedTables.size());
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains one table.
	 */
	@Test
	void testGetTablesOrderedByRI_OneTable() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table = new Table(""table1"");
		tables.add(table);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(1, orderedTables.size());
		assertEquals(table, orderedTables.get(0));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains two tables.
	 */
	@Test
	void testGetTablesOrderedByRI_TwoTables() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		tables.add(table1);
		tables.add(table2);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(2, orderedTables.size());
		assertEquals(table1, orderedTables.get(0));
		assertEquals(table2, orderedTables.get(1));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table1, orderedTables.get(0));
		assertEquals(table2, orderedTables.get(1));
		assertEquals(table3, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChild() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table1, orderedTables.get(0));
		assertEquals(table2, orderedTables.get(1));
		assertEquals(table3, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a parent of another.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneParent() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addParent(table2);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table2, orderedTables.get(0));
		assertEquals(table1, orderedTables.get(1));
		assertEquals(table3, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParent() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table2, orderedTables.get(0));
		assertEquals(table1, orderedTables.get(1));
		assertEquals(table3, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first and the third is a child of the second.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParentOneChild() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		table2.addChild(table3);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table2, orderedTables.get(0));
		assertEquals(table1, orderedTables.get(1));
		assertEquals(table3, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first and the third is a parent of the second.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParentOneParent() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		table2.addParent(table3);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table3, orderedTables.get(0));
		assertEquals(table2, orderedTables.get(1));
		assertEquals(table1, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first and the third is a child of the second and a parent of the first.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParentOneChildOneParent() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		table2.addChild(table3);
		table3.addParent(table1);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table2, orderedTables.get(0));
		assertEquals(table3, orderedTables.get(1));
		assertEquals(table1, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first and the third is a child of the second and a parent of the first and the second is a child of the third.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParentOneChildOneParentOneChild() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		table2.addChild(table3);
		table3.addParent(table1);
		table2.addChild(table3);
		Collection<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();
		TableOrderer tableOrderer = new TableOrderer();
		List<Table> orderedTables = tableOrderer.getTablesOrderedByRI(tables, recursiveConstraints);
		assertEquals(3, orderedTables.size());
		assertEquals(table2, orderedTables.get(0));
		assertEquals(table3, orderedTables.get(1));
		assertEquals(table1, orderedTables.get(2));
		assertEquals(0, recursiveConstraints.size());
	}
	
	/**
	 * Test case for {@link TableOrderer#getTablesOrderedByRI(Collection, Collection)} method.
	 * It tests the case when the input collection contains three tables and one of them is a child of another and the other is a parent of the first and the third is a child of the second and a parent of the first and the second is a child of the third and a parent of the first.
	 */
	@Test
	void testGetTablesOrderedByRI_ThreeTables_OneChildOneParentOneChildOneParentOneChildOneParent() {
		Collection<Table> tables = new ArrayList<Table>();
		Table table1 = new Table(""table1"");
		Table table2 = new Table(""table2"");
		Table table3 = new Table(""table3"");
		tables.add(table1);
		tables.add(table2);
		tables.add(table3);
		table1.addChild(table2);
		table1.addParent(table2);
		table2.addChild(table3);
		table3.addParent(table1);
		table2.addChild(table3);
		table2.addParent(table1);
		Collection<ForeignKeyConstraint"
31552b61-045e-4818-a873-59438b1882ed,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Database_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16476 tokens (12476 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Database.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

public class Database {

    private final Config config;

    private final String databaseName;

    private final String catalog;

    private final String schema;

    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();

    private final Map<String, View> views = new CaseInsensitiveMap<View>();

    // key: schema.tableName
    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();

    private final Map<String, Table> locals = new CombinedMap(tables, views);

    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();

    private final DatabaseMetaData meta;

    private final Connection connection;

    private final String connectTime = new SimpleDateFormat(""EEE MMM dd HH:mm z yyyy"").format(new Date());

    private Set<String> sqlKeywords;

    private Pattern invalidIdentifierPattern;

    private final Logger logger = Logger.getLogger(getClass().getName());

    private final boolean fineEnabled = logger.isLoggable(Level.FINE);

    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {
        this.config = config;
        this.connection = connection;
        this.meta = meta;
        this.databaseName = name;
        this.catalog = catalog;
        this.schema = schema;
        initTables(meta);
        if (config.isViewsEnabled())
            initViews(meta);
        initCheckConstraints();
        initTableIds();
        initIndexIds();
        initTableComments();
        initTableColumnComments();
        initViewComments();
        initViewColumnComments();
        initColumnTypes();
        initRoutines();
        connectTables();
        updateFromXmlMetadata(schemaMeta);
    }

    public String getName() {
        return databaseName;
    }

    public String getCatalog() {
        return catalog;
    }

    public String getSchema() {
        return schema;
    }

    /**
     * Details of the database type that's running under the covers.
     *
     * @return null if a description wasn't specified.
     */
    public String getDescription() {
        return config.getDescription();
    }

    public Collection<Table> getTables() {
        return tables.values();
    }

    /**
     * Return a {@link Map} of all {@link Table}s keyed by their name.
     *
     * @return
     */
    public Map<String, Table> getTablesByName() {
        return tables;
    }

    public Collection<View> getViews() {
        return views.values();
    }

    public Collection<Table> getRemoteTables() {
        return remoteTables.values();
    }

    public Collection<Routine> getRoutines() {
        return routines.values();
    }

    public Connection getConnection() {
        return connection;
    }

    public DatabaseMetaData getMetaData() {
        return meta;
    }

    public String getConnectTime() {
        return connectTime;
    }

    public String getDatabaseProduct() {
        try {
            return meta.getDatabaseProductName() + "" - "" + meta.getDatabaseProductVersion();
        } catch (SQLException exc) {
            return """";
        }
    }

    /**
     *  ""macro"" to validate that a table is somewhat valid
     */
    class NameValidator {

        private final String clazz;

        private final Pattern include;

        private final Pattern exclude;

        private final Set<String> validTypes;

        /**
         * @param clazz table or view
         * @param include
         * @param exclude
         * @param verbose
         * @param validTypes
         */
        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {
            this.clazz = clazz;
            this.include = include;
            this.exclude = exclude;
            this.validTypes = new HashSet<String>();
            for (String type : validTypes) {
                this.validTypes.add(type.toUpperCase());
            }
        }

        /**
         * Returns <code>true</code> if the table/view name is deemed ""valid""
         *
         * @param name name of the table or view
         * @param type type as returned by metadata.getTables():TABLE_TYPE
         * @return
         */
        boolean isValid(String name, String type) {
            // some databases (MySQL) return more than we wanted
            if (!validTypes.contains(type.toUpperCase()))
                return false;
            // Oracle 10g introduced problematic flashback tables
            // with bizarre illegal names
            if (name.indexOf(""$"") != -1) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": embedded $ implies illegal name"");
                }
                return false;
            }
            if (exclude.matcher(name).matches()) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": matches exclusion pattern \"""" + exclude + '""');
                }
                return false;
            }
            boolean valid = include.matcher(name).matches();
            if (fineEnabled) {
                if (valid) {
                    logger.fine(""Including "" + clazz + "" "" + name + "": matches inclusion pattern \"""" + include + '""');
                } else {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": doesn't match inclusion pattern \"""" + include + '""');
                }
            }
            return valid;
        }
    }

    /**
     * Create/initialize any tables in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initTables(final DatabaseMetaData metadata) throws SQLException {
        final Pattern include = config.getTableInclusions();
        final Pattern exclude = config.getTableExclusions();
        final int maxThreads = config.getMaxDbThreads();
        String[] types = getTypes(""tableTypes"", ""TABLE"");
        NameValidator validator = new NameValidator(""table"", include, exclude, types);
        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);
        TableCreator creator;
        if (maxThreads == 1) {
            creator = new TableCreator();
        } else {
            // creating tables takes a LONG time (based on JProbe analysis),
            // so attempt to speed it up by doing several in parallel.
            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive
            creator = new ThreadedTableCreator(maxThreads);
            // ""prime the pump"" so if there's a database problem we'll probably see it now
            // and not in a secondary thread
            while (!entries.isEmpty()) {
                BasicTableMeta entry = entries.remove(0);
                if (validator.isValid(entry.name, entry.type)) {
                    new TableCreator().create(entry);
                    break;
                }
            }
        }
        // kick off the secondary threads to do the creation in parallel
        for (BasicTableMeta entry : entries) {
            if (validator.isValid(entry.name, entry.type)) {
                creator.create(entry);
            }
        }
        // wait for everyone to finish
        creator.join();
    }

    /**
     * Create/initialize any views in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initViews(DatabaseMetaData metadata) throws SQLException {
        Pattern includeTables = config.getTableInclusions();
        Pattern excludeTables = config.getTableExclusions();
        String[] types = getTypes(""viewTypes"", ""VIEW"");
        NameValidator validator = new NameValidator(""view"", includeTables, excludeTables, types);
        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {
            if (validator.isValid(entry.name, entry.type)) {
                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);
                views.put(view.getName(), view);
                if (fineEnabled) {
                    logger.fine(""Found details of view "" + view.getName());
                } else {
                    System.out.print('.');
                }
            }
        }
    }

    /**
     * Collection of fundamental table/view metadata
     */
    private class BasicTableMeta {

        @SuppressWarnings(""hiding"")
        final String catalog;

        @SuppressWarnings(""hiding"")
        final String schema;

        final String name;

        final String type;

        final String remarks;

        final String viewSql;

        // -1 if not determined
        final int numRows;

        /**
         * @param schema
         * @param name
         * @param type typically ""TABLE"" or ""VIEW""
         * @param remarks
         * @param text optional textual SQL used to create the view
         * @param numRows number of rows, or -1 if not determined
         */
        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {
            this.catalog = catalog;
            this.schema = schema;
            this.name = name;
            this.type = type;
            this.remarks = remarks;
            viewSql = text;
            this.numRows = numRows;
        }
    }

    /**
     * Return a list of basic details of the tables in the schema.
     *
     * @param metadata
     * @param forTables true if we're getting table data, false if getting view data
     * @return
     * @throws SQLException
     */
    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {
        String queryName = forTables ? ""selectTablesSql"" : ""selectViewsSql"";
        String sql = Config.getInstance().getDbProperties().getProperty(queryName);
        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();
        ResultSet rs = null;
        if (sql != null) {
            String clazz = forTables ? ""table"" : ""view"";
            PreparedStatement stmt = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String name = rs.getString(clazz + ""_name"");
                    String cat = getOptionalString(rs, clazz + ""_catalog"");
                    String sch = getOptionalString(rs, clazz + ""_schema"");
                    if (cat == null && sch == null)
                        sch = schema;
                    String remarks = getOptionalString(rs, clazz + ""_comment"");
                    String text = forTables ? null : getOptionalString(rs, ""view_definition"");
                    String rows = forTables ? getOptionalString(rs, ""table_rows"") : null;
                    int numRows = rows == null ? -1 : Integer.parseInt(rows);
                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve "" + clazz + "" names with custom SQL: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
        if (basics.isEmpty()) {
            rs = metadata.getTables(null, schema, ""%"", types);
            try {
                while (rs.next()) {
                    String name = rs.getString(""TABLE_NAME"");
                    String type = rs.getString(""TABLE_TYPE"");
                    String cat = rs.getString(""TABLE_CAT"");
                    String schem = rs.getString(""TABLE_SCHEM"");
                    String remarks = getOptionalString(rs, ""REMARKS"");
                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));
                }
            } catch (SQLException exc) {
                if (forTables)
                    throw exc;
                System.out.flush();
                System.err.println();
                System.err.println(""Ignoring view "" + rs.getString(""TABLE_NAME"") + "" due to exception:"");
                exc.printStackTrace();
                System.err.println(""Continuing analysis."");
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        return basics;
    }

    /**
     * Return a database-specific array of types from the .properties file
     * with the specified property name.
     *
     * @param propName
     * @param defaultValue
     * @return
     */
    private String[] getTypes(String propName, String defaultValue) {
        String value = config.getDbProperties().getProperty(propName, defaultValue);
        List<String> types = new ArrayList<String>();
        for (String type : value.split("","")) {
            type = type.trim();
            if (type.length() > 0)
                types.add(type);
        }
        return types.toArray(new String[types.size()]);
    }

    /**
     * Some databases don't play nice with their metadata.
     * E.g. Oracle doesn't have a REMARKS column at all.
     * This method ignores those types of failures, replacing them with null.
     */
    public String getOptionalString(ResultSet rs, String columnName) {
        try {
            return rs.getString(columnName);
        } catch (SQLException ignore) {
            return null;
        }
    }

    private void initCheckConstraints() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectCheckConstraintsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.addCheckConstraint(rs.getString(""constraint_name""), rs.getString(""text""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve check constraints: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initColumnTypes() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnTypesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        String columnName = rs.getString(""column_name"");
                        TableColumn column = table.getColumn(columnName);
                        if (column != null) {
                            column.setType(rs.getString(""column_type""));
                            column.setShortType(getOptionalString(rs, ""short_column_type""));
                        }
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column type details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initTableIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setId(rs.getObject(""table_id""));
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initIndexIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectIndexIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableIndex index = table.getIndex(rs.getString(""index_name""));
                        if (index != null)
                            index.setId(rs.getObject(""index_id""));
                    }
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table comments.
     * If the SQL also returns view comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view comments.
     *
     * @throws SQLException
     */
    private void initViewComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null)
                        view.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table column comments.
     * If the SQL also returns view column comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableColumn column = table.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view column comments.
     *
     * @throws SQLException
     */
    private void initViewColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null) {
                        TableColumn column = view.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve view column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes stored procedures / functions.
     *
     * @throws SQLException
     */
    private void initRoutines() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectRoutinesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""routine_name"");
                    String routineType = rs.getString(""routine_type"");
                    String returnType = rs.getString(""dtd_identifier"");
                    String definitionLanguage = rs.getString(""routine_body"");
                    String definition = rs.getString(""routine_definition"");
                    String dataAccess = rs.getString(""sql_data_access"");
                    String securityType = rs.getString(""security_type"");
                    boolean deterministic = rs.getBoolean(""is_deterministic"");
                    String comment = getOptionalString(rs, ""routine_comment"");
                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);
                    routines.put(routineName, routine);
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
                rs = null;
                stmt = null;
            }
        }
        sql = config.getDbProperties().getProperty(""selectRoutineParametersSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""specific_name"");
                    Routine routine = routines.get(routineName);
                    if (routine != null) {
                        String paramName = rs.getString(""parameter_name"");
                        String type = rs.getString(""dtd_identifier"");
                        String mode = rs.getString(""parameter_mode"");
                        RoutineParameter param = new RoutineParameter(paramName, type, mode);
                        routine.addParameter(param);
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Dump a warning message out to a new line
     *
     * @param msg1
     * @param msg2
     */
    private void warning(String msg1, String msg2) {
        System.out.println();
        System.out.flush();
        logger.warning(msg1);
        if (msg2 != null)
            logger.warning(msg2);
    }

    /**
     * Create a <code>PreparedStatement</code> from the specified SQL.
     * The SQL can contain these named parameters (but <b>not</b> question marks).
     * <ol>
     * <li>:schema - replaced with the name of the schema
     * <li>:owner - alias for :schema
     * <li>:table - replaced with the name of the table
     * </ol>
     * @param sql String - SQL without question marks
     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.
     * @throws SQLException
     * @return PreparedStatement
     */
    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {
        StringBuilder sqlBuf = new StringBuilder(sql);
        // modifies sqlBuf
        List<String> sqlParams = getSqlParams(sqlBuf, tableName);
        if (fineEnabled)
            logger.fine(sqlBuf + "" "" + sqlParams);
        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());
        try {
            for (int i = 0; i < sqlParams.size(); ++i) {
                stmt.setString(i + 1, sqlParams.get(i).toString());
            }
        } catch (SQLException exc) {
            stmt.close();
            throw exc;
        }
        return stmt;
    }

    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {
        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);
        Table remoteTable = remoteTables.get(fullName);
        if (remoteTable == null) {
            if (fineEnabled)
                logger.fine(""Creating remote table "" + fullName);
            if (logical)
                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            else
                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            if (fineEnabled)
                logger.fine(""Adding remote table "" + fullName);
            remoteTables.put(fullName, remoteTable);
            remoteTable.connectForeignKeys(locals);
        }
        return remoteTable;
    }

    /**
     * Return an uppercased <code>Set</code> of all SQL keywords used by a database
     *
     * @return
     * @throws SQLException
     */
    public Set<String> getSqlKeywords() throws SQLException {
        if (sqlKeywords == null) {
            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:
            String[] sql92Keywords = (""ADA"" + ""| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME"" + ""| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG"" + ""| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED"" + ""| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME"" + ""| CONSTRAINT_SCHEMA | CURSOR_NAME"" + ""| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION"" + ""| FORTRAN"" + ""| LENGTH"" + ""| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS"" + ""| NAME | NULLABLE | NUMBER"" + ""| PASCAL | PLI"" + ""| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE"" + ""| ROW_COUNT"" + ""| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN"" + ""| TABLE_NAME | TYPE"" + ""| UNCOMMITTED | UNNAMED"" + ""| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND"" + ""| ANY | ARE | AS | ASC"" + ""| ASSERTION | AT | AUTHORIZATION | AVG"" + ""| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY"" + ""| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH"" + ""| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION"" + ""| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT"" + ""| CONSTRAINTS | CONTINUE"" + ""| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT"" + ""| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR"" + ""| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE"" + ""| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS"" + ""| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP"" + ""| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION"" + ""| EXEC | EXECUTE | EXISTS"" + ""| EXTERNAL | EXTRACT"" + ""| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL"" + ""| GET | GLOBAL | GO | GOTO | GRANT | GROUP"" + ""| HAVING | HOUR"" + ""| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT"" + ""| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS"" + ""| ISOLATION"" + ""| JOIN"" + ""| KEY"" + ""| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER"" + ""| MATCH | MAX | MIN | MINUTE | MODULE | MONTH"" + ""| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL"" + ""| NULLIF | NUMERIC"" + ""| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR"" + ""| ORDER | OUTER"" + ""| OUTPUT | OVERLAPS"" + ""| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY"" + ""| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC"" + ""| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT"" + ""| ROLLBACK | ROWS"" + ""| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET"" + ""| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE"" + ""| SUBSTRING | SUM | SYSTEM_USER"" + ""| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE"" + ""| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE"" + ""| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING"" + ""| VALUE | VALUES | VARCHAR | VARYING | VIEW"" + ""| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE"" + ""| YEAR"" + ""| ZONE"").split(""[| ]+"");
            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split("",\\s*"");
            sqlKeywords = new HashSet<String>() {

                private static final long serialVersionUID = 1L;

                @Override
                public boolean contains(Object key) {
                    return super.contains(((String) key).toUpperCase());
                }
            };
            sqlKeywords.addAll(Arrays.asList(sql92Keywords));
            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));
        }
        return sqlKeywords;
    }

    /**
     * Return <code>id</code> quoted if required, otherwise return <code>id</code>
     *
     * @param id
     * @return
     * @throws SQLException
     */
    public String getQuotedIdentifier(String id) throws SQLException {
        // look for any character that isn't valid (then matcher.find() returns true)
        Matcher matcher = getInvalidIdentifierPattern().matcher(id);
        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);
        if (quotesRequired) {
            // name contains something that must be quoted
            String quote = getMetaData().getIdentifierQuoteString().trim();
            return quote + id + quote;
        }
        // no quoting necessary
        return id;
    }

    /**
     * Return a <code>Pattern</code> whose matcher will return <code>true</code>
     * when run against an identifier that contains a character that is not
     * acceptable by the database without being quoted.
     */
    private Pattern getInvalidIdentifierPattern() throws SQLException {
        if (invalidIdentifierPattern == null) {
            String validChars = ""a-zA-Z0-9_"";
            String reservedRegexChars = ""-&^"";
            String extraValidChars = getMetaData().getExtraNameCharacters();
            for (int i = 0; i < extraValidChars.length(); ++i) {
                char ch = extraValidChars.charAt(i);
                if (reservedRegexChars.indexOf(ch) >= 0)
                    validChars += ""\\"";
                validChars += ch;
            }
            invalidIdentifierPattern = Pattern.compile(""[^"" + validChars + ""]"");
        }
        return invalidIdentifierPattern;
    }

    /**
     * Replaces named parameters in <code>sql</code> with question marks and
     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.
     *
     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.
     * @param tableName String
     * @return List of Strings
     *
     * @see #prepareStatement(String, String)
     */
    private List<String> getSqlParams(StringBuilder sql, String tableName) {
        Map<String, String> namedParams = new HashMap<String, String>();
        @SuppressWarnings(""hiding"")
        String schema = getSchema();
        if (schema == null)
            // some 'schema-less' db's treat the db name like a schema (unusual case)
            schema = getName();
        namedParams.put("":schema"", schema);
        // alias for :schema
        namedParams.put("":owner"", schema);
        if (tableName != null) {
            namedParams.put("":table"", tableName);
            // alias for :table
            namedParams.put("":view"", tableName);
        }
        List<String> sqlParams = new ArrayList<String>();
        int nextColon = sql.indexOf("":"");
        while (nextColon != -1) {
            String paramName = new StringTokenizer(sql.substring(nextColon), "" ,\""')"").nextToken();
            String paramValue = namedParams.get(paramName);
            if (paramValue == null)
                throw new InvalidConfigurationException(""Unexpected named parameter '"" + paramName + ""' found in SQL '"" + sql + ""'"");
            sqlParams.add(paramValue);
            // replace with a ?
            sql.replace(nextColon, nextColon + paramName.length(), ""?"");
            nextColon = sql.indexOf("":"", nextColon);
        }
        return sqlParams;
    }

    /**
     * Take the supplied XML-based metadata and update our model of the schema with it
     *
     * @param schemaMeta
     * @throws SQLException
     */
    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {
        if (schemaMeta != null) {
            config.setDescription(schemaMeta.getComments());
            // done in three passes:
            // 1: create any new tables
            // 2: add/mod columns
            // 3: connect
            // add the newly defined tables and columns first
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {
                    // will add it if it doesn't already exist
                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);
                } else {
                    table = locals.get(tableMeta.getName());
                    if (table == null) {
                        // new table defined only in XML metadata
                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());
                        tables.put(table.getName(), table);
                    }
                }
                table.update(tableMeta);
            }
            // then tie the tables together
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {
                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));
                } else {
                    table = locals.get(tableMeta.getName());
                }
                table.connect(tableMeta, locals);
            }
        }
    }

    private void connectTables() throws SQLException {
        for (Table table : tables.values()) {
            table.connectForeignKeys(locals);
        }
        for (Table view : views.values()) {
            view.connectForeignKeys(locals);
        }
    }

    /**
     * Returns a 'key' that's used to identify a remote table
     * in the remoteTables map.
     *
     * @param cat
     * @param sch
     * @param table
     * @return
     */
    public String getRemoteTableKey(String cat, String sch, String table) {
        return Table.getFullName(getName(), cat, sch, table);
    }

    /**
     * Single-threaded implementation of a class that creates tables
     */
    private class TableCreator {

        /**
         * Create a table and put it into <code>tables</code>
         */
        void create(BasicTableMeta tableMeta) throws SQLException {
            createImpl(tableMeta);
        }

        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {
            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);
            if (tableMeta.numRows != -1) {
                table.setNumRows(tableMeta.numRows);
            }
            synchronized (tables) {
                tables.put(table.getName(), table);
            }
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""Retrieved details of "" + table.getFullName());
            } else {
                System.out.print('.');
            }
        }

        /**
         * Wait for all of the tables to be created.
         * By default this does nothing since this implementation isn't threaded.
         */
        void join() {
        }
    }

    /**
     * Multi-threaded implementation of a class that creates tables
     */
    private class ThreadedTableCreator extends TableCreator {

        private final Set<Thread> threads = new HashSet<Thread>();

        private final int maxThreads;

        ThreadedTableCreator(int maxThreads) {
            this.maxThreads = maxThreads;
        }

        @Override
        void create(final BasicTableMeta tableMeta) throws SQLException {
            Thread runner = new Thread() {

                @Override
                public void run() {
                    try {
                        createImpl(tableMeta);
                    } catch (SQLException exc) {
                        // nobody above us in call stack...dump it here
                        exc.printStackTrace();
                    } finally {
                        synchronized (threads) {
                            threads.remove(this);
                            threads.notify();
                        }
                    }
                }
            };
            synchronized (threads) {
                // wait for enough 'room'
                while (threads.size() >= maxThreads) {
                    try {
                        threads.wait();
                    } catch (InterruptedException interrupted) {
                    }
                }
                threads.add(runner);
            }
            runner.start();
        }

        /**
         * Wait for all of the started threads to complete
         */
        @Override
        public void join() {
            while (true) {
                Thread thread;
                synchronized (threads) {
                    Iterator<Thread> iter = threads.iterator();
                    if (!iter.hasNext())
                        break;
                    thread = iter.next();
                }
                try {
                    thread.join();
                } catch (InterruptedException exc) {
                }
            }
        }
    }

    /**
     * A read-only map that treats both collections of Tables and Views as one
     * combined collection.
     * This is a bit strange, but it simplifies logic that otherwise treats
     * the two as if they were one collection.
     */
    private class CombinedMap implements Map<String, Table> {

        private final Map<String, ? extends Table> map1;

        private final Map<String, ? extends Table> map2;

        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {
            this.map1 = map1;
            this.map2 = map2;
        }

        public Table get(Object name) {
            Table table = map1.get(name);
            if (table == null)
                table = map2.get(name);
            return table;
        }

        public int size() {
            return map1.size() + map2.size();
        }

        public boolean isEmpty() {
            return map1.isEmpty() && map2.isEmpty();
        }

        public boolean containsKey(Object key) {
            return map1.containsKey(key) || map2.containsKey(key);
        }

        public boolean containsValue(Object value) {
            return map1.containsValue(value) || map2.containsValue(value);
        }

        public Table put(String name, Table table) {
            throw new UnsupportedOperationException();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<String> keySet() {
            return getCombined().keySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<Map.Entry<String, Table>> entrySet() {
            return getCombined().entrySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Collection<Table> values() {
            return getCombined().values();
        }

        private Map<String, Table> getCombined() {
            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());
            all.putAll(map1);
            all.putAll(map2);
            return all;
        }

        public Table remove(Object key) {
            throw new UnsupportedOperationException();
        }

        public void putAll(Map<? extends String, ? extends Table> table) {
            throw new UnsupportedOperationException();
        }

        public void clear() {
            throw new UnsupportedOperationException();
        }
    }
}
","// Database_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getOptionalString(ResultSet, String)} method.
*/
class Database_0Test {","// Database_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getOptionalString(ResultSet, String)} method.
*/
class Database_0Test {
"
f06c75f6-8e52-4aed-80db-19d34454b9f3,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Database_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16475 tokens (12475 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Database.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

public class Database {

    private final Config config;

    private final String databaseName;

    private final String catalog;

    private final String schema;

    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();

    private final Map<String, View> views = new CaseInsensitiveMap<View>();

    // key: schema.tableName
    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();

    private final Map<String, Table> locals = new CombinedMap(tables, views);

    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();

    private final DatabaseMetaData meta;

    private final Connection connection;

    private final String connectTime = new SimpleDateFormat(""EEE MMM dd HH:mm z yyyy"").format(new Date());

    private Set<String> sqlKeywords;

    private Pattern invalidIdentifierPattern;

    private final Logger logger = Logger.getLogger(getClass().getName());

    private final boolean fineEnabled = logger.isLoggable(Level.FINE);

    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {
        this.config = config;
        this.connection = connection;
        this.meta = meta;
        this.databaseName = name;
        this.catalog = catalog;
        this.schema = schema;
        initTables(meta);
        if (config.isViewsEnabled())
            initViews(meta);
        initCheckConstraints();
        initTableIds();
        initIndexIds();
        initTableComments();
        initTableColumnComments();
        initViewComments();
        initViewColumnComments();
        initColumnTypes();
        initRoutines();
        connectTables();
        updateFromXmlMetadata(schemaMeta);
    }

    public String getName() {
        return databaseName;
    }

    public String getCatalog() {
        return catalog;
    }

    public String getSchema() {
        return schema;
    }

    /**
     * Details of the database type that's running under the covers.
     *
     * @return null if a description wasn't specified.
     */
    public String getDescription() {
        return config.getDescription();
    }

    public Collection<Table> getTables() {
        return tables.values();
    }

    /**
     * Return a {@link Map} of all {@link Table}s keyed by their name.
     *
     * @return
     */
    public Map<String, Table> getTablesByName() {
        return tables;
    }

    public Collection<View> getViews() {
        return views.values();
    }

    public Collection<Table> getRemoteTables() {
        return remoteTables.values();
    }

    public Collection<Routine> getRoutines() {
        return routines.values();
    }

    public Connection getConnection() {
        return connection;
    }

    public DatabaseMetaData getMetaData() {
        return meta;
    }

    public String getConnectTime() {
        return connectTime;
    }

    public String getDatabaseProduct() {
        try {
            return meta.getDatabaseProductName() + "" - "" + meta.getDatabaseProductVersion();
        } catch (SQLException exc) {
            return """";
        }
    }

    /**
     *  ""macro"" to validate that a table is somewhat valid
     */
    class NameValidator {

        private final String clazz;

        private final Pattern include;

        private final Pattern exclude;

        private final Set<String> validTypes;

        /**
         * @param clazz table or view
         * @param include
         * @param exclude
         * @param verbose
         * @param validTypes
         */
        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {
            this.clazz = clazz;
            this.include = include;
            this.exclude = exclude;
            this.validTypes = new HashSet<String>();
            for (String type : validTypes) {
                this.validTypes.add(type.toUpperCase());
            }
        }

        /**
         * Returns <code>true</code> if the table/view name is deemed ""valid""
         *
         * @param name name of the table or view
         * @param type type as returned by metadata.getTables():TABLE_TYPE
         * @return
         */
        boolean isValid(String name, String type) {
            // some databases (MySQL) return more than we wanted
            if (!validTypes.contains(type.toUpperCase()))
                return false;
            // Oracle 10g introduced problematic flashback tables
            // with bizarre illegal names
            if (name.indexOf(""$"") != -1) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": embedded $ implies illegal name"");
                }
                return false;
            }
            if (exclude.matcher(name).matches()) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": matches exclusion pattern \"""" + exclude + '""');
                }
                return false;
            }
            boolean valid = include.matcher(name).matches();
            if (fineEnabled) {
                if (valid) {
                    logger.fine(""Including "" + clazz + "" "" + name + "": matches inclusion pattern \"""" + include + '""');
                } else {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": doesn't match inclusion pattern \"""" + include + '""');
                }
            }
            return valid;
        }
    }

    /**
     * Create/initialize any tables in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initTables(final DatabaseMetaData metadata) throws SQLException {
        final Pattern include = config.getTableInclusions();
        final Pattern exclude = config.getTableExclusions();
        final int maxThreads = config.getMaxDbThreads();
        String[] types = getTypes(""tableTypes"", ""TABLE"");
        NameValidator validator = new NameValidator(""table"", include, exclude, types);
        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);
        TableCreator creator;
        if (maxThreads == 1) {
            creator = new TableCreator();
        } else {
            // creating tables takes a LONG time (based on JProbe analysis),
            // so attempt to speed it up by doing several in parallel.
            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive
            creator = new ThreadedTableCreator(maxThreads);
            // ""prime the pump"" so if there's a database problem we'll probably see it now
            // and not in a secondary thread
            while (!entries.isEmpty()) {
                BasicTableMeta entry = entries.remove(0);
                if (validator.isValid(entry.name, entry.type)) {
                    new TableCreator().create(entry);
                    break;
                }
            }
        }
        // kick off the secondary threads to do the creation in parallel
        for (BasicTableMeta entry : entries) {
            if (validator.isValid(entry.name, entry.type)) {
                creator.create(entry);
            }
        }
        // wait for everyone to finish
        creator.join();
    }

    /**
     * Create/initialize any views in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initViews(DatabaseMetaData metadata) throws SQLException {
        Pattern includeTables = config.getTableInclusions();
        Pattern excludeTables = config.getTableExclusions();
        String[] types = getTypes(""viewTypes"", ""VIEW"");
        NameValidator validator = new NameValidator(""view"", includeTables, excludeTables, types);
        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {
            if (validator.isValid(entry.name, entry.type)) {
                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);
                views.put(view.getName(), view);
                if (fineEnabled) {
                    logger.fine(""Found details of view "" + view.getName());
                } else {
                    System.out.print('.');
                }
            }
        }
    }

    /**
     * Collection of fundamental table/view metadata
     */
    private class BasicTableMeta {

        @SuppressWarnings(""hiding"")
        final String catalog;

        @SuppressWarnings(""hiding"")
        final String schema;

        final String name;

        final String type;

        final String remarks;

        final String viewSql;

        // -1 if not determined
        final int numRows;

        /**
         * @param schema
         * @param name
         * @param type typically ""TABLE"" or ""VIEW""
         * @param remarks
         * @param text optional textual SQL used to create the view
         * @param numRows number of rows, or -1 if not determined
         */
        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {
            this.catalog = catalog;
            this.schema = schema;
            this.name = name;
            this.type = type;
            this.remarks = remarks;
            viewSql = text;
            this.numRows = numRows;
        }
    }

    /**
     * Return a list of basic details of the tables in the schema.
     *
     * @param metadata
     * @param forTables true if we're getting table data, false if getting view data
     * @return
     * @throws SQLException
     */
    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {
        String queryName = forTables ? ""selectTablesSql"" : ""selectViewsSql"";
        String sql = Config.getInstance().getDbProperties().getProperty(queryName);
        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();
        ResultSet rs = null;
        if (sql != null) {
            String clazz = forTables ? ""table"" : ""view"";
            PreparedStatement stmt = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String name = rs.getString(clazz + ""_name"");
                    String cat = getOptionalString(rs, clazz + ""_catalog"");
                    String sch = getOptionalString(rs, clazz + ""_schema"");
                    if (cat == null && sch == null)
                        sch = schema;
                    String remarks = getOptionalString(rs, clazz + ""_comment"");
                    String text = forTables ? null : getOptionalString(rs, ""view_definition"");
                    String rows = forTables ? getOptionalString(rs, ""table_rows"") : null;
                    int numRows = rows == null ? -1 : Integer.parseInt(rows);
                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve "" + clazz + "" names with custom SQL: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
        if (basics.isEmpty()) {
            rs = metadata.getTables(null, schema, ""%"", types);
            try {
                while (rs.next()) {
                    String name = rs.getString(""TABLE_NAME"");
                    String type = rs.getString(""TABLE_TYPE"");
                    String cat = rs.getString(""TABLE_CAT"");
                    String schem = rs.getString(""TABLE_SCHEM"");
                    String remarks = getOptionalString(rs, ""REMARKS"");
                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));
                }
            } catch (SQLException exc) {
                if (forTables)
                    throw exc;
                System.out.flush();
                System.err.println();
                System.err.println(""Ignoring view "" + rs.getString(""TABLE_NAME"") + "" due to exception:"");
                exc.printStackTrace();
                System.err.println(""Continuing analysis."");
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        return basics;
    }

    /**
     * Return a database-specific array of types from the .properties file
     * with the specified property name.
     *
     * @param propName
     * @param defaultValue
     * @return
     */
    private String[] getTypes(String propName, String defaultValue) {
        String value = config.getDbProperties().getProperty(propName, defaultValue);
        List<String> types = new ArrayList<String>();
        for (String type : value.split("","")) {
            type = type.trim();
            if (type.length() > 0)
                types.add(type);
        }
        return types.toArray(new String[types.size()]);
    }

    /**
     * Some databases don't play nice with their metadata.
     * E.g. Oracle doesn't have a REMARKS column at all.
     * This method ignores those types of failures, replacing them with null.
     */
    public String getOptionalString(ResultSet rs, String columnName) {
        try {
            return rs.getString(columnName);
        } catch (SQLException ignore) {
            return null;
        }
    }

    private void initCheckConstraints() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectCheckConstraintsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.addCheckConstraint(rs.getString(""constraint_name""), rs.getString(""text""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve check constraints: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initColumnTypes() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnTypesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        String columnName = rs.getString(""column_name"");
                        TableColumn column = table.getColumn(columnName);
                        if (column != null) {
                            column.setType(rs.getString(""column_type""));
                            column.setShortType(getOptionalString(rs, ""short_column_type""));
                        }
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column type details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initTableIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setId(rs.getObject(""table_id""));
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initIndexIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectIndexIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableIndex index = table.getIndex(rs.getString(""index_name""));
                        if (index != null)
                            index.setId(rs.getObject(""index_id""));
                    }
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table comments.
     * If the SQL also returns view comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view comments.
     *
     * @throws SQLException
     */
    private void initViewComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null)
                        view.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table column comments.
     * If the SQL also returns view column comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableColumn column = table.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view column comments.
     *
     * @throws SQLException
     */
    private void initViewColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null) {
                        TableColumn column = view.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve view column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes stored procedures / functions.
     *
     * @throws SQLException
     */
    private void initRoutines() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectRoutinesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""routine_name"");
                    String routineType = rs.getString(""routine_type"");
                    String returnType = rs.getString(""dtd_identifier"");
                    String definitionLanguage = rs.getString(""routine_body"");
                    String definition = rs.getString(""routine_definition"");
                    String dataAccess = rs.getString(""sql_data_access"");
                    String securityType = rs.getString(""security_type"");
                    boolean deterministic = rs.getBoolean(""is_deterministic"");
                    String comment = getOptionalString(rs, ""routine_comment"");
                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);
                    routines.put(routineName, routine);
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
                rs = null;
                stmt = null;
            }
        }
        sql = config.getDbProperties().getProperty(""selectRoutineParametersSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""specific_name"");
                    Routine routine = routines.get(routineName);
                    if (routine != null) {
                        String paramName = rs.getString(""parameter_name"");
                        String type = rs.getString(""dtd_identifier"");
                        String mode = rs.getString(""parameter_mode"");
                        RoutineParameter param = new RoutineParameter(paramName, type, mode);
                        routine.addParameter(param);
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Dump a warning message out to a new line
     *
     * @param msg1
     * @param msg2
     */
    private void warning(String msg1, String msg2) {
        System.out.println();
        System.out.flush();
        logger.warning(msg1);
        if (msg2 != null)
            logger.warning(msg2);
    }

    /**
     * Create a <code>PreparedStatement</code> from the specified SQL.
     * The SQL can contain these named parameters (but <b>not</b> question marks).
     * <ol>
     * <li>:schema - replaced with the name of the schema
     * <li>:owner - alias for :schema
     * <li>:table - replaced with the name of the table
     * </ol>
     * @param sql String - SQL without question marks
     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.
     * @throws SQLException
     * @return PreparedStatement
     */
    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {
        StringBuilder sqlBuf = new StringBuilder(sql);
        // modifies sqlBuf
        List<String> sqlParams = getSqlParams(sqlBuf, tableName);
        if (fineEnabled)
            logger.fine(sqlBuf + "" "" + sqlParams);
        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());
        try {
            for (int i = 0; i < sqlParams.size(); ++i) {
                stmt.setString(i + 1, sqlParams.get(i).toString());
            }
        } catch (SQLException exc) {
            stmt.close();
            throw exc;
        }
        return stmt;
    }

    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {
        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);
        Table remoteTable = remoteTables.get(fullName);
        if (remoteTable == null) {
            if (fineEnabled)
                logger.fine(""Creating remote table "" + fullName);
            if (logical)
                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            else
                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            if (fineEnabled)
                logger.fine(""Adding remote table "" + fullName);
            remoteTables.put(fullName, remoteTable);
            remoteTable.connectForeignKeys(locals);
        }
        return remoteTable;
    }

    /**
     * Return an uppercased <code>Set</code> of all SQL keywords used by a database
     *
     * @return
     * @throws SQLException
     */
    public Set<String> getSqlKeywords() throws SQLException {
        if (sqlKeywords == null) {
            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:
            String[] sql92Keywords = (""ADA"" + ""| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME"" + ""| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG"" + ""| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED"" + ""| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME"" + ""| CONSTRAINT_SCHEMA | CURSOR_NAME"" + ""| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION"" + ""| FORTRAN"" + ""| LENGTH"" + ""| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS"" + ""| NAME | NULLABLE | NUMBER"" + ""| PASCAL | PLI"" + ""| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE"" + ""| ROW_COUNT"" + ""| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN"" + ""| TABLE_NAME | TYPE"" + ""| UNCOMMITTED | UNNAMED"" + ""| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND"" + ""| ANY | ARE | AS | ASC"" + ""| ASSERTION | AT | AUTHORIZATION | AVG"" + ""| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY"" + ""| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH"" + ""| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION"" + ""| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT"" + ""| CONSTRAINTS | CONTINUE"" + ""| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT"" + ""| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR"" + ""| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE"" + ""| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS"" + ""| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP"" + ""| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION"" + ""| EXEC | EXECUTE | EXISTS"" + ""| EXTERNAL | EXTRACT"" + ""| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL"" + ""| GET | GLOBAL | GO | GOTO | GRANT | GROUP"" + ""| HAVING | HOUR"" + ""| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT"" + ""| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS"" + ""| ISOLATION"" + ""| JOIN"" + ""| KEY"" + ""| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER"" + ""| MATCH | MAX | MIN | MINUTE | MODULE | MONTH"" + ""| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL"" + ""| NULLIF | NUMERIC"" + ""| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR"" + ""| ORDER | OUTER"" + ""| OUTPUT | OVERLAPS"" + ""| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY"" + ""| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC"" + ""| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT"" + ""| ROLLBACK | ROWS"" + ""| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET"" + ""| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE"" + ""| SUBSTRING | SUM | SYSTEM_USER"" + ""| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE"" + ""| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE"" + ""| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING"" + ""| VALUE | VALUES | VARCHAR | VARYING | VIEW"" + ""| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE"" + ""| YEAR"" + ""| ZONE"").split(""[| ]+"");
            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split("",\\s*"");
            sqlKeywords = new HashSet<String>() {

                private static final long serialVersionUID = 1L;

                @Override
                public boolean contains(Object key) {
                    return super.contains(((String) key).toUpperCase());
                }
            };
            sqlKeywords.addAll(Arrays.asList(sql92Keywords));
            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));
        }
        return sqlKeywords;
    }

    /**
     * Return <code>id</code> quoted if required, otherwise return <code>id</code>
     *
     * @param id
     * @return
     * @throws SQLException
     */
    public String getQuotedIdentifier(String id) throws SQLException {
        // look for any character that isn't valid (then matcher.find() returns true)
        Matcher matcher = getInvalidIdentifierPattern().matcher(id);
        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);
        if (quotesRequired) {
            // name contains something that must be quoted
            String quote = getMetaData().getIdentifierQuoteString().trim();
            return quote + id + quote;
        }
        // no quoting necessary
        return id;
    }

    /**
     * Return a <code>Pattern</code> whose matcher will return <code>true</code>
     * when run against an identifier that contains a character that is not
     * acceptable by the database without being quoted.
     */
    private Pattern getInvalidIdentifierPattern() throws SQLException {
        if (invalidIdentifierPattern == null) {
            String validChars = ""a-zA-Z0-9_"";
            String reservedRegexChars = ""-&^"";
            String extraValidChars = getMetaData().getExtraNameCharacters();
            for (int i = 0; i < extraValidChars.length(); ++i) {
                char ch = extraValidChars.charAt(i);
                if (reservedRegexChars.indexOf(ch) >= 0)
                    validChars += ""\\"";
                validChars += ch;
            }
            invalidIdentifierPattern = Pattern.compile(""[^"" + validChars + ""]"");
        }
        return invalidIdentifierPattern;
    }

    /**
     * Replaces named parameters in <code>sql</code> with question marks and
     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.
     *
     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.
     * @param tableName String
     * @return List of Strings
     *
     * @see #prepareStatement(String, String)
     */
    private List<String> getSqlParams(StringBuilder sql, String tableName) {
        Map<String, String> namedParams = new HashMap<String, String>();
        @SuppressWarnings(""hiding"")
        String schema = getSchema();
        if (schema == null)
            // some 'schema-less' db's treat the db name like a schema (unusual case)
            schema = getName();
        namedParams.put("":schema"", schema);
        // alias for :schema
        namedParams.put("":owner"", schema);
        if (tableName != null) {
            namedParams.put("":table"", tableName);
            // alias for :table
            namedParams.put("":view"", tableName);
        }
        List<String> sqlParams = new ArrayList<String>();
        int nextColon = sql.indexOf("":"");
        while (nextColon != -1) {
            String paramName = new StringTokenizer(sql.substring(nextColon), "" ,\""')"").nextToken();
            String paramValue = namedParams.get(paramName);
            if (paramValue == null)
                throw new InvalidConfigurationException(""Unexpected named parameter '"" + paramName + ""' found in SQL '"" + sql + ""'"");
            sqlParams.add(paramValue);
            // replace with a ?
            sql.replace(nextColon, nextColon + paramName.length(), ""?"");
            nextColon = sql.indexOf("":"", nextColon);
        }
        return sqlParams;
    }

    /**
     * Take the supplied XML-based metadata and update our model of the schema with it
     *
     * @param schemaMeta
     * @throws SQLException
     */
    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {
        if (schemaMeta != null) {
            config.setDescription(schemaMeta.getComments());
            // done in three passes:
            // 1: create any new tables
            // 2: add/mod columns
            // 3: connect
            // add the newly defined tables and columns first
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {
                    // will add it if it doesn't already exist
                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);
                } else {
                    table = locals.get(tableMeta.getName());
                    if (table == null) {
                        // new table defined only in XML metadata
                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());
                        tables.put(table.getName(), table);
                    }
                }
                table.update(tableMeta);
            }
            // then tie the tables together
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {
                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));
                } else {
                    table = locals.get(tableMeta.getName());
                }
                table.connect(tableMeta, locals);
            }
        }
    }

    private void connectTables() throws SQLException {
        for (Table table : tables.values()) {
            table.connectForeignKeys(locals);
        }
        for (Table view : views.values()) {
            view.connectForeignKeys(locals);
        }
    }

    /**
     * Returns a 'key' that's used to identify a remote table
     * in the remoteTables map.
     *
     * @param cat
     * @param sch
     * @param table
     * @return
     */
    public String getRemoteTableKey(String cat, String sch, String table) {
        return Table.getFullName(getName(), cat, sch, table);
    }

    /**
     * Single-threaded implementation of a class that creates tables
     */
    private class TableCreator {

        /**
         * Create a table and put it into <code>tables</code>
         */
        void create(BasicTableMeta tableMeta) throws SQLException {
            createImpl(tableMeta);
        }

        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {
            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);
            if (tableMeta.numRows != -1) {
                table.setNumRows(tableMeta.numRows);
            }
            synchronized (tables) {
                tables.put(table.getName(), table);
            }
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""Retrieved details of "" + table.getFullName());
            } else {
                System.out.print('.');
            }
        }

        /**
         * Wait for all of the tables to be created.
         * By default this does nothing since this implementation isn't threaded.
         */
        void join() {
        }
    }

    /**
     * Multi-threaded implementation of a class that creates tables
     */
    private class ThreadedTableCreator extends TableCreator {

        private final Set<Thread> threads = new HashSet<Thread>();

        private final int maxThreads;

        ThreadedTableCreator(int maxThreads) {
            this.maxThreads = maxThreads;
        }

        @Override
        void create(final BasicTableMeta tableMeta) throws SQLException {
            Thread runner = new Thread() {

                @Override
                public void run() {
                    try {
                        createImpl(tableMeta);
                    } catch (SQLException exc) {
                        // nobody above us in call stack...dump it here
                        exc.printStackTrace();
                    } finally {
                        synchronized (threads) {
                            threads.remove(this);
                            threads.notify();
                        }
                    }
                }
            };
            synchronized (threads) {
                // wait for enough 'room'
                while (threads.size() >= maxThreads) {
                    try {
                        threads.wait();
                    } catch (InterruptedException interrupted) {
                    }
                }
                threads.add(runner);
            }
            runner.start();
        }

        /**
         * Wait for all of the started threads to complete
         */
        @Override
        public void join() {
            while (true) {
                Thread thread;
                synchronized (threads) {
                    Iterator<Thread> iter = threads.iterator();
                    if (!iter.hasNext())
                        break;
                    thread = iter.next();
                }
                try {
                    thread.join();
                } catch (InterruptedException exc) {
                }
            }
        }
    }

    /**
     * A read-only map that treats both collections of Tables and Views as one
     * combined collection.
     * This is a bit strange, but it simplifies logic that otherwise treats
     * the two as if they were one collection.
     */
    private class CombinedMap implements Map<String, Table> {

        private final Map<String, ? extends Table> map1;

        private final Map<String, ? extends Table> map2;

        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {
            this.map1 = map1;
            this.map2 = map2;
        }

        public Table get(Object name) {
            Table table = map1.get(name);
            if (table == null)
                table = map2.get(name);
            return table;
        }

        public int size() {
            return map1.size() + map2.size();
        }

        public boolean isEmpty() {
            return map1.isEmpty() && map2.isEmpty();
        }

        public boolean containsKey(Object key) {
            return map1.containsKey(key) || map2.containsKey(key);
        }

        public boolean containsValue(Object value) {
            return map1.containsValue(value) || map2.containsValue(value);
        }

        public Table put(String name, Table table) {
            throw new UnsupportedOperationException();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<String> keySet() {
            return getCombined().keySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<Map.Entry<String, Table>> entrySet() {
            return getCombined().entrySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Collection<Table> values() {
            return getCombined().values();
        }

        private Map<String, Table> getCombined() {
            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());
            all.putAll(map1);
            all.putAll(map2);
            return all;
        }

        public Table remove(Object key) {
            throw new UnsupportedOperationException();
        }

        public void putAll(Map<? extends String, ? extends Table> table) {
            throw new UnsupportedOperationException();
        }

        public void clear() {
            throw new UnsupportedOperationException();
        }
    }
}
","// Database_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#prepareStatement(String, String)} method.
*/
class Database_1Test {","// Database_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#prepareStatement(String, String)} method.
*/
class Database_1Test {
"
a4b608b0-35fc-4b97-a11a-8477aa54f435,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Database_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16475 tokens (12475 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Database.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

public class Database {

    private final Config config;

    private final String databaseName;

    private final String catalog;

    private final String schema;

    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();

    private final Map<String, View> views = new CaseInsensitiveMap<View>();

    // key: schema.tableName
    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();

    private final Map<String, Table> locals = new CombinedMap(tables, views);

    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();

    private final DatabaseMetaData meta;

    private final Connection connection;

    private final String connectTime = new SimpleDateFormat(""EEE MMM dd HH:mm z yyyy"").format(new Date());

    private Set<String> sqlKeywords;

    private Pattern invalidIdentifierPattern;

    private final Logger logger = Logger.getLogger(getClass().getName());

    private final boolean fineEnabled = logger.isLoggable(Level.FINE);

    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {
        this.config = config;
        this.connection = connection;
        this.meta = meta;
        this.databaseName = name;
        this.catalog = catalog;
        this.schema = schema;
        initTables(meta);
        if (config.isViewsEnabled())
            initViews(meta);
        initCheckConstraints();
        initTableIds();
        initIndexIds();
        initTableComments();
        initTableColumnComments();
        initViewComments();
        initViewColumnComments();
        initColumnTypes();
        initRoutines();
        connectTables();
        updateFromXmlMetadata(schemaMeta);
    }

    public String getName() {
        return databaseName;
    }

    public String getCatalog() {
        return catalog;
    }

    public String getSchema() {
        return schema;
    }

    /**
     * Details of the database type that's running under the covers.
     *
     * @return null if a description wasn't specified.
     */
    public String getDescription() {
        return config.getDescription();
    }

    public Collection<Table> getTables() {
        return tables.values();
    }

    /**
     * Return a {@link Map} of all {@link Table}s keyed by their name.
     *
     * @return
     */
    public Map<String, Table> getTablesByName() {
        return tables;
    }

    public Collection<View> getViews() {
        return views.values();
    }

    public Collection<Table> getRemoteTables() {
        return remoteTables.values();
    }

    public Collection<Routine> getRoutines() {
        return routines.values();
    }

    public Connection getConnection() {
        return connection;
    }

    public DatabaseMetaData getMetaData() {
        return meta;
    }

    public String getConnectTime() {
        return connectTime;
    }

    public String getDatabaseProduct() {
        try {
            return meta.getDatabaseProductName() + "" - "" + meta.getDatabaseProductVersion();
        } catch (SQLException exc) {
            return """";
        }
    }

    /**
     *  ""macro"" to validate that a table is somewhat valid
     */
    class NameValidator {

        private final String clazz;

        private final Pattern include;

        private final Pattern exclude;

        private final Set<String> validTypes;

        /**
         * @param clazz table or view
         * @param include
         * @param exclude
         * @param verbose
         * @param validTypes
         */
        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {
            this.clazz = clazz;
            this.include = include;
            this.exclude = exclude;
            this.validTypes = new HashSet<String>();
            for (String type : validTypes) {
                this.validTypes.add(type.toUpperCase());
            }
        }

        /**
         * Returns <code>true</code> if the table/view name is deemed ""valid""
         *
         * @param name name of the table or view
         * @param type type as returned by metadata.getTables():TABLE_TYPE
         * @return
         */
        boolean isValid(String name, String type) {
            // some databases (MySQL) return more than we wanted
            if (!validTypes.contains(type.toUpperCase()))
                return false;
            // Oracle 10g introduced problematic flashback tables
            // with bizarre illegal names
            if (name.indexOf(""$"") != -1) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": embedded $ implies illegal name"");
                }
                return false;
            }
            if (exclude.matcher(name).matches()) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": matches exclusion pattern \"""" + exclude + '""');
                }
                return false;
            }
            boolean valid = include.matcher(name).matches();
            if (fineEnabled) {
                if (valid) {
                    logger.fine(""Including "" + clazz + "" "" + name + "": matches inclusion pattern \"""" + include + '""');
                } else {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": doesn't match inclusion pattern \"""" + include + '""');
                }
            }
            return valid;
        }
    }

    /**
     * Create/initialize any tables in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initTables(final DatabaseMetaData metadata) throws SQLException {
        final Pattern include = config.getTableInclusions();
        final Pattern exclude = config.getTableExclusions();
        final int maxThreads = config.getMaxDbThreads();
        String[] types = getTypes(""tableTypes"", ""TABLE"");
        NameValidator validator = new NameValidator(""table"", include, exclude, types);
        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);
        TableCreator creator;
        if (maxThreads == 1) {
            creator = new TableCreator();
        } else {
            // creating tables takes a LONG time (based on JProbe analysis),
            // so attempt to speed it up by doing several in parallel.
            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive
            creator = new ThreadedTableCreator(maxThreads);
            // ""prime the pump"" so if there's a database problem we'll probably see it now
            // and not in a secondary thread
            while (!entries.isEmpty()) {
                BasicTableMeta entry = entries.remove(0);
                if (validator.isValid(entry.name, entry.type)) {
                    new TableCreator().create(entry);
                    break;
                }
            }
        }
        // kick off the secondary threads to do the creation in parallel
        for (BasicTableMeta entry : entries) {
            if (validator.isValid(entry.name, entry.type)) {
                creator.create(entry);
            }
        }
        // wait for everyone to finish
        creator.join();
    }

    /**
     * Create/initialize any views in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initViews(DatabaseMetaData metadata) throws SQLException {
        Pattern includeTables = config.getTableInclusions();
        Pattern excludeTables = config.getTableExclusions();
        String[] types = getTypes(""viewTypes"", ""VIEW"");
        NameValidator validator = new NameValidator(""view"", includeTables, excludeTables, types);
        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {
            if (validator.isValid(entry.name, entry.type)) {
                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);
                views.put(view.getName(), view);
                if (fineEnabled) {
                    logger.fine(""Found details of view "" + view.getName());
                } else {
                    System.out.print('.');
                }
            }
        }
    }

    /**
     * Collection of fundamental table/view metadata
     */
    private class BasicTableMeta {

        @SuppressWarnings(""hiding"")
        final String catalog;

        @SuppressWarnings(""hiding"")
        final String schema;

        final String name;

        final String type;

        final String remarks;

        final String viewSql;

        // -1 if not determined
        final int numRows;

        /**
         * @param schema
         * @param name
         * @param type typically ""TABLE"" or ""VIEW""
         * @param remarks
         * @param text optional textual SQL used to create the view
         * @param numRows number of rows, or -1 if not determined
         */
        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {
            this.catalog = catalog;
            this.schema = schema;
            this.name = name;
            this.type = type;
            this.remarks = remarks;
            viewSql = text;
            this.numRows = numRows;
        }
    }

    /**
     * Return a list of basic details of the tables in the schema.
     *
     * @param metadata
     * @param forTables true if we're getting table data, false if getting view data
     * @return
     * @throws SQLException
     */
    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {
        String queryName = forTables ? ""selectTablesSql"" : ""selectViewsSql"";
        String sql = Config.getInstance().getDbProperties().getProperty(queryName);
        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();
        ResultSet rs = null;
        if (sql != null) {
            String clazz = forTables ? ""table"" : ""view"";
            PreparedStatement stmt = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String name = rs.getString(clazz + ""_name"");
                    String cat = getOptionalString(rs, clazz + ""_catalog"");
                    String sch = getOptionalString(rs, clazz + ""_schema"");
                    if (cat == null && sch == null)
                        sch = schema;
                    String remarks = getOptionalString(rs, clazz + ""_comment"");
                    String text = forTables ? null : getOptionalString(rs, ""view_definition"");
                    String rows = forTables ? getOptionalString(rs, ""table_rows"") : null;
                    int numRows = rows == null ? -1 : Integer.parseInt(rows);
                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve "" + clazz + "" names with custom SQL: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
        if (basics.isEmpty()) {
            rs = metadata.getTables(null, schema, ""%"", types);
            try {
                while (rs.next()) {
                    String name = rs.getString(""TABLE_NAME"");
                    String type = rs.getString(""TABLE_TYPE"");
                    String cat = rs.getString(""TABLE_CAT"");
                    String schem = rs.getString(""TABLE_SCHEM"");
                    String remarks = getOptionalString(rs, ""REMARKS"");
                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));
                }
            } catch (SQLException exc) {
                if (forTables)
                    throw exc;
                System.out.flush();
                System.err.println();
                System.err.println(""Ignoring view "" + rs.getString(""TABLE_NAME"") + "" due to exception:"");
                exc.printStackTrace();
                System.err.println(""Continuing analysis."");
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        return basics;
    }

    /**
     * Return a database-specific array of types from the .properties file
     * with the specified property name.
     *
     * @param propName
     * @param defaultValue
     * @return
     */
    private String[] getTypes(String propName, String defaultValue) {
        String value = config.getDbProperties().getProperty(propName, defaultValue);
        List<String> types = new ArrayList<String>();
        for (String type : value.split("","")) {
            type = type.trim();
            if (type.length() > 0)
                types.add(type);
        }
        return types.toArray(new String[types.size()]);
    }

    /**
     * Some databases don't play nice with their metadata.
     * E.g. Oracle doesn't have a REMARKS column at all.
     * This method ignores those types of failures, replacing them with null.
     */
    public String getOptionalString(ResultSet rs, String columnName) {
        try {
            return rs.getString(columnName);
        } catch (SQLException ignore) {
            return null;
        }
    }

    private void initCheckConstraints() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectCheckConstraintsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.addCheckConstraint(rs.getString(""constraint_name""), rs.getString(""text""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve check constraints: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initColumnTypes() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnTypesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        String columnName = rs.getString(""column_name"");
                        TableColumn column = table.getColumn(columnName);
                        if (column != null) {
                            column.setType(rs.getString(""column_type""));
                            column.setShortType(getOptionalString(rs, ""short_column_type""));
                        }
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column type details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initTableIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setId(rs.getObject(""table_id""));
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initIndexIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectIndexIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableIndex index = table.getIndex(rs.getString(""index_name""));
                        if (index != null)
                            index.setId(rs.getObject(""index_id""));
                    }
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table comments.
     * If the SQL also returns view comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view comments.
     *
     * @throws SQLException
     */
    private void initViewComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null)
                        view.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table column comments.
     * If the SQL also returns view column comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableColumn column = table.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view column comments.
     *
     * @throws SQLException
     */
    private void initViewColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null) {
                        TableColumn column = view.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve view column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes stored procedures / functions.
     *
     * @throws SQLException
     */
    private void initRoutines() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectRoutinesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""routine_name"");
                    String routineType = rs.getString(""routine_type"");
                    String returnType = rs.getString(""dtd_identifier"");
                    String definitionLanguage = rs.getString(""routine_body"");
                    String definition = rs.getString(""routine_definition"");
                    String dataAccess = rs.getString(""sql_data_access"");
                    String securityType = rs.getString(""security_type"");
                    boolean deterministic = rs.getBoolean(""is_deterministic"");
                    String comment = getOptionalString(rs, ""routine_comment"");
                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);
                    routines.put(routineName, routine);
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
                rs = null;
                stmt = null;
            }
        }
        sql = config.getDbProperties().getProperty(""selectRoutineParametersSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""specific_name"");
                    Routine routine = routines.get(routineName);
                    if (routine != null) {
                        String paramName = rs.getString(""parameter_name"");
                        String type = rs.getString(""dtd_identifier"");
                        String mode = rs.getString(""parameter_mode"");
                        RoutineParameter param = new RoutineParameter(paramName, type, mode);
                        routine.addParameter(param);
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Dump a warning message out to a new line
     *
     * @param msg1
     * @param msg2
     */
    private void warning(String msg1, String msg2) {
        System.out.println();
        System.out.flush();
        logger.warning(msg1);
        if (msg2 != null)
            logger.warning(msg2);
    }

    /**
     * Create a <code>PreparedStatement</code> from the specified SQL.
     * The SQL can contain these named parameters (but <b>not</b> question marks).
     * <ol>
     * <li>:schema - replaced with the name of the schema
     * <li>:owner - alias for :schema
     * <li>:table - replaced with the name of the table
     * </ol>
     * @param sql String - SQL without question marks
     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.
     * @throws SQLException
     * @return PreparedStatement
     */
    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {
        StringBuilder sqlBuf = new StringBuilder(sql);
        // modifies sqlBuf
        List<String> sqlParams = getSqlParams(sqlBuf, tableName);
        if (fineEnabled)
            logger.fine(sqlBuf + "" "" + sqlParams);
        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());
        try {
            for (int i = 0; i < sqlParams.size(); ++i) {
                stmt.setString(i + 1, sqlParams.get(i).toString());
            }
        } catch (SQLException exc) {
            stmt.close();
            throw exc;
        }
        return stmt;
    }

    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {
        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);
        Table remoteTable = remoteTables.get(fullName);
        if (remoteTable == null) {
            if (fineEnabled)
                logger.fine(""Creating remote table "" + fullName);
            if (logical)
                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            else
                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            if (fineEnabled)
                logger.fine(""Adding remote table "" + fullName);
            remoteTables.put(fullName, remoteTable);
            remoteTable.connectForeignKeys(locals);
        }
        return remoteTable;
    }

    /**
     * Return an uppercased <code>Set</code> of all SQL keywords used by a database
     *
     * @return
     * @throws SQLException
     */
    public Set<String> getSqlKeywords() throws SQLException {
        if (sqlKeywords == null) {
            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:
            String[] sql92Keywords = (""ADA"" + ""| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME"" + ""| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG"" + ""| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED"" + ""| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME"" + ""| CONSTRAINT_SCHEMA | CURSOR_NAME"" + ""| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION"" + ""| FORTRAN"" + ""| LENGTH"" + ""| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS"" + ""| NAME | NULLABLE | NUMBER"" + ""| PASCAL | PLI"" + ""| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE"" + ""| ROW_COUNT"" + ""| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN"" + ""| TABLE_NAME | TYPE"" + ""| UNCOMMITTED | UNNAMED"" + ""| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND"" + ""| ANY | ARE | AS | ASC"" + ""| ASSERTION | AT | AUTHORIZATION | AVG"" + ""| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY"" + ""| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH"" + ""| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION"" + ""| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT"" + ""| CONSTRAINTS | CONTINUE"" + ""| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT"" + ""| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR"" + ""| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE"" + ""| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS"" + ""| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP"" + ""| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION"" + ""| EXEC | EXECUTE | EXISTS"" + ""| EXTERNAL | EXTRACT"" + ""| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL"" + ""| GET | GLOBAL | GO | GOTO | GRANT | GROUP"" + ""| HAVING | HOUR"" + ""| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT"" + ""| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS"" + ""| ISOLATION"" + ""| JOIN"" + ""| KEY"" + ""| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER"" + ""| MATCH | MAX | MIN | MINUTE | MODULE | MONTH"" + ""| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL"" + ""| NULLIF | NUMERIC"" + ""| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR"" + ""| ORDER | OUTER"" + ""| OUTPUT | OVERLAPS"" + ""| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY"" + ""| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC"" + ""| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT"" + ""| ROLLBACK | ROWS"" + ""| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET"" + ""| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE"" + ""| SUBSTRING | SUM | SYSTEM_USER"" + ""| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE"" + ""| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE"" + ""| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING"" + ""| VALUE | VALUES | VARCHAR | VARYING | VIEW"" + ""| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE"" + ""| YEAR"" + ""| ZONE"").split(""[| ]+"");
            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split("",\\s*"");
            sqlKeywords = new HashSet<String>() {

                private static final long serialVersionUID = 1L;

                @Override
                public boolean contains(Object key) {
                    return super.contains(((String) key).toUpperCase());
                }
            };
            sqlKeywords.addAll(Arrays.asList(sql92Keywords));
            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));
        }
        return sqlKeywords;
    }

    /**
     * Return <code>id</code> quoted if required, otherwise return <code>id</code>
     *
     * @param id
     * @return
     * @throws SQLException
     */
    public String getQuotedIdentifier(String id) throws SQLException {
        // look for any character that isn't valid (then matcher.find() returns true)
        Matcher matcher = getInvalidIdentifierPattern().matcher(id);
        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);
        if (quotesRequired) {
            // name contains something that must be quoted
            String quote = getMetaData().getIdentifierQuoteString().trim();
            return quote + id + quote;
        }
        // no quoting necessary
        return id;
    }

    /**
     * Return a <code>Pattern</code> whose matcher will return <code>true</code>
     * when run against an identifier that contains a character that is not
     * acceptable by the database without being quoted.
     */
    private Pattern getInvalidIdentifierPattern() throws SQLException {
        if (invalidIdentifierPattern == null) {
            String validChars = ""a-zA-Z0-9_"";
            String reservedRegexChars = ""-&^"";
            String extraValidChars = getMetaData().getExtraNameCharacters();
            for (int i = 0; i < extraValidChars.length(); ++i) {
                char ch = extraValidChars.charAt(i);
                if (reservedRegexChars.indexOf(ch) >= 0)
                    validChars += ""\\"";
                validChars += ch;
            }
            invalidIdentifierPattern = Pattern.compile(""[^"" + validChars + ""]"");
        }
        return invalidIdentifierPattern;
    }

    /**
     * Replaces named parameters in <code>sql</code> with question marks and
     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.
     *
     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.
     * @param tableName String
     * @return List of Strings
     *
     * @see #prepareStatement(String, String)
     */
    private List<String> getSqlParams(StringBuilder sql, String tableName) {
        Map<String, String> namedParams = new HashMap<String, String>();
        @SuppressWarnings(""hiding"")
        String schema = getSchema();
        if (schema == null)
            // some 'schema-less' db's treat the db name like a schema (unusual case)
            schema = getName();
        namedParams.put("":schema"", schema);
        // alias for :schema
        namedParams.put("":owner"", schema);
        if (tableName != null) {
            namedParams.put("":table"", tableName);
            // alias for :table
            namedParams.put("":view"", tableName);
        }
        List<String> sqlParams = new ArrayList<String>();
        int nextColon = sql.indexOf("":"");
        while (nextColon != -1) {
            String paramName = new StringTokenizer(sql.substring(nextColon), "" ,\""')"").nextToken();
            String paramValue = namedParams.get(paramName);
            if (paramValue == null)
                throw new InvalidConfigurationException(""Unexpected named parameter '"" + paramName + ""' found in SQL '"" + sql + ""'"");
            sqlParams.add(paramValue);
            // replace with a ?
            sql.replace(nextColon, nextColon + paramName.length(), ""?"");
            nextColon = sql.indexOf("":"", nextColon);
        }
        return sqlParams;
    }

    /**
     * Take the supplied XML-based metadata and update our model of the schema with it
     *
     * @param schemaMeta
     * @throws SQLException
     */
    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {
        if (schemaMeta != null) {
            config.setDescription(schemaMeta.getComments());
            // done in three passes:
            // 1: create any new tables
            // 2: add/mod columns
            // 3: connect
            // add the newly defined tables and columns first
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {
                    // will add it if it doesn't already exist
                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);
                } else {
                    table = locals.get(tableMeta.getName());
                    if (table == null) {
                        // new table defined only in XML metadata
                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());
                        tables.put(table.getName(), table);
                    }
                }
                table.update(tableMeta);
            }
            // then tie the tables together
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {
                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));
                } else {
                    table = locals.get(tableMeta.getName());
                }
                table.connect(tableMeta, locals);
            }
        }
    }

    private void connectTables() throws SQLException {
        for (Table table : tables.values()) {
            table.connectForeignKeys(locals);
        }
        for (Table view : views.values()) {
            view.connectForeignKeys(locals);
        }
    }

    /**
     * Returns a 'key' that's used to identify a remote table
     * in the remoteTables map.
     *
     * @param cat
     * @param sch
     * @param table
     * @return
     */
    public String getRemoteTableKey(String cat, String sch, String table) {
        return Table.getFullName(getName(), cat, sch, table);
    }

    /**
     * Single-threaded implementation of a class that creates tables
     */
    private class TableCreator {

        /**
         * Create a table and put it into <code>tables</code>
         */
        void create(BasicTableMeta tableMeta) throws SQLException {
            createImpl(tableMeta);
        }

        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {
            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);
            if (tableMeta.numRows != -1) {
                table.setNumRows(tableMeta.numRows);
            }
            synchronized (tables) {
                tables.put(table.getName(), table);
            }
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""Retrieved details of "" + table.getFullName());
            } else {
                System.out.print('.');
            }
        }

        /**
         * Wait for all of the tables to be created.
         * By default this does nothing since this implementation isn't threaded.
         */
        void join() {
        }
    }

    /**
     * Multi-threaded implementation of a class that creates tables
     */
    private class ThreadedTableCreator extends TableCreator {

        private final Set<Thread> threads = new HashSet<Thread>();

        private final int maxThreads;

        ThreadedTableCreator(int maxThreads) {
            this.maxThreads = maxThreads;
        }

        @Override
        void create(final BasicTableMeta tableMeta) throws SQLException {
            Thread runner = new Thread() {

                @Override
                public void run() {
                    try {
                        createImpl(tableMeta);
                    } catch (SQLException exc) {
                        // nobody above us in call stack...dump it here
                        exc.printStackTrace();
                    } finally {
                        synchronized (threads) {
                            threads.remove(this);
                            threads.notify();
                        }
                    }
                }
            };
            synchronized (threads) {
                // wait for enough 'room'
                while (threads.size() >= maxThreads) {
                    try {
                        threads.wait();
                    } catch (InterruptedException interrupted) {
                    }
                }
                threads.add(runner);
            }
            runner.start();
        }

        /**
         * Wait for all of the started threads to complete
         */
        @Override
        public void join() {
            while (true) {
                Thread thread;
                synchronized (threads) {
                    Iterator<Thread> iter = threads.iterator();
                    if (!iter.hasNext())
                        break;
                    thread = iter.next();
                }
                try {
                    thread.join();
                } catch (InterruptedException exc) {
                }
            }
        }
    }

    /**
     * A read-only map that treats both collections of Tables and Views as one
     * combined collection.
     * This is a bit strange, but it simplifies logic that otherwise treats
     * the two as if they were one collection.
     */
    private class CombinedMap implements Map<String, Table> {

        private final Map<String, ? extends Table> map1;

        private final Map<String, ? extends Table> map2;

        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {
            this.map1 = map1;
            this.map2 = map2;
        }

        public Table get(Object name) {
            Table table = map1.get(name);
            if (table == null)
                table = map2.get(name);
            return table;
        }

        public int size() {
            return map1.size() + map2.size();
        }

        public boolean isEmpty() {
            return map1.isEmpty() && map2.isEmpty();
        }

        public boolean containsKey(Object key) {
            return map1.containsKey(key) || map2.containsKey(key);
        }

        public boolean containsValue(Object value) {
            return map1.containsValue(value) || map2.containsValue(value);
        }

        public Table put(String name, Table table) {
            throw new UnsupportedOperationException();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<String> keySet() {
            return getCombined().keySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<Map.Entry<String, Table>> entrySet() {
            return getCombined().entrySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Collection<Table> values() {
            return getCombined().values();
        }

        private Map<String, Table> getCombined() {
            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());
            all.putAll(map1);
            all.putAll(map2);
            return all;
        }

        public Table remove(Object key) {
            throw new UnsupportedOperationException();
        }

        public void putAll(Map<? extends String, ? extends Table> table) {
            throw new UnsupportedOperationException();
        }

        public void clear() {
            throw new UnsupportedOperationException();
        }
    }
}
","// Database_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getQuotedIdentifier(String)} method.
*/
class Database_3Test {","// Database_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getQuotedIdentifier(String)} method.
*/
class Database_3Test {
"
1eb1ce65-532e-4af7-a9c6-fc56fd2c0d5f,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Database_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16478 tokens (12478 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Database.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

public class Database {

    private final Config config;

    private final String databaseName;

    private final String catalog;

    private final String schema;

    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();

    private final Map<String, View> views = new CaseInsensitiveMap<View>();

    // key: schema.tableName
    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();

    private final Map<String, Table> locals = new CombinedMap(tables, views);

    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();

    private final DatabaseMetaData meta;

    private final Connection connection;

    private final String connectTime = new SimpleDateFormat(""EEE MMM dd HH:mm z yyyy"").format(new Date());

    private Set<String> sqlKeywords;

    private Pattern invalidIdentifierPattern;

    private final Logger logger = Logger.getLogger(getClass().getName());

    private final boolean fineEnabled = logger.isLoggable(Level.FINE);

    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {
        this.config = config;
        this.connection = connection;
        this.meta = meta;
        this.databaseName = name;
        this.catalog = catalog;
        this.schema = schema;
        initTables(meta);
        if (config.isViewsEnabled())
            initViews(meta);
        initCheckConstraints();
        initTableIds();
        initIndexIds();
        initTableComments();
        initTableColumnComments();
        initViewComments();
        initViewColumnComments();
        initColumnTypes();
        initRoutines();
        connectTables();
        updateFromXmlMetadata(schemaMeta);
    }

    public String getName() {
        return databaseName;
    }

    public String getCatalog() {
        return catalog;
    }

    public String getSchema() {
        return schema;
    }

    /**
     * Details of the database type that's running under the covers.
     *
     * @return null if a description wasn't specified.
     */
    public String getDescription() {
        return config.getDescription();
    }

    public Collection<Table> getTables() {
        return tables.values();
    }

    /**
     * Return a {@link Map} of all {@link Table}s keyed by their name.
     *
     * @return
     */
    public Map<String, Table> getTablesByName() {
        return tables;
    }

    public Collection<View> getViews() {
        return views.values();
    }

    public Collection<Table> getRemoteTables() {
        return remoteTables.values();
    }

    public Collection<Routine> getRoutines() {
        return routines.values();
    }

    public Connection getConnection() {
        return connection;
    }

    public DatabaseMetaData getMetaData() {
        return meta;
    }

    public String getConnectTime() {
        return connectTime;
    }

    public String getDatabaseProduct() {
        try {
            return meta.getDatabaseProductName() + "" - "" + meta.getDatabaseProductVersion();
        } catch (SQLException exc) {
            return """";
        }
    }

    /**
     *  ""macro"" to validate that a table is somewhat valid
     */
    class NameValidator {

        private final String clazz;

        private final Pattern include;

        private final Pattern exclude;

        private final Set<String> validTypes;

        /**
         * @param clazz table or view
         * @param include
         * @param exclude
         * @param verbose
         * @param validTypes
         */
        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {
            this.clazz = clazz;
            this.include = include;
            this.exclude = exclude;
            this.validTypes = new HashSet<String>();
            for (String type : validTypes) {
                this.validTypes.add(type.toUpperCase());
            }
        }

        /**
         * Returns <code>true</code> if the table/view name is deemed ""valid""
         *
         * @param name name of the table or view
         * @param type type as returned by metadata.getTables():TABLE_TYPE
         * @return
         */
        boolean isValid(String name, String type) {
            // some databases (MySQL) return more than we wanted
            if (!validTypes.contains(type.toUpperCase()))
                return false;
            // Oracle 10g introduced problematic flashback tables
            // with bizarre illegal names
            if (name.indexOf(""$"") != -1) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": embedded $ implies illegal name"");
                }
                return false;
            }
            if (exclude.matcher(name).matches()) {
                if (fineEnabled) {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": matches exclusion pattern \"""" + exclude + '""');
                }
                return false;
            }
            boolean valid = include.matcher(name).matches();
            if (fineEnabled) {
                if (valid) {
                    logger.fine(""Including "" + clazz + "" "" + name + "": matches inclusion pattern \"""" + include + '""');
                } else {
                    logger.fine(""Excluding "" + clazz + "" "" + name + "": doesn't match inclusion pattern \"""" + include + '""');
                }
            }
            return valid;
        }
    }

    /**
     * Create/initialize any tables in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initTables(final DatabaseMetaData metadata) throws SQLException {
        final Pattern include = config.getTableInclusions();
        final Pattern exclude = config.getTableExclusions();
        final int maxThreads = config.getMaxDbThreads();
        String[] types = getTypes(""tableTypes"", ""TABLE"");
        NameValidator validator = new NameValidator(""table"", include, exclude, types);
        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);
        TableCreator creator;
        if (maxThreads == 1) {
            creator = new TableCreator();
        } else {
            // creating tables takes a LONG time (based on JProbe analysis),
            // so attempt to speed it up by doing several in parallel.
            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive
            creator = new ThreadedTableCreator(maxThreads);
            // ""prime the pump"" so if there's a database problem we'll probably see it now
            // and not in a secondary thread
            while (!entries.isEmpty()) {
                BasicTableMeta entry = entries.remove(0);
                if (validator.isValid(entry.name, entry.type)) {
                    new TableCreator().create(entry);
                    break;
                }
            }
        }
        // kick off the secondary threads to do the creation in parallel
        for (BasicTableMeta entry : entries) {
            if (validator.isValid(entry.name, entry.type)) {
                creator.create(entry);
            }
        }
        // wait for everyone to finish
        creator.join();
    }

    /**
     * Create/initialize any views in the schema.
     *
     * @param metadata
     * @throws SQLException
     */
    private void initViews(DatabaseMetaData metadata) throws SQLException {
        Pattern includeTables = config.getTableInclusions();
        Pattern excludeTables = config.getTableExclusions();
        String[] types = getTypes(""viewTypes"", ""VIEW"");
        NameValidator validator = new NameValidator(""view"", includeTables, excludeTables, types);
        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {
            if (validator.isValid(entry.name, entry.type)) {
                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);
                views.put(view.getName(), view);
                if (fineEnabled) {
                    logger.fine(""Found details of view "" + view.getName());
                } else {
                    System.out.print('.');
                }
            }
        }
    }

    /**
     * Collection of fundamental table/view metadata
     */
    private class BasicTableMeta {

        @SuppressWarnings(""hiding"")
        final String catalog;

        @SuppressWarnings(""hiding"")
        final String schema;

        final String name;

        final String type;

        final String remarks;

        final String viewSql;

        // -1 if not determined
        final int numRows;

        /**
         * @param schema
         * @param name
         * @param type typically ""TABLE"" or ""VIEW""
         * @param remarks
         * @param text optional textual SQL used to create the view
         * @param numRows number of rows, or -1 if not determined
         */
        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {
            this.catalog = catalog;
            this.schema = schema;
            this.name = name;
            this.type = type;
            this.remarks = remarks;
            viewSql = text;
            this.numRows = numRows;
        }
    }

    /**
     * Return a list of basic details of the tables in the schema.
     *
     * @param metadata
     * @param forTables true if we're getting table data, false if getting view data
     * @return
     * @throws SQLException
     */
    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {
        String queryName = forTables ? ""selectTablesSql"" : ""selectViewsSql"";
        String sql = Config.getInstance().getDbProperties().getProperty(queryName);
        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();
        ResultSet rs = null;
        if (sql != null) {
            String clazz = forTables ? ""table"" : ""view"";
            PreparedStatement stmt = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String name = rs.getString(clazz + ""_name"");
                    String cat = getOptionalString(rs, clazz + ""_catalog"");
                    String sch = getOptionalString(rs, clazz + ""_schema"");
                    if (cat == null && sch == null)
                        sch = schema;
                    String remarks = getOptionalString(rs, clazz + ""_comment"");
                    String text = forTables ? null : getOptionalString(rs, ""view_definition"");
                    String rows = forTables ? getOptionalString(rs, ""table_rows"") : null;
                    int numRows = rows == null ? -1 : Integer.parseInt(rows);
                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve "" + clazz + "" names with custom SQL: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
        if (basics.isEmpty()) {
            rs = metadata.getTables(null, schema, ""%"", types);
            try {
                while (rs.next()) {
                    String name = rs.getString(""TABLE_NAME"");
                    String type = rs.getString(""TABLE_TYPE"");
                    String cat = rs.getString(""TABLE_CAT"");
                    String schem = rs.getString(""TABLE_SCHEM"");
                    String remarks = getOptionalString(rs, ""REMARKS"");
                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));
                }
            } catch (SQLException exc) {
                if (forTables)
                    throw exc;
                System.out.flush();
                System.err.println();
                System.err.println(""Ignoring view "" + rs.getString(""TABLE_NAME"") + "" due to exception:"");
                exc.printStackTrace();
                System.err.println(""Continuing analysis."");
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        return basics;
    }

    /**
     * Return a database-specific array of types from the .properties file
     * with the specified property name.
     *
     * @param propName
     * @param defaultValue
     * @return
     */
    private String[] getTypes(String propName, String defaultValue) {
        String value = config.getDbProperties().getProperty(propName, defaultValue);
        List<String> types = new ArrayList<String>();
        for (String type : value.split("","")) {
            type = type.trim();
            if (type.length() > 0)
                types.add(type);
        }
        return types.toArray(new String[types.size()]);
    }

    /**
     * Some databases don't play nice with their metadata.
     * E.g. Oracle doesn't have a REMARKS column at all.
     * This method ignores those types of failures, replacing them with null.
     */
    public String getOptionalString(ResultSet rs, String columnName) {
        try {
            return rs.getString(columnName);
        } catch (SQLException ignore) {
            return null;
        }
    }

    private void initCheckConstraints() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectCheckConstraintsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.addCheckConstraint(rs.getString(""constraint_name""), rs.getString(""text""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve check constraints: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initColumnTypes() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnTypesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        String columnName = rs.getString(""column_name"");
                        TableColumn column = table.getColumn(columnName);
                        if (column != null) {
                            column.setType(rs.getString(""column_type""));
                            column.setShortType(getOptionalString(rs, ""short_column_type""));
                        }
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column type details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initTableIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setId(rs.getObject(""table_id""));
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    private void initIndexIds() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectIndexIdsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableIndex index = table.getIndex(rs.getString(""index_name""));
                        if (index != null)
                            index.setId(rs.getObject(""index_id""));
                    }
                }
            } catch (SQLException sqlException) {
                System.err.println();
                System.err.println(sql);
                throw sqlException;
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table comments.
     * If the SQL also returns view comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectTableCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null)
                        table.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view comments.
     *
     * @throws SQLException
     */
    private void initViewComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null)
                        view.setComments(rs.getString(""comments""));
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve table/view comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes table column comments.
     * If the SQL also returns view column comments then they're plugged into the
     * appropriate views.
     *
     * @throws SQLException
     */
    private void initTableColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String tableName = rs.getString(""table_name"");
                    Table table = locals.get(tableName);
                    if (table != null) {
                        TableColumn column = table.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes view column comments.
     *
     * @throws SQLException
     */
    private void initViewColumnComments() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectViewColumnCommentsSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String viewName = rs.getString(""view_name"");
                    if (viewName == null)
                        viewName = rs.getString(""table_name"");
                    Table view = views.get(viewName);
                    if (view != null) {
                        TableColumn column = view.getColumn(rs.getString(""column_name""));
                        if (column != null)
                            column.setComments(rs.getString(""comments""));
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve view column comments: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Initializes stored procedures / functions.
     *
     * @throws SQLException
     */
    private void initRoutines() throws SQLException {
        String sql = config.getDbProperties().getProperty(""selectRoutinesSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""routine_name"");
                    String routineType = rs.getString(""routine_type"");
                    String returnType = rs.getString(""dtd_identifier"");
                    String definitionLanguage = rs.getString(""routine_body"");
                    String definition = rs.getString(""routine_definition"");
                    String dataAccess = rs.getString(""sql_data_access"");
                    String securityType = rs.getString(""security_type"");
                    boolean deterministic = rs.getBoolean(""is_deterministic"");
                    String comment = getOptionalString(rs, ""routine_comment"");
                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);
                    routines.put(routineName, routine);
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
                rs = null;
                stmt = null;
            }
        }
        sql = config.getDbProperties().getProperty(""selectRoutineParametersSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = prepareStatement(sql, null);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String routineName = rs.getString(""specific_name"");
                    Routine routine = routines.get(routineName);
                    if (routine != null) {
                        String paramName = rs.getString(""parameter_name"");
                        String type = rs.getString(""dtd_identifier"");
                        String mode = rs.getString(""parameter_mode"");
                        RoutineParameter param = new RoutineParameter(paramName, type, mode);
                        routine.addParameter(param);
                    }
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                warning(""Failed to retrieve stored procedure/function details: "" + sqlException, sql);
            } finally {
                if (rs != null)
                    rs.close();
                if (stmt != null)
                    stmt.close();
            }
        }
    }

    /**
     * Dump a warning message out to a new line
     *
     * @param msg1
     * @param msg2
     */
    private void warning(String msg1, String msg2) {
        System.out.println();
        System.out.flush();
        logger.warning(msg1);
        if (msg2 != null)
            logger.warning(msg2);
    }

    /**
     * Create a <code>PreparedStatement</code> from the specified SQL.
     * The SQL can contain these named parameters (but <b>not</b> question marks).
     * <ol>
     * <li>:schema - replaced with the name of the schema
     * <li>:owner - alias for :schema
     * <li>:table - replaced with the name of the table
     * </ol>
     * @param sql String - SQL without question marks
     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.
     * @throws SQLException
     * @return PreparedStatement
     */
    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {
        StringBuilder sqlBuf = new StringBuilder(sql);
        // modifies sqlBuf
        List<String> sqlParams = getSqlParams(sqlBuf, tableName);
        if (fineEnabled)
            logger.fine(sqlBuf + "" "" + sqlParams);
        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());
        try {
            for (int i = 0; i < sqlParams.size(); ++i) {
                stmt.setString(i + 1, sqlParams.get(i).toString());
            }
        } catch (SQLException exc) {
            stmt.close();
            throw exc;
        }
        return stmt;
    }

    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {
        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);
        Table remoteTable = remoteTables.get(fullName);
        if (remoteTable == null) {
            if (fineEnabled)
                logger.fine(""Creating remote table "" + fullName);
            if (logical)
                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            else
                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);
            if (fineEnabled)
                logger.fine(""Adding remote table "" + fullName);
            remoteTables.put(fullName, remoteTable);
            remoteTable.connectForeignKeys(locals);
        }
        return remoteTable;
    }

    /**
     * Return an uppercased <code>Set</code> of all SQL keywords used by a database
     *
     * @return
     * @throws SQLException
     */
    public Set<String> getSqlKeywords() throws SQLException {
        if (sqlKeywords == null) {
            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:
            String[] sql92Keywords = (""ADA"" + ""| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME"" + ""| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG"" + ""| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED"" + ""| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME"" + ""| CONSTRAINT_SCHEMA | CURSOR_NAME"" + ""| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION"" + ""| FORTRAN"" + ""| LENGTH"" + ""| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS"" + ""| NAME | NULLABLE | NUMBER"" + ""| PASCAL | PLI"" + ""| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE"" + ""| ROW_COUNT"" + ""| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN"" + ""| TABLE_NAME | TYPE"" + ""| UNCOMMITTED | UNNAMED"" + ""| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND"" + ""| ANY | ARE | AS | ASC"" + ""| ASSERTION | AT | AUTHORIZATION | AVG"" + ""| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY"" + ""| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH"" + ""| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION"" + ""| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT"" + ""| CONSTRAINTS | CONTINUE"" + ""| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT"" + ""| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR"" + ""| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE"" + ""| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS"" + ""| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP"" + ""| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION"" + ""| EXEC | EXECUTE | EXISTS"" + ""| EXTERNAL | EXTRACT"" + ""| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL"" + ""| GET | GLOBAL | GO | GOTO | GRANT | GROUP"" + ""| HAVING | HOUR"" + ""| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT"" + ""| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS"" + ""| ISOLATION"" + ""| JOIN"" + ""| KEY"" + ""| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER"" + ""| MATCH | MAX | MIN | MINUTE | MODULE | MONTH"" + ""| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL"" + ""| NULLIF | NUMERIC"" + ""| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR"" + ""| ORDER | OUTER"" + ""| OUTPUT | OVERLAPS"" + ""| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY"" + ""| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC"" + ""| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT"" + ""| ROLLBACK | ROWS"" + ""| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET"" + ""| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE"" + ""| SUBSTRING | SUM | SYSTEM_USER"" + ""| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE"" + ""| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE"" + ""| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING"" + ""| VALUE | VALUES | VARCHAR | VARYING | VIEW"" + ""| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE"" + ""| YEAR"" + ""| ZONE"").split(""[| ]+"");
            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split("",\\s*"");
            sqlKeywords = new HashSet<String>() {

                private static final long serialVersionUID = 1L;

                @Override
                public boolean contains(Object key) {
                    return super.contains(((String) key).toUpperCase());
                }
            };
            sqlKeywords.addAll(Arrays.asList(sql92Keywords));
            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));
        }
        return sqlKeywords;
    }

    /**
     * Return <code>id</code> quoted if required, otherwise return <code>id</code>
     *
     * @param id
     * @return
     * @throws SQLException
     */
    public String getQuotedIdentifier(String id) throws SQLException {
        // look for any character that isn't valid (then matcher.find() returns true)
        Matcher matcher = getInvalidIdentifierPattern().matcher(id);
        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);
        if (quotesRequired) {
            // name contains something that must be quoted
            String quote = getMetaData().getIdentifierQuoteString().trim();
            return quote + id + quote;
        }
        // no quoting necessary
        return id;
    }

    /**
     * Return a <code>Pattern</code> whose matcher will return <code>true</code>
     * when run against an identifier that contains a character that is not
     * acceptable by the database without being quoted.
     */
    private Pattern getInvalidIdentifierPattern() throws SQLException {
        if (invalidIdentifierPattern == null) {
            String validChars = ""a-zA-Z0-9_"";
            String reservedRegexChars = ""-&^"";
            String extraValidChars = getMetaData().getExtraNameCharacters();
            for (int i = 0; i < extraValidChars.length(); ++i) {
                char ch = extraValidChars.charAt(i);
                if (reservedRegexChars.indexOf(ch) >= 0)
                    validChars += ""\\"";
                validChars += ch;
            }
            invalidIdentifierPattern = Pattern.compile(""[^"" + validChars + ""]"");
        }
        return invalidIdentifierPattern;
    }

    /**
     * Replaces named parameters in <code>sql</code> with question marks and
     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.
     *
     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.
     * @param tableName String
     * @return List of Strings
     *
     * @see #prepareStatement(String, String)
     */
    private List<String> getSqlParams(StringBuilder sql, String tableName) {
        Map<String, String> namedParams = new HashMap<String, String>();
        @SuppressWarnings(""hiding"")
        String schema = getSchema();
        if (schema == null)
            // some 'schema-less' db's treat the db name like a schema (unusual case)
            schema = getName();
        namedParams.put("":schema"", schema);
        // alias for :schema
        namedParams.put("":owner"", schema);
        if (tableName != null) {
            namedParams.put("":table"", tableName);
            // alias for :table
            namedParams.put("":view"", tableName);
        }
        List<String> sqlParams = new ArrayList<String>();
        int nextColon = sql.indexOf("":"");
        while (nextColon != -1) {
            String paramName = new StringTokenizer(sql.substring(nextColon), "" ,\""')"").nextToken();
            String paramValue = namedParams.get(paramName);
            if (paramValue == null)
                throw new InvalidConfigurationException(""Unexpected named parameter '"" + paramName + ""' found in SQL '"" + sql + ""'"");
            sqlParams.add(paramValue);
            // replace with a ?
            sql.replace(nextColon, nextColon + paramName.length(), ""?"");
            nextColon = sql.indexOf("":"", nextColon);
        }
        return sqlParams;
    }

    /**
     * Take the supplied XML-based metadata and update our model of the schema with it
     *
     * @param schemaMeta
     * @throws SQLException
     */
    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {
        if (schemaMeta != null) {
            config.setDescription(schemaMeta.getComments());
            // done in three passes:
            // 1: create any new tables
            // 2: add/mod columns
            // 3: connect
            // add the newly defined tables and columns first
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {
                    // will add it if it doesn't already exist
                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);
                } else {
                    table = locals.get(tableMeta.getName());
                    if (table == null) {
                        // new table defined only in XML metadata
                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());
                        tables.put(table.getName(), table);
                    }
                }
                table.update(tableMeta);
            }
            // then tie the tables together
            for (TableMeta tableMeta : schemaMeta.getTables()) {
                Table table;
                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {
                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));
                } else {
                    table = locals.get(tableMeta.getName());
                }
                table.connect(tableMeta, locals);
            }
        }
    }

    private void connectTables() throws SQLException {
        for (Table table : tables.values()) {
            table.connectForeignKeys(locals);
        }
        for (Table view : views.values()) {
            view.connectForeignKeys(locals);
        }
    }

    /**
     * Returns a 'key' that's used to identify a remote table
     * in the remoteTables map.
     *
     * @param cat
     * @param sch
     * @param table
     * @return
     */
    public String getRemoteTableKey(String cat, String sch, String table) {
        return Table.getFullName(getName(), cat, sch, table);
    }

    /**
     * Single-threaded implementation of a class that creates tables
     */
    private class TableCreator {

        /**
         * Create a table and put it into <code>tables</code>
         */
        void create(BasicTableMeta tableMeta) throws SQLException {
            createImpl(tableMeta);
        }

        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {
            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);
            if (tableMeta.numRows != -1) {
                table.setNumRows(tableMeta.numRows);
            }
            synchronized (tables) {
                tables.put(table.getName(), table);
            }
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""Retrieved details of "" + table.getFullName());
            } else {
                System.out.print('.');
            }
        }

        /**
         * Wait for all of the tables to be created.
         * By default this does nothing since this implementation isn't threaded.
         */
        void join() {
        }
    }

    /**
     * Multi-threaded implementation of a class that creates tables
     */
    private class ThreadedTableCreator extends TableCreator {

        private final Set<Thread> threads = new HashSet<Thread>();

        private final int maxThreads;

        ThreadedTableCreator(int maxThreads) {
            this.maxThreads = maxThreads;
        }

        @Override
        void create(final BasicTableMeta tableMeta) throws SQLException {
            Thread runner = new Thread() {

                @Override
                public void run() {
                    try {
                        createImpl(tableMeta);
                    } catch (SQLException exc) {
                        // nobody above us in call stack...dump it here
                        exc.printStackTrace();
                    } finally {
                        synchronized (threads) {
                            threads.remove(this);
                            threads.notify();
                        }
                    }
                }
            };
            synchronized (threads) {
                // wait for enough 'room'
                while (threads.size() >= maxThreads) {
                    try {
                        threads.wait();
                    } catch (InterruptedException interrupted) {
                    }
                }
                threads.add(runner);
            }
            runner.start();
        }

        /**
         * Wait for all of the started threads to complete
         */
        @Override
        public void join() {
            while (true) {
                Thread thread;
                synchronized (threads) {
                    Iterator<Thread> iter = threads.iterator();
                    if (!iter.hasNext())
                        break;
                    thread = iter.next();
                }
                try {
                    thread.join();
                } catch (InterruptedException exc) {
                }
            }
        }
    }

    /**
     * A read-only map that treats both collections of Tables and Views as one
     * combined collection.
     * This is a bit strange, but it simplifies logic that otherwise treats
     * the two as if they were one collection.
     */
    private class CombinedMap implements Map<String, Table> {

        private final Map<String, ? extends Table> map1;

        private final Map<String, ? extends Table> map2;

        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {
            this.map1 = map1;
            this.map2 = map2;
        }

        public Table get(Object name) {
            Table table = map1.get(name);
            if (table == null)
                table = map2.get(name);
            return table;
        }

        public int size() {
            return map1.size() + map2.size();
        }

        public boolean isEmpty() {
            return map1.isEmpty() && map2.isEmpty();
        }

        public boolean containsKey(Object key) {
            return map1.containsKey(key) || map2.containsKey(key);
        }

        public boolean containsValue(Object value) {
            return map1.containsValue(value) || map2.containsValue(value);
        }

        public Table put(String name, Table table) {
            throw new UnsupportedOperationException();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<String> keySet() {
            return getCombined().keySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Set<Map.Entry<String, Table>> entrySet() {
            return getCombined().entrySet();
        }

        /**
         * Warning: potentially expensive operation
         */
        public Collection<Table> values() {
            return getCombined().values();
        }

        private Map<String, Table> getCombined() {
            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());
            all.putAll(map1);
            all.putAll(map2);
            return all;
        }

        public Table remove(Object key) {
            throw new UnsupportedOperationException();
        }

        public void putAll(Map<? extends String, ? extends Table> table) {
            throw new UnsupportedOperationException();
        }

        public void clear() {
            throw new UnsupportedOperationException();
        }
    }
}
","// Database_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getRemoteTableKey(String, String, String)} method.
*/
class Database_4Test {","// Database_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.SchemaMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Database}.
* It contains ten unit test cases for the {@link Database#getRemoteTableKey(String, String, String)} method.
*/
class Database_4Test {
"
cmpl-6u883PonkFEXGVreIdqCMvtedSSZU,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraint.java,106.44834542274475,length,"// ForeignKeyConstraint.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import static java.sql.DatabaseMetaData.importedKeyCascade;
import static java.sql.DatabaseMetaData.importedKeyNoAction;
import static java.sql.DatabaseMetaData.importedKeyRestrict;
import static java.sql.DatabaseMetaData.importedKeySetNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>
 * Foreign Key Constraint</a> that ""ties"" a child table to a parent table
 * via foreign and primary keys.
 */
public class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {

    private final String name;

    private Table parentTable;

    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();

    private final Table childTable;

    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();

    private final int deleteRule;

    private final int updateRule;

    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a foreign key for the specified child table.
     * Relationship details will be added later.
     *
     * @param child
     * @param name
     * @param deleteRule
     */
    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {
        // implied constraints will have a null name and override getName()
        this.name = name;
        if (finerEnabled)
            logger.finer(""Adding foreign key constraint '"" + getName() + ""' to "" + child.getFullName());
        childTable = child;
        this.deleteRule = deleteRule;
        this.updateRule = updateRule;
    }

    /**
     * This constructor is intended for use <b>after</b> all of the tables have been
     * found in the system.  One impact of using this constructor is that it will
     * ""glue"" the two tables together through their columns.
     *
     * @param parentColumn
     * @param childColumn
     */
    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {
        this(childColumn.getTable(), null, updateRule, deleteRule);
        addChildColumn(childColumn);
        addParentColumn(parentColumn);
        childColumn.addParent(parentColumn, this);
        parentColumn.addChild(childColumn, this);
    }

    /**
     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},
     * but defaults updateRule and deleteRule to
     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.
     *
     * @param parentColumn
     * @param childColumn
     */
    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {
        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);
    }

    /**
     * Add a ""parent"" side to the constraint.
     *
     * @param column
     */
    void addParentColumn(TableColumn column) {
        if (column != null) {
            parentColumns.add(column);
            parentTable = column.getTable();
        }
    }

    /**
     * Add a ""child"" side to the constraint.
     *
     * @param column
     */
    void addChildColumn(TableColumn column) {
        if (column != null) {
            childColumns.add(column);
        }
    }

    /**
     * Returns the name of the constraint
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the parent table (the table that contains the referenced primary key
     * column).
     *
     * @return
     */
    public Table getParentTable() {
        return parentTable;
    }

    /**
     * Returns all of the primary key columns that are referenced by this constraint.
     *
     * @return
     */
    public List<TableColumn> getParentColumns() {
        return Collections.unmodifiableList(parentColumns);
    }

    /**
     * Returns the table on the ""child"" end of the relationship (contains the foreign
     * key that references the parent table's primary key).
     *
     * @return
     */
    public Table getChildTable() {
        return childTable;
    }

    /**
     * Returns all of the foreign key columns that are referenced by this constraint.
     *
     * @return
     */
    public List<TableColumn> getChildColumns() {
        return Collections.unmodifiableList(childColumns);
    }

    /**
     * Returns the delete rule for this constraint.
     *
     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}
     */
    public int getDeleteRule() {
        return deleteRule;
    }

    /**
     * Returns <code>true</code> if this constraint should
     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.
     *
     * @return
     */
    public boolean isCascadeOnDelete() {
        return getDeleteRule() == importedKeyCascade;
    }

    /**
     * Returns <code>true</code> if the constraint prevents the parent table
     * from being deleted if child tables exist.
     *
     * @return
     */
    public boolean isRestrictDelete() {
        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;
    }

    /**
     * Returns <code>true</code> if the constraint indicates that the foreign key
     * will be set to <code>null</code> when the parent key is deleted.
     *
     * @return
     */
    public boolean isNullOnDelete() {
        return getDeleteRule() == importedKeySetNull;
    }

    public String getDeleteRuleName() {
        switch(getDeleteRule()) {
            case importedKeyCascade:
                return ""Cascade on delete"";
            case importedKeyRestrict:
            case importedKeyNoAction:
                return ""Restrict delete"";
            case importedKeySetNull:
                return ""Null on delete"";
            default:
                return """";
        }
    }

    public String getDeleteRuleDescription() {
        switch(getDeleteRule()) {
            case importedKeyCascade:
                return ""Cascade on delete:\n Deletion of parent deletes child"";
            case importedKeyRestrict:
            case importedKeyNoAction:
                return ""Restrict delete:\n Parent cannot be deleted if children exist"";
            case importedKeySetNull:
                return ""Null on delete:\n Foreign key to parent set to NULL when parent deleted"";
            default:
                return """";
        }
    }

    public String getDeleteRuleAlias() {
        switch(getDeleteRule()) {
            case importedKeyCascade:
                return ""C"";
            case importedKeyRestrict:
            case importedKeyNoAction:
                return ""R"";
            case importedKeySetNull:
                return ""N"";
            default:
                return """";
        }
    }

    /**
     * Returns the update rule for this constraint.
     *
     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}
     */
    public int getUpdateRule() {
        return updateRule;
    }

    /**
     * Returns <code>true</code> if this is an implied constraint or
     * <code>false</code> if it is ""real"".
     *
     * Subclasses that implement implied constraints should override this method.
     *
     * @return
     */
    public boolean isImplied() {
        return false;
    }

    /**
     * We have several types of constraints.
     * This returns <code>true</code> if the constraint came from the database
     * metadata and not inferred by something else.
     * This is different than {@link #isImplied()} in that implied relationships
     * are a specific type of non-real relationships.
     *
     * @return
     */
    public boolean isReal() {
        return getClass() == ForeignKeyConstraint.class;
    }

    /**
     * Custom comparison method to deal with foreign key names that aren't
     * unique across all schemas being evaluated
     *
     * @param other ForeignKeyConstraint
     *
     * @return
     */
    public int compareTo(ForeignKeyConstraint other) {
        if (other == this)
            return 0;
        int rc = getName().compareToIgnoreCase(other.getName());
        if (rc == 0) {
            // should only get here if we're dealing with cross-schema references (rare)
            String ours = getChildColumns().get(0).getTable().getContainer();
            String theirs = other.getChildColumns().get(0).getTable().getContainer();
            if (ours != null && theirs != null)
                rc = ours.compareToIgnoreCase(theirs);
            else if (ours == null)
                rc = -1;
            else
                rc = 1;
        }
        return rc;
    }

    /**
     * Static method that returns a string representation of the specified
     * list of {@link TableColumn columns}.
     *
     * @param columns
     * @return
     */
    public static String toString(List<TableColumn> columns) {
        if (columns.size() == 1)
            return columns.iterator().next().toString();
        return columns.toString();
    }

    /**
     * Returns a string representation of this foreign key constraint.
     *
     * @return
     */
    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder();
        buf.append(childTable.getName());
        buf.append('.');
        buf.append(toString(childColumns));
        buf.append("" references "");
        if (parentTable.isRemote()) {
            buf.append(parentTable.getContainer());
            buf.append('.');
        }
        buf.append(parentTable.getName());
        buf.append('.');
        buf.append(toString(parentColumns));
        if (name != null) {
            buf.append("" via "");
            buf.append(name);
        }
        return buf.toString();
    }
}
","// ForeignKeyConstraintTest.java
package net.sourceforge.schemaspy.model;

import static java.sql.DatabaseMetaData.importedKeyCascade;
import static java.sql.DatabaseMetaData.importedKeyNoAction;
import static java.sql.DatabaseMetaData.importedKeyRestrict;
import static java.sql.DatabaseMetaData.importedKeySetNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ForeignKeyConstraint}.
* It contains ten unit test cases for the {@link ForeignKeyConstraint#compareTo(ForeignKeyConstraint)} method.
*/
class ForeignKeyConstraintTest {","// ForeignKeyConstraintTest.java
package net.sourceforge.schemaspy.model;

import static java.sql.DatabaseMetaData.importedKeyCascade;
import static java.sql.DatabaseMetaData.importedKeyNoAction;
import static java.sql.DatabaseMetaData.importedKeyRestrict;
import static java.sql.DatabaseMetaData.importedKeySetNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ForeignKeyConstraint}.
* It contains ten unit test cases for the {@link ForeignKeyConstraint#compareTo(ForeignKeyConstraint)} method.
*/
class ForeignKeyConstraintTest {

	private static final Logger logger = Logger.getLogger(ForeignKeyConstraintTest.class.getName());
	private static final boolean finerEnabled = logger.isLoggable(Level.FINER);
	
	/**
	 * Test case for {@link ForeignKeyConstraint#compareTo(ForeignKeyConstraint)} method.
	 * It tests the case when the two foreign key constraints are the same.
	 */
	@Test
	void testCompareTo_Same() {
		if (finerEnabled) logger.finer(""testCompareTo_Same"");
		
		TableColumn parentColumn = new TableColumn(""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"
908a6aa7-98f3-483d-aad1-b7f9f00e53ed,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8714 tokens (4714 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#getParentConstraint(TableColumn)} method.
*/
class TableColumn_0Test {","// TableColumn_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#getParentConstraint(TableColumn)} method.
*/
class TableColumn_0Test {
"
adbb0eb6-0009-4406-8f56-d3daaf970853,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8714 tokens (4714 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#removeAParentFKConstraint()} method.
*/
class TableColumn_1Test {","// TableColumn_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#removeAParentFKConstraint()} method.
*/
class TableColumn_1Test {
"
6663104c-65dd-4d1a-8a38-cb95bb56a06f,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8714 tokens (4714 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_2Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#removeAChildFKConstraint()} method.
*/
class TableColumn_2Test {","// TableColumn_2Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#removeAChildFKConstraint()} method.
*/
class TableColumn_2Test {
"
78ffb687-05c0-4d19-8248-c6b7e6533f6c,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8714 tokens (4714 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#getChildConstraint(TableColumn)} method.
*/
class TableColumn_3Test {","// TableColumn_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#getChildConstraint(TableColumn)} method.
*/
class TableColumn_3Test {
"
3bee3a62-2fb9-4efb-9421-70e305627d51,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8710 tokens (4710 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#matches(Pattern)} method.
*/
class TableColumn_4Test {","// TableColumn_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#matches(Pattern)} method.
*/
class TableColumn_4Test {
"
6ac5bc32-549f-42b3-bc07-d540bb5d84ba,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8711 tokens (4711 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_5Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#allowsImpliedParents()} method.
*/
class TableColumn_5Test {","// TableColumn_5Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#allowsImpliedParents()} method.
*/
class TableColumn_5Test {
"
a0fa4957-aec7-489a-bf95-f975afe401ab,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumn_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8711 tokens (4711 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// TableColumn.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;

public class TableColumn {

    private final Table table;

    private final String name;

    private final Object id;

    private String type;

    private String shortType;

    private final int length;

    private final int decimalDigits;

    private final String detailedSize;

    private final boolean isNullable;

    private boolean isAutoUpdated;

    private Boolean isUnique;

    private final Object defaultValue;

    private String comments;

    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();

    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());

    private boolean allowImpliedParents = true;

    private boolean allowImpliedChildren = true;

    private boolean isExcluded = false;

    private boolean isAllExcluded = false;

    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());

    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Create a column associated with a table.
     *
     * @param table Table the table that this column belongs to
     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    TableColumn(Table table, ResultSet rs) throws SQLException {
        this.table = table;
        // names and types are typically reused *many* times in a database,
        // so keep a single instance of each distinct one
        // (thanks to Mike Barnes for the suggestion)
        String tmp = rs.getString(""COLUMN_NAME"");
        name = tmp == null ? null : tmp.intern();
        tmp = rs.getString(""TYPE_NAME"");
        type = tmp == null ? ""unknown"" : tmp.intern();
        decimalDigits = rs.getInt(""DECIMAL_DIGITS"");
        Number bufLength = (Number) rs.getObject(""BUFFER_LENGTH"");
        if (bufLength != null && bufLength.shortValue() > 0)
            length = bufLength.shortValue();
        else
            length = rs.getInt(""COLUMN_SIZE"");
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = rs.getInt(""NULLABLE"") == DatabaseMetaData.columnNullable;
        defaultValue = rs.getString(""COLUMN_DEF"");
        setComments(rs.getString(""REMARKS""));
        id = new Integer(rs.getInt(""ORDINAL_POSITION"") - 1);
        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();
        Pattern excludeColumns = Config.getInstance().getColumnExclusions();
        isAllExcluded = matches(excludeColumns);
        isExcluded = isAllExcluded || matches(excludeIndirectColumns);
        if (isExcluded && finerEnabled) {
            logger.finer(""Excluding column "" + getTable() + '.' + getName() + "": matches "" + excludeColumns + "":"" + isAllExcluded + "" "" + excludeIndirectColumns + "":"" + matches(excludeIndirectColumns));
        }
    }

    /**
     * A TableColumn that's derived from something other than traditional database metadata
     * (e.g. defined in XML).
     *
     * @param table
     * @param colMeta
     */
    public TableColumn(Table table, TableColumnMeta colMeta) {
        this.table = table;
        name = colMeta.getName();
        id = colMeta.getId();
        type = colMeta.getType();
        length = colMeta.getSize();
        decimalDigits = colMeta.getDigits();
        StringBuilder buf = new StringBuilder();
        buf.append(length);
        if (decimalDigits > 0) {
            buf.append(',');
            buf.append(decimalDigits);
        }
        detailedSize = buf.toString();
        isNullable = colMeta.isNullable();
        isAutoUpdated = colMeta.isAutoUpdated();
        defaultValue = colMeta.getDefaultValue();
        comments = colMeta.getComments();
    }

    /**
     * Returns the {@link Table} that this column belongs to.
     *
     * @return
     */
    public Table getTable() {
        return table;
    }

    /**
     * Returns the column's name.
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Type of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.
     * @return
     */
    public String getType() {
        return type;
    }

    /**
     * Normally only used for ""special"" types such as enums.
     *
     * @param type
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Abbreviated form of {@link #getType()}
     *
     * @return
     */
    public String getShortType() {
        return shortType == null ? type : shortType;
    }

    /**
     * Abbreviated form of {@link #setType(String)}
     *
     * @param shortType
     */
    public void setShortType(String shortType) {
        this.shortType = shortType;
    }

    /**
     * Length of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,
     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.
     * @return
     */
    public int getLength() {
        return length;
    }

    /**
     * Decimal digits of the column.
     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.
     *
     * @return
     */
    public int getDecimalDigits() {
        return decimalDigits;
    }

    /**
     * String representation of length with optional decimal digits (if decimal digits &gt; 0).
     *
     * @return
     */
    public String getDetailedSize() {
        return detailedSize;
    }

    /**
     * Returns <code>true</code> if null values are allowed
     *
     * @return
     */
    public boolean isNullable() {
        return isNullable;
    }

    /**
     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}
     *
     * @return
     */
    public boolean isAutoUpdated() {
        return isAutoUpdated;
    }

    /**
     * setIsAutoUpdated
     *
     * @param isAutoUpdated boolean
     */
    public void setIsAutoUpdated(boolean isAutoUpdated) {
        this.isAutoUpdated = isAutoUpdated;
    }

    /**
     * Returns <code>true</code> if this column can only contain unique values
     *
     * @return
     */
    public boolean isUnique() {
        if (isUnique == null) {
            // see if there's a unique index on this column by itself
            for (TableIndex index : table.getIndexes()) {
                if (index.isUnique()) {
                    List<TableColumn> indexColumns = index.getColumns();
                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {
                        isUnique = true;
                        break;
                    }
                }
            }
            if (isUnique == null) {
                // if it's a single PK column then it's unique
                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();
            }
        }
        return isUnique;
    }

    /**
     * Returns <code>true</code> if this column is a primary key
     *
     * @return
     */
    public boolean isPrimary() {
        return table.getPrimaryColumns().contains(this);
    }

    /**
     * Returns <code>true</code> if this column points to another table's primary key.
     *
     * @return
     */
    public boolean isForeignKey() {
        return !parents.isEmpty();
    }

    /**
     * Returns the value that the database uses for this column if one isn't provided.
     *
     * @return
     */
    public Object getDefaultValue() {
        return defaultValue;
    }

    /**
     * @return Comments associated with this column, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * See {@link #getComments()}
     * @param comments
     */
    public void setComments(String comments) {
        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.
     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed
     * diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isExcluded() {
        return isExcluded;
    }

    /**
     * Returns <code>true</code> if this column is to be excluded from all relationships in
     * relationship diagrams.  This includes the detailed diagrams of the containing table.
     *
     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables
     * reference a given column.
     *
     * @return
     */
    public boolean isAllExcluded() {
        return isAllExcluded;
    }

    /**
     * Add a parent column (PK) to this column (FK) via the associated constraint
     *
     * @param parent
     * @param constraint
     */
    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {
        parents.put(parent, constraint);
        table.addedParent();
    }

    /**
     * Remove the specified parent column from this column
     *
     * @param parent
     */
    public void removeParent(TableColumn parent) {
        parents.remove(parent);
    }

    /**
     * Disassociate all parents from this column
     */
    public void unlinkParents() {
        for (TableColumn parent : parents.keySet()) {
            parent.removeChild(this);
        }
        parents.clear();
    }

    /**
     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column
     *
     * @return
     */
    public Set<TableColumn> getParents() {
        return parents.keySet();
    }

    /**
     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)
     */
    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {
        return parents.get(parent);
    }

    /**
     * Removes a parent constraint and returns it, or null if there are no parent constraints
     *
     * @return the removed {@link ForeignKeyConstraint}
     */
    public ForeignKeyConstraint removeAParentFKConstraint() {
        for (TableColumn relatedColumn : parents.keySet()) {
            ForeignKeyConstraint constraint = parents.remove(relatedColumn);
            relatedColumn.removeChild(this);
            return constraint;
        }
        return null;
    }

    /**
     * Remove one child {@link ForeignKeyConstraint} that points to this column.
     *
     * @return the removed constraint, or <code>null</code> if none were available to be removed
     */
    public ForeignKeyConstraint removeAChildFKConstraint() {
        for (TableColumn relatedColumn : children.keySet()) {
            ForeignKeyConstraint constraint = children.remove(relatedColumn);
            relatedColumn.removeParent(this);
            return constraint;
        }
        return null;
    }

    /**
     * Add a child column (FK) to this column (PK) via the associated constraint
     *
     * @param child
     * @param constraint
     */
    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {
        children.put(child, constraint);
        table.addedChild();
    }

    /**
     * Remove the specified child column from this column
     *
     * @param child
     */
    public void removeChild(TableColumn child) {
        children.remove(child);
    }

    /**
     * Disassociate all children from this column
     */
    public void unlinkChildren() {
        for (TableColumn child : children.keySet()) child.removeParent(this);
        children.clear();
    }

    /**
     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that
     * references this <code>TableColumn</code>.
     * @return Set
     */
    public Set<TableColumn> getChildren() {
        return children.keySet();
    }

    /**
     * returns the constraint that connects the specified column to this column
     * (specified 'child' to this 'parent' column)
     */
    public ForeignKeyConstraint getChildConstraint(TableColumn child) {
        return children.get(child);
    }

    /**
     * Returns <code>true</code> if tableName.columnName matches the supplied
     * regular expression.
     *
     * @param regex
     * @return
     */
    public boolean matches(Pattern regex) {
        return regex.matcher(getTable().getName() + '.' + getName()).matches();
    }

    /**
     * Update the state of this column with the supplied {@link TableColumnMeta}.
     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.
     *
     * @param colMeta
     */
    public void update(TableColumnMeta colMeta) {
        String newComments = colMeta.getComments();
        if (newComments != null)
            setComments(newComments);
        if (!isPrimary() && colMeta.isPrimary()) {
            table.setPrimaryColumn(this);
        }
        allowImpliedParents = !colMeta.isImpliedParentsDisabled();
        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();
        isExcluded |= colMeta.isExcluded();
        isAllExcluded |= colMeta.isAllExcluded();
    }

    /**
     * Returns the name of this column.
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Two {@link TableColumn}s are considered equal if their tables and names match.
     */
    private class ColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    /**
     * Returns <code>true</code> if this column is permitted to be an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedParents() {
        return allowImpliedParents;
    }

    /**
     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK
     * (based on name/type/size matches to PKs).
     *
     * @return
     */
    public boolean allowsImpliedChildren() {
        return allowImpliedChildren;
    }
}
","// TableColumn_6Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#allowsImpliedChildren()} method.
*/
class TableColumn_6Test {","// TableColumn_6Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableColumn}.
* It contains ten unit test cases for the {@link TableColumn#allowsImpliedChildren()} method.
*/
class TableColumn_6Test {
"
cmpl-6u8GZsUUvxsJ8Iy9IFxK4u2JxBBgL,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndex_0Test.java,105.53836274147034,length,"// TableIndex.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class TableIndex implements Comparable<TableIndex> {

    private final String name;

    private final boolean isUnique;

    private Object id;

    private boolean isPrimary;

    private final List<TableColumn> columns = new ArrayList<TableColumn>();

    // for whether colums are ascending order
    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();

    /**
     * @param rs
     * @throws java.sql.SQLException
     */
    public TableIndex(ResultSet rs) throws SQLException {
        name = rs.getString(""INDEX_NAME"");
        isUnique = !rs.getBoolean(""NON_UNIQUE"");
    }

    public void setId(Object id) {
        this.id = id;
    }

    public Object getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    void addColumn(TableColumn column, String sortOrder) {
        if (column != null) {
            columns.add(column);
            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(""A"")));
        }
    }

    /**
     * @return
     */
    public String getType() {
        if (isPrimaryKey())
            return ""Primary key"";
        if (isUnique())
            return ""Must be unique"";
        return ""Performance"";
    }

    /**
     * @return
     */
    public boolean isPrimaryKey() {
        return isPrimary;
    }

    /**
     * @param isPrimaryKey
     */
    public void setIsPrimaryKey(boolean isPrimaryKey) {
        isPrimary = isPrimaryKey;
    }

    /**
     * @return
     */
    public boolean isUnique() {
        return isUnique;
    }

    /**
     * @return
     */
    public String getColumnsAsString() {
        StringBuilder buf = new StringBuilder();
        for (TableColumn column : columns) {
            if (buf.length() > 0)
                buf.append("" + "");
            buf.append(column);
        }
        return buf.toString();
    }

    public List<TableColumn> getColumns() {
        return Collections.unmodifiableList(columns);
    }

    /**
     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.
     *
     * @return boolean
     */
    public boolean isUniqueNullable() {
        if (!isUnique())
            return false;
        // if all of the columns specified by the Unique Index are nullable
        // then return true, otherwise false
        boolean allNullable = true;
        for (TableColumn column : getColumns()) {
            allNullable = column != null && column.isNullable();
            if (!allNullable)
                break;
        }
        return allNullable;
    }

    /**
     * @param column
     * @return
     */
    public boolean isAscending(TableColumn column) {
        return columnsAscending.get(columns.indexOf(column)).booleanValue();
    }

    /**
     * @param object
     * @return
     */
    public int compareTo(TableIndex other) {
        if (isPrimaryKey() && !other.isPrimaryKey())
            return -1;
        if (!isPrimaryKey() && other.isPrimaryKey())
            return 1;
        Object thisId = getId();
        Object otherId = other.getId();
        if (thisId == null || otherId == null)
            return getName().compareToIgnoreCase(other.getName());
        if (thisId instanceof Number)
            return ((Number) thisId).intValue() - ((Number) otherId).intValue();
        return thisId.toString().compareToIgnoreCase(otherId.toString());
    }
}
","// TableIndex_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableIndex}.
* It contains ten unit test cases for the {@link TableIndex#isAscending(TableColumn)} method.
*/
class TableIndex_0Test {","// TableIndex_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableIndex}.
* It contains ten unit test cases for the {@link TableIndex#isAscending(TableColumn)} method.
*/
class TableIndex_0Test {

	/**
	* Test case for {@link TableIndex#isAscending(TableColumn)} method.
	* Test data: column is null.
	* Expected result: NullPointerException.
	*/
	@Test
	void testIsAscending_0() {
		TableIndex tableIndex = new TableIndex(null);
		assertThrows(NullPointerException.class, () -> {
			tableIndex.isAscending(null);
		});
	}
	
	/**
	* Test case for {@link TableIndex#isAscending(TableColumn)} method.
	* Test data: column is not null, but not contained in the index.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	void testIsAscending_1() {
		TableIndex tableIndex = new TableIndex(null);
		TableColumn column = new TableColumn(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null"
cmpl-6u8IGJzIFWXbQHyGCNElxDoXUXFJ6,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndex_1Test.java,109.28704261779785,length,"// TableIndex.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class TableIndex implements Comparable<TableIndex> {

    private final String name;

    private final boolean isUnique;

    private Object id;

    private boolean isPrimary;

    private final List<TableColumn> columns = new ArrayList<TableColumn>();

    // for whether colums are ascending order
    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();

    /**
     * @param rs
     * @throws java.sql.SQLException
     */
    public TableIndex(ResultSet rs) throws SQLException {
        name = rs.getString(""INDEX_NAME"");
        isUnique = !rs.getBoolean(""NON_UNIQUE"");
    }

    public void setId(Object id) {
        this.id = id;
    }

    public Object getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    void addColumn(TableColumn column, String sortOrder) {
        if (column != null) {
            columns.add(column);
            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(""A"")));
        }
    }

    /**
     * @return
     */
    public String getType() {
        if (isPrimaryKey())
            return ""Primary key"";
        if (isUnique())
            return ""Must be unique"";
        return ""Performance"";
    }

    /**
     * @return
     */
    public boolean isPrimaryKey() {
        return isPrimary;
    }

    /**
     * @param isPrimaryKey
     */
    public void setIsPrimaryKey(boolean isPrimaryKey) {
        isPrimary = isPrimaryKey;
    }

    /**
     * @return
     */
    public boolean isUnique() {
        return isUnique;
    }

    /**
     * @return
     */
    public String getColumnsAsString() {
        StringBuilder buf = new StringBuilder();
        for (TableColumn column : columns) {
            if (buf.length() > 0)
                buf.append("" + "");
            buf.append(column);
        }
        return buf.toString();
    }

    public List<TableColumn> getColumns() {
        return Collections.unmodifiableList(columns);
    }

    /**
     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.
     *
     * @return boolean
     */
    public boolean isUniqueNullable() {
        if (!isUnique())
            return false;
        // if all of the columns specified by the Unique Index are nullable
        // then return true, otherwise false
        boolean allNullable = true;
        for (TableColumn column : getColumns()) {
            allNullable = column != null && column.isNullable();
            if (!allNullable)
                break;
        }
        return allNullable;
    }

    /**
     * @param column
     * @return
     */
    public boolean isAscending(TableColumn column) {
        return columnsAscending.get(columns.indexOf(column)).booleanValue();
    }

    /**
     * @param object
     * @return
     */
    public int compareTo(TableIndex other) {
        if (isPrimaryKey() && !other.isPrimaryKey())
            return -1;
        if (!isPrimaryKey() && other.isPrimaryKey())
            return 1;
        Object thisId = getId();
        Object otherId = other.getId();
        if (thisId == null || otherId == null)
            return getName().compareToIgnoreCase(other.getName());
        if (thisId instanceof Number)
            return ((Number) thisId).intValue() - ((Number) otherId).intValue();
        return thisId.toString().compareToIgnoreCase(otherId.toString());
    }
}
","// TableIndex_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableIndex}.
* It contains ten unit test cases for the {@link TableIndex#compareTo(TableIndex)} method.
*/
class TableIndex_1Test {","// TableIndex_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableIndex}.
* It contains ten unit test cases for the {@link TableIndex#compareTo(TableIndex)} method.
*/
class TableIndex_1Test {

	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: primary key index.
	* Expected result: -1.
	*/
	@Test
	void testCompareTo_1() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(true);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(false);
		int result = index1.compareTo(index2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: non-primary key index.
	* Expected result: 1.
	*/
	@Test
	void testCompareTo_2() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(false);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(true);
		int result = index1.compareTo(index2);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: primary key index and null id.
	* Expected result: 0.
	*/
	@Test
	void testCompareTo_3() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(true);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(true);
		int result = index1.compareTo(index2);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: non-primary key index and null id.
	* Expected result: 0.
	*/
	@Test
	void testCompareTo_4() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(false);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(false);
		int result = index1.compareTo(index2);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: primary key index and non-null id.
	* Expected result: -1.
	*/
	@Test
	void testCompareTo_5() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(true);
		index1.setId(1);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(true);
		index2.setId(2);
		int result = index1.compareTo(index2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: non-primary key index and non-null id.
	* Expected result: -1.
	*/
	@Test
	void testCompareTo_6() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(false);
		index1.setId(1);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(false);
		index2.setId(2);
		int result = index1.compareTo(index2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: primary key index and non-null id.
	* Expected result: 1.
	*/
	@Test
	void testCompareTo_7() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(true);
		index1.setId(2);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(true);
		index2.setId(1);
		int result = index1.compareTo(index2);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: non-primary key index and non-null id.
	* Expected result: 1.
	*/
	@Test
	void testCompareTo_8() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(false);
		index1.setId(2);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(false);
		index2.setId(1);
		int result = index1.compareTo(index2);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: primary key index and non-null id.
	* Expected result: 0.
	*/
	@Test
	void testCompareTo_9() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(true);
		index1.setId(1);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(true);
		index2.setId(1);
		int result = index1.compareTo(index2);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link TableIndex#compareTo(TableIndex)} method.
	* Test data: non-primary key index and non-null id.
	* Expected result: 0.
	*/
	@Test
	void testCompareTo_10() {
		TableIndex index1 = new TableIndex(null);
		index1.setIsPrimaryKey(false);
		index1.setId(1);
		TableIndex index2 = new TableIndex(null);
		index2.setIsPrimaryKey(false);
		index2.setId(1);
		int result = index1.compareTo(index2);
		assertEquals(0, result);
	}
}

// TableIndex_2Test.java
package net.sourceforge.schemaspy.model;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TableIndex}.
* It contains ten unit test cases for the {@link TableIndex#isUniqueNullable()} method.
*/
class TableIndex_2Test {
		
	/**
	* Test case for {@link TableIndex#isUniqueNullable()} method.
	* Test data: unique index and nullable column.
	* Expected result: true.
	*/
	@Test
	void testIsUniqueNullable_1() {
		TableIndex index = new TableIndex(null);
		index.setIsPrimaryKey(false);
		index.setId(1);
		TableColumn column = new TableColumn(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,"
76f9588f-c034-4424-b0e0-0e4850ddb836,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14972 tokens (10972 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getIndex(String)} method.
*/
class Table_0Test {","// Table_0Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getIndex(String)} method.
*/
class Table_0Test {
"
f9c938ed-1543-4538-951d-c757071613d0,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14979 tokens (10979 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getFullName(String, String, String, String)} method.
*/
class Table_1Test {","// Table_1Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getFullName(String, String, String, String)} method.
*/
class Table_1Test {
"
49a92c81-4f51-4ebc-9f70-f8f03136237e,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14972 tokens (10972 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_2Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getColumn(String)} method.
*/
class Table_2Test {","// Table_2Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#getColumn(String)} method.
*/
class Table_2Test {
"
31f5c78d-0b44-4ab0-b2f3-d7f61f5bb04b,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14977 tokens (10977 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeSelfReferencingConstraint()} method.
*/
class Table_3Test {","// Table_3Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeSelfReferencingConstraint()} method.
*/
class Table_3Test {
"
942c87a0-298d-4495-a7d7-e1b8c6eff940,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14974 tokens (10974 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeNonRealForeignKeys()} method.
*/
class Table_4Test {","// Table_4Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeNonRealForeignKeys()} method.
*/
class Table_4Test {
"
3ec9c2cb-3418-4a2c-8d91-3469eb93318a,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14977 tokens (10977 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_5Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeAForeignKeyConstraint()} method.
*/
class Table_5Test {","// Table_5Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#removeAForeignKeyConstraint()} method.
*/
class Table_5Test {
"
ff8f521f-2bd3-466d-a9d3-2151d0fc551d,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14974 tokens (10974 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_6Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#isOrphan(boolean)} method.
*/
class Table_6Test {","// Table_6Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#isOrphan(boolean)} method.
*/
class Table_6Test {
"
f9dc5375-778e-474e-96fa-f20f31f80926,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/Table_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14973 tokens (10973 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Table.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;

/**
 * A <code>Table</code> is one of the basic building blocks of SchemaSpy
 * that knows everything about the database table's metadata.
 *
 * @author John Currier
 */
public class Table implements Comparable<Table> {

    private final String catalog;

    private final String schema;

    private final String name;

    private final String fullName;

    private final String container;

    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();

    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();

    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();

    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();

    private Object id;

    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);

    private Long numRows;

    protected final Database db;

    private String comments;

    private int maxChildren;

    private int maxParents;

    private final static Logger logger = Logger.getLogger(Table.class.getName());

    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);

    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);

    /**
     * Construct a table that knows everything about the database table's metadata
     *
     * @param db
     * @param catalog
     * @param schema
     * @param name
     * @param comments
     * @throws SQLException
     */
    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {
        this.db = db;
        this.catalog = catalog;
        this.schema = schema;
        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();
        this.name = name;
        this.fullName = getFullName(db.getName(), catalog, schema, name);
        if (fineEnabled)
            logger.fine(""Creating "" + getClass().getSimpleName() + "" "" + fullName);
        setComments(comments);
        initColumns();
        initIndexes();
        initPrimaryKeys();
    }

    /**
     * ""Connect"" all of this table's foreign keys to their referenced primary keys
     * (and, in some cases, do the reverse as well).
     *
     * @param tables
     * @throws SQLException
     */
    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {
        if (finerEnabled)
            logger.finer(""Connecting foreign keys to "" + getFullName());
        ResultSet rs = null;
        try {
            // get our foreign keys that reference other tables' primary keys
            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) {
                addForeignKey(rs.getString(""FK_NAME""), rs.getString(""FKCOLUMN_NAME""), rs.getString(""PKTABLE_CAT""), rs.getString(""PKTABLE_SCHEM""), rs.getString(""PKTABLE_NAME""), rs.getString(""PKCOLUMN_NAME""), rs.getInt(""UPDATE_RULE""), rs.getInt(""DELETE_RULE""), tables);
            }
        } finally {
            if (rs != null)
                rs.close();
        }
        // also try to find all of the 'remote' tables in other schemas that
        // point to our primary keys (not necessary in the normal case
        // as we infer this from the opposite direction)
        if (getSchema() != null || getCatalog() != null) {
            try {
                // get the foreign keys that reference our primary keys
                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());
                while (rs.next()) {
                    String otherCatalog = rs.getString(""FKTABLE_CAT"");
                    String otherSchema = rs.getString(""FKTABLE_SCHEM"");
                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {
                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(""FKTABLE_NAME""), getSchema(), false);
                    }
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
    }

    /**
     * Get the foreign keys associated with this table
     *
     * @return
     */
    public Collection<ForeignKeyConstraint> getForeignKeys() {
        return Collections.unmodifiableCollection(foreignKeys.values());
    }

    /**
     * Add a check constraint to the table
     * (no real details, just name and textual representation)
     *
     * @param constraintName
     * @param text
     */
    public void addCheckConstraint(String constraintName, String text) {
        checkConstraints.put(constraintName, text);
    }

    /**
     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}
     * rs.getString(""FK_NAME"");
     * rs.getString(""FKCOLUMN_NAME"");
     * rs.getString(""PKTABLE_CAT"");
     * rs.getString(""PKTABLE_SCHEM"");
     * rs.getString(""PKTABLE_NAME"");
     * rs.getString(""PKCOLUMN_NAME"");
     * @param tables Map
     * @param db
     * @throws SQLException
     */
    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {
        if (fkName == null)
            return;
        Pattern include = Config.getInstance().getTableInclusions();
        Pattern exclude = Config.getInstance().getTableExclusions();
        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {
            if (fineEnabled)
                logger.fine(""Ignoring "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + "" referenced by FK "" + fkName);
            return;
        }
        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);
        if (foreignKey == null) {
            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);
            foreignKeys.put(fkName, foreignKey);
        }
        TableColumn childColumn = getColumn(fkColName);
        if (childColumn != null) {
            foreignKey.addChildColumn(childColumn);
            Config config = Config.getInstance();
            Table parentTable = tables.get(pkTableName);
            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();
            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();
            // if named table doesn't exist in this schema
            // or exists here but really referencing same named table in another schema
            if (parentTable == null || !baseContainer.equals(parentContainer)) {
                if (fineEnabled)
                    logger.fine(""Adding remote table "" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));
                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);
            }
            if (parentTable != null) {
                TableColumn parentColumn = parentTable.getColumn(pkColName);
                if (parentColumn != null) {
                    foreignKey.addParentColumn(parentColumn);
                    childColumn.addParent(parentColumn, foreignKey);
                    parentColumn.addChild(childColumn, foreignKey);
                } else {
                    logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + pkColName + ""' doesn't exist in table '"" + parentTable + ""'"");
                }
            } else {
                logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Unknown Referenced Table '"" + pkTableName + ""'"");
            }
        } else {
            logger.warning(""Couldn't add FK '"" + foreignKey.getName() + ""' to table '"" + this + ""' - Column '"" + fkColName + ""' doesn't exist"");
        }
    }

    /**
     * @param meta
     * @throws SQLException
     */
    private void initPrimaryKeys() throws SQLException {
        ResultSet rs = null;
        try {
            if (fineEnabled)
                logger.fine(""Querying primary keys for "" + getFullName());
            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());
            while (rs.next()) setPrimaryColumn(rs);
        } catch (SQLException exc) {
            if (!isLogical()) {
                throw exc;
            }
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void setPrimaryColumn(ResultSet rs) throws SQLException {
        String pkName = rs.getString(""PK_NAME"");
        if (pkName == null)
            return;
        TableIndex index = getIndex(pkName);
        if (index != null) {
            index.setIsPrimaryKey(true);
        }
        String columnName = rs.getString(""COLUMN_NAME"");
        setPrimaryColumn(getColumn(columnName));
    }

    /**
     * @param primaryColumn
     */
    void setPrimaryColumn(TableColumn primaryColumn) {
        primaryKeys.add(primaryColumn);
    }

    /**
     * @throws SQLException
     */
    private void initColumns() throws SQLException {
        ResultSet rs = null;
        synchronized (Table.class) {
            try {
                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), ""%"");
                while (rs.next()) addColumn(rs);
            } catch (SQLException exc) {
                if (!isLogical()) {
                    class ColumnInitializationFailure extends SQLException {

                        private static final long serialVersionUID = 1L;

                        public ColumnInitializationFailure(SQLException failure) {
                            super(""Failed to collect column details for "" + (isView() ? ""view"" : ""table"") + "" '"" + getName() + ""' in schema '"" + getContainer() + ""'"");
                            initCause(failure);
                        }
                    }
                    throw new ColumnInitializationFailure(exc);
                }
            } finally {
                if (rs != null)
                    rs.close();
            }
        }
        initColumnAutoUpdate(false);
    }

    /**
     * @param forceQuotes
     * @throws SQLException
     */
    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        if (isView() || isRemote())
            return;
        // we've got to get a result set with all the columns in it
        // so we can ask if the columns are auto updated
        // Ugh!!!  Should have been in DatabaseMetaData instead!!!
        StringBuilder sql = new StringBuilder(""select * from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        sql.append("" where 0 = 1"");
        try {
            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            ResultSetMetaData rsMeta = rs.getMetaData();
            for (int i = rsMeta.getColumnCount(); i > 0; --i) {
                TableColumn column = getColumn(rsMeta.getColumnName(i));
                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));
            }
        } catch (SQLException exc) {
            if (forceQuotes) {
                if (!isLogical()) {
                    // don't completely choke just because we couldn't do this....
                    logger.warning(""Failed to determine auto increment status: "" + exc);
                    logger.warning(""SQL: "" + sql.toString());
                }
            } else {
                initColumnAutoUpdate(true);
            }
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}
     * @throws SQLException
     */
    protected void addColumn(ResultSet rs) throws SQLException {
        String columnName = rs.getString(""COLUMN_NAME"");
        if (columnName == null)
            return;
        if (getColumn(columnName) == null) {
            TableColumn column = new TableColumn(this, rs);
            columns.put(column.getName(), column);
        }
    }

    /**
     * Add a column that's defined in xml metadata.
     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.
     * @param colMeta
     * @return
     */
    protected TableColumn addColumn(TableColumnMeta colMeta) {
        TableColumn column = new TableColumn(this, colMeta);
        columns.put(column.getName(), column);
        return column;
    }

    /**
     * Initialize index information
     *
     * @throws SQLException
     */
    private void initIndexes() throws SQLException {
        if (isView() || isRemote())
            return;
        // first try to initialize using the index query spec'd in the .properties
        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()
        // (they try to do a DDL analyze command that has some bad side-effects)
        if (initIndexes(Config.getInstance().getDbProperties().getProperty(""selectIndexesSql"")))
            return;
        // couldn't, so try the old fashioned approach
        ResultSet rs = null;
        try {
            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException exc) {
            if (!isLogical())
                logger.warning(""Unable to extract index info for table '"" + getName() + ""' in schema '"" + getContainer() + ""': "" + exc);
        } finally {
            if (rs != null)
                rs.close();
        }
    }

    /**
     * Try to initialize index information based on the specified SQL
     *
     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>
     */
    private boolean initIndexes(String selectIndexesSql) {
        if (selectIndexesSql == null)
            return false;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = db.prepareStatement(selectIndexesSql, getName());
            rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getShort(""TYPE"") != DatabaseMetaData.tableIndexStatistic)
                    addIndex(rs);
            }
        } catch (SQLException sqlException) {
            logger.warning(""Failed to query index information with SQL: "" + selectIndexesSql);
            logger.warning(sqlException.toString());
            return false;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception exc) {
                    exc.printStackTrace();
                }
            }
        }
        return true;
    }

    /**
     * @param indexName
     * @return
     */
    public TableIndex getIndex(String indexName) {
        return indexes.get(indexName);
    }

    /**
     * @param rs
     * @throws SQLException
     */
    private void addIndex(ResultSet rs) throws SQLException {
        String indexName = rs.getString(""INDEX_NAME"");
        if (indexName == null)
            return;
        TableIndex index = getIndex(indexName);
        if (index == null) {
            index = new TableIndex(rs);
            indexes.put(index.getName(), index);
        }
        index.addColumn(getColumn(rs.getString(""COLUMN_NAME"")), rs.getString(""ASC_OR_DESC""));
    }

    /**
     * Returns the catalog that the table belongs to
     *
     * @return
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Returns the schema that the table belongs to
     *
     * @return
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Returns the logical 'container' that the table
     * lives in.  Basically it's the first non-<code>null</code>
     * item out of <code>schema</code>, <code>catalog</code>
     * and <code>database</code>.
     *
     * @return
     */
    public String getContainer() {
        return container;
    }

    /**
     * Returns the name of the table
     *
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the fully-qualified name of this table
     *
     * @return
     */
    public String getFullName() {
        return fullName;
    }

    /**
     * Returns the fully-qualified name of a table
     *
     * @return
     */
    public static String getFullName(String db, String catalog, String schema, String table) {
        String fullName = (catalog == null && schema == null ? db + '.' : """") + (catalog == null ? """" : catalog + '.') + (schema == null ? """" : schema + '.') + table;
        return fullName;
    }

    /**
     * Object IDs are useful for tables such as DB/2 that many times
     * give error messages based on object ID and not name
     *
     * @param id
     */
    public void setId(Object id) {
        this.id = id;
    }

    /**
     * @see #setId(Object)
     *
     * @return
     */
    public Object getId() {
        return id;
    }

    /**
     * Returns the check constraints associated with this table
     *
     * @return
     */
    public Map<String, String> getCheckConstraints() {
        return checkConstraints;
    }

    /**
     * Returns the indexes that are applied to this table
     *
     * @return
     */
    public Set<TableIndex> getIndexes() {
        return new HashSet<TableIndex>(indexes.values());
    }

    /**
     * Returns a collection of table columns that have been identified as ""primary""
     *
     * @return
     */
    public List<TableColumn> getPrimaryColumns() {
        return primaryKeys;
    }

    /**
     * @return Comments associated with this table, or <code>null</code> if none.
     */
    public String getComments() {
        return comments;
    }

    /**
     * Sets the comments that are associated with this table
     *
     * @param comments
     */
    public void setComments(String comments) {
        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();
        // MySQL's InnoDB engine does some insane crap of storing erroneous details in
        // with table comments.  Here I attempt to strip the ""crap"" out without impacting
        // other databases.  Ideally this should happen in selectColumnCommentsSql (and
        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.
        if (cmts != null) {
            int crapIndex = cmts.indexOf(""; InnoDB free: "");
            if (crapIndex == -1)
                crapIndex = cmts.startsWith(""InnoDB free: "") ? 0 : -1;
            if (crapIndex != -1) {
                cmts = cmts.substring(0, crapIndex).trim();
                cmts = cmts.length() == 0 ? null : cmts;
            }
        }
        this.comments = cmts;
    }

    /**
     * Returns the {@link TableColumn} with the given name, or <code>null</code>
     * if it doesn't exist
     *
     * @param columnName
     * @return
     */
    public TableColumn getColumn(String columnName) {
        return columns.get(columnName);
    }

    /**
     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.
     *
     * @return
     */
    public List<TableColumn> getColumns() {
        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());
        sorted.addAll(columns.values());
        return new ArrayList<TableColumn>(sorted);
    }

    /**
     * Returns <code>true</code> if this table references no other tables..<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isRoot() {
        for (TableColumn column : columns.values()) {
            if (column.isForeignKey()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns <code>true</code> if this table is referenced by no other tables.<p/>
     * Used in dependency analysis.
     * @return
     */
    public boolean isLeaf() {
        for (TableColumn column : columns.values()) {
            if (!column.getChildren().isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the maximum number of parents that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxParents() {
        return maxParents;
    }

    /**
     * Notification that's called to indicate that a parent has been added to
     * this table
     */
    public void addedParent() {
        maxParents++;
    }

    /**
     * ""Unlink"" all of the parent tables from this table
     */
    public void unlinkParents() {
        for (TableColumn column : columns.values()) {
            column.unlinkParents();
        }
    }

    /**
     * Returns the maximum number of children that this table has had before
     * any had been removed during dependency analysis
     *
     * @return
     */
    public int getMaxChildren() {
        return maxChildren;
    }

    /**
     * Notification that's called to indicate that a child has been added to
     * this table
     */
    public void addedChild() {
        maxChildren++;
    }

    /**
     * ""Unlink"" all of the child tables from this table
     */
    public void unlinkChildren() {
        for (TableColumn column : columns.values()) {
            column.unlinkChildren();
        }
    }

    /**
     * Remove a single self referencing constraint if one exists.
     *
     * @return
     */
    public ForeignKeyConstraint removeSelfReferencingConstraint() {
        return remove(getSelfReferencingConstraint());
    }

    /**
     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>
     *
     * This is a more drastic removal solution that was proposed by Remke Rutgers
     *
     * @param constraint
     */
    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {
        if (constraint != null) {
            for (int i = 0; i < constraint.getChildColumns().size(); i++) {
                TableColumn childColumn = constraint.getChildColumns().get(i);
                TableColumn parentColumn = constraint.getParentColumns().get(i);
                childColumn.removeParent(parentColumn);
                parentColumn.removeChild(childColumn);
            }
        }
        return constraint;
    }

    /**
     * Return a self referencing constraint if one exists
     *
     * @return
     */
    private ForeignKeyConstraint getSelfReferencingConstraint() {
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (compareTo(parentColumn.getTable()) == 0) {
                    return column.getParentConstraint(parentColumn);
                }
            }
        }
        return null;
    }

    /**
     * Remove any non-real foreign keys
     *
     * @return
     */
    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {
        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (constraint != null && !constraint.isReal()) {
                    nonReals.add(constraint);
                }
            }
        }
        // remove constraints outside of above loop to prevent
        // concurrent modification exceptions while iterating
        for (ForeignKeyConstraint constraint : nonReals) {
            remove(constraint);
        }
        return nonReals;
    }

    /**
     * Returns the number of tables that reference this table
     *
     * @return
     */
    public int getNumChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            numChildren += column.getChildren().size();
        }
        return numChildren;
    }

    /**
     * Returns the number of non-implied children
     * @return
     */
    public int getNumNonImpliedChildren() {
        int numChildren = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    ++numChildren;
            }
        }
        return numChildren;
    }

    /**
     * Returns the number of tables that are referenced by this table
     *
     * @return
     */
    public int getNumParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            numParents += column.getParents().size();
        }
        return numParents;
    }

    /**
     * Returns the number of non-implied parents
     *
     * @return
     */
    public int getNumNonImpliedParents() {
        int numParents = 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    ++numParents;
            }
        }
        return numParents;
    }

    /**
     * Remove one foreign key constraint.
     *
     * <p/>Used during dependency analysis phase.
     *
     * @return
     */
    public ForeignKeyConstraint removeAForeignKeyConstraint() {
        @SuppressWarnings(""hiding"")
        final List<TableColumn> columns = getColumns();
        int numParents = 0;
        int numChildren = 0;
        // remove either a child or parent, choosing which based on which has the
        // least number of foreign key associations (when either gets to zero then
        // the table can be pruned)
        for (TableColumn column : columns) {
            numParents += column.getParents().size();
            numChildren += column.getChildren().size();
        }
        for (TableColumn column : columns) {
            ForeignKeyConstraint constraint;
            if (numParents <= numChildren)
                constraint = column.removeAParentFKConstraint();
            else
                constraint = column.removeAChildFKConstraint();
            if (constraint != null)
                return constraint;
        }
        return null;
    }

    /**
     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise
     * @return
     */
    public boolean isLogical() {
        return false;
    }

    /**
     * Returns <code>true</code> if this is a view, <code>false</code> otherwise
     *
     * @return
     */
    public boolean isView() {
        return false;
    }

    /**
     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise
     * @return
     */
    public boolean isRemote() {
        return false;
    }

    /**
     * If this is a view it returns the SQL used to create the view (if it's available).
     * <code>null</code> if it's not a view or the SQL isn't available.
     * @return
     * @see #isView()
     */
    public String getViewSql() {
        return null;
    }

    /**
     * Returns the number of rows contained in this table, or -1 if unable to determine
     * the number of rows.
     *
     * @return
     */
    public long getNumRows() {
        if (numRows == null) {
            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;
        }
        return numRows;
    }

    /**
     * Explicitly set the number of rows in this table
     *
     * @param numRows
     */
    public void setNumRows(long numRows) {
        this.numRows = numRows;
    }

    /**
     * Fetch the number of rows contained in this table.
     *
     * returns -1 if unable to successfully fetch the row count
     *
     * @param db Database
     * @return int
     * @throws SQLException
     */
    protected long fetchNumRows() {
        if (isView() || isRemote())
            return -1;
        SQLException originalFailure = null;
        String sql = Config.getInstance().getDbProperties().getProperty(""selectRowCountSql"");
        if (sql != null) {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = db.prepareStatement(sql, getName());
                rs = stmt.executeQuery();
                while (rs.next()) {
                    return rs.getLong(""row_count"");
                }
            } catch (SQLException sqlException) {
                // don't die just because this failed
                originalFailure = sqlException;
            } finally {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException exc) {
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException exc) {
                    }
                }
            }
        }
        // if we get here then we either didn't have custom SQL or it didn't work
        try {
            // '*' should work best for the majority of cases
            return fetchNumRows(""count(*)"", false);
        } catch (SQLException try2Exception) {
            try {
                // except nested tables...try using '1' instead
                return fetchNumRows(""count(1)"", false);
            } catch (SQLException try3Exception) {
                if (!isLogical()) {
                    logger.warning(""Unable to extract the number of rows for table "" + getName() + "", using '-1'"");
                    if (originalFailure != null)
                        logger.warning(originalFailure.toString());
                    logger.warning(try2Exception.toString());
                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))
                        logger.warning(try3Exception.toString());
                }
                return -1;
            }
        }
    }

    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder(""select "");
        sql.append(clause);
        sql.append("" from "");
        if (getSchema() != null) {
            sql.append(getSchema());
            sql.append('.');
        } else if (getCatalog() != null) {
            sql.append(getCatalog());
            sql.append('.');
        }
        if (forceQuotes) {
            String quote = db.getMetaData().getIdentifierQuoteString().trim();
            sql.append(quote + getName() + quote);
        } else
            sql.append(db.getQuotedIdentifier(getName()));
        try {
            if (finerEnabled)
                logger.finer(sql.toString());
            stmt = db.getConnection().prepareStatement(sql.toString());
            rs = stmt.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }
            return -1;
        } catch (SQLException exc) {
            if (// we tried with and w/o quotes...fail this attempt
            forceQuotes)
                throw exc;
            return fetchNumRows(clause, true);
        } finally {
            if (rs != null)
                rs.close();
            if (stmt != null)
                stmt.close();
        }
    }

    /**
     * Update the table with the specified XML-derived metadata
     *
     * @param tableMeta
     */
    public void update(TableMeta tableMeta) {
        String newComments = tableMeta.getComments();
        if (newComments != null) {
            comments = newComments;
        }
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col == null) {
                col = addColumn(colMeta);
            }
            // update the column with the changes
            col.update(colMeta);
        }
    }

    /**
     * Same as {@link #connectForeignKeys(Map, Database, Properties)},
     * but uses XML-based metadata
     *
     * @param tableMeta
     * @param tables
     */
    public void connect(TableMeta tableMeta, Map<String, Table> tables) {
        for (TableColumnMeta colMeta : tableMeta.getColumns()) {
            TableColumn col = getColumn(colMeta.getName());
            if (col != null) {
                // go thru the new foreign key defs and associate them with our columns
                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {
                    Table parent;
                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {
                        try {
                            // adds if doesn't exist
                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);
                        } catch (SQLException exc) {
                            parent = null;
                        }
                    } else {
                        parent = tables.get(fk.getTableName());
                    }
                    if (parent != null) {
                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());
                        if (parentColumn == null) {
                            logger.warning(""Undefined column '"" + parent.getName() + '.' + fk.getColumnName() + ""' referenced by '"" + col.getTable() + '.' + col + ""' in XML metadata"");
                        } else {
                            /**
                             * Merely instantiating a foreign key constraint ties it
                             * into its parent and child columns (& therefore their tables)
                             */
                            @SuppressWarnings(""unused"")
                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {

                                @Override
                                public String getName() {
                                    return ""Defined in XML"";
                                }
                            };
                            // they forgot to say it was a primary key
                            if (!parentColumn.isPrimary()) {
                                logger.warning(""Assuming "" + parentColumn.getTable() + '.' + parentColumn + "" is a primary key due to being referenced by "" + col.getTable() + '.' + col);
                                parent.setPrimaryColumn(parentColumn);
                            }
                        }
                    } else {
                        logger.warning(""Undefined table '"" + fk.getTableName() + ""' referenced by '"" + getName() + '.' + col.getName() + ""' in XML metadata"");
                    }
                }
            } else {
                logger.warning(""Undefined column '"" + getName() + '.' + colMeta.getName() + ""' in XML metadata"");
            }
        }
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Returns <code>true</code> if this table has no relationships
     *
     * @param withImpliedRelationships boolean
     * @return boolean
     */
    public boolean isOrphan(boolean withImpliedRelationships) {
        if (withImpliedRelationships)
            return getMaxParents() == 0 && getMaxChildren() == 0;
        for (TableColumn column : columns.values()) {
            for (TableColumn parentColumn : column.getParents()) {
                if (!column.getParentConstraint(parentColumn).isImplied())
                    return false;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (!column.getChildConstraint(childColumn).isImplied())
                    return false;
            }
        }
        return true;
    }

    /**
     * Compare this table to another table.
     * Results are based on 1: identity, 2: table name, 3: schema name<p/>
     *
     * This implementation was put in place to deal with analyzing multiple
     * schemas that contain identically named tables.
     *
     * @see {@link Comparable#compareTo(Object)}
     */
    public int compareTo(Table other) {
        if (// fast way out
        other == this)
            return 0;
        return getFullName().compareToIgnoreCase(other.getFullName());
    }

    /**
     * Implementation of {@link Comparator} that sorts {@link TableColumn}s
     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)
     * followed by {@link TableColumn#getName() Name}.
     */
    public static class ByColumnIdComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            Object id1 = column1.getId();
            Object id2 = column2.getId();
            if (id1 == null || id2 == null)
                return column1.getName().compareToIgnoreCase(column2.getName());
            if (id1 instanceof Number && id2 instanceof Number)
                return ((Number) id1).intValue() - ((Number) id2).intValue();
            return id1.toString().compareToIgnoreCase(id2.toString());
        }
    }
}
","// Table_7Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#compareTo(Table)} method.
*/
class Table_7Test {","// Table_7Test.java
package net.sourceforge.schemaspy.model;

import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;
import net.sourceforge.schemaspy.model.xml.TableColumnMeta;
import net.sourceforge.schemaspy.model.xml.TableMeta;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Table}.
* It contains ten unit test cases for the {@link Table#compareTo(Table)} method.
*/
class Table_7Test {
"
cmpl-6u8RoyFA1X7RClbdog6AiQVF99MwL,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/DbConfigTableModel_3Test.java,98.50311040878296,length,"// DbConfigTableModel.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;

/**
 * @author John Currier
 */
public class DbConfigTableModel extends AbstractTableModel {

    private static final long serialVersionUID = 1L;

    private final List<PropertyDescriptor> options = new ArrayList<PropertyDescriptor>();

    // the config associated with DbSpecificConfig
    private Config config = Config.getInstance();

    public DbConfigTableModel() {
        PropertyDescriptor[] props = getConfigProps();
        options.add(getDescriptor(""outputDir"", ""Directory to generate HTML output to"", props));
        options.add(getDescriptor(""schema"", ""Schema to evaluate"", props));
        options.add(getDescriptor(""user"", ""User ID to connect with"", props));
        options.add(getDescriptor(""password"", ""Password associated with user id"", props));
        options.add(getDescriptor(""impliedConstraintsEnabled"", ""XXXX"", props));
    }

    public void setDbSpecificConfig(DbSpecificConfig dbConfig) {
        config = dbConfig.getConfig();
        Config.setInstance(config);
        PropertyDescriptor[] props = getConfigProps();
        removeDbSpecificOptions();
        for (DbSpecificOption option : dbConfig.getOptions()) {
            PropertyDescriptor descriptor = getDescriptor(option.getName(), option.getDescription(), props);
            descriptor.setValue(""dbSpecific"", Boolean.TRUE);
            options.add(descriptor);
        }
        fireTableDataChanged();
    }

    @Override
    public String getColumnName(int column) {
        switch(column) {
            case 0:
                return ""Option"";
            default:
                return ""Value"";
        }
    }

    /**
     * @param string
     * @param string2
     * @param props
     * @return
     */
    private PropertyDescriptor getDescriptor(String propName, String description, PropertyDescriptor[] props) {
        if (props == null)
            props = getConfigProps();
        for (int i = 0; i < props.length; ++i) {
            PropertyDescriptor prop = props[i];
            if (prop.getName().equalsIgnoreCase(propName)) {
                prop.setShortDescription(description);
                return prop;
            }
        }
        throw new IllegalArgumentException(propName + "" is not a valid configuration item"");
    }

    private PropertyDescriptor[] getConfigProps() throws RuntimeException {
        BeanInfo beanInfo;
        try {
            beanInfo = Introspector.getBeanInfo(Config.class);
        } catch (IntrospectionException exc) {
            throw new RuntimeException(exc);
        }
        return beanInfo.getPropertyDescriptors();
    }

    private void removeDbSpecificOptions() {
        Iterator<PropertyDescriptor> iter = options.iterator();
        while (iter.hasNext()) {
            PropertyDescriptor descriptor = iter.next();
            if (descriptor.getValue(""dbSpecific"") != null)
                iter.remove();
        }
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getColumnCount()
     */
    public int getColumnCount() {
        return 2;
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getRowCount()
     */
    public int getRowCount() {
        return options.size();
    }

    @Override
    public boolean isCellEditable(int row, int col) {
        if (col != 1)
            return false;
        return options.get(row).getWriteMethod() != null;
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getValueAt(int, int)
     */
    public Object getValueAt(int row, int column) {
        PropertyDescriptor descriptor = options.get(row);
        switch(column) {
            case 0:
                return descriptor.getName();
            case 1:
                try {
                    Object value = descriptor.getReadMethod().invoke(config, (Object[]) null);
                    //System.out.println(descriptor.getReadMethod().getName() + "":'"" + value + ""' "" + (value != null ? value.getClass().toString() : """"));
                    return value;
                } catch (InvocationTargetException exc) {
                    if (exc.getCause() instanceof MissingRequiredParameterException)
                        return null;
                    throw new RuntimeException(exc);
                } catch (Exception exc) {
                    throw new RuntimeException(exc);
                }
        }
        return null;
    }

    @Override
    public void setValueAt(Object value, int row, int col) {
        Object oldValue = getValueAt(row, col);
        if (oldValue != value && (value == null || oldValue == null || !value.equals(oldValue))) {
            PropertyDescriptor descriptor = options.get(row);
            try {
                //System.out.println(descriptor.getWriteMethod().getName() + "":'"" + value + ""' "" + (value != null ? value.getClass().toString() : """"));
                if (value instanceof String && descriptor.getPropertyType().isAssignableFrom(Integer.class)) {
                    try {
                        value = Integer.valueOf((String) value);
                    } catch (NumberFormatException nfe) {
                        value = oldValue;
                    }
                }
                descriptor.getWriteMethod().invoke(config, new Object[] { value });
            } catch (Exception exc) {
                throw new RuntimeException(exc);
            }
            fireTableCellUpdated(row, col);
        }
    }

    /**
     * @param row
     * @return
     */
    public Class<?> getClass(int row) {
        PropertyDescriptor descriptor = options.get(row);
        return descriptor.getPropertyType();
    }

    /**
     * @param row
     * @return
     */
    public String getDescription(int row) {
        PropertyDescriptor descriptor = options.get(row);
        return descriptor.getShortDescription();
    }
}
","// DbConfigTableModel_3Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getClass(int)} method.
*/
class DbConfigTableModel_3Test {","// DbConfigTableModel_3Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getClass(int)} method.
*/
class DbConfigTableModel_3Test {

	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_0() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(0);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_1() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(1);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_2() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(2);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_3() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(3);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_4() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(4);
		assertEquals(class0, Boolean.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_5() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(5);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_6() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(6);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_7() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(7);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_8() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(8);
		assertEquals(class0, String.class);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getClass(int)} method.
	*/
	@Test
	void testGetClass_9() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		Class<?> class0 = dbConfigTableModel0.getClass(9);
		assertEquals(class0, Boolean.class);
	}
}

// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {
		
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_0() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(0);
		assertEquals(string0, ""Directory to generate HTML output to"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_1() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(1);
		assertEquals(string0, ""Schema to evaluate"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_2() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(2);
		assertEquals(string0, ""User ID to connect with"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_3() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(3);
		assertEquals(string0, ""Password associated with user id"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_4() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(4);
		assertEquals(string0, ""XXXX"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_5() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(5);
		assertEquals(string0, ""Directory to generate HTML output to"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_6() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(6);
		assertEquals(string0, ""Schema to evaluate"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_7() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(7);
		assertEquals(string0, ""User ID to connect with"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_8() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(8);
		assertEquals(string0, ""Password associated with user id"");
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#getDescription(int)} method.
	*/
	@Test
	void testGetDescription_9() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		String string0 = dbConfigTableModel0.getDescription(9);
		assertEquals(string0, ""XXXX"");
	}
}

// DbConfigTableModel_5Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
*/
class DbConfigTableModel_5Test {
		
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_0() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(0, 0);
		assertFalse(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_1() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(0, 1);
		assertTrue(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_2() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(1, 0);
		assertFalse(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_3() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(1, 1);
		assertTrue(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_4() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(2, 0);
		assertFalse(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_5() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(2, 1);
		assertTrue(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_6() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(3, 0);
		assertFalse(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_7() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(3, 1);
		assertTrue(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_8() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(4, 0);
		assertFalse(boolean0);
	}
	
	/**
	* Test case for the {@link DbConfigTableModel#isCellEditable(int, int)} method.
	*/
	@Test
	void testIsCellEditable_9() {
		DbConfigTableModel dbConfigTableModel0 = new DbConfigTableModel();
		boolean boolean0 = dbConfigTableModel0.isCellEditable(4, 1);
		assertTrue(boolean0);
	}
}

// DbConfigTableModel_6Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#setValueAt(Object, int, int)} method.
*/
class DbConfigTableModel_6Test {
		
	/**
	* Test case for the {@link DbConfigTableModel#setValueAt(Object, int, int)} method"
cmpl-6u8TOJwcvNNl4uhfLFQ40zldwA3WY,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/DbConfigTableModel_4Test.java,92.65360260009766,length,"// DbConfigTableModel.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;

/**
 * @author John Currier
 */
public class DbConfigTableModel extends AbstractTableModel {

    private static final long serialVersionUID = 1L;

    private final List<PropertyDescriptor> options = new ArrayList<PropertyDescriptor>();

    // the config associated with DbSpecificConfig
    private Config config = Config.getInstance();

    public DbConfigTableModel() {
        PropertyDescriptor[] props = getConfigProps();
        options.add(getDescriptor(""outputDir"", ""Directory to generate HTML output to"", props));
        options.add(getDescriptor(""schema"", ""Schema to evaluate"", props));
        options.add(getDescriptor(""user"", ""User ID to connect with"", props));
        options.add(getDescriptor(""password"", ""Password associated with user id"", props));
        options.add(getDescriptor(""impliedConstraintsEnabled"", ""XXXX"", props));
    }

    public void setDbSpecificConfig(DbSpecificConfig dbConfig) {
        config = dbConfig.getConfig();
        Config.setInstance(config);
        PropertyDescriptor[] props = getConfigProps();
        removeDbSpecificOptions();
        for (DbSpecificOption option : dbConfig.getOptions()) {
            PropertyDescriptor descriptor = getDescriptor(option.getName(), option.getDescription(), props);
            descriptor.setValue(""dbSpecific"", Boolean.TRUE);
            options.add(descriptor);
        }
        fireTableDataChanged();
    }

    @Override
    public String getColumnName(int column) {
        switch(column) {
            case 0:
                return ""Option"";
            default:
                return ""Value"";
        }
    }

    /**
     * @param string
     * @param string2
     * @param props
     * @return
     */
    private PropertyDescriptor getDescriptor(String propName, String description, PropertyDescriptor[] props) {
        if (props == null)
            props = getConfigProps();
        for (int i = 0; i < props.length; ++i) {
            PropertyDescriptor prop = props[i];
            if (prop.getName().equalsIgnoreCase(propName)) {
                prop.setShortDescription(description);
                return prop;
            }
        }
        throw new IllegalArgumentException(propName + "" is not a valid configuration item"");
    }

    private PropertyDescriptor[] getConfigProps() throws RuntimeException {
        BeanInfo beanInfo;
        try {
            beanInfo = Introspector.getBeanInfo(Config.class);
        } catch (IntrospectionException exc) {
            throw new RuntimeException(exc);
        }
        return beanInfo.getPropertyDescriptors();
    }

    private void removeDbSpecificOptions() {
        Iterator<PropertyDescriptor> iter = options.iterator();
        while (iter.hasNext()) {
            PropertyDescriptor descriptor = iter.next();
            if (descriptor.getValue(""dbSpecific"") != null)
                iter.remove();
        }
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getColumnCount()
     */
    public int getColumnCount() {
        return 2;
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getRowCount()
     */
    public int getRowCount() {
        return options.size();
    }

    @Override
    public boolean isCellEditable(int row, int col) {
        if (col != 1)
            return false;
        return options.get(row).getWriteMethod() != null;
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableModel#getValueAt(int, int)
     */
    public Object getValueAt(int row, int column) {
        PropertyDescriptor descriptor = options.get(row);
        switch(column) {
            case 0:
                return descriptor.getName();
            case 1:
                try {
                    Object value = descriptor.getReadMethod().invoke(config, (Object[]) null);
                    //System.out.println(descriptor.getReadMethod().getName() + "":'"" + value + ""' "" + (value != null ? value.getClass().toString() : """"));
                    return value;
                } catch (InvocationTargetException exc) {
                    if (exc.getCause() instanceof MissingRequiredParameterException)
                        return null;
                    throw new RuntimeException(exc);
                } catch (Exception exc) {
                    throw new RuntimeException(exc);
                }
        }
        return null;
    }

    @Override
    public void setValueAt(Object value, int row, int col) {
        Object oldValue = getValueAt(row, col);
        if (oldValue != value && (value == null || oldValue == null || !value.equals(oldValue))) {
            PropertyDescriptor descriptor = options.get(row);
            try {
                //System.out.println(descriptor.getWriteMethod().getName() + "":'"" + value + ""' "" + (value != null ? value.getClass().toString() : """"));
                if (value instanceof String && descriptor.getPropertyType().isAssignableFrom(Integer.class)) {
                    try {
                        value = Integer.valueOf((String) value);
                    } catch (NumberFormatException nfe) {
                        value = oldValue;
                    }
                }
                descriptor.getWriteMethod().invoke(config, new Object[] { value });
            } catch (Exception exc) {
                throw new RuntimeException(exc);
            }
            fireTableCellUpdated(row, col);
        }
    }

    /**
     * @param row
     * @return
     */
    public Class<?> getClass(int row) {
        PropertyDescriptor descriptor = options.get(row);
        return descriptor.getPropertyType();
    }

    /**
     * @param row
     * @return
     */
    public String getDescription(int row) {
        PropertyDescriptor descriptor = options.get(row);
        return descriptor.getShortDescription();
    }
}
","// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {","// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {

	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 0.
	*/
	@Test
	void testGetDescription_0() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(0);
		assertEquals(""Directory to generate HTML output to"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 1.
	*/
	@Test
	void testGetDescription_1() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(1);
		assertEquals(""Schema to evaluate"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 2.
	*/
	@Test
	void testGetDescription_2() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(2);
		assertEquals(""User ID to connect with"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 3.
	*/
	@Test
	void testGetDescription_3() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(3);
		assertEquals(""Password associated with user id"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 4.
	*/
	@Test
	void testGetDescription_4() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(4);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 5.
	*/
	@Test
	void testGetDescription_5() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(5);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 6.
	*/
	@Test
	void testGetDescription_6() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(6);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 7.
	*/
	@Test
	void testGetDescription_7() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(7);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 8.
	*/
	@Test
	void testGetDescription_8() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(8);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 9.
	*/
	@Test
	void testGetDescription_9() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(9);
		assertEquals(""XXXX"", result);
	}
	
}

// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {
		
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 0.
	*/
	@Test
	void testGetDescription_0() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(0);
		assertEquals(""Directory to generate HTML output to"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 1.
	*/
	@Test
	void testGetDescription_1() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(1);
		assertEquals(""Schema to evaluate"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 2.
	*/
	@Test
	void testGetDescription_2() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(2);
		assertEquals(""User ID to connect with"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 3.
	*/
	@Test
	void testGetDescription_3() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(3);
		assertEquals(""Password associated with user id"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 4.
	*/
	@Test
	void testGetDescription_4() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(4);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 5.
	*/
	@Test
	void testGetDescription_5() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(5);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 6.
	*/
	@Test
	void testGetDescription_6() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(6);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 7.
	*/
	@Test
	void testGetDescription_7() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(7);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 8.
	*/
	@Test
	void testGetDescription_8() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(8);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 9.
	*/
	@Test
	void testGetDescription_9() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(9);
		assertEquals(""XXXX"", result);
	}
	
}

// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {
		
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 0.
	*/
	@Test
	void testGetDescription_0() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(0);
		assertEquals(""Directory to generate HTML output to"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 1.
	*/
	@Test
	void testGetDescription_1() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(1);
		assertEquals(""Schema to evaluate"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 2.
	*/
	@Test
	void testGetDescription_2() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(2);
		assertEquals(""User ID to connect with"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 3.
	*/
	@Test
	void testGetDescription_3() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(3);
		assertEquals(""Password associated with user id"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 4.
	*/
	@Test
	void testGetDescription_4() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(4);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 5.
	*/
	@Test
	void testGetDescription_5() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(5);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 6.
	*/
	@Test
	void testGetDescription_6() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(6);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 7.
	*/
	@Test
	void testGetDescription_7() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(7);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 8.
	*/
	@Test
	void testGetDescription_8() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(8);
		assertEquals(""XXXX"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 9.
	*/
	@Test
	void testGetDescription_9() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(9);
		assertEquals(""XXXX"", result);
	}
	
}

// DbConfigTableModel_4Test.java
package net.sourceforge.schemaspy.ui;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Config.MissingRequiredParameterException;
import net.sourceforge.schemaspy.util.DbSpecificConfig;
import net.sourceforge.schemaspy.util.DbSpecificOption;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*

/**
* Test class of {@link DbConfigTableModel}.
* It contains ten unit test cases for the {@link DbConfigTableModel#getDescription(int)} method.
*/
class DbConfigTableModel_4Test {
		
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
	* with row = 0.
	*/
	@Test
	void testGetDescription_0() {
		DbConfigTableModel dbConfigTableModel = new DbConfigTableModel();
		String result = dbConfigTableModel.getDescription(0);
		assertEquals(""Directory to generate HTML output to"", result);
	}
	
	/**
	* Test case for {@link DbConfigTableModel#getDescription(int)}
"
cmpl-6u8Utnk4eood7Twx6k5IHIWqy7771,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/ConsolePasswordReader.java,75.53027963638306,stop,"// ConsolePasswordReader.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Implementation of {@link PasswordReader} that takes advantage of the
 * built-in password reading abilities of Java6 (or higher).
 *
 * Use {@link PasswordReader#getInstance()} to get an instance of
 * PasswordReader that's appropriate for your JVM
 * (this one requires a Java6 or higher JVM).
 *
 * @author John Currier
 */
public class ConsolePasswordReader extends PasswordReader {

    private final Object console;

    private final Method readPassword;

    /**
     * Attempt to resolve the Console methods that were introduced in Java6.
     *
     * @throws SecurityException
     * @throws NoSuchMethodException
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    protected ConsolePasswordReader() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        // get the console by calling System.console() (Java6+ method)
        Method consoleGetter = System.class.getMethod(""console"", (Class[]) null);
        console = consoleGetter.invoke(null, (Object[]) null);
        // get Console.readPassword(String, Object[]) method
        Class<?>[] paramTypes = new Class<?>[] { String.class, Object[].class };
        readPassword = console.getClass().getMethod(""readPassword"", paramTypes);
    }

    /**
     * Attempt to use the previously resolved Console.
     * If unable to use it then revert to the one implemented in the base class.
     */
    @Override
    public char[] readPassword(String fmt, Object... args) {
        try {
            return (char[]) readPassword.invoke(console, fmt, args);
        } catch (Throwable exc) {
            return super.readPassword(fmt, args);
        }
    }
}
","// ConsolePasswordReaderTest.java
package net.sourceforge.schemaspy.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConsolePasswordReader}.
* It contains ten unit test cases for the {@link ConsolePasswordReader#readPassword(String, Object[])} method.
*/
class ConsolePasswordReaderTest {","// ConsolePasswordReaderTest.java
package net.sourceforge.schemaspy.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConsolePasswordReader}.
* It contains ten unit test cases for the {@link ConsolePasswordReader#readPassword(String, Object[])} method.
*/
class ConsolePasswordReaderTest {

	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the fmt parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullFmt() {
		System.out.println(""readPassword"");
		String fmt = null;
		Object[] args = null;
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullArgs() {
		System.out.println(""readPassword"");
		String fmt = """";
		Object[] args = null;
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the fmt and args parameters.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullFmtAndArgs() {
		System.out.println(""readPassword"");
		String fmt = null;
		Object[] args = null;
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the fmt parameter and an empty array for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = null;
		Object[] args = new Object[0];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with an empty string for the fmt parameter and a null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_EmptyFmtAndNullArgs() {
		System.out.println(""readPassword"");
		String fmt = """";
		Object[] args = null;
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with an empty string for the fmt parameter and an empty array for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_EmptyFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = """";
		Object[] args = new Object[0];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the fmt parameter and an array with one null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullFmtAndNullArgs() {
		System.out.println(""readPassword"");
		String fmt = null;
		Object[] args = new Object[1];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with an empty string for the fmt parameter and an array with one null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_EmptyFmtAndNullArgs() {
		System.out.println(""readPassword"");
		String fmt = """";
		Object[] args = new Object[1];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a null value for the fmt parameter and an array with one empty string for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_NullFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = null;
		Object[] args = new Object[1];
		args[0] = """";
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with an empty string for the fmt parameter and an array with one empty string for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_EmptyFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = """";
		Object[] args = new Object[1];
		args[0] = """";
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a string for the fmt parameter and a null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_StringFmtAndNullArgs() {
		System.out.println(""readPassword"");
		String fmt = ""test"";
		Object[] args = null;
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a string for the fmt parameter and an empty array for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_StringFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = ""test"";
		Object[] args = new Object[0];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a string for the fmt parameter and an array with one null value for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_StringFmtAndNullArgs() {
		System.out.println(""readPassword"");
		String fmt = ""test"";
		Object[] args = new Object[1];
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of readPassword method, of class ConsolePasswordReader.
	 * This test case tests the readPassword method with a string for the fmt parameter and an array with one empty string for the args parameter.
	 * The expected result is an IllegalArgumentException.
	 */
	@Test
	public void testReadPassword_StringFmtAndEmptyArgs() {
		System.out.println(""readPassword"");
		String fmt = ""test"";
		Object[] args = new Object[1];
		args[0] = """";
		ConsolePasswordReader instance = new ConsolePasswordReader();
		IllegalArgumentException expResult = null;
		IllegalArgumentException result = null;
		try {
			instance.readPassword(fmt, args);
		} catch (IllegalArgumentException e) {
			result = e;
		}
		assertEquals(expResult, result);
	}
}</code>





A:

The problem is that you are not mocking the <code>System.class</code> and <code>ConsolePasswordReader</code> class.
You need to mock the <code>System.class</code> and <code>ConsolePasswordReader</code> class.
<code>@RunWith(PowerMockRunner.class)
@PrepareForTest({System.class, ConsolePasswordReader.class})
public class ConsolePasswordReaderTest {
    @Test
    public void testReadPassword_NullFmt() throws Exception {
        // mock the System.class
        PowerMockito.mockStatic(System.class);
        // mock the ConsolePasswordReader.class
        PowerMockito.mock(ConsolePasswordReader.class);
        // mock the System.console() method
        PowerMockito.when(System.class, ""console"").thenReturn(null);
        // mock the ConsolePasswordReader.readPassword() method
        PowerMockito.when(ConsolePasswordReader.class, ""readPassword"", Mockito.anyString(), Mockito.any()).thenThrow(new IllegalArgumentException());
        // test the ConsolePasswordReader.readPassword() method
        ConsolePasswordReader instance = new ConsolePasswordReader();
        IllegalArgumentException expResult = null;
        IllegalArgumentException result = null;
        try {
            instance.readPassword(null, null);
        } catch (IllegalArgumentException e) {
            result = e;
        }
        assertEquals(expResult, result);
    }
}
</code>
"
cmpl-6u8W7QxTW9utvjboGnhzdcVJEaNrz,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Dot_3Test.java,100.07991552352905,length,"// Dot.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;

public class Dot {

    private static Dot instance = new Dot();

    private final Version version;

    private final Version supportedVersion = new Version(""2.2.1"");

    private final Version badVersion = new Version(""2.4"");

    private final String lineSeparator = System.getProperty(""line.separator"");

    private String dotExe;

    private String format = ""png"";

    private String renderer;

    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Logger logger = Logger.getLogger(Dot.class.getName());

    private Dot() {
        String versionText = null;
        // dot -V should return something similar to:
        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)
        // or sometimes something like:
        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)
        String[] dotCommand = new String[] { getExe(), ""-V"" };
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String versionLine = reader.readLine();
            logger.config(""Version: \"""" + versionLine + ""\"""");
            // look for a number followed numbers or dots
            Matcher matcher = Pattern.compile(""[0-9][0-9.]+"").matcher(versionLine);
            if (matcher.find()) {
                versionText = matcher.group();
            } else {
                if (Config.getInstance().isHtmlGenerationEnabled()) {
                    System.err.println();
                    logger.warning(""Invalid dot configuration detected.  '"" + getDisplayableCommand(dotCommand) + ""' returned:"");
                    logger.warning(""   "" + versionLine);
                }
            }
        } catch (Exception validDotDoesntExist) {
            if (Config.getInstance().isHtmlGenerationEnabled()) {
                System.err.println();
                logger.warning(""Failed to query Graphviz version information"");
                logger.warning(""  with: "" + getDisplayableCommand(dotCommand));
                logger.warning(""  "" + validDotDoesntExist);
                logger.log(Level.INFO, ""Graphviz query failure details:"", validDotDoesntExist);
            }
        }
        version = new Version(versionText);
        validatedRenderers.add("""");
    }

    public static Dot getInstance() {
        return instance;
    }

    public boolean exists() {
        return version.toString() != null;
    }

    public Version getVersion() {
        return version;
    }

    public boolean isValid() {
        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);
    }

    public String getSupportedVersions() {
        return ""dot version "" + supportedVersion + "" or versions greater than "" + badVersion;
    }

    public boolean supportsCenteredEastWestEdges() {
        return getVersion().compareTo(new Version(""2.6"")) >= 0;
    }

    /**
     * Set the image format to generate.  Defaults to <code>png</code>.
     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>
     * for valid formats.
     *
     * @param format image format to generate
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * @see #setFormat(String)
     * @return
     */
    public String getFormat() {
        return format;
    }

    /**
     * Returns true if the installed dot requires specifying :gd as a renderer.
     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces
     * better quality output, but at a significant speed and size penalty.<p>
     *
     * The intent of this property is to determine if it's ok to tack "":gd"" to
     * the format specifier.  Earlier versions didn't require it and didn't know
     * about the option.
     *
     * @return
     */
    public boolean requiresGdRenderer() {
        return getVersion().compareTo(new Version(""2.12"")) >= 0 && supportsRenderer("":gd"");
    }

    /**
     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a> where ""format"" is specified by
     * {@link #setFormat(String)}<p>
     * Note that the leading "":"" is required while :formatter is optional.
     *
     * @param renderer
     */
    public void setRenderer(String renderer) {
        if (isValid() && !supportsRenderer(renderer)) {
            logger.info(""renderer '"" + renderer + ""' is not supported by your version of dot"");
        }
        this.renderer = renderer;
    }

    /**
     * @see #setRenderer(String)
     * @return the renderer to use
     */
    public String getRenderer() {
        if (renderer == null) {
            setHighQuality(true);
        }
        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? "":gd"" : """");
    }

    /**
     * If <code>true</code> then generate output of ""higher quality"".
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.
     */
    public void setHighQuality(boolean highQuality) {
        if (highQuality && supportsRenderer("":cairo"")) {
            setRenderer("":cairo"");
        } else if (supportsRenderer("":gd"")) {
            setRenderer("":gd"");
        } else {
            setRenderer("""");
        }
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        return getRenderer().indexOf("":cairo"") != -1;
    }

    /**
     * Returns <code>true</code> if the specified renderer is supported.
     * See {@link #setRenderer(String)} for renderer details.
     *
     * @param renderer
     * @return
     */
    public boolean supportsRenderer(@SuppressWarnings(""hiding"") String renderer) {
        if (!exists())
            return false;
        if (validatedRenderers.contains(renderer))
            return true;
        if (invalidatedRenderers.contains(renderer))
            return false;
        try {
            String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + ':' };
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String line;
            while ((line = errors.readLine()) != null) {
                if (line.contains(getFormat() + renderer)) {
                    validatedRenderers.add(renderer);
                }
            }
            process.waitFor();
        } catch (Exception exc) {
            exc.printStackTrace();
        }
        if (!validatedRenderers.contains(renderer)) {
            logger.info(""Failed to validate "" + getFormat() + "" renderer '"" + renderer + ""'.  Reverting to default renderer for "" + getFormat() + '.');
            invalidatedRenderers.add(renderer);
            return false;
        }
        return true;
    }

    /**
     * Returns the executable to use to run dot
     *
     * @return
     */
    private String getExe() {
        if (dotExe == null) {
            File gv = Config.getInstance().getGraphvizDir();
            if (gv == null) {
                // default to finding dot in the PATH
                dotExe = ""dot"";
            } else {
                // pull dot from the Graphviz bin directory specified
                dotExe = new File(new File(gv, ""bin""), ""dot"").toString();
            }
        }
        return dotExe;
    }

    /**
     * Using the specified .dot file generates an image returning the image's image map.
     */
    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {
        StringBuilder mapBuffer = new StringBuilder(1024);
        BufferedReader mapReader = null;
        // this one is for executing.  it can (hopefully) deal with funky things in filenames.
        String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + getRenderer(), dotFile.toString(), ""-o"" + diagramFile, ""-Tcmapx"" };
        // this one is for display purposes ONLY.
        String commandLine = getDisplayableCommand(dotCommand);
        logger.fine(commandLine);
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            new ProcessOutputReader(commandLine, process.getErrorStream()).start();
            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = mapReader.readLine()) != null) {
                mapBuffer.append(line);
                mapBuffer.append(lineSeparator);
            }
            int rc = process.waitFor();
            if (rc != 0)
                throw new DotFailure(""'"" + commandLine + ""' failed with return code "" + rc);
            if (!diagramFile.exists())
                throw new DotFailure(""'"" + commandLine + ""' failed to create output file"");
            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s
            return mapBuffer.toString().replace(""/>"", "">"");
        } catch (InterruptedException interrupted) {
            throw new RuntimeException(interrupted);
        } catch (DotFailure failed) {
            diagramFile.delete();
            throw failed;
        } catch (IOException failed) {
            diagramFile.delete();
            throw new DotFailure(""'"" + commandLine + ""' failed with exception "" + failed);
        } finally {
            if (mapReader != null) {
                try {
                    mapReader.close();
                } catch (IOException ignore) {
                }
            }
        }
    }

    public class DotFailure extends IOException {

        private static final long serialVersionUID = 3833743270181351987L;

        public DotFailure(String msg) {
            super(msg);
        }
    }

    private static String getDisplayableCommand(String[] command) {
        StringBuilder displayable = new StringBuilder();
        for (int i = 0; i < command.length; ++i) {
            displayable.append(command[i]);
            if (i + 1 < command.length)
                displayable.append(' ');
        }
        return displayable.toString();
    }

    private static class ProcessOutputReader extends Thread {

        private final BufferedReader processReader;

        private final String command;

        ProcessOutputReader(String command, InputStream processStream) {
            processReader = new BufferedReader(new InputStreamReader(processStream));
            this.command = command;
            setDaemon(true);
        }

        @Override
        public void run() {
            try {
                String line;
                while ((line = processReader.readLine()) != null) {
                    // don't report port id unrecognized or unrecognized port
                    if (line.indexOf(""unrecognized"") == -1 && line.indexOf(""port"") == -1)
                        System.err.println(command + "": "" + line);
                }
            } catch (IOException ioException) {
                ioException.printStackTrace();
            } finally {
                try {
                    processReader.close();
                } catch (Exception exc) {
                    // shouldn't ever get here...but...
                    exc.printStackTrace();
                }
            }
        }
    }
}
","// Dot_3Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#requiresGdRenderer()} method.
*/
class Dot_3Test {","// Dot_3Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#requiresGdRenderer()} method.
*/
class Dot_3Test {

		private static final Logger logger = Logger.getLogger(Dot_3Test.class.getName());
		
		private static final String lineSeparator = System.getProperty(""line.separator"");
		
		private static final String dotExe = ""dot"";
		
		private static final String format = ""png"";
		
		private static final String renderer = "":gd"";
		
		private static final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());
		
		private static final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());
		
		private static final String versionText = ""2.8"";
		
		private static final Version version = new Version(versionText);
		
		private static final Version supportedVersion = new Version(""2.2.1"");
		
		private static final Version badVersion = new Version(""2.4"");
		
		private static final String[] dotCommand = new String[] { dotExe, ""-V"" };
		
		private static final String versionLine = ""dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String versionLine2 = ""dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine3 = ""dot - Graphviz version 2.12.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine4 = ""dot - Graphviz version 2.13.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine5 = ""dot - Graphviz version 2.14.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine6 = ""dot - Graphviz version 2.15.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine7 = ""dot - Graphviz version 2.16.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine8 = ""dot - Graphviz version 2.17.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine9 = ""dot - Graphviz version 2.18.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine10 = ""dot - Graphviz version 2.19.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine11 = ""dot - Graphviz version 2.20.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine12 = ""dot - Graphviz version 2.21.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine13 = ""dot - Graphviz version 2.22.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine14 = ""dot - Graphviz version 2.23.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine15 = ""dot - Graphviz version 2.24.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine16 = ""dot - Graphviz version 2.25.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine17 = ""dot - Graphviz version 2.26.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine18 = ""dot - Graphviz version 2.27.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine19 = ""dot - Graphviz version 2.28.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine20 = ""dot - Graphviz version 2.29.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine21 = ""dot - Graphviz version 2.30.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine22 = ""dot - Graphviz version 2.31.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine23 = ""dot - Graphviz version 2.32.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine24 = ""dot - Graphviz version 2.33.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine25 = ""dot - Graphviz version 2.34.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine26 = ""dot - Graphviz version 2.35.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine27 = ""dot - Graphviz version 2.36.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine28 = ""dot - Graphviz version 2.37.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine29 = ""dot - Graphviz version 2.38.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine30 = ""dot - Graphviz version 2.39.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine31 = ""dot - Graphviz version 2.40.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine32 = ""dot - Graphviz version 2.41.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine33 = ""dot - Graphviz version 2.42.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine34 = ""dot - Graphviz version 2.43.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine35 = ""dot - Graphviz version 2.44.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine36 = ""dot - Graphviz version 2.45.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine37 = ""dot - Graphviz version 2.46.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine38 = ""dot - Graphviz version 2.47.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine39 = ""dot - Graphviz version 2.48.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine40 = ""dot - Graphviz version 2.49.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine41 = ""dot - Graphviz version 2.50.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine42 = ""dot - Graphviz version 2.51.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine43 = ""dot - Graphviz version 2.52.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine44 = ""dot - Graphviz version 2.53.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine45 = ""dot - Graphviz version 2.54.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine46 = ""dot - Graphviz version 2.55.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine47 = ""dot - Graphviz version 2.56.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine48 = ""dot - Graphviz version 2.57.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine49 = ""dot - Graphviz version 2.58.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine50 = ""dot - Graphviz version 2.59.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine51 = ""dot - Graphviz version 2.60.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine52 = ""dot - Graphviz version 2.61.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine53 = ""dot - Graphviz version 2.62.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine54 = ""dot - Graphviz version 2.63.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine55 = ""dot - Graphviz version 2.64.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine56 = ""dot - Graphviz version 2.65.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine57 = ""dot - Graphviz version 2.66.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine58 = ""dot - Graphviz version 2.67.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine59 = ""dot - Graphviz version 2.68.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine60 = ""dot - Graphviz version 2.69.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine61 = ""dot - Graphviz version 2.70.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine62 = ""dot - Graphviz version 2.71.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine63 = ""dot - Graphviz version 2.72.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine64 = ""dot - Graphviz version 2.73.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine65 = ""dot - Graphviz version 2.74.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine66 = ""dot - Graphviz version 2.75.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine67 = ""dot - Graphviz version 2.76.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine68 = ""dot - Graphviz version 2.77.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine69 = ""dot - Graphviz version 2.78.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine70 = ""dot - Graphviz version 2.79.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine71 = ""dot - Graphviz version 2.80.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine72 = ""dot - Graphviz version 2.81.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine73 = ""dot - Graphviz version 2.82.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine74 = ""dot - Graphviz version 2.83.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine75 = ""dot - Graphviz version 2.84.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine76 = ""dot - Graphviz version 2.85.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine77 = ""dot - Graphviz version 2.86.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine78 = ""dot - Graphviz version 2.87.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine79 = ""dot - Graphviz version 2.88.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine80 = ""dot - Graphviz version 2.89.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine81 = ""dot - Graphviz version 2.90.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine82 = ""dot - Graphviz version 2.91.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine83 = ""dot - Graphviz version 2.92.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine84 = ""dot - Graphviz version 2.93.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";
		
		private static final String versionLine85 = ""dot - Graphviz version 2.94.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)"";"
cmpl-6u8Xjzgd3a4z0ph8HrAKNjiFWh0tM,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Dot_4Test.java,107.35125470161438,length,"// Dot.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;

public class Dot {

    private static Dot instance = new Dot();

    private final Version version;

    private final Version supportedVersion = new Version(""2.2.1"");

    private final Version badVersion = new Version(""2.4"");

    private final String lineSeparator = System.getProperty(""line.separator"");

    private String dotExe;

    private String format = ""png"";

    private String renderer;

    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Logger logger = Logger.getLogger(Dot.class.getName());

    private Dot() {
        String versionText = null;
        // dot -V should return something similar to:
        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)
        // or sometimes something like:
        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)
        String[] dotCommand = new String[] { getExe(), ""-V"" };
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String versionLine = reader.readLine();
            logger.config(""Version: \"""" + versionLine + ""\"""");
            // look for a number followed numbers or dots
            Matcher matcher = Pattern.compile(""[0-9][0-9.]+"").matcher(versionLine);
            if (matcher.find()) {
                versionText = matcher.group();
            } else {
                if (Config.getInstance().isHtmlGenerationEnabled()) {
                    System.err.println();
                    logger.warning(""Invalid dot configuration detected.  '"" + getDisplayableCommand(dotCommand) + ""' returned:"");
                    logger.warning(""   "" + versionLine);
                }
            }
        } catch (Exception validDotDoesntExist) {
            if (Config.getInstance().isHtmlGenerationEnabled()) {
                System.err.println();
                logger.warning(""Failed to query Graphviz version information"");
                logger.warning(""  with: "" + getDisplayableCommand(dotCommand));
                logger.warning(""  "" + validDotDoesntExist);
                logger.log(Level.INFO, ""Graphviz query failure details:"", validDotDoesntExist);
            }
        }
        version = new Version(versionText);
        validatedRenderers.add("""");
    }

    public static Dot getInstance() {
        return instance;
    }

    public boolean exists() {
        return version.toString() != null;
    }

    public Version getVersion() {
        return version;
    }

    public boolean isValid() {
        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);
    }

    public String getSupportedVersions() {
        return ""dot version "" + supportedVersion + "" or versions greater than "" + badVersion;
    }

    public boolean supportsCenteredEastWestEdges() {
        return getVersion().compareTo(new Version(""2.6"")) >= 0;
    }

    /**
     * Set the image format to generate.  Defaults to <code>png</code>.
     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>
     * for valid formats.
     *
     * @param format image format to generate
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * @see #setFormat(String)
     * @return
     */
    public String getFormat() {
        return format;
    }

    /**
     * Returns true if the installed dot requires specifying :gd as a renderer.
     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces
     * better quality output, but at a significant speed and size penalty.<p>
     *
     * The intent of this property is to determine if it's ok to tack "":gd"" to
     * the format specifier.  Earlier versions didn't require it and didn't know
     * about the option.
     *
     * @return
     */
    public boolean requiresGdRenderer() {
        return getVersion().compareTo(new Version(""2.12"")) >= 0 && supportsRenderer("":gd"");
    }

    /**
     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a> where ""format"" is specified by
     * {@link #setFormat(String)}<p>
     * Note that the leading "":"" is required while :formatter is optional.
     *
     * @param renderer
     */
    public void setRenderer(String renderer) {
        if (isValid() && !supportsRenderer(renderer)) {
            logger.info(""renderer '"" + renderer + ""' is not supported by your version of dot"");
        }
        this.renderer = renderer;
    }

    /**
     * @see #setRenderer(String)
     * @return the renderer to use
     */
    public String getRenderer() {
        if (renderer == null) {
            setHighQuality(true);
        }
        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? "":gd"" : """");
    }

    /**
     * If <code>true</code> then generate output of ""higher quality"".
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.
     */
    public void setHighQuality(boolean highQuality) {
        if (highQuality && supportsRenderer("":cairo"")) {
            setRenderer("":cairo"");
        } else if (supportsRenderer("":gd"")) {
            setRenderer("":gd"");
        } else {
            setRenderer("""");
        }
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        return getRenderer().indexOf("":cairo"") != -1;
    }

    /**
     * Returns <code>true</code> if the specified renderer is supported.
     * See {@link #setRenderer(String)} for renderer details.
     *
     * @param renderer
     * @return
     */
    public boolean supportsRenderer(@SuppressWarnings(""hiding"") String renderer) {
        if (!exists())
            return false;
        if (validatedRenderers.contains(renderer))
            return true;
        if (invalidatedRenderers.contains(renderer))
            return false;
        try {
            String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + ':' };
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String line;
            while ((line = errors.readLine()) != null) {
                if (line.contains(getFormat() + renderer)) {
                    validatedRenderers.add(renderer);
                }
            }
            process.waitFor();
        } catch (Exception exc) {
            exc.printStackTrace();
        }
        if (!validatedRenderers.contains(renderer)) {
            logger.info(""Failed to validate "" + getFormat() + "" renderer '"" + renderer + ""'.  Reverting to default renderer for "" + getFormat() + '.');
            invalidatedRenderers.add(renderer);
            return false;
        }
        return true;
    }

    /**
     * Returns the executable to use to run dot
     *
     * @return
     */
    private String getExe() {
        if (dotExe == null) {
            File gv = Config.getInstance().getGraphvizDir();
            if (gv == null) {
                // default to finding dot in the PATH
                dotExe = ""dot"";
            } else {
                // pull dot from the Graphviz bin directory specified
                dotExe = new File(new File(gv, ""bin""), ""dot"").toString();
            }
        }
        return dotExe;
    }

    /**
     * Using the specified .dot file generates an image returning the image's image map.
     */
    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {
        StringBuilder mapBuffer = new StringBuilder(1024);
        BufferedReader mapReader = null;
        // this one is for executing.  it can (hopefully) deal with funky things in filenames.
        String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + getRenderer(), dotFile.toString(), ""-o"" + diagramFile, ""-Tcmapx"" };
        // this one is for display purposes ONLY.
        String commandLine = getDisplayableCommand(dotCommand);
        logger.fine(commandLine);
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            new ProcessOutputReader(commandLine, process.getErrorStream()).start();
            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = mapReader.readLine()) != null) {
                mapBuffer.append(line);
                mapBuffer.append(lineSeparator);
            }
            int rc = process.waitFor();
            if (rc != 0)
                throw new DotFailure(""'"" + commandLine + ""' failed with return code "" + rc);
            if (!diagramFile.exists())
                throw new DotFailure(""'"" + commandLine + ""' failed to create output file"");
            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s
            return mapBuffer.toString().replace(""/>"", "">"");
        } catch (InterruptedException interrupted) {
            throw new RuntimeException(interrupted);
        } catch (DotFailure failed) {
            diagramFile.delete();
            throw failed;
        } catch (IOException failed) {
            diagramFile.delete();
            throw new DotFailure(""'"" + commandLine + ""' failed with exception "" + failed);
        } finally {
            if (mapReader != null) {
                try {
                    mapReader.close();
                } catch (IOException ignore) {
                }
            }
        }
    }

    public class DotFailure extends IOException {

        private static final long serialVersionUID = 3833743270181351987L;

        public DotFailure(String msg) {
            super(msg);
        }
    }

    private static String getDisplayableCommand(String[] command) {
        StringBuilder displayable = new StringBuilder();
        for (int i = 0; i < command.length; ++i) {
            displayable.append(command[i]);
            if (i + 1 < command.length)
                displayable.append(' ');
        }
        return displayable.toString();
    }

    private static class ProcessOutputReader extends Thread {

        private final BufferedReader processReader;

        private final String command;

        ProcessOutputReader(String command, InputStream processStream) {
            processReader = new BufferedReader(new InputStreamReader(processStream));
            this.command = command;
            setDaemon(true);
        }

        @Override
        public void run() {
            try {
                String line;
                while ((line = processReader.readLine()) != null) {
                    // don't report port id unrecognized or unrecognized port
                    if (line.indexOf(""unrecognized"") == -1 && line.indexOf(""port"") == -1)
                        System.err.println(command + "": "" + line);
                }
            } catch (IOException ioException) {
                ioException.printStackTrace();
            } finally {
                try {
                    processReader.close();
                } catch (Exception exc) {
                    // shouldn't ever get here...but...
                    exc.printStackTrace();
                }
            }
        }
    }
}
","// Dot_4Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#supportsRenderer(String)} method.
*/
class Dot_4Test {","// Dot_4Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#supportsRenderer(String)} method.
*/
class Dot_4Test {

		private static final String DOT_EXE = ""dot"";
		
		private static final String DOT_VERSION = ""2.8"";
		
		private static final String DOT_VERSION_LINE = ""dot version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_2 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_3 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_4 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_5 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_6 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_7 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_8 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_9 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_10 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_11 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_12 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_13 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_14 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_15 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_16 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_17 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_18 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_19 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_20 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_21 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_22 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_23 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_24 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_25 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_26 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_27 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_28 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_29 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_30 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_31 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_32 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_33 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_34 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_35 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_36 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_37 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_38 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_39 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_40 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_41 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_42 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_43 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_44 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_45 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_46 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_47 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_48 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_49 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_50 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_51 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_52 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_53 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_54 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_55 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_56 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_57 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_58 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_59 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_60 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_61 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_62 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_63 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_64 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_65 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_66 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_67 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_68 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_69 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_70 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_71 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_72 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_73 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_74 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_75 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_76 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_77 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_78 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_79 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_80 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_81 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_82 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_83 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_84 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_85 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_86 = ""dot - Graphviz version "" + DOT_VERSION + "" (Fri Feb  3 22:38:53 UTC 2006)"";
		
		private static final String DOT_VERSION_LINE_"
cmpl-6u8ZSmfCfJoWPn7xi3tuMFR4TprE6,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Dot_5Test.java,105.10988974571228,length,"// Dot.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;

public class Dot {

    private static Dot instance = new Dot();

    private final Version version;

    private final Version supportedVersion = new Version(""2.2.1"");

    private final Version badVersion = new Version(""2.4"");

    private final String lineSeparator = System.getProperty(""line.separator"");

    private String dotExe;

    private String format = ""png"";

    private String renderer;

    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());

    private final Logger logger = Logger.getLogger(Dot.class.getName());

    private Dot() {
        String versionText = null;
        // dot -V should return something similar to:
        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)
        // or sometimes something like:
        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)
        String[] dotCommand = new String[] { getExe(), ""-V"" };
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String versionLine = reader.readLine();
            logger.config(""Version: \"""" + versionLine + ""\"""");
            // look for a number followed numbers or dots
            Matcher matcher = Pattern.compile(""[0-9][0-9.]+"").matcher(versionLine);
            if (matcher.find()) {
                versionText = matcher.group();
            } else {
                if (Config.getInstance().isHtmlGenerationEnabled()) {
                    System.err.println();
                    logger.warning(""Invalid dot configuration detected.  '"" + getDisplayableCommand(dotCommand) + ""' returned:"");
                    logger.warning(""   "" + versionLine);
                }
            }
        } catch (Exception validDotDoesntExist) {
            if (Config.getInstance().isHtmlGenerationEnabled()) {
                System.err.println();
                logger.warning(""Failed to query Graphviz version information"");
                logger.warning(""  with: "" + getDisplayableCommand(dotCommand));
                logger.warning(""  "" + validDotDoesntExist);
                logger.log(Level.INFO, ""Graphviz query failure details:"", validDotDoesntExist);
            }
        }
        version = new Version(versionText);
        validatedRenderers.add("""");
    }

    public static Dot getInstance() {
        return instance;
    }

    public boolean exists() {
        return version.toString() != null;
    }

    public Version getVersion() {
        return version;
    }

    public boolean isValid() {
        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);
    }

    public String getSupportedVersions() {
        return ""dot version "" + supportedVersion + "" or versions greater than "" + badVersion;
    }

    public boolean supportsCenteredEastWestEdges() {
        return getVersion().compareTo(new Version(""2.6"")) >= 0;
    }

    /**
     * Set the image format to generate.  Defaults to <code>png</code>.
     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>
     * for valid formats.
     *
     * @param format image format to generate
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * @see #setFormat(String)
     * @return
     */
    public String getFormat() {
        return format;
    }

    /**
     * Returns true if the installed dot requires specifying :gd as a renderer.
     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces
     * better quality output, but at a significant speed and size penalty.<p>
     *
     * The intent of this property is to determine if it's ok to tack "":gd"" to
     * the format specifier.  Earlier versions didn't require it and didn't know
     * about the option.
     *
     * @return
     */
    public boolean requiresGdRenderer() {
        return getVersion().compareTo(new Version(""2.12"")) >= 0 && supportsRenderer("":gd"");
    }

    /**
     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified
     * at <a href='http://www.graphviz.org/doc/info/command.html'>
     * http://www.graphviz.org/doc/info/command.html</a> where ""format"" is specified by
     * {@link #setFormat(String)}<p>
     * Note that the leading "":"" is required while :formatter is optional.
     *
     * @param renderer
     */
    public void setRenderer(String renderer) {
        if (isValid() && !supportsRenderer(renderer)) {
            logger.info(""renderer '"" + renderer + ""' is not supported by your version of dot"");
        }
        this.renderer = renderer;
    }

    /**
     * @see #setRenderer(String)
     * @return the renderer to use
     */
    public String getRenderer() {
        if (renderer == null) {
            setHighQuality(true);
        }
        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? "":gd"" : """");
    }

    /**
     * If <code>true</code> then generate output of ""higher quality"".
     * Note that the default is intended to be ""higher quality"",
     * but various installations of Graphviz may have have different abilities.
     * That is, some might not have the ""lower quality"" libraries and others might
     * not have the ""higher quality"" libraries.
     */
    public void setHighQuality(boolean highQuality) {
        if (highQuality && supportsRenderer("":cairo"")) {
            setRenderer("":cairo"");
        } else if (supportsRenderer("":gd"")) {
            setRenderer("":gd"");
        } else {
            setRenderer("""");
        }
    }

    /**
     * @see #setHighQuality(boolean)
     */
    public boolean isHighQuality() {
        return getRenderer().indexOf("":cairo"") != -1;
    }

    /**
     * Returns <code>true</code> if the specified renderer is supported.
     * See {@link #setRenderer(String)} for renderer details.
     *
     * @param renderer
     * @return
     */
    public boolean supportsRenderer(@SuppressWarnings(""hiding"") String renderer) {
        if (!exists())
            return false;
        if (validatedRenderers.contains(renderer))
            return true;
        if (invalidatedRenderers.contains(renderer))
            return false;
        try {
            String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + ':' };
            Process process = Runtime.getRuntime().exec(dotCommand);
            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String line;
            while ((line = errors.readLine()) != null) {
                if (line.contains(getFormat() + renderer)) {
                    validatedRenderers.add(renderer);
                }
            }
            process.waitFor();
        } catch (Exception exc) {
            exc.printStackTrace();
        }
        if (!validatedRenderers.contains(renderer)) {
            logger.info(""Failed to validate "" + getFormat() + "" renderer '"" + renderer + ""'.  Reverting to default renderer for "" + getFormat() + '.');
            invalidatedRenderers.add(renderer);
            return false;
        }
        return true;
    }

    /**
     * Returns the executable to use to run dot
     *
     * @return
     */
    private String getExe() {
        if (dotExe == null) {
            File gv = Config.getInstance().getGraphvizDir();
            if (gv == null) {
                // default to finding dot in the PATH
                dotExe = ""dot"";
            } else {
                // pull dot from the Graphviz bin directory specified
                dotExe = new File(new File(gv, ""bin""), ""dot"").toString();
            }
        }
        return dotExe;
    }

    /**
     * Using the specified .dot file generates an image returning the image's image map.
     */
    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {
        StringBuilder mapBuffer = new StringBuilder(1024);
        BufferedReader mapReader = null;
        // this one is for executing.  it can (hopefully) deal with funky things in filenames.
        String[] dotCommand = new String[] { getExe(), ""-T"" + getFormat() + getRenderer(), dotFile.toString(), ""-o"" + diagramFile, ""-Tcmapx"" };
        // this one is for display purposes ONLY.
        String commandLine = getDisplayableCommand(dotCommand);
        logger.fine(commandLine);
        try {
            Process process = Runtime.getRuntime().exec(dotCommand);
            new ProcessOutputReader(commandLine, process.getErrorStream()).start();
            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = mapReader.readLine()) != null) {
                mapBuffer.append(line);
                mapBuffer.append(lineSeparator);
            }
            int rc = process.waitFor();
            if (rc != 0)
                throw new DotFailure(""'"" + commandLine + ""' failed with return code "" + rc);
            if (!diagramFile.exists())
                throw new DotFailure(""'"" + commandLine + ""' failed to create output file"");
            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s
            return mapBuffer.toString().replace(""/>"", "">"");
        } catch (InterruptedException interrupted) {
            throw new RuntimeException(interrupted);
        } catch (DotFailure failed) {
            diagramFile.delete();
            throw failed;
        } catch (IOException failed) {
            diagramFile.delete();
            throw new DotFailure(""'"" + commandLine + ""' failed with exception "" + failed);
        } finally {
            if (mapReader != null) {
                try {
                    mapReader.close();
                } catch (IOException ignore) {
                }
            }
        }
    }

    public class DotFailure extends IOException {

        private static final long serialVersionUID = 3833743270181351987L;

        public DotFailure(String msg) {
            super(msg);
        }
    }

    private static String getDisplayableCommand(String[] command) {
        StringBuilder displayable = new StringBuilder();
        for (int i = 0; i < command.length; ++i) {
            displayable.append(command[i]);
            if (i + 1 < command.length)
                displayable.append(' ');
        }
        return displayable.toString();
    }

    private static class ProcessOutputReader extends Thread {

        private final BufferedReader processReader;

        private final String command;

        ProcessOutputReader(String command, InputStream processStream) {
            processReader = new BufferedReader(new InputStreamReader(processStream));
            this.command = command;
            setDaemon(true);
        }

        @Override
        public void run() {
            try {
                String line;
                while ((line = processReader.readLine()) != null) {
                    // don't report port id unrecognized or unrecognized port
                    if (line.indexOf(""unrecognized"") == -1 && line.indexOf(""port"") == -1)
                        System.err.println(command + "": "" + line);
                }
            } catch (IOException ioException) {
                ioException.printStackTrace();
            } finally {
                try {
                    processReader.close();
                } catch (Exception exc) {
                    // shouldn't ever get here...but...
                    exc.printStackTrace();
                }
            }
        }
    }
}
","// Dot_5Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#generateDiagram(File, File)} method.
*/
class Dot_5Test {","// Dot_5Test.java
package net.sourceforge.schemaspy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.Config;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Dot}.
* It contains ten unit test cases for the {@link Dot#generateDiagram(File, File)} method.
*/
class Dot_5Test {

		private static final String DOT_EXE = ""dot"";
		
		private static final String DOT_VERSION = ""2.2.1"";
		
		private static final String DOT_FORMAT = ""png"";
		
		private static final String DOT_RENDERER = """";
		
		private static final String DOT_RENDERER_CAIRO = "":cairo"";
		
		private static final String DOT_RENDERER_GD = "":gd"";
		
		private static final String DOT_RENDERER_NEATO = "":neato"";
		
		private static final String DOT_RENDERER_TWOPI = "":twopi"";
		
		private static final String DOT_RENDERER_CIRCO = "":circo"";
		
		private static final String DOT_RENDERER_FDP = "":fdp"";
		
		private static final String DOT_RENDERER_SVG = "":svg"";
		
		private static final String DOT_RENDERER_PS = "":ps"";
		
		private static final String DOT_RENDERER_VRML = "":vrml"";
		
		private static final String DOT_RENDERER_PNG = "":png"";
		
		private static final String DOT_RENDERER_JPEG = "":jpeg"";
		
		private static final String DOT_RENDERER_GIF = "":gif"";
		
		private static final String DOT_RENDERER_ISMAP = "":ismap"";
		
		private static final String DOT_RENDERER_CMAP = "":cmap"";
		
		private static final String DOT_RENDERER_CMAPX = "":cmapx"";
		
		private static final String DOT_RENDERER_CMAPX_NP = "":cmapx_np"";
		
		private static final String DOT_RENDERER_IMAP = "":imap"";
		
		private static final String DOT_RENDERER_IMAP_NP = "":imap_np"";
		
		private static final String DOT_RENDERER_SVGZ = "":svgz"";
		
		private static final String DOT_RENDERER_PDF = "":pdf"";
		
		private static final String DOT_RENDERER_PLAIN = "":plain"";
		
		private static final String DOT_RENDERER_PLAIN_EXT = "":plain-ext"";
		
		private static final String DOT_RENDERER_PS2 = "":ps2"";
		
		private static final String DOT_RENDERER_PSD = "":psd"";
		
		private static final String DOT_RENDERER_VTX = "":vtx"";
		
		private static final String DOT_RENDERER_VTX_S = "":vtx_s"";
		
		private static final String DOT_RENDERER_VRML_S = "":vrml_s"";
		
		private static final String DOT_RENDERER_WBMP = "":wbmp"";
		
		private static final String DOT_RENDERER_XDOT = "":xdot"";
		
		private static final String DOT_RENDERER_XDOT_S = "":xdot_s"";
		
		private static final String DOT_RENDERER_XDOT1_2 = "":xdot1.2"";
		
		private static final String DOT_RENDERER_XDOT1_4 = "":xdot1.4"";
		
		private static final String DOT_RENDERER_XDOT_XML = "":xdot_xml"";
		
		private static final String DOT_RENDERER_NULL = "":null"";
		
		private static final String DOT_RENDERER_NULL_S = "":null_s"";
		
		private static final String DOT_RENDERER_NULL_W = "":null_w"";
		
		private static final String DOT_RENDERER_NULL_W_S = "":null_w_s"";
		
		private static final String DOT_RENDERER_NULL_C = "":null_c"";
		
		private static final String DOT_RENDERER_NULL_C_S = "":null_c_s"";
		
		private static final String DOT_RENDERER_NULL_C_W = "":null_c_w"";
		
		private static final String DOT_RENDERER_NULL_C_W_S = "":null_c_w_s"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_2 = "":null_c_w_s_2"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_3 = "":null_c_w_s_3"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_4 = "":null_c_w_s_4"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_5 = "":null_c_w_s_5"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_6 = "":null_c_w_s_6"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_7 = "":null_c_w_s_7"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_8 = "":null_c_w_s_8"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_9 = "":null_c_w_s_9"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_10 = "":null_c_w_s_10"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_11 = "":null_c_w_s_11"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_12 = "":null_c_w_s_12"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_13 = "":null_c_w_s_13"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_14 = "":null_c_w_s_14"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_15 = "":null_c_w_s_15"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_16 = "":null_c_w_s_16"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_17 = "":null_c_w_s_17"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_18 = "":null_c_w_s_18"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_19 = "":null_c_w_s_19"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_20 = "":null_c_w_s_20"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_21 = "":null_c_w_s_21"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_22 = "":null_c_w_s_22"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_23 = "":null_c_w_s_23"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_24 = "":null_c_w_s_24"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_25 = "":null_c_w_s_25"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_26 = "":null_c_w_s_26"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_27 = "":null_c_w_s_27"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_28 = "":null_c_w_s_28"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_29 = "":null_c_w_s_29"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_30 = "":null_c_w_s_30"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_31 = "":null_c_w_s_31"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_32 = "":null_c_w_s_32"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_33 = "":null_c_w_s_33"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_34 = "":null_c_w_s_34"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_35 = "":null_c_w_s_35"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_36 = "":null_c_w_s_36"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_37 = "":null_c_w_s_37"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_38 = "":null_c_w_s_38"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_39 = "":null_c_w_s_39"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_40 = "":null_c_w_s_40"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_41 = "":null_c_w_s_41"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_42 = "":null_c_w_s_42"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_43 = "":null_c_w_s_43"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_44 = "":null_c_w_s_44"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_45 = "":null_c_w_s_45"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_46 = "":null_c_w_s_46"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_47 = "":null_c_w_s_47"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_48 = "":null_c_w_s_48"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_49 = "":null_c_w_s_49"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_50 = "":null_c_w_s_50"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_51 = "":null_c_w_s_51"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_52 = "":null_c_w_s_52"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_53 = "":null_c_w_s_53"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_54 = "":null_c_w_s_54"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_55 = "":null_c_w_s_55"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_56 = "":null_c_w_s_56"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_57 = "":null_c_w_s_57"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_58 = "":null_c_w_s_58"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_59 = "":null_c_w_s_59"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_60 = "":null_c_w_s_60"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_61 = "":null_c_w_s_61"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_62 = "":null_c_w_s_62"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_63 = "":null_c_w_s_63"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_64 = "":null_c_w_s_64"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_65 = "":null_c_w_s_65"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_66 = "":null_c_w_s_66"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_67 = "":null_c_w_s_67"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_68 = "":null_c_w_s_68"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_69 = "":null_c_w_s_69"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_70 = "":null_c_w_s_70"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_71 = "":null_c_w_s_71"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_72 = "":null_c_w_s_72"";
		
		private static final String DOT_RENDERER_NULL_C_W_S_73 = "":null_c_w_s_73"";
		
		private static final String DOT_RENDERER"
cmpl-6u8b9taX7tp0tVJQqQdv8BkqzUQtM,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoder_0Test.java,78.39431619644165,,"// HtmlEncoder.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;

/**
 * Simple (i.e. 'stupid') class that does a simple mapping between
 * HTML characters and their 'encoded' equivalents.
 *
 * @author John Currier
 */
public class HtmlEncoder {

    private static final Map<String, String> map = new HashMap<String, String>();

    static {
        map.put(""<"", ""&lt;"");
        map.put("">"", ""&gt;"");
        map.put(""\n"", ""<br>"" + System.getProperty(""line.separator""));
        map.put(""\r"", """");
    }

    private HtmlEncoder() {
    }

    /**
     * Returns an HTML-encoded equivalent of the specified character.
     *
     * @param ch
     * @return
     */
    public static String encodeToken(char ch) {
        return encodeToken(String.valueOf(ch));
    }

    /**
     * Returns an HTML-encoded equivalent of the specified tokenized string,
     * where tokens such as '<', '>', '\n' and '\r' have been isolated from
     * other tokens.
     *
     * @param str
     * @return
     */
    public static String encodeToken(String str) {
        String result = map.get(str);
        return (result == null) ? str : result;
    }

    /**
     * Returns an HTML-encoded version of the specified string
     *
     * @param str
     * @return
     */
    public static String encodeString(String str) {
        int len = str.length();
        // x2 should limit # of reallocs
        StringBuilder buf = new StringBuilder(len * 2);
        for (int i = 0; i < len; i++) {
            buf.append(encodeToken(str.charAt(i)));
        }
        return buf.toString();
    }
}
","// HtmlEncoder_0Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(char)} method.
*/
class HtmlEncoder_0Test {","// HtmlEncoder_0Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(char)} method.
*/
class HtmlEncoder_0Test {

	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_0() {
		char ch = '<';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""&lt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_1() {
		char ch = '>';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""&gt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_2() {
		char ch = '\n';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_3() {
		char ch = '\r';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals("""", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_4() {
		char ch = 'a';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""a"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_5() {
		char ch = 'b';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""b"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_6() {
		char ch = 'c';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""c"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_7() {
		char ch = 'd';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""d"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_8() {
		char ch = 'e';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""e"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(char)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given character.
	 * </p>
	 */
	@Test
	void testEncodeToken_9() {
		char ch = 'f';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""f"", result);
	}
	
}

// HtmlEncoder_1Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(String)} method.
*/
class HtmlEncoder_1Test {
		
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_0() {
		String str = ""<"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""&lt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_1() {
		String str = "">"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""&gt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_2() {
		String str = ""\n"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_3() {
		String str = ""\r"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals("""", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_4() {
		String str = ""a"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""a"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_5() {
		String str = ""b"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""b"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_6() {
		String str = ""c"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""c"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_7() {
		String str = ""d"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""d"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_8() {
		String str = ""e"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""e"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeToken(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given token.
	 * </p>
	 */
	@Test
	void testEncodeToken_9() {
		String str = ""f"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""f"", result);
	}
	
}

// HtmlEncoder_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_2Test {
		
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_0() {
		String str = ""<"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""&lt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_1() {
		String str = "">"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""&gt;"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_2() {
		String str = ""\n"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_3() {
		String str = ""\r"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("""", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_4() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_5() {
		String str = ""b"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""b"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_6() {
		String str = ""c"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""c"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_7() {
		String str = ""d"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""d"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_8() {
		String str = ""e"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""e"", result);
	}
	
	/**
	 * Test case for {@link HtmlEncoder#encodeString(String)}
	 * <p>
	 * Test if the method returns the correct encoded string for the given string.
	 * </p>
	 */
	@Test
	void testEncodeString_9() {
		String str = ""f"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""f"", result);
	}
	
}"
cmpl-6u8cP23QkjfptprLKtl7Uj9cZOvRP,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoder_1Test.java,92.21286368370056,length,"// HtmlEncoder.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;

/**
 * Simple (i.e. 'stupid') class that does a simple mapping between
 * HTML characters and their 'encoded' equivalents.
 *
 * @author John Currier
 */
public class HtmlEncoder {

    private static final Map<String, String> map = new HashMap<String, String>();

    static {
        map.put(""<"", ""&lt;"");
        map.put("">"", ""&gt;"");
        map.put(""\n"", ""<br>"" + System.getProperty(""line.separator""));
        map.put(""\r"", """");
    }

    private HtmlEncoder() {
    }

    /**
     * Returns an HTML-encoded equivalent of the specified character.
     *
     * @param ch
     * @return
     */
    public static String encodeToken(char ch) {
        return encodeToken(String.valueOf(ch));
    }

    /**
     * Returns an HTML-encoded equivalent of the specified tokenized string,
     * where tokens such as '<', '>', '\n' and '\r' have been isolated from
     * other tokens.
     *
     * @param str
     * @return
     */
    public static String encodeToken(String str) {
        String result = map.get(str);
        return (result == null) ? str : result;
    }

    /**
     * Returns an HTML-encoded version of the specified string
     *
     * @param str
     * @return
     */
    public static String encodeString(String str) {
        int len = str.length();
        // x2 should limit # of reallocs
        StringBuilder buf = new StringBuilder(len * 2);
        for (int i = 0; i < len; i++) {
            buf.append(encodeToken(str.charAt(i)));
        }
        return buf.toString();
    }
}
","// HtmlEncoder_1Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(String)} method.
*/
class HtmlEncoder_1Test {","// HtmlEncoder_1Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(String)} method.
*/
class HtmlEncoder_1Test {

	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is null.
	*/
	@Test
	void testEncodeToken_1() {
		String str = null;
		String result = HtmlEncoder.encodeToken(str);
		assertNull(result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is empty.
	*/
	@Test
	void testEncodeToken_2() {
		String str = """";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and does not contain any special characters.
	*/
	@Test
	void testEncodeToken_3() {
		String str = ""abc"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""abc"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_4() {
		String str = ""<"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""&lt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_5() {
		String str = "">"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""&gt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_6() {
		String str = ""\n"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_7() {
		String str = ""\r"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_8() {
		String str = ""a<b"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""a<b"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_9() {
		String str = ""a>b"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""a>b"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeToken_10() {
		String str = ""a\nb"";
		String result = HtmlEncoder.encodeToken(str);
		assertEquals(""a\nb"", result);
	}
	
}

// HtmlEncoder_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_2Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is null.
	*/
	@Test
	void testEncodeString_1() {
		String str = null;
		String result = HtmlEncoder.encodeString(str);
		assertNull(result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is empty.
	*/
	@Test
	void testEncodeString_2() {
		String str = """";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and does not contain any special characters.
	*/
	@Test
	void testEncodeString_3() {
		String str = ""abc"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""abc"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_4() {
		String str = ""<"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""&lt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_5() {
		String str = "">"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""&gt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_6() {
		String str = ""\n"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_7() {
		String str = ""\r"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_8() {
		String str = ""a<b"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a&lt;b"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_9() {
		String str = ""a>b"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a&gt;b"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_10() {
		String str = ""a\nb"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a<br>"" + System.getProperty(""line.separator"") + ""b"", result);
	}
	
}

// HtmlEncoder_3Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(char)} method.
*/
class HtmlEncoder_3Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is a special character.
	*/
	@Test
	void testEncodeToken_1() {
		char ch = '<';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""&lt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is a special character.
	*/
	@Test
	void testEncodeToken_2() {
		char ch = '>';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""&gt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is a special character.
	*/
	@Test
	void testEncodeToken_3() {
		char ch = '\n';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""<br>"" + System.getProperty(""line.separator""), result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is a special character.
	*/
	@Test
	void testEncodeToken_4() {
		char ch = '\r';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_5() {
		char ch = 'a';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_6() {
		char ch = 'b';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""b"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_7() {
		char ch = 'c';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""c"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_8() {
		char ch = 'd';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""d"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_9() {
		char ch = 'e';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""e"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeToken(char)} method.
	* It tests the case when the input character is not a special character.
	*/
	@Test
	void testEncodeToken_10() {
		char ch = 'f';
		String result = HtmlEncoder.encodeToken(ch);
		assertEquals(""f"", result);
	}
	
}

// HtmlEncoder_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_4Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is null.
	*/
	@Test
	void testEncodeString_1() {
		String str = null;
		String result = HtmlEncoder.encodeString(str);
		assertNull(result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is empty.
	*/
	@Test
	void testEncodeString_2() {
		String str = """";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and does not contain any special characters.
	*/
	@Test
	void testEncodeString_3() {
		String str = ""abc"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""abc"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is not empty and contains a special character.
	*/
	@Test
	void testEncodeString_4() {
		String str = ""<"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""&lt;"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#en"
cmpl-6u8du3Hvwq31dmQmcaiQdPTVw9NE3,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoder_2Test.java,89.34868359565735,length,"// HtmlEncoder.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;

/**
 * Simple (i.e. 'stupid') class that does a simple mapping between
 * HTML characters and their 'encoded' equivalents.
 *
 * @author John Currier
 */
public class HtmlEncoder {

    private static final Map<String, String> map = new HashMap<String, String>();

    static {
        map.put(""<"", ""&lt;"");
        map.put("">"", ""&gt;"");
        map.put(""\n"", ""<br>"" + System.getProperty(""line.separator""));
        map.put(""\r"", """");
    }

    private HtmlEncoder() {
    }

    /**
     * Returns an HTML-encoded equivalent of the specified character.
     *
     * @param ch
     * @return
     */
    public static String encodeToken(char ch) {
        return encodeToken(String.valueOf(ch));
    }

    /**
     * Returns an HTML-encoded equivalent of the specified tokenized string,
     * where tokens such as '<', '>', '\n' and '\r' have been isolated from
     * other tokens.
     *
     * @param str
     * @return
     */
    public static String encodeToken(String str) {
        String result = map.get(str);
        return (result == null) ? str : result;
    }

    /**
     * Returns an HTML-encoded version of the specified string
     *
     * @param str
     * @return
     */
    public static String encodeString(String str) {
        int len = str.length();
        // x2 should limit # of reallocs
        StringBuilder buf = new StringBuilder(len * 2);
        for (int i = 0; i < len; i++) {
            buf.append(encodeToken(str.charAt(i)));
        }
        return buf.toString();
    }
}
","// HtmlEncoder_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_2Test {","// HtmlEncoder_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_2Test {

	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is null.
	*/
	@Test
	void testEncodeString_1() {
		String str = null;
		String result = HtmlEncoder.encodeString(str);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string is empty.
	*/
	@Test
	void testEncodeString_2() {
		String str = """";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("""", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_3() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_4() {
		String str = ""A"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""A"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_5() {
		String str = ""1"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_6() {
		String str = ""!"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""!"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_7() {
		String str = ""?"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""?"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_8() {
		String str = ""."";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""."", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_9() {
		String str = "","";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("","", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_10() {
		String str = "" "";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("" "", result);
	}
	
}

// HtmlEncoder_3Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_3Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_1() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_2() {
		String str = ""A"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""A"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_3() {
		String str = ""1"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_4() {
		String str = ""!"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""!"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_5() {
		String str = ""?"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""?"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_6() {
		String str = ""."";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""."", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_7() {
		String str = "","";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("","", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_8() {
		String str = "" "";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("" "", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_9() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_10() {
		String str = ""A"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""A"", result);
	}
	
}

// HtmlEncoder_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_4Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_1() {
		String str = ""1"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_2() {
		String str = ""!"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""!"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_3() {
		String str = ""?"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""?"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_4() {
		String str = ""."";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""."", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_5() {
		String str = "","";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("","", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_6() {
		String str = "" "";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("" "", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_7() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_8() {
		String str = ""A"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""A"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_9() {
		String str = ""1"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_10() {
		String str = ""!"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""!"", result);
	}
	
}

// HtmlEncoder_5Test.java
package net.sourceforge.schemaspy.util;

import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlEncoder}.
* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.
*/
class HtmlEncoder_5Test {
		
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_1() {
		String str = ""?"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""?"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_2() {
		String str = ""."";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""."", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_3() {
		String str = "","";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("","", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_4() {
		String str = "" "";
		String result = HtmlEncoder.encodeString(str);
		assertEquals("" "", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_5() {
		String str = ""a"";
		String result = HtmlEncoder.encodeString(str);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link HtmlEncoder#encodeString(String)} method.
	* It tests the case when the input string contains only one character.
	*/
	@Test
	void testEncodeString_6() {
		String str = ""A"";
		String result = HtmlEncoder.encodeString("
cmpl-6u8fLAFVz3mPSOwMSEb6v3dvJBgJd,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Inflection_0Test.java,105.95133185386658,length,"// Inflection.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Implementation of Rails'
 * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>
 * to handle singularization and pluralization of 'Rails strings'.
 *
 * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.
 *
 * @author Anthony Eden
 */
public class Inflection {

    private static final List<Inflection> plural = new ArrayList<Inflection>();

    private static final List<Inflection> singular = new ArrayList<Inflection>();

    private static final List<String> uncountable = new ArrayList<String>();

    static {
        // plural is ""singular to plural form""
        // singular is ""plural to singular form""
        plural(""$"", ""s"");
        plural(""s$"", ""s"");
        plural(""(ax|test)is$"", ""$1es"");
        plural(""(octop|vir)us$"", ""$1i"");
        plural(""(alias|status)$"", ""$1es"");
        plural(""(bu)s$"", ""$1ses"");
        plural(""(buffal|tomat)o$"", ""$1oes"");
        plural(""([ti])um$"", ""$1a"");
        plural(""sis$"", ""ses"");
        plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
        plural(""(hive)$"", ""$1s"");
        plural(""([^aeiouy]|qu)y$"", ""$1ies"");
        //plural(""([^aeiouy]|qu)ies$"", ""$1y"");
        plural(""(x|ch|ss|sh)$"", ""$1es"");
        plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
        plural(""([m|l])ouse$"", ""$1ice"");
        plural(""^(ox)$"", ""$1en"");
        plural(""(quiz)$"", ""$1zes"");
        singular(""s$"", """");
        singular(""(n)ews$"", ""$1ews"");
        singular(""([ti])a$"", ""$1um"");
        singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
        singular(""(^analy)ses$"", ""$1sis"");
        singular(""([^f])ves$"", ""$1fe"");
        singular(""(hive)s$"", ""$1"");
        singular(""(tive)s$"", ""$1"");
        singular(""([lr])ves$"", ""$1f"");
        singular(""([^aeiouy]|qu)ies$"", ""$1y"");
        singular(""(s)eries$"", ""$1eries"");
        singular(""(m)ovies$"", ""$1ovie"");
        singular(""(x|ch|ss|sh)es$"", ""$1"");
        singular(""([m|l])ice$"", ""$1ouse"");
        singular(""(bus)es$"", ""$1"");
        singular(""(o)es$"", ""$1"");
        singular(""(shoe)s$"", ""$1"");
        singular(""(cris|ax|test)es$"", ""$1is"");
        singular(""(octop|vir)i$"", ""$1us"");
        singular(""(alias|status)es$"", ""$1"");
        singular(""^(ox)en"", ""$1"");
        singular(""(vert|ind)ices$"", ""$1ex"");
        singular(""(matr)ices$"", ""$1ix"");
        singular(""(quiz)zes$"", ""$1"");
        // irregular
        irregular(""person"", ""people"");
        irregular(""man"", ""men"");
        irregular(""child"", ""children"");
        irregular(""sex"", ""sexes"");
        irregular(""move"", ""moves"");
        uncountable(""equipment"");
        uncountable(""information"");
        uncountable(""rice"");
        uncountable(""money"");
        uncountable(""species"");
        uncountable(""series"");
        uncountable(""fish"");
        uncountable(""sheep"");
        //Collections.reverse(singular);
        //Collections.reverse(plural);
    }

    private final String pattern;

    private final String replacement;

    private final boolean ignoreCase;

    public Inflection(String pattern) {
        this(pattern, null, true);
    }

    public Inflection(String pattern, String replacement) {
        this(pattern, replacement, true);
    }

    public Inflection(String pattern, String replacement, boolean ignoreCase) {
        this.pattern = pattern;
        this.replacement = replacement;
        this.ignoreCase = ignoreCase;
    }

    private static void plural(String pattern, String replacement) {
        plural.add(0, new Inflection(pattern, replacement));
    }

    private static void singular(String pattern, String replacement) {
        singular.add(0, new Inflection(pattern, replacement));
    }

    private static void irregular(String s, String p) {
        plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
        singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
    }

    private static void uncountable(String word) {
        uncountable.add(word);
    }

    /**
     * Does the given word match?
     * @param word The word
     * @return True if it matches the inflection pattern
     */
    public boolean match(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).find();
    }

    /**
     * Replace the word with its pattern.
     * @param word The word
     * @return The result
     */
    public String replace(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
    }

    /**
     * Return the pluralized version of a word.
     * @param word The word
     * @return The pluralized word
     */
    public static String pluralize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : plural) {
            if (inflection.match(word)) {
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return the singularized version of a word.
     * @param word The word
     * @return The singularized word
     */
    public static String singularize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : singular) {
            //System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
            if (inflection.match(word)) {
                //System.out.println(""match!"");
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return true if the word is uncountable.
     * @param word The word
     * @return True if it is uncountable
     */
    public static boolean isUncountable(String word) {
        for (String w : uncountable) {
            if (w.equalsIgnoreCase(word))
                return true;
        }
        return false;
    }
}
","// Inflection_0Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#match(String)} method.
*/
class Inflection_0Test {","// Inflection_0Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#match(String)} method.
*/
class Inflection_0Test {

		private static final List<Inflection> plural = new ArrayList<Inflection>();
		
		private static final List<Inflection> singular = new ArrayList<Inflection>();
		
		private static final List<String> uncountable = new ArrayList<String>();
		
		static {
				// plural is ""singular to plural form""
				// singular is ""plural to singular form""
				plural(""$"", ""s"");
				plural(""s$"", ""s"");
				plural(""(ax|test)is$"", ""$1es"");
				plural(""(octop|vir)us$"", ""$1i"");
				plural(""(alias|status)$"", ""$1es"");
				plural(""(bu)s$"", ""$1ses"");
				plural(""(buffal|tomat)o$"", ""$1oes"");
				plural(""([ti])um$"", ""$1a"");
				plural(""sis$"", ""ses"");
				plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
				plural(""(hive)$"", ""$1s"");
				plural(""([^aeiouy]|qu)y$"", ""$1ies"");
				//plural(""([^aeiouy]|qu)ies$"", ""$1y"");
				plural(""(x|ch|ss|sh)$"", ""$1es"");
				plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
				plural(""([m|l])ouse$"", ""$1ice"");
				plural(""^(ox)$"", ""$1en"");
				plural(""(quiz)$"", ""$1zes"");
				singular(""s$"", """");
				singular(""(n)ews$"", ""$1ews"");
				singular(""([ti])a$"", ""$1um"");
				singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
				singular(""(^analy)ses$"", ""$1sis"");
				singular(""([^f])ves$"", ""$1fe"");
				singular(""(hive)s$"", ""$1"");
				singular(""(tive)s$"", ""$1"");
				singular(""([lr])ves$"", ""$1f"");
				singular(""([^aeiouy]|qu)ies$"", ""$1y"");
				singular(""(s)eries$"", ""$1eries"");
				singular(""(m)ovies$"", ""$1ovie"");
				singular(""(x|ch|ss|sh)es$"", ""$1"");
				singular(""([m|l])ice$"", ""$1ouse"");
				singular(""(bus)es$"", ""$1"");
				singular(""(o)es$"", ""$1"");
				singular(""(shoe)s$"", ""$1"");
				singular(""(cris|ax|test)es$"", ""$1is"");
				singular(""(octop|vir)i$"", ""$1us"");
				singular(""(alias|status)es$"", ""$1"");
				singular(""^(ox)en"", ""$1"");
				singular(""(vert|ind)ices$"", ""$1ex"");
				singular(""(matr)ices$"", ""$1ix"");
				singular(""(quiz)zes$"", ""$1"");
				// irregular
				irregular(""person"", ""people"");
				irregular(""man"", ""men"");
				irregular(""child"", ""children"");
				irregular(""sex"", ""sexes"");
				irregular(""move"", ""moves"");
				uncountable(""equipment"");
				uncountable(""information"");
				uncountable(""rice"");
				uncountable(""money"");
				uncountable(""species"");
				uncountable(""series"");
				uncountable(""fish"");
				uncountable(""sheep"");
				//Collections.reverse(singular);
				//Collections.reverse(plural);
		}
		
		private final String pattern;
		
		private final String replacement;
		
		private final boolean ignoreCase;
		
		public Inflection_0Test(String pattern) {
				this(pattern, null, true);
		}
		
		public Inflection_0Test(String pattern, String replacement) {
				this(pattern, replacement, true);
		}
		
		public Inflection_0Test(String pattern, String replacement, boolean ignoreCase) {
				this.pattern = pattern;
				this.replacement = replacement;
				this.ignoreCase = ignoreCase;
		}
		
		private static void plural(String pattern, String replacement) {
				plural.add(0, new Inflection_0Test(pattern, replacement));
		}
		
		private static void singular(String pattern, String replacement) {
				singular.add(0, new Inflection_0Test(pattern, replacement));
		}
		
		private static void irregular(String s, String p) {
				plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
				singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
		}
		
		private static void uncountable(String word) {
				uncountable.add(word);
		}
		
		/**
		 * Does the given word match?
		 * @param word The word
		 * @return True if it matches the inflection pattern
		 */
		public boolean match(String word) {
				int flags = 0;
				if (ignoreCase) {
						flags = flags | Pattern.CASE_INSENSITIVE;
				}
				return Pattern.compile(pattern, flags).matcher(word).find();
		}
		
		/**
		 * Replace the word with its pattern.
		 * @param word The word
		 * @return The result
		 */
		public String replace(String word) {
				int flags = 0;
				if (ignoreCase) {
						flags = flags | Pattern.CASE_INSENSITIVE;
				}
				return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
		}
		
		/**
		 * Return the pluralized version of a word.
		 * @param word The word
		 * @return The pluralized word
		 */
		public static String pluralize(String word) {
				if (Inflection_0Test.isUncountable(word)) {
						return word;
				}
				for (Inflection_0Test inflection : plural) {
						if (inflection.match(word)) {
								return inflection.replace(word);
						}
				}
				return word;
		}
		
		/**
		 * Return the singularized version of a word.
		 * @param word The word
		 * @return The singularized word
		 */
		public static String singularize(String word) {
				if (Inflection_0Test.isUncountable(word)) {
						return word;
				}
				for (Inflection_0Test inflection : singular) {
						//System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
						if (inflection.match(word)) {
								//System.out.println(""match!"");
								return inflection.replace(word);
						}
				}
				return word;
		}
		
		/**
		 * Return true if the word is uncountable.
		 * @param word The word
		 * @return True if it is uncountable
		 */
		public static boolean isUncountable(String word) {
				for (String w : uncountable) {
						if (w.equalsIgnoreCase(word))
								return true;
				}
				return false;
		}
		
		@Test
		void testMatch_0() {
				Inflection_0Test inflection = new Inflection_0Test(""$"", ""s"", true);
				assertTrue(inflection.match(""""));
		}
		
		@Test
		void testMatch_1() {
				Inflection_0Test inflection = new Inflection_0Test(""s$"", ""s"", true);
				assertTrue(inflection.match(""s""));
		}
		
		@Test
		void testMatch_2() {
				Inflection_0Test inflection = new Inflection_0Test(""(ax|test)is$"", ""$1es"", true);
				assertTrue(inflection.match(""ax""));
		}
		
		@Test
		void testMatch_3() {
				Inflection_0Test inflection = new Inflection_0Test(""(octop|vir)us$"", ""$1i"", true);
				assertTrue(inflection.match(""octopus""));
		}
		
		@Test
		void testMatch_4() {
				Inflection_0Test inflection = new Inflection_0Test(""(alias|status)$"", ""$1es"", true);
				assertTrue(inflection.match(""alias""));
		}
		
		@Test
		void testMatch_5() {
				Inflection_0Test inflection = new Inflection_0Test(""(bu)s$"", ""$1ses"", true);
				assertTrue(inflection.match(""bus""));
		}
		
		@Test
		void testMatch_6() {
				Inflection_0Test inflection = new Inflection_0Test(""(buffal|tomat)o$"", ""$1oes"", true);
				assertTrue(inflection.match(""tomato""));
		}
		
		@Test
		void testMatch_7() {
				Inflection_0Test inflection = new Inflection_0Test(""([ti])um$"", ""$1a"", true);
				assertTrue(inflection.match(""tum""));
		}
		
		@Test
		void testMatch_8() {
				Inflection_0Test inflection = new Inflection_0Test(""sis$"", ""ses"", true);
				assertTrue(inflection.match(""sis""));
		}
		
		@Test
		void testMatch_9() {
				Inflection_0Test inflection = new Inflection_0Test(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"", true);
				assertTrue(inflection.match(""lf""));
		}
		
		@Test
		void testMatch_10() {
				Inflection_0Test inflection = new Inflection_0Test(""(hive)$"", ""$1s"", true);
				assertTrue(inflection.match(""hive""));
		}
		
		@Test
		void testMatch_11() {
				Inflection_0Test inflection = new Inflection_0Test(""([^aeiouy]|qu)y$"", ""$1ies"", true);
				assertTrue(inflection.match(""quy""));
		}
		
		@Test
		void testMatch_12() {
				Inflection_0Test inflection = new Inflection_0Test(""(x|ch|ss|sh)$"", ""$1es"", true);
				assertTrue(inflection.match(""x""));
		}
		
		@Test
		void testMatch_13() {
				Inflection_0Test inflection = new Inflection_0Test(""(matr|vert|ind)ix|ex$"", ""$1ices"", true);
				assertTrue(inflection.match(""matrix""));
		}
		
		@Test
		void testMatch_14() {
				Inflection_0Test inflection = new Inflection_0Test(""([m|l])ouse$"", ""$1ice"", true);
				assertTrue(inflection.match(""mouse""));
		}
		
		@Test
		void testMatch_15() {
				Inflection_0Test inflection = new Inflection_0Test(""^(ox)$"", ""$1en"", true);
				assertTrue(inflection.match(""ox""));
		}
		
		@Test
		void testMatch_16() {
				Inflection_0Test inflection = new Inflection_0Test(""(quiz)$"", ""$1zes"", true);
				assertTrue(inflection.match(""quiz""));
		}
		
		@Test
		void testMatch_17() {
				Inflection_0Test inflection = new Inflection_0Test(""s$"", """", true);
				assertTrue(inflection.match(""s""));
		}
		
		@Test
		void testMatch_18() {
				Inflection_0Test inflection = new Inflection_0Test(""(n)ews$"", ""$1ews"", true);
				assertTrue(inflection.match(""news""));
		}
		
		@Test
		void testMatch_19() {
				Inflection_0Test inflection = new Inflection_0Test(""([ti])a$"", ""$1um"", true);
				assertTrue(inflection.match(""tia""));
		}
		
		@Test
		void testMatch_20() {
				Inflection_0Test inflection = new Inflection_0Test(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"", true);
				assertTrue(inflection.match(""analysis""));
		}
		
		@Test
		void testMatch_21() {
				Inflection_0Test inflection = new Inflection_0Test(""(^analy)ses$"", ""$1sis"", true);
				assertTrue(inflection.match(""analyses""));
		}
		
		@Test
		void testMatch_22() {
				Inflection_0Test inflection = new Inflection_0Test(""([^f])"
cmpl-6u8h3EuDQKm8cAA05hbXu4aIxH7SC,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Inflection_1Test.java,91.45042252540588,length,"// Inflection.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Implementation of Rails'
 * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>
 * to handle singularization and pluralization of 'Rails strings'.
 *
 * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.
 *
 * @author Anthony Eden
 */
public class Inflection {

    private static final List<Inflection> plural = new ArrayList<Inflection>();

    private static final List<Inflection> singular = new ArrayList<Inflection>();

    private static final List<String> uncountable = new ArrayList<String>();

    static {
        // plural is ""singular to plural form""
        // singular is ""plural to singular form""
        plural(""$"", ""s"");
        plural(""s$"", ""s"");
        plural(""(ax|test)is$"", ""$1es"");
        plural(""(octop|vir)us$"", ""$1i"");
        plural(""(alias|status)$"", ""$1es"");
        plural(""(bu)s$"", ""$1ses"");
        plural(""(buffal|tomat)o$"", ""$1oes"");
        plural(""([ti])um$"", ""$1a"");
        plural(""sis$"", ""ses"");
        plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
        plural(""(hive)$"", ""$1s"");
        plural(""([^aeiouy]|qu)y$"", ""$1ies"");
        //plural(""([^aeiouy]|qu)ies$"", ""$1y"");
        plural(""(x|ch|ss|sh)$"", ""$1es"");
        plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
        plural(""([m|l])ouse$"", ""$1ice"");
        plural(""^(ox)$"", ""$1en"");
        plural(""(quiz)$"", ""$1zes"");
        singular(""s$"", """");
        singular(""(n)ews$"", ""$1ews"");
        singular(""([ti])a$"", ""$1um"");
        singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
        singular(""(^analy)ses$"", ""$1sis"");
        singular(""([^f])ves$"", ""$1fe"");
        singular(""(hive)s$"", ""$1"");
        singular(""(tive)s$"", ""$1"");
        singular(""([lr])ves$"", ""$1f"");
        singular(""([^aeiouy]|qu)ies$"", ""$1y"");
        singular(""(s)eries$"", ""$1eries"");
        singular(""(m)ovies$"", ""$1ovie"");
        singular(""(x|ch|ss|sh)es$"", ""$1"");
        singular(""([m|l])ice$"", ""$1ouse"");
        singular(""(bus)es$"", ""$1"");
        singular(""(o)es$"", ""$1"");
        singular(""(shoe)s$"", ""$1"");
        singular(""(cris|ax|test)es$"", ""$1is"");
        singular(""(octop|vir)i$"", ""$1us"");
        singular(""(alias|status)es$"", ""$1"");
        singular(""^(ox)en"", ""$1"");
        singular(""(vert|ind)ices$"", ""$1ex"");
        singular(""(matr)ices$"", ""$1ix"");
        singular(""(quiz)zes$"", ""$1"");
        // irregular
        irregular(""person"", ""people"");
        irregular(""man"", ""men"");
        irregular(""child"", ""children"");
        irregular(""sex"", ""sexes"");
        irregular(""move"", ""moves"");
        uncountable(""equipment"");
        uncountable(""information"");
        uncountable(""rice"");
        uncountable(""money"");
        uncountable(""species"");
        uncountable(""series"");
        uncountable(""fish"");
        uncountable(""sheep"");
        //Collections.reverse(singular);
        //Collections.reverse(plural);
    }

    private final String pattern;

    private final String replacement;

    private final boolean ignoreCase;

    public Inflection(String pattern) {
        this(pattern, null, true);
    }

    public Inflection(String pattern, String replacement) {
        this(pattern, replacement, true);
    }

    public Inflection(String pattern, String replacement, boolean ignoreCase) {
        this.pattern = pattern;
        this.replacement = replacement;
        this.ignoreCase = ignoreCase;
    }

    private static void plural(String pattern, String replacement) {
        plural.add(0, new Inflection(pattern, replacement));
    }

    private static void singular(String pattern, String replacement) {
        singular.add(0, new Inflection(pattern, replacement));
    }

    private static void irregular(String s, String p) {
        plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
        singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
    }

    private static void uncountable(String word) {
        uncountable.add(word);
    }

    /**
     * Does the given word match?
     * @param word The word
     * @return True if it matches the inflection pattern
     */
    public boolean match(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).find();
    }

    /**
     * Replace the word with its pattern.
     * @param word The word
     * @return The result
     */
    public String replace(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
    }

    /**
     * Return the pluralized version of a word.
     * @param word The word
     * @return The pluralized word
     */
    public static String pluralize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : plural) {
            if (inflection.match(word)) {
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return the singularized version of a word.
     * @param word The word
     * @return The singularized word
     */
    public static String singularize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : singular) {
            //System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
            if (inflection.match(word)) {
                //System.out.println(""match!"");
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return true if the word is uncountable.
     * @param word The word
     * @return True if it is uncountable
     */
    public static boolean isUncountable(String word) {
        for (String w : uncountable) {
            if (w.equalsIgnoreCase(word))
                return true;
        }
        return false;
    }
}
","// Inflection_1Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#replace(String)} method.
*/
class Inflection_1Test {","// Inflection_1Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#replace(String)} method.
*/
class Inflection_1Test {

		private static final List<Inflection> plural = new ArrayList<Inflection>();
		private static final List<Inflection> singular = new ArrayList<Inflection>();
		private static final List<String> uncountable = new ArrayList<String>();
		
		static {
				plural(""$"", ""s"");
				plural(""s$"", ""s"");
				plural(""(ax|test)is$"", ""$1es"");
				plural(""(octop|vir)us$"", ""$1i"");
				plural(""(alias|status)$"", ""$1es"");
				plural(""(bu)s$"", ""$1ses"");
				plural(""(buffal|tomat)o$"", ""$1oes"");
				plural(""([ti])um$"", ""$1a"");
				plural(""sis$"", ""ses"");
				plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
				plural(""(hive)$"", ""$1s"");
				plural(""([^aeiouy]|qu)y$"", ""$1ies"");
				//plural(""([^aeiouy]|qu)ies$"", ""$1y"");
				plural(""(x|ch|ss|sh)$"", ""$1es"");
				plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
				plural(""([m|l])ouse$"", ""$1ice"");
				plural(""^(ox)$"", ""$1en"");
				plural(""(quiz)$"", ""$1zes"");
				singular(""s$"", """");
				singular(""(n)ews$"", ""$1ews"");
				singular(""([ti])a$"", ""$1um"");
				singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
				singular(""(^analy)ses$"", ""$1sis"");
				singular(""([^f])ves$"", ""$1fe"");
				singular(""(hive)s$"", ""$1"");
				singular(""(tive)s$"", ""$1"");
				singular(""([lr])ves$"", ""$1f"");
				singular(""([^aeiouy]|qu)ies$"", ""$1y"");
				singular(""(s)eries$"", ""$1eries"");
				singular(""(m)ovies$"", ""$1ovie"");
				singular(""(x|ch|ss|sh)es$"", ""$1"");
				singular(""([m|l])ice$"", ""$1ouse"");
				singular(""(bus)es$"", ""$1"");
				singular(""(o)es$"", ""$1"");
				singular(""(shoe)s$"", ""$1"");
				singular(""(cris|ax|test)es$"", ""$1is"");
				singular(""(octop|vir)i$"", ""$1us"");
				singular(""(alias|status)es$"", ""$1"");
				singular(""^(ox)en"", ""$1"");
				singular(""(vert|ind)ices$"", ""$1ex"");
				singular(""(matr)ices$"", ""$1ix"");
				singular(""(quiz)zes$"", ""$1"");
				// irregular
				irregular(""person"", ""people"");
				irregular(""man"", ""men"");
				irregular(""child"", ""children"");
				irregular(""sex"", ""sexes"");
				irregular(""move"", ""moves"");
				uncountable(""equipment"");
				uncountable(""information"");
				uncountable(""rice"");
				uncountable(""money"");
				uncountable(""species"");
				uncountable(""series"");
				uncountable(""fish"");
				uncountable(""sheep"");
				//Collections.reverse(singular);
				//Collections.reverse(plural);
		}
		
		private static void plural(String pattern, String replacement) {
				plural.add(0, new Inflection(pattern, replacement));
		}
		
		private static void singular(String pattern, String replacement) {
				singular.add(0, new Inflection(pattern, replacement));
		}
		
		private static void irregular(String s, String p) {
				plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
				singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
		}
		
		private static void uncountable(String word) {
				uncountable.add(word);
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace() {
				Inflection inflection = new Inflection(""s$"", """");
				assertEquals("""", inflection.replace(""s""));
				assertEquals("""", inflection.replace(""ss""));
				assertEquals("""", inflection.replace(""sss""));
				assertEquals("""", inflection.replace(""ssss""));
				assertEquals("""", inflection.replace(""sssss""));
				assertEquals("""", inflection.replace(""ssssss""));
				assertEquals("""", inflection.replace(""sssssss""));
				assertEquals("""", inflection.replace(""ssssssss""));
				assertEquals("""", inflection.replace(""sssssssss""));
				assertEquals("""", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace2() {
				Inflection inflection = new Inflection(""s$"", ""ss"");
				assertEquals(""ss"", inflection.replace(""s""));
				assertEquals(""sss"", inflection.replace(""ss""));
				assertEquals(""ssss"", inflection.replace(""sss""));
				assertEquals(""sssss"", inflection.replace(""ssss""));
				assertEquals(""ssssss"", inflection.replace(""sssss""));
				assertEquals(""sssssss"", inflection.replace(""ssssss""));
				assertEquals(""ssssssss"", inflection.replace(""sssssss""));
				assertEquals(""sssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""ssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""sssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace3() {
				Inflection inflection = new Inflection(""s$"", ""sss"");
				assertEquals(""sss"", inflection.replace(""s""));
				assertEquals(""ssss"", inflection.replace(""ss""));
				assertEquals(""sssss"", inflection.replace(""sss""));
				assertEquals(""ssssss"", inflection.replace(""ssss""));
				assertEquals(""sssssss"", inflection.replace(""sssss""));
				assertEquals(""ssssssss"", inflection.replace(""ssssss""));
				assertEquals(""sssssssss"", inflection.replace(""sssssss""));
				assertEquals(""ssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""sssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace4() {
				Inflection inflection = new Inflection(""s$"", ""ssss"");
				assertEquals(""ssss"", inflection.replace(""s""));
				assertEquals(""sssss"", inflection.replace(""ss""));
				assertEquals(""ssssss"", inflection.replace(""sss""));
				assertEquals(""sssssss"", inflection.replace(""ssss""));
				assertEquals(""ssssssss"", inflection.replace(""sssss""));
				assertEquals(""sssssssss"", inflection.replace(""ssssss""));
				assertEquals(""ssssssssss"", inflection.replace(""sssssss""));
				assertEquals(""sssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""sssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace5() {
				Inflection inflection = new Inflection(""s$"", ""sssss"");
				assertEquals(""sssss"", inflection.replace(""s""));
				assertEquals(""ssssss"", inflection.replace(""ss""));
				assertEquals(""sssssss"", inflection.replace(""sss""));
				assertEquals(""ssssssss"", inflection.replace(""ssss""));
				assertEquals(""sssssssss"", inflection.replace(""sssss""));
				assertEquals(""ssssssssss"", inflection.replace(""ssssss""));
				assertEquals(""sssssssssss"", inflection.replace(""sssssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""sssssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""ssssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace6() {
				Inflection inflection = new Inflection(""s$"", ""ssssss"");
				assertEquals(""ssssss"", inflection.replace(""s""));
				assertEquals(""sssssss"", inflection.replace(""ss""));
				assertEquals(""ssssssss"", inflection.replace(""sss""));
				assertEquals(""sssssssss"", inflection.replace(""ssss""));
				assertEquals(""ssssssssss"", inflection.replace(""sssss""));
				assertEquals(""sssssssssss"", inflection.replace(""ssssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""sssssss""));
				assertEquals(""sssssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""ssssssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""sssssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace7() {
				Inflection inflection = new Inflection(""s$"", ""sssssss"");
				assertEquals(""sssssss"", inflection.replace(""s""));
				assertEquals(""ssssssss"", inflection.replace(""ss""));
				assertEquals(""sssssssss"", inflection.replace(""sss""));
				assertEquals(""ssssssssss"", inflection.replace(""ssss""));
				assertEquals(""sssssssssss"", inflection.replace(""sssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""ssssss""));
				assertEquals(""sssssssssssss"", inflection.replace(""sssssss""));
				assertEquals(""ssssssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""sssssssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""ssssssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace8() {
				Inflection inflection = new Inflection(""s$"", ""ssssssss"");
				assertEquals(""ssssssss"", inflection.replace(""s""));
				assertEquals(""sssssssss"", inflection.replace(""ss""));
				assertEquals(""ssssssssss"", inflection.replace(""sss""));
				assertEquals(""sssssssssss"", inflection.replace(""ssss""));
				assertEquals(""ssssssssssss"", inflection.replace(""sssss""));
				assertEquals(""sssssssssssss"", inflection.replace(""ssssss""));
				assertEquals(""ssssssssssssss"", inflection.replace(""sssssss""));
				assertEquals(""sssssssssssssss"", inflection.replace(""ssssssss""));
				assertEquals(""ssssssssssssssss"", inflection.replace(""sssssssss""));
				assertEquals(""sssssssssssssssss"", inflection.replace(""ssssssssss""));
		}
		
		/**
		* Test method for {@link Inflection#replace(String)}.
		*/
		@Test
		void testReplace9() {
				Inflection inflection = new Inflection(""s$"", ""sssssssss"");
				assertEquals(""sssssssss"", inflection.replace(""s""));
				assertEquals(""ssssssssss"", inflection.replace(""ss""));
				assertEquals(""sssssssssss"", inflection.replace(""sss""));
				assertEquals("""
cmpl-6u8iWpCbYk0r4n1kPFpA4xq4mCtao,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Inflection_2Test.java,103.20497179031372,length,"// Inflection.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Implementation of Rails'
 * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>
 * to handle singularization and pluralization of 'Rails strings'.
 *
 * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.
 *
 * @author Anthony Eden
 */
public class Inflection {

    private static final List<Inflection> plural = new ArrayList<Inflection>();

    private static final List<Inflection> singular = new ArrayList<Inflection>();

    private static final List<String> uncountable = new ArrayList<String>();

    static {
        // plural is ""singular to plural form""
        // singular is ""plural to singular form""
        plural(""$"", ""s"");
        plural(""s$"", ""s"");
        plural(""(ax|test)is$"", ""$1es"");
        plural(""(octop|vir)us$"", ""$1i"");
        plural(""(alias|status)$"", ""$1es"");
        plural(""(bu)s$"", ""$1ses"");
        plural(""(buffal|tomat)o$"", ""$1oes"");
        plural(""([ti])um$"", ""$1a"");
        plural(""sis$"", ""ses"");
        plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
        plural(""(hive)$"", ""$1s"");
        plural(""([^aeiouy]|qu)y$"", ""$1ies"");
        //plural(""([^aeiouy]|qu)ies$"", ""$1y"");
        plural(""(x|ch|ss|sh)$"", ""$1es"");
        plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
        plural(""([m|l])ouse$"", ""$1ice"");
        plural(""^(ox)$"", ""$1en"");
        plural(""(quiz)$"", ""$1zes"");
        singular(""s$"", """");
        singular(""(n)ews$"", ""$1ews"");
        singular(""([ti])a$"", ""$1um"");
        singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
        singular(""(^analy)ses$"", ""$1sis"");
        singular(""([^f])ves$"", ""$1fe"");
        singular(""(hive)s$"", ""$1"");
        singular(""(tive)s$"", ""$1"");
        singular(""([lr])ves$"", ""$1f"");
        singular(""([^aeiouy]|qu)ies$"", ""$1y"");
        singular(""(s)eries$"", ""$1eries"");
        singular(""(m)ovies$"", ""$1ovie"");
        singular(""(x|ch|ss|sh)es$"", ""$1"");
        singular(""([m|l])ice$"", ""$1ouse"");
        singular(""(bus)es$"", ""$1"");
        singular(""(o)es$"", ""$1"");
        singular(""(shoe)s$"", ""$1"");
        singular(""(cris|ax|test)es$"", ""$1is"");
        singular(""(octop|vir)i$"", ""$1us"");
        singular(""(alias|status)es$"", ""$1"");
        singular(""^(ox)en"", ""$1"");
        singular(""(vert|ind)ices$"", ""$1ex"");
        singular(""(matr)ices$"", ""$1ix"");
        singular(""(quiz)zes$"", ""$1"");
        // irregular
        irregular(""person"", ""people"");
        irregular(""man"", ""men"");
        irregular(""child"", ""children"");
        irregular(""sex"", ""sexes"");
        irregular(""move"", ""moves"");
        uncountable(""equipment"");
        uncountable(""information"");
        uncountable(""rice"");
        uncountable(""money"");
        uncountable(""species"");
        uncountable(""series"");
        uncountable(""fish"");
        uncountable(""sheep"");
        //Collections.reverse(singular);
        //Collections.reverse(plural);
    }

    private final String pattern;

    private final String replacement;

    private final boolean ignoreCase;

    public Inflection(String pattern) {
        this(pattern, null, true);
    }

    public Inflection(String pattern, String replacement) {
        this(pattern, replacement, true);
    }

    public Inflection(String pattern, String replacement, boolean ignoreCase) {
        this.pattern = pattern;
        this.replacement = replacement;
        this.ignoreCase = ignoreCase;
    }

    private static void plural(String pattern, String replacement) {
        plural.add(0, new Inflection(pattern, replacement));
    }

    private static void singular(String pattern, String replacement) {
        singular.add(0, new Inflection(pattern, replacement));
    }

    private static void irregular(String s, String p) {
        plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
        singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
    }

    private static void uncountable(String word) {
        uncountable.add(word);
    }

    /**
     * Does the given word match?
     * @param word The word
     * @return True if it matches the inflection pattern
     */
    public boolean match(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).find();
    }

    /**
     * Replace the word with its pattern.
     * @param word The word
     * @return The result
     */
    public String replace(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
    }

    /**
     * Return the pluralized version of a word.
     * @param word The word
     * @return The pluralized word
     */
    public static String pluralize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : plural) {
            if (inflection.match(word)) {
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return the singularized version of a word.
     * @param word The word
     * @return The singularized word
     */
    public static String singularize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : singular) {
            //System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
            if (inflection.match(word)) {
                //System.out.println(""match!"");
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return true if the word is uncountable.
     * @param word The word
     * @return True if it is uncountable
     */
    public static boolean isUncountable(String word) {
        for (String w : uncountable) {
            if (w.equalsIgnoreCase(word))
                return true;
        }
        return false;
    }
}
","// Inflection_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_2Test {","// Inflection_2Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_2Test {

		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's'.
		*/
		@Test
		void testPluralize_1() {
				String word = ""test"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's' and 's'.
		*/
		@Test
		void testPluralize_2() {
				String word = ""tests"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'is' and 'es'.
		*/
		@Test
		void testPluralize_3() {
				String word = ""axis"";
				String expected = ""axes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_4() {
				String word = ""octopus"";
				String expected = ""octopi"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_5() {
				String word = ""virus"";
				String expected = ""viri"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_6() {
				String word = ""alias"";
				String expected = ""aliases"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_7() {
				String word = ""status"";
				String expected = ""statuses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_8() {
				String word = ""bus"";
				String expected = ""buses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_9() {
				String word = ""buffalo"";
				String expected = ""buffaloes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_10() {
				String word = ""tomato"";
				String expected = ""tomatoes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
}

// Inflection_3Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_3Test {
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's'.
		*/
		@Test
		void testPluralize_1() {
				String word = ""test"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's' and 's'.
		*/
		@Test
		void testPluralize_2() {
				String word = ""tests"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'is' and 'es'.
		*/
		@Test
		void testPluralize_3() {
				String word = ""axis"";
				String expected = ""axes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_4() {
				String word = ""octopus"";
				String expected = ""octopi"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_5() {
				String word = ""virus"";
				String expected = ""viri"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_6() {
				String word = ""alias"";
				String expected = ""aliases"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_7() {
				String word = ""status"";
				String expected = ""statuses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_8() {
				String word = ""bus"";
				String expected = ""buses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_9() {
				String word = ""buffalo"";
				String expected = ""buffaloes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_10() {
				String word = ""tomato"";
				String expected = ""tomatoes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
}

// Inflection_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_4Test {
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's'.
		*/
		@Test
		void testPluralize_1() {
				String word = ""test"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 's' and 's'.
		*/
		@Test
		void testPluralize_2() {
				String word = ""tests"";
				String expected = ""tests"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'is' and 'es'.
		*/
		@Test
		void testPluralize_3() {
				String word = ""axis"";
				String expected = ""axes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_4() {
				String word = ""octopus"";
				String expected = ""octopi"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_5() {
				String word = ""virus"";
				String expected = ""viri"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_6() {
				String word = ""alias"";
				String expected = ""aliases"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_7() {
				String word = ""status"";
				String expected = ""statuses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_8() {
				String word = ""bus"";
				String expected = ""buses"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of a word ending with 'us' and 'i'.
		*/
		@Test
		void testPluralize_9() {
				String word = ""buffalo"";
				String expected = ""buffaloes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pl"
cmpl-6u8kCyiQUBpBZdssfEBbtGnWE717f,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Inflection_3Test.java,96.31461668014526,length,"// Inflection.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Implementation of Rails'
 * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>
 * to handle singularization and pluralization of 'Rails strings'.
 *
 * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.
 *
 * @author Anthony Eden
 */
public class Inflection {

    private static final List<Inflection> plural = new ArrayList<Inflection>();

    private static final List<Inflection> singular = new ArrayList<Inflection>();

    private static final List<String> uncountable = new ArrayList<String>();

    static {
        // plural is ""singular to plural form""
        // singular is ""plural to singular form""
        plural(""$"", ""s"");
        plural(""s$"", ""s"");
        plural(""(ax|test)is$"", ""$1es"");
        plural(""(octop|vir)us$"", ""$1i"");
        plural(""(alias|status)$"", ""$1es"");
        plural(""(bu)s$"", ""$1ses"");
        plural(""(buffal|tomat)o$"", ""$1oes"");
        plural(""([ti])um$"", ""$1a"");
        plural(""sis$"", ""ses"");
        plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
        plural(""(hive)$"", ""$1s"");
        plural(""([^aeiouy]|qu)y$"", ""$1ies"");
        //plural(""([^aeiouy]|qu)ies$"", ""$1y"");
        plural(""(x|ch|ss|sh)$"", ""$1es"");
        plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
        plural(""([m|l])ouse$"", ""$1ice"");
        plural(""^(ox)$"", ""$1en"");
        plural(""(quiz)$"", ""$1zes"");
        singular(""s$"", """");
        singular(""(n)ews$"", ""$1ews"");
        singular(""([ti])a$"", ""$1um"");
        singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
        singular(""(^analy)ses$"", ""$1sis"");
        singular(""([^f])ves$"", ""$1fe"");
        singular(""(hive)s$"", ""$1"");
        singular(""(tive)s$"", ""$1"");
        singular(""([lr])ves$"", ""$1f"");
        singular(""([^aeiouy]|qu)ies$"", ""$1y"");
        singular(""(s)eries$"", ""$1eries"");
        singular(""(m)ovies$"", ""$1ovie"");
        singular(""(x|ch|ss|sh)es$"", ""$1"");
        singular(""([m|l])ice$"", ""$1ouse"");
        singular(""(bus)es$"", ""$1"");
        singular(""(o)es$"", ""$1"");
        singular(""(shoe)s$"", ""$1"");
        singular(""(cris|ax|test)es$"", ""$1is"");
        singular(""(octop|vir)i$"", ""$1us"");
        singular(""(alias|status)es$"", ""$1"");
        singular(""^(ox)en"", ""$1"");
        singular(""(vert|ind)ices$"", ""$1ex"");
        singular(""(matr)ices$"", ""$1ix"");
        singular(""(quiz)zes$"", ""$1"");
        // irregular
        irregular(""person"", ""people"");
        irregular(""man"", ""men"");
        irregular(""child"", ""children"");
        irregular(""sex"", ""sexes"");
        irregular(""move"", ""moves"");
        uncountable(""equipment"");
        uncountable(""information"");
        uncountable(""rice"");
        uncountable(""money"");
        uncountable(""species"");
        uncountable(""series"");
        uncountable(""fish"");
        uncountable(""sheep"");
        //Collections.reverse(singular);
        //Collections.reverse(plural);
    }

    private final String pattern;

    private final String replacement;

    private final boolean ignoreCase;

    public Inflection(String pattern) {
        this(pattern, null, true);
    }

    public Inflection(String pattern, String replacement) {
        this(pattern, replacement, true);
    }

    public Inflection(String pattern, String replacement, boolean ignoreCase) {
        this.pattern = pattern;
        this.replacement = replacement;
        this.ignoreCase = ignoreCase;
    }

    private static void plural(String pattern, String replacement) {
        plural.add(0, new Inflection(pattern, replacement));
    }

    private static void singular(String pattern, String replacement) {
        singular.add(0, new Inflection(pattern, replacement));
    }

    private static void irregular(String s, String p) {
        plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
        singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
    }

    private static void uncountable(String word) {
        uncountable.add(word);
    }

    /**
     * Does the given word match?
     * @param word The word
     * @return True if it matches the inflection pattern
     */
    public boolean match(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).find();
    }

    /**
     * Replace the word with its pattern.
     * @param word The word
     * @return The result
     */
    public String replace(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
    }

    /**
     * Return the pluralized version of a word.
     * @param word The word
     * @return The pluralized word
     */
    public static String pluralize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : plural) {
            if (inflection.match(word)) {
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return the singularized version of a word.
     * @param word The word
     * @return The singularized word
     */
    public static String singularize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : singular) {
            //System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
            if (inflection.match(word)) {
                //System.out.println(""match!"");
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return true if the word is uncountable.
     * @param word The word
     * @return True if it is uncountable
     */
    public static boolean isUncountable(String word) {
        for (String w : uncountable) {
            if (w.equalsIgnoreCase(word))
                return true;
        }
        return false;
    }
}
","// Inflection_3Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#singularize(String)} method.
*/
class Inflection_3Test {","// Inflection_3Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#singularize(String)} method.
*/
class Inflection_3Test {

		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""people"".
		*/
		@Test
		void testSingularize_people() {
				String word = ""people"";
				String expected = ""person"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""men"".
		*/
		@Test
		void testSingularize_men() {
				String word = ""men"";
				String expected = ""man"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""children"".
		*/
		@Test
		void testSingularize_children() {
				String word = ""children"";
				String expected = ""child"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""sexes"".
		*/
		@Test
		void testSingularize_sexes() {
				String word = ""sexes"";
				String expected = ""sex"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""moves"".
		*/
		@Test
		void testSingularize_moves() {
				String word = ""moves"";
				String expected = ""move"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""equipment"".
		*/
		@Test
		void testSingularize_equipment() {
				String word = ""equipment"";
				String expected = ""equipment"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""information"".
		*/
		@Test
		void testSingularize_information() {
				String word = ""information"";
				String expected = ""information"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""rice"".
		*/
		@Test
		void testSingularize_rice() {
				String word = ""rice"";
				String expected = ""rice"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""money"".
		*/
		@Test
		void testSingularize_money() {
				String word = ""money"";
				String expected = ""money"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""species"".
		*/
		@Test
		void testSingularize_species() {
				String word = ""species"";
				String expected = ""species"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""series"".
		*/
		@Test
		void testSingularize_series() {
				String word = ""series"";
				String expected = ""series"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""fish"".
		*/
		@Test
		void testSingularize_fish() {
				String word = ""fish"";
				String expected = ""fish"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests the singularization of the word ""sheep"".
		*/
		@Test
		void testSingularize_sheep() {
				String word = ""sheep"";
				String expected = ""sheep"";
				String actual = Inflection.singularize(word);
				assertEquals(expected, actual);
		}
		
}

// Inflection_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_4Test {
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""person"".
		*/
		@Test
		void testPluralize_person() {
				String word = ""person"";
				String expected = ""people"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""man"".
		*/
		@Test
		void testPluralize_man() {
				String word = ""man"";
				String expected = ""men"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""child"".
		*/
		@Test
		void testPluralize_child() {
				String word = ""child"";
				String expected = ""children"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""sex"".
		*/
		@Test
		void testPluralize_sex() {
				String word = ""sex"";
				String expected = ""sexes"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""move"".
		*/
		@Test
		void testPluralize_move() {
				String word = ""move"";
				String expected = ""moves"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""equipment"".
		*/
		@Test
		void testPluralize_equipment() {
				String word = ""equipment"";
				String expected = ""equipment"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""information"".
		*/
		@Test
		void testPluralize_information() {
				String word = ""information"";
				String expected = ""information"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""rice"".
		*/
		@Test
		void testPluralize_rice() {
				String word = ""rice"";
				String expected = ""rice"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""money"".
		*/
		@Test
		void testPluralize_money() {
				String word = ""money"";
				String expected = ""money"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""species"".
		*/
		@Test
		void testPluralize_species() {
				String word = ""species"";
				String expected = ""species"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""series"".
		*/
		@Test
		void testPluralize_series() {
				String word = ""series"";
				String expected = ""series"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""fish"".
		*/
		@Test
		void testPluralize_fish() {
				String word = ""fish"";
				String expected = ""fish"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests the pluralization of the word ""sheep"".
		*/
		@Test
		void testPluralize_sheep() {
				String word = ""sheep"";
				String expected = ""sheep"";
				String actual = Inflection.pluralize(word);
				assertEquals(expected, actual);
		}
		
}

// Inflection_5Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#isUncountable(String)} method.
*/
class Inflection_5Test {
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests the uncountability of the word ""equipment"".
		*/
		@Test
		void testIsUncountable_equipment() {
				String word = ""equipment"";
				boolean expected = true;
				boolean actual = Inflection.isUncountable(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests the uncountability of the word ""information"".
		*/
		@Test
		void testIsUncountable_information() {
				String word = ""information"";
				boolean expected = true;
				boolean actual = Inflection.isUncountable(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests the uncountability of the word ""rice"".
		*/
		@Test
		void testIsUncountable_rice() {
				String word = ""rice"";
				boolean expected = true;
				boolean actual = Inflection.isUncountable(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests the uncountability of the word ""money"".
		*/
		@Test
		void testIsUncountable_money() {
				String word = ""money"";
				boolean expected = true;
				boolean actual = Inflection.isUncountable(word);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests the uncountability of the word ""species"".
		"
cmpl-6u8lkq1yT3jsieQz85OHTOL3m1tLK,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Inflection_4Test.java,97.62668013572693,length,"// Inflection.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Implementation of Rails'
 * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>
 * to handle singularization and pluralization of 'Rails strings'.
 *
 * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.
 *
 * @author Anthony Eden
 */
public class Inflection {

    private static final List<Inflection> plural = new ArrayList<Inflection>();

    private static final List<Inflection> singular = new ArrayList<Inflection>();

    private static final List<String> uncountable = new ArrayList<String>();

    static {
        // plural is ""singular to plural form""
        // singular is ""plural to singular form""
        plural(""$"", ""s"");
        plural(""s$"", ""s"");
        plural(""(ax|test)is$"", ""$1es"");
        plural(""(octop|vir)us$"", ""$1i"");
        plural(""(alias|status)$"", ""$1es"");
        plural(""(bu)s$"", ""$1ses"");
        plural(""(buffal|tomat)o$"", ""$1oes"");
        plural(""([ti])um$"", ""$1a"");
        plural(""sis$"", ""ses"");
        plural(""(?:([^f])fe|([lr])f)$"", ""$1$2ves"");
        plural(""(hive)$"", ""$1s"");
        plural(""([^aeiouy]|qu)y$"", ""$1ies"");
        //plural(""([^aeiouy]|qu)ies$"", ""$1y"");
        plural(""(x|ch|ss|sh)$"", ""$1es"");
        plural(""(matr|vert|ind)ix|ex$"", ""$1ices"");
        plural(""([m|l])ouse$"", ""$1ice"");
        plural(""^(ox)$"", ""$1en"");
        plural(""(quiz)$"", ""$1zes"");
        singular(""s$"", """");
        singular(""(n)ews$"", ""$1ews"");
        singular(""([ti])a$"", ""$1um"");
        singular(""((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$"", ""$1$2sis"");
        singular(""(^analy)ses$"", ""$1sis"");
        singular(""([^f])ves$"", ""$1fe"");
        singular(""(hive)s$"", ""$1"");
        singular(""(tive)s$"", ""$1"");
        singular(""([lr])ves$"", ""$1f"");
        singular(""([^aeiouy]|qu)ies$"", ""$1y"");
        singular(""(s)eries$"", ""$1eries"");
        singular(""(m)ovies$"", ""$1ovie"");
        singular(""(x|ch|ss|sh)es$"", ""$1"");
        singular(""([m|l])ice$"", ""$1ouse"");
        singular(""(bus)es$"", ""$1"");
        singular(""(o)es$"", ""$1"");
        singular(""(shoe)s$"", ""$1"");
        singular(""(cris|ax|test)es$"", ""$1is"");
        singular(""(octop|vir)i$"", ""$1us"");
        singular(""(alias|status)es$"", ""$1"");
        singular(""^(ox)en"", ""$1"");
        singular(""(vert|ind)ices$"", ""$1ex"");
        singular(""(matr)ices$"", ""$1ix"");
        singular(""(quiz)zes$"", ""$1"");
        // irregular
        irregular(""person"", ""people"");
        irregular(""man"", ""men"");
        irregular(""child"", ""children"");
        irregular(""sex"", ""sexes"");
        irregular(""move"", ""moves"");
        uncountable(""equipment"");
        uncountable(""information"");
        uncountable(""rice"");
        uncountable(""money"");
        uncountable(""species"");
        uncountable(""series"");
        uncountable(""fish"");
        uncountable(""sheep"");
        //Collections.reverse(singular);
        //Collections.reverse(plural);
    }

    private final String pattern;

    private final String replacement;

    private final boolean ignoreCase;

    public Inflection(String pattern) {
        this(pattern, null, true);
    }

    public Inflection(String pattern, String replacement) {
        this(pattern, replacement, true);
    }

    public Inflection(String pattern, String replacement, boolean ignoreCase) {
        this.pattern = pattern;
        this.replacement = replacement;
        this.ignoreCase = ignoreCase;
    }

    private static void plural(String pattern, String replacement) {
        plural.add(0, new Inflection(pattern, replacement));
    }

    private static void singular(String pattern, String replacement) {
        singular.add(0, new Inflection(pattern, replacement));
    }

    private static void irregular(String s, String p) {
        plural(""("" + s.substring(0, 1) + "")"" + s.substring(1) + ""$"", ""$1"" + p.substring(1));
        singular(""("" + p.substring(0, 1) + "")"" + p.substring(1) + ""$"", ""$1"" + s.substring(1));
    }

    private static void uncountable(String word) {
        uncountable.add(word);
    }

    /**
     * Does the given word match?
     * @param word The word
     * @return True if it matches the inflection pattern
     */
    public boolean match(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).find();
    }

    /**
     * Replace the word with its pattern.
     * @param word The word
     * @return The result
     */
    public String replace(String word) {
        int flags = 0;
        if (ignoreCase) {
            flags = flags | Pattern.CASE_INSENSITIVE;
        }
        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);
    }

    /**
     * Return the pluralized version of a word.
     * @param word The word
     * @return The pluralized word
     */
    public static String pluralize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : plural) {
            if (inflection.match(word)) {
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return the singularized version of a word.
     * @param word The word
     * @return The singularized word
     */
    public static String singularize(String word) {
        if (Inflection.isUncountable(word)) {
            return word;
        }
        for (Inflection inflection : singular) {
            //System.out.println(word + "" matches "" + inflection.pattern + ""? (ignore case: "" + inflection.ignoreCase + "")"");
            if (inflection.match(word)) {
                //System.out.println(""match!"");
                return inflection.replace(word);
            }
        }
        return word;
    }

    /**
     * Return true if the word is uncountable.
     * @param word The word
     * @return True if it is uncountable
     */
    public static boolean isUncountable(String word) {
        for (String w : uncountable) {
            if (w.equalsIgnoreCase(word))
                return true;
        }
        return false;
    }
}
","// Inflection_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#isUncountable(String)} method.
*/
class Inflection_4Test {","// Inflection_4Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#isUncountable(String)} method.
*/
class Inflection_4Test {

		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""equipment"".
		*/
		@Test
		void testIsUncountable_equipment() {
				assertTrue(Inflection.isUncountable(""equipment""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""information"".
		*/
		@Test
		void testIsUncountable_information() {
				assertTrue(Inflection.isUncountable(""information""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""rice"".
		*/
		@Test
		void testIsUncountable_rice() {
				assertTrue(Inflection.isUncountable(""rice""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""money"".
		*/
		@Test
		void testIsUncountable_money() {
				assertTrue(Inflection.isUncountable(""money""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""species"".
		*/
		@Test
		void testIsUncountable_species() {
				assertTrue(Inflection.isUncountable(""species""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""series"".
		*/
		@Test
		void testIsUncountable_series() {
				assertTrue(Inflection.isUncountable(""series""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""fish"".
		*/
		@Test
		void testIsUncountable_fish() {
				assertTrue(Inflection.isUncountable(""fish""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns true for the word ""sheep"".
		*/
		@Test
		void testIsUncountable_sheep() {
				assertTrue(Inflection.isUncountable(""sheep""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns false for the word ""table"".
		*/
		@Test
		void testIsUncountable_table() {
				assertFalse(Inflection.isUncountable(""table""));
		}
		
		/**
		* Test case for the {@link Inflection#isUncountable(String)} method.
		* It tests if the method returns false for the word ""chair"".
		*/
		@Test
		void testIsUncountable_chair() {
				assertFalse(Inflection.isUncountable(""chair""));
		}
}

// Inflection_5Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.
*/
class Inflection_5Test {
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""equipments"" for the word ""equipment"".
		*/
		@Test
		void testPluralize_equipment() {
				assertEquals(""equipments"", Inflection.pluralize(""equipment""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""informations"" for the word ""information"".
		*/
		@Test
		void testPluralize_information() {
				assertEquals(""informations"", Inflection.pluralize(""information""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""rices"" for the word ""rice"".
		*/
		@Test
		void testPluralize_rice() {
				assertEquals(""rices"", Inflection.pluralize(""rice""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""moneys"" for the word ""money"".
		*/
		@Test
		void testPluralize_money() {
				assertEquals(""moneys"", Inflection.pluralize(""money""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""species"" for the word ""species"".
		*/
		@Test
		void testPluralize_species() {
				assertEquals(""species"", Inflection.pluralize(""species""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""series"" for the word ""series"".
		*/
		@Test
		void testPluralize_series() {
				assertEquals(""series"", Inflection.pluralize(""series""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""fish"" for the word ""fish"".
		*/
		@Test
		void testPluralize_fish() {
				assertEquals(""fish"", Inflection.pluralize(""fish""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""sheep"" for the word ""sheep"".
		*/
		@Test
		void testPluralize_sheep() {
				assertEquals(""sheep"", Inflection.pluralize(""sheep""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""tables"" for the word ""table"".
		*/
		@Test
		void testPluralize_table() {
				assertEquals(""tables"", Inflection.pluralize(""table""));
		}
		
		/**
		* Test case for the {@link Inflection#pluralize(String)} method.
		* It tests if the method returns ""chairs"" for the word ""chair"".
		*/
		@Test
		void testPluralize_chair() {
				assertEquals(""chairs"", Inflection.pluralize(""chair""));
		}
}

// Inflection_6Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#singularize(String)} method.
*/
class Inflection_6Test {
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""equipment"" for the word ""equipments"".
		*/
		@Test
		void testSingularize_equipments() {
				assertEquals(""equipment"", Inflection.singularize(""equipments""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""information"" for the word ""informations"".
		*/
		@Test
		void testSingularize_informations() {
				assertEquals(""information"", Inflection.singularize(""informations""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""rice"" for the word ""rices"".
		*/
		@Test
		void testSingularize_rices() {
				assertEquals(""rice"", Inflection.singularize(""rices""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""money"" for the word ""moneys"".
		*/
		@Test
		void testSingularize_moneys() {
				assertEquals(""money"", Inflection.singularize(""moneys""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""species"" for the word ""species"".
		*/
		@Test
		void testSingularize_species() {
				assertEquals(""species"", Inflection.singularize(""species""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""series"" for the word ""series"".
		*/
		@Test
		void testSingularize_series() {
				assertEquals(""series"", Inflection.singularize(""series""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""fish"" for the word ""fish"".
		*/
		@Test
		void testSingularize_fish() {
				assertEquals(""fish"", Inflection.singularize(""fish""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""sheep"" for the word ""sheep"".
		*/
		@Test
		void testSingularize_sheep() {
				assertEquals(""sheep"", Inflection.singularize(""sheep""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""table"" for the word ""tables"".
		*/
		@Test
		void testSingularize_tables() {
				assertEquals(""table"", Inflection.singularize(""tables""));
		}
		
		/**
		* Test case for the {@link Inflection#singularize(String)} method.
		* It tests if the method returns ""chair"" for the word ""chairs"".
		*/
		@Test
		void testSingularize_chairs() {
				assertEquals(""chair"", Inflection.singularize(""chairs""));
		}
}

// Inflection_7Test.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Inflection}.
* It contains ten unit test cases for the {@link Inflection#match(String)} method.
*/
class Inflection_7Test {
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""equipment"".
		*/
		@Test
		void testMatch_equipment() {
				assertTrue(Inflection.match(""equipment""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""information"".
		*/
		@Test
		void testMatch_information() {
				assertTrue(Inflection.match(""information""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""rice"".
		*/
		@Test
		void testMatch_rice() {
				assertTrue(Inflection.match(""rice""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""money"".
		*/
		@Test
		void testMatch_money() {
				assertTrue(Inflection.match(""money""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""species"".
		*/
		@Test
		void testMatch_species() {
				assertTrue(Inflection.match(""species""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""series"".
		*/
		@Test
		void testMatch_series() {
				assertTrue(Inflection.match(""series""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""fish"".
		*/
		@Test
		void testMatch_fish() {
				assertTrue(Inflection.match(""fish""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns true for the word ""sheep"".
		*/
		@Test
		void testMatch_sheep() {
				assertTrue(Inflection.match(""sheep""));
		}
		
		/**
		* Test case for the {@link Inflection#match(String)} method.
		* It tests if the method returns false for the word ""table"".
		*/
		@Test
		void testMatch_table() {
				assertFalse(Inflection.match(""table""));"
cmpl-6u8nKGeUVOtTn1idpiOhwdMoHxoMh,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/LogFormatter.java,100.44581866264343,length,"// LogFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;

/**
 * Format a LogRecord into a single concise line.
 *
 * @author John Currier
 */
public class LogFormatter extends Formatter {

    private final String lineSeparator = System.getProperty(""line.separator"");

    private final int MAX_LEVEL_LEN = 7;

    private static final String formatSpec = ""HH:mm:ss."";

    private static final long serialVersionUID = 1L;

    /**
     * Date formatter for time-to-text translation.
     * These are very expensive to create and not thread-safe, so do it once per thread.
     */
    private static final ThreadLocal<DateFormat> dateFormatter = new ThreadLocal<DateFormat>() {

        @Override
        public DateFormat initialValue() {
            SimpleDateFormat formatter = new SimpleDateFormat(formatSpec);
            return formatter;
        }
    };

    /**
     * Optimization to keep from creating a new {@link java.util.Date} for every call to
     * {@link #toString()}.
     */
    private static final ThreadLocal<Date> date = new ThreadLocal<Date>() {

        @Override
        public Date initialValue() {
            return new Date();
        }
    };

    /**
     * Format the given LogRecord.
     *
     * @param record
     *            the log record to be formatted.
     * @return a formatted log record
     */
    @Override
    public String format(LogRecord record) {
        StringBuilder buf = new StringBuilder(128);
        // format the date portion:
        // thread-safe pseudo-singletons:
        date.get().setTime(record.getMillis());
        buf.append(dateFormatter.get().format(date.get()));
        // compute frac as the number of milliseconds off of a whole second
        long frac = record.getMillis() % 1000;
        // force longFrac to overflow 1000 to give 1 followed by
        // 'leading' zeros
        frac += 1000;
        // append the fraction of a second at the end (w/o leading overflowed 1)
        buf.append(Long.toString(frac).substring(1));
        buf.append("" "");
        StringBuilder level = new StringBuilder(record.getLevel().getLocalizedName());
        if (level.length() > MAX_LEVEL_LEN)
            level.setLength(MAX_LEVEL_LEN);
        level.append("":"");
        while (level.length() < MAX_LEVEL_LEN + 1) level.append(' ');
        buf.append(level);
        buf.append("" "");
        String name;
        if (record.getSourceClassName() != null) {
            name = record.getSourceClassName();
        } else {
            name = record.getLoggerName();
        }
        int lastDot = name.lastIndexOf('.');
        if (lastDot >= 0 && lastDot < name.length() - 1)
            name = name.substring(lastDot + 1);
        buf.append(name);
        if (record.getSourceMethodName() != null) {
            buf.append('.');
            buf.append(record.getSourceMethodName());
        }
        buf.append("" - "");
        buf.append(formatMessage(record));
        buf.append(lineSeparator);
        if (record.getThrown() != null) {
            try {
                StringWriter stacktrace = new StringWriter();
                record.getThrown().printStackTrace(new PrintWriter(stacktrace, true));
                buf.append(stacktrace.toString());
                // stack trace already has a line separator
            } catch (Exception ignore) {
            }
        }
        return buf.toString();
    }
}
","// LogFormatterTest.java
package net.sourceforge.schemaspy.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LogFormatter}.
* It contains ten unit test cases for the {@link LogFormatter#format(LogRecord)} method.
*/
class LogFormatterTest {","// LogFormatterTest.java
package net.sourceforge.schemaspy.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LogFormatter}.
* It contains ten unit test cases for the {@link LogFormatter#format(LogRecord)} method.
*/
class LogFormatterTest {

	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a null LogRecord.
	*/
	@Test
	void testFormatNullLogRecord() {
		LogFormatter logFormatter = new LogFormatter();
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(null);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null level.
	*/
	@Test
	void testFormatLogRecordWithNullLevel() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null message.
	*/
	@Test
	void testFormatLogRecordWithNullMessage() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null source class name.
	*/
	@Test
	void testFormatLogRecordWithNullSourceClassName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setSourceClassName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null source method name.
	*/
	@Test
	void testFormatLogRecordWithNullSourceMethodName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setSourceMethodName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null logger name.
	*/
	@Test
	void testFormatLogRecordWithNullLoggerName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setLoggerName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown.
	*/
	@Test
	void testFormatLogRecordWithNullThrown() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTrace() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace print writer.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTracePrintWriter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace string writer.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTraceStringWriter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null date formatter.
	*/
	@Test
	void testFormatLogRecordWithNullDateFormatter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setMillis(0);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null date.
	*/
	@Test
	void testFormatLogRecordWithNullDate() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setMillis(0);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
}

// LogFormatterTest.java
package net.sourceforge.schemaspy.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LogFormatter}.
* It contains ten unit test cases for the {@link LogFormatter#format(LogRecord)} method.
*/
class LogFormatterTest {
		
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a null LogRecord.
	*/
	@Test
	void testFormatNullLogRecord() {
		LogFormatter logFormatter = new LogFormatter();
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(null);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null level.
	*/
	@Test
	void testFormatLogRecordWithNullLevel() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null message.
	*/
	@Test
	void testFormatLogRecordWithNullMessage() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null source class name.
	*/
	@Test
	void testFormatLogRecordWithNullSourceClassName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setSourceClassName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null source method name.
	*/
	@Test
	void testFormatLogRecordWithNullSourceMethodName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setSourceMethodName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null logger name.
	*/
	@Test
	void testFormatLogRecordWithNullLoggerName() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setLoggerName(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown.
	*/
	@Test
	void testFormatLogRecordWithNullThrown() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(null);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTrace() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace print writer.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTracePrintWriter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null thrown stack trace string writer.
	*/
	@Test
	void testFormatLogRecordWithNullThrownStackTraceStringWriter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setThrown(new Exception());
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null date formatter.
	*/
	@Test
	void testFormatLogRecordWithNullDateFormatter() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setMillis(0);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null date.
	*/
	@Test
	void testFormatLogRecordWithNullDate() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord(null, ""Test message"");
		logRecord.setMillis(0);
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(logRecord);
		});
	}
}

// LogFormatterTest.java
package net.sourceforge.schemaspy.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LogFormatter}.
* It contains ten unit test cases for the {@link LogFormatter#format(LogRecord)} method.
*/
class LogFormatterTest {
		
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a null LogRecord.
	*/
	@Test
	void testFormatNullLogRecord() {
		LogFormatter logFormatter = new LogFormatter();
		assertThrows(NullPointerException.class, () -> {
			logFormatter.format(null);
		});
	}
	
	/**
	* Test case for {@link LogFormatter#format(LogRecord)} method.
	* This test case tests the format method with a LogRecord with a null level.
	*/
	@Test
	void testFormatLogRecordWithNullLevel() {
		LogFormatter logFormatter = new LogFormatter();
		LogRecord logRecord = new LogRecord"
cmpl-6u8owLGovyiRlRMLUaoO53DyGfX3n,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/PasswordReader_1Test.java,103.6491379737854,length,"// PasswordReader.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.util.Arrays;

/**
 * This class prompts the user for a password and attempts to mask input with
 * ""*""
 */
public class PasswordReader {

    private static PasswordReader instance;

    public static synchronized PasswordReader getInstance() {
        if (instance == null) {
            try {
                instance = new ConsolePasswordReader();
            } catch (Throwable exc) {
                // Java6+ version can't be loaded, so revert to this implementation
                instance = new PasswordReader();
            }
        }
        return instance;
    }

    /**
     * Use {@link #getInstance()} instead.
     */
    protected PasswordReader() {
    }

    /**
     * Matches the contract of Java 1.6+'s {@link java.io.Console#readPassword}
     * except that our own IOError is thrown in place of the 1.6-specific IOError.
     * By matching the contract we can use this implementation when
     * running in a 1.5 JVM or the much better implementation that
     * was introduced in 1.6 when running in a JVM that supplies it.
     *
     * @param fmt
     * @param args
     * @return
     */
    public char[] readPassword(String fmt, Object... args) {
        InputStream in = System.in;
        char[] lineBuffer;
        char[] buf = lineBuffer = new char[128];
        int room = buf.length;
        int offset = 0;
        int ch;
        boolean reading = true;
        Masker masker = new Masker(String.format(fmt, args));
        masker.start();
        try {
            while (reading) {
                switch(ch = in.read()) {
                    case -1:
                    case '\n':
                        reading = false;
                        break;
                    case '\r':
                        int c2 = in.read();
                        if (c2 != '\n' && c2 != -1) {
                            if (!(in instanceof PushbackInputStream)) {
                                in = new PushbackInputStream(in);
                            }
                            ((PushbackInputStream) in).unread(c2);
                        } else {
                            reading = false;
                        }
                        break;
                    default:
                        if (--room < 0) {
                            buf = new char[offset + 128];
                            room = buf.length - offset - 1;
                            System.arraycopy(lineBuffer, 0, buf, 0, offset);
                            Arrays.fill(lineBuffer, ' ');
                            lineBuffer = buf;
                        }
                        buf[offset++] = (char) ch;
                        break;
                }
            }
        } catch (IOException exc) {
            throw new IOError(exc);
        } finally {
            masker.stopMasking();
        }
        if (offset == 0) {
            return null;
        }
        char[] password = new char[offset];
        System.arraycopy(buf, 0, password, 0, offset);
        Arrays.fill(buf, ' ');
        return password;
    }

    /**
     * Simple thread that constantly overwrites (masking) whatever
     * the user is typing as their password.
     */
    private static class Masker extends Thread {

        private volatile boolean masking = true;

        private final String mask;

        /**
         * @param prompt The prompt displayed to the user
         */
        public Masker(String prompt) {
            // mask that will be printed every iteration
            // it includes spaces to replace what's typed
            // and backspaces to move back over them
            mask = ""\r"" + prompt + ""     \010\010\010\010\010"";
            // set our priority to something higher than the caller's
            setPriority(Thread.currentThread().getPriority() + 1);
        }

        /**
         * Keep masking until asked to stop
         */
        @Override
        public void run() {
            while (masking) {
                System.out.print(mask);
                try {
                    sleep(100);
                } catch (InterruptedException iex) {
                    interrupt();
                    masking = false;
                }
            }
        }

        /**
         * Stop masking the password
         */
        public void stopMasking() {
            masking = false;
        }
    }

    /**
     * Our own implementation of the Java 1.6 IOError class.
     */
    public class IOError extends Error {

        private static final long serialVersionUID = 20100629L;

        public IOError(Throwable cause) {
            super(cause);
        }
    }
}
","// PasswordReader_1Test.java
package net.sourceforge.schemaspy.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordReader}.
* It contains ten unit test cases for the {@link PasswordReader#readPassword(String, Object[])} method.
*/
class PasswordReader_1Test {","// PasswordReader_1Test.java
package net.sourceforge.schemaspy.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordReader}.
* It contains ten unit test cases for the {@link PasswordReader#readPassword(String, Object[])} method.
*/
class PasswordReader_1Test {

	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_1() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_2() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_3() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_4() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_5() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_6() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_7() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_8() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_9() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_10() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
}

// PasswordReader_2Test.java
package net.sourceforge.schemaspy.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordReader}.
* It contains ten unit test cases for the {@link PasswordReader#readPassword(String, Object[])} method.
*/
class PasswordReader_2Test {
		
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_1() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_2() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_3() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_4() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return and a line feed.
	 * @throws IOException
	 */
	@Test
	void testReadPassword_5() throws IOException {
		InputStream in = new InputStream() {
			private int[] bytes = {'a', 'b', 'c', '\r', '\n'};
			private int index = 0;
			@Override
			public int read() throws IOException {
				if (index &lt; bytes.length) {
					return bytes[index++];
				}
				return -1;
			}
		};
		System.setIn(in);
		char[] password = PasswordReader.getInstance().readPassword(""Enter password: "");
		assertArrayEquals(new char[] {'a', 'b', 'c'}, password);
	}
	
	/**
	 * Test case for {@link PasswordReader#readPassword(String, Object[])} method.
	 * It tests the case when the user enters a password with a carriage return"
cmpl-6u8qcpaxGJBQYTwLWqcaOnBcGw6n1,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/Version.java,99.23223328590393,length,"// Version.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * Simple class that allows logical comparisons between ""dotted"" versions of products.
 *
 * e.g. version 2.1.4 should be less than version 2.1.10.
 *
 * @author John Currier
 * @version 1.0
 */
public class Version implements Comparable<Version> {

    private final List<Integer> segments = new ArrayList<Integer>();

    private final String asString;

    private final int hashCode;

    public Version(String version) {
        asString = version;
        int hash = 0;
        if (version != null) {
            StringTokenizer tokenizer = new StringTokenizer(version, "". -_"");
            while (tokenizer.hasMoreTokens()) {
                Integer segment = new Integer(tokenizer.nextToken());
                segments.add(segment);
                hash += segment.intValue();
            }
        }
        hashCode = hash;
    }

    /**
     * Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     */
    public int compareTo(Version other) {
        int size = Math.min(segments.size(), other.segments.size());
        for (int i = 0; i < size; ++i) {
            Integer thisSegment = segments.get(i);
            Integer otherSegment = other.segments.get(i);
            int result = thisSegment.compareTo(otherSegment);
            if (result != 0)
                return result;
        }
        if (segments.size() == other.segments.size())
            return 0;
        if (segments.size() > other.segments.size())
            return 1;
        return -1;
    }

    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof Version))
            return false;
        return compareTo((Version) other) == 0;
    }

    @Override
    public int hashCode() {
        return hashCode;
    }

    @Override
    public String toString() {
        return asString;
    }
}
","// VersionTest.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Version}.
* It contains ten unit test cases for the {@link Version#compareTo(Version)} method.
*/
class VersionTest {","// VersionTest.java
package net.sourceforge.schemaspy.util;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Version}.
* It contains ten unit test cases for the {@link Version#compareTo(Version)} method.
*/
class VersionTest {

	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is null.
	 */
	@Test
	void testCompareToNull() {
		Version version = new Version(null);
		Version other = new Version(null);
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is empty.
	 */
	@Test
	void testCompareToEmpty() {
		Version version = new Version("""");
		Version other = new Version("""");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber() {
		Version version = new Version(""1"");
		Version other = new Version(""1"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber2() {
		Version version = new Version(""1"");
		Version other = new Version(""2"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber3() {
		Version version = new Version(""2"");
		Version other = new Version(""1"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber4() {
		Version version = new Version(""1"");
		Version other = new Version(""1.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber5() {
		Version version = new Version(""1.0"");
		Version other = new Version(""1"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber6() {
		Version version = new Version(""1.0"");
		Version other = new Version(""1.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber7() {
		Version version = new Version(""1.1"");
		Version other = new Version(""1.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber8() {
		Version version = new Version(""1.0"");
		Version other = new Version(""1.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber9() {
		Version version = new Version(""1.0.0"");
		Version other = new Version(""1.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber10() {
		Version version = new Version(""1.0.0"");
		Version other = new Version(""1.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber11() {
		Version version = new Version(""1.0.1"");
		Version other = new Version(""1.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber12() {
		Version version = new Version(""1.0.0"");
		Version other = new Version(""1.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber13() {
		Version version = new Version(""1.0.0.0"");
		Version other = new Version(""1.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber14() {
		Version version = new Version(""1.0.0.0"");
		Version other = new Version(""1.0.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber15() {
		Version version = new Version(""1.0.0.1"");
		Version other = new Version(""1.0.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber16() {
		Version version = new Version(""1.0.0.0"");
		Version other = new Version(""1.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber17() {
		Version version = new Version(""1.0.0.0.0"");
		Version other = new Version(""1.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber18() {
		Version version = new Version(""1.0.0.0.0"");
		Version other = new Version(""1.0.0.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber19() {
		Version version = new Version(""1.0.0.0.1"");
		Version other = new Version(""1.0.0.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber20() {
		Version version = new Version(""1.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber21() {
		Version version = new Version(""1.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber22() {
		Version version = new Version(""1.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber23() {
		Version version = new Version(""1.0.0.0.0.1"");
		Version other = new Version(""1.0.0.0.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber24() {
		Version version = new Version(""1.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber25() {
		Version version = new Version(""1.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber26() {
		Version version = new Version(""1.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber27() {
		Version version = new Version(""1.0.0.0.0.0.1"");
		Version other = new Version(""1.0.0.0.0.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber28() {
		Version version = new Version(""1.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber29() {
		Version version = new Version(""1.0.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber30() {
		Version version = new Version(""1.0.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0.1"");
		assertEquals(-1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber31() {
		Version version = new Version(""1.0.0.0.0.0.0.1"");
		Version other = new Version(""1.0.0.0.0.0.0.0"");
		assertEquals(1, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber32() {
		Version version = new Version(""1.0.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber33() {
		Version version = new Version(""1.0.0.0.0.0.0.0.0"");
		Version other = new Version(""1.0.0.0.0.0.0.0"");
		assertEquals(0, version.compareTo(other));
	}
	
	/**
	 * Test case for {@link Version#compareTo(Version)} method.
	 * It tests the case when the version is a single number.
	 */
	@Test
	void testCompareToSingleNumber34() {
		Version version = new Version(""1."
cmpl-6u8sDLlc66ZRyQmTB6awhEEJholvg,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DefaultSqlFormatter_0Test.java,106.70319080352783,length,"// DefaultSqlFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;

/**
 * Default implementation of {@link SqlFormatter}
 *
 * @author John Currier
 */
public class DefaultSqlFormatter implements SqlFormatter {

    private Set<String> keywords;

    private Map<String, Table> tablesByPossibleNames;

    private static String TOKENS = "" \t\n\r\f()<>|,"";

    /**
     * Return a HTML-formatted representation of the specified SQL.
     *
     * @param sql SQL to be formatted
     * @param db Database
     * @return HTML-formatted representation of the specified SQL
     */
    public String format(String sql, Database db, Set<Table> references) {
        StringBuilder formatted = new StringBuilder(sql.length() * 2);
        boolean alreadyFormatted = sql.contains(""\n"") || sql.contains(""\r"");
        if (alreadyFormatted) {
            // apparently already formatted, so dump it as is
            formatted.append(""<div class='viewDefinition preFormatted'>"");
            int len = sql.length();
            for (int i = 0; i < len; i++) {
                char ch = sql.charAt(i);
                // encode everything except whitespace
                if (Character.isWhitespace(ch)) {
                    formatted.append(ch);
                } else {
                    formatted.append(HtmlEncoder.encodeToken(ch));
                }
            }
        } else {
            formatted.append(""  <div class='viewDefinition'>"");
            @SuppressWarnings(""hiding"")
            Set<String> keywords = getKeywords(db.getMetaData());
            StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);
            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();
                if (keywords.contains(token.toUpperCase())) {
                    formatted.append(""<b>"");
                    formatted.append(token);
                    formatted.append(""</b>"");
                } else {
                    formatted.append(HtmlEncoder.encodeToken(token));
                }
            }
        }
        formatted.append(""</div>"");
        references.addAll(getReferencedTables(sql, db));
        return formatted.toString();
    }

    /**
     * Returns a {@link Set} of tables/views that are possibly referenced
     * by the specified SQL.
     *
     * @param sql
     * @param db
     * @return
     */
    protected Set<Table> getReferencedTables(String sql, Database db) {
        Set<Table> referenced = new HashSet<Table>();
        Map<String, Table> tables = getTableMap(db);
        @SuppressWarnings(""hiding"")
        Set<String> keywords = getKeywords(db.getMetaData());
        StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();
            if (!keywords.contains(token.toUpperCase())) {
                Table t = tables.get(token);
                if (t == null) {
                    int lastDot = token.lastIndexOf('.');
                    if (lastDot != -1) {
                        t = tables.get(token.substring(0, lastDot));
                    }
                }
                if (t != null) {
                    referenced.add(t);
                }
            }
        }
        return referenced;
    }

    /**
     * Returns a {@link Map} of all tables/views in the database
     * keyed by several possible ways to refer to the table.
     *
     * @param db
     * @return
     */
    protected Map<String, Table> getTableMap(Database db) {
        if (tablesByPossibleNames == null) {
            tablesByPossibleNames = new CaseInsensitiveMap<Table>();
            tablesByPossibleNames.putAll(getTableMap(db.getTables()));
            tablesByPossibleNames.putAll(getTableMap(db.getViews()));
        }
        return tablesByPossibleNames;
    }

    /**
     * Returns a {@link Map} of the specified tables/views
     * keyed by several possible ways to refer to the table.
     *
     * @param tables
     * @param dbName
     * @return
     */
    protected Map<String, Table> getTableMap(Collection<? extends Table> tables) {
        Map<String, Table> map = new CaseInsensitiveMap<Table>();
        for (Table t : tables) {
            String name = t.getName();
            String container = t.getContainer();
            map.put(name, t);
            map.put(""`"" + name + ""`"", t);
            map.put(""'"" + name + ""'"", t);
            map.put(""\"""" + name + ""\"""", t);
            map.put(container + ""."" + name, t);
            map.put(""`"" + container + ""`.`"" + name + ""`"", t);
            map.put(""'"" + container + ""'.'"" + name + ""'"", t);
            map.put(""\"""" + container + ""\"".\"""" + name + ""\"""", t);
            map.put(""`"" + container + '.' + name + ""`"", t);
            map.put(""'"" + container + '.' + name + ""'"", t);
            map.put(""\"""" + container + '.' + name + ""\"""", t);
        }
        return map;
    }

    /**
     * @param meta
     * @return
     */
    public Set<String> getKeywords(DatabaseMetaData meta) {
        if (keywords == null) {
            keywords = new HashSet<String>(Arrays.asList(new String[] { ""ABSOLUTE"", ""ACTION"", ""ADD"", ""ALL"", ""ALLOCATE"", ""ALTER"", ""AND"", ""ANY"", ""ARE"", ""AS"", ""ASC"", ""ASSERTION"", ""AT"", ""AUTHORIZATION"", ""AVG"", ""BEGIN"", ""BETWEEN"", ""BIT"", ""BIT_LENGTH"", ""BOTH"", ""BY"", ""CASCADE"", ""CASCADED"", ""CASE"", ""CAST"", ""CATALOG"", ""CHAR"", ""CHARACTER"", ""CHAR_LENGTH"", ""CHARACTER_LENGTH"", ""CHECK"", ""CLOSE"", ""COALESCE"", ""COLLATE"", ""COLLATION"", ""COLUMN"", ""COMMIT"", ""CONNECT"", ""CONNECTION"", ""CONSTRAINT"", ""CONSTRAINTS"", ""CONTINUE"", ""CONVERT"", ""CORRESPONDING"", ""COUNT"", ""CREATE"", ""CROSS"", ""CURRENT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""CURRENT_USER"", ""CURSOR"", ""DATE"", ""DAY"", ""DEALLOCATE"", ""DEC"", ""DECIMAL"", ""DECLARE"", ""DEFAULT"", ""DEFERRABLE"", ""DEFERRED"", ""DELETE"", ""DESC"", ""DESCRIBE"", ""DESCRIPTOR"", ""DIAGNOSTICS"", ""DISCONNECT"", ""DISTINCT"", ""DOMAIN"", ""DOUBLE"", ""DROP"", ""ELSE"", ""END"", ""END - EXEC"", ""ESCAPE"", ""EXCEPT"", ""EXCEPTION"", ""EXEC"", ""EXECUTE"", ""EXISTS"", ""EXTERNAL"", ""EXTRACT"", ""FALSE"", ""FETCH"", ""FIRST"", ""FLOAT"", ""FOR"", ""FOREIGN"", ""FOUND"", ""FROM"", ""FULL"", ""GET"", ""GLOBAL"", ""GO"", ""GOTO"", ""GRANT"", ""GROUP"", ""HAVING"", ""HOUR"", ""IDENTITY"", ""IMMEDIATE"", ""IN"", ""INDICATOR"", ""INITIALLY"", ""INNER"", ""INPUT"", ""INSENSITIVE"", ""INSERT"", ""INT"", ""INTEGER"", ""INTERSECT"", ""INTERVAL"", ""INTO"", ""IS"", ""ISOLATION"", ""JOIN"", ""KEY"", ""LANGUAGE"", ""LAST"", ""LEADING"", ""LEFT"", ""LEVEL"", ""LIKE"", ""LOCAL"", ""LOWER"", ""MATCH"", ""MAX"", ""MIN"", ""MINUTE"", ""MODULE"", ""MONTH"", ""NAMES"", ""NATIONAL"", ""NATURAL"", ""NCHAR"", ""NEXT"", ""NO"", ""NOT"", ""NULL"", ""NULLIF"", ""NUMERIC"", ""OCTET_LENGTH"", ""OF"", ""ON"", ""ONLY"", ""OPEN"", ""OPTION"", ""OR"", ""ORDER"", ""OUTER"", ""OUTPUT"", ""OVERLAPS"", ""PAD"", ""PARTIAL"", ""POSITION"", ""PRECISION"", ""PREPARE"", ""PRESERVE"", ""PRIMARY"", ""PRIOR"", ""PRIVILEGES"", ""PROCEDURE"", ""PUBLIC"", ""READ"", ""REAL"", ""REFERENCES"", ""RELATIVE"", ""RESTRICT"", ""REVOKE"", ""RIGHT"", ""ROLLBACK"", ""ROWS"", ""SCHEMA"", ""SCROLL"", ""SECOND"", ""SECTION"", ""SELECT"", ""SESSION"", ""SESSION_USER"", ""SET"", ""SIZE"", ""SMALLINT"", ""SOME"", ""SPACE"", ""SQL"", ""SQLCODE"", ""SQLERROR"", ""SQLSTATE"", ""SUBSTRING"", ""SUM"", ""SYSTEM_USER"", ""TABLE"", ""TEMPORARY"", ""THEN"", ""TIME"", ""TIMESTAMP"", ""TIMEZONE_HOUR"", ""TIMEZONE_MINUTE"", ""TO"", ""TRAILING"", ""TRANSACTION"", ""TRANSLATE"", ""TRANSLATION"", ""TRIM"", ""TRUE"", ""UNION"", ""UNIQUE"", ""UNKNOWN"", ""UPDATE"", ""UPPER"", ""USAGE"", ""USER"", ""USING"", ""VALUE"", ""VALUES"", ""VARCHAR"", ""VARYING"", ""VIEW"", ""WHEN"", ""WHENEVER"", ""WHERE"", ""WITH"", ""WORK"", ""WRITE"", ""YEAR"", ""ZONE"" }));
            try {
                String[] keywordsArray = new String[] { meta.getSQLKeywords(), meta.getSystemFunctions(), meta.getNumericFunctions(), meta.getStringFunctions(), meta.getTimeDateFunctions() };
                for (int i = 0; i < keywordsArray.length; ++i) {
                    StringTokenizer tokenizer = new StringTokenizer(keywordsArray[i].toUpperCase(), "","");
                    while (tokenizer.hasMoreTokens()) {
                        keywords.add(tokenizer.nextToken().trim());
                    }
                }
            } catch (Exception exc) {
                // don't totally fail just because we can't extract these details...
                System.err.println(exc);
            }
        }
        return keywords;
    }
}
","// DefaultSqlFormatter_0Test.java
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultSqlFormatter}.
* It contains ten unit test cases for the {@link DefaultSqlFormatter#format(String, Database, Set)} method.
*/
class DefaultSqlFormatter_0Test {","// DefaultSqlFormatter_0Test.java
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultSqlFormatter}.
* It contains ten unit test cases for the {@link DefaultSqlFormatter#format(String, Database, Set)} method.
*/
class DefaultSqlFormatter_0Test {

	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is already formatted.
	 * </p>
	 */
	@Test
	void testFormat_0() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""<div class='viewDefinition preFormatted'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_1() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_2() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_3() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_4() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_5() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_6() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_7() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_8() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#format(String, Database, Set)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testFormat_9() {
		String sql = ""SELECT * FROM table1"";
		Database db = new Database();
		Set<Table> references = new HashSet<Table>();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		String result = defaultSqlFormatter.format(sql, db, references);
		assertEquals(""  <div class='viewDefinition'>SELECT * FROM table1</div>"", result);
	}
	
}

// DefaultSqlFormatter_1Test.java
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultSqlFormatter}.
* It contains ten unit test cases for the {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)} method.
*/
class DefaultSqlFormatter_1Test {
		
	/**
	 * Test case for {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is already formatted.
	 * </p>
	 */
	@Test
	void testGetKeywords_0() {
		DatabaseMetaData meta = new DatabaseMetaData();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		Set<String> result = defaultSqlFormatter.getKeywords(meta);
		assertEquals(new HashSet<String>(Arrays.asList(new String[] { ""ABSOLUTE"", ""ACTION"", ""ADD"", ""ALL"", ""ALLOCATE"", ""ALTER"", ""AND"", ""ANY"", ""ARE"", ""AS"", ""ASC"", ""ASSERTION"", ""AT"", ""AUTHORIZATION"", ""AVG"", ""BEGIN"", ""BETWEEN"", ""BIT"", ""BIT_LENGTH"", ""BOTH"", ""BY"", ""CASCADE"", ""CASCADED"", ""CASE"", ""CAST"", ""CATALOG"", ""CHAR"", ""CHARACTER"", ""CHAR_LENGTH"", ""CHARACTER_LENGTH"", ""CHECK"", ""CLOSE"", ""COALESCE"", ""COLLATE"", ""COLLATION"", ""COLUMN"", ""COMMIT"", ""CONNECT"", ""CONNECTION"", ""CONSTRAINT"", ""CONSTRAINTS"", ""CONTINUE"", ""CONVERT"", ""CORRESPONDING"", ""COUNT"", ""CREATE"", ""CROSS"", ""CURRENT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""CURRENT_USER"", ""CURSOR"", ""DATE"", ""DAY"", ""DEALLOCATE"", ""DEC"", ""DECIMAL"", ""DECLARE"", ""DEFAULT"", ""DEFERRABLE"", ""DEFERRED"", ""DELETE"", ""DESC"", ""DESCRIBE"", ""DESCRIPTOR"", ""DIAGNOSTICS"", ""DISCONNECT"", ""DISTINCT"", ""DOMAIN"", ""DOUBLE"", ""DROP"", ""ELSE"", ""END"", ""END - EXEC"", ""ESCAPE"", ""EXCEPT"", ""EXCEPTION"", ""EXEC"", ""EXECUTE"", ""EXISTS"", ""EXTERNAL"", ""EXTRACT"", ""FALSE"", ""FETCH"", ""FIRST"", ""FLOAT"", ""FOR"", ""FOREIGN"", ""FOUND"", ""FROM"", ""FULL"", ""GET"", ""GLOBAL"", ""GO"", ""GOTO"", ""GRANT"", ""GROUP"", ""HAVING"", ""HOUR"", ""IDENTITY"", ""IMMEDIATE"", ""IN"", ""INDICATOR"", ""INITIALLY"", ""INNER"", ""INPUT"", ""INSENSITIVE"", ""INSERT"", ""INT"", ""INTEGER"", ""INTERSECT"", ""INTERVAL"", ""INTO"", ""IS"", ""ISOLATION"", ""JOIN"", ""KEY"", ""LANGUAGE"", ""LAST"", ""LEADING"", ""LEFT"", ""LEVEL"", ""LIKE"", ""LOCAL"", ""LOWER"", ""MATCH"", ""MAX"", ""MIN"", ""MINUTE"", ""MODULE"", ""MONTH"", ""NAMES"", ""NATIONAL"", ""NATURAL"", ""NCHAR"", ""NEXT"", ""NO"", ""NOT"", ""NULL"", ""NULLIF"", ""NUMERIC"", ""OCTET_LENGTH"", ""OF"", ""ON"", ""ONLY"", ""OPEN"", ""OPTION"", ""OR"", ""ORDER"", ""OUTER"", ""OUTPUT"", ""OVERLAPS"", ""PAD"", ""PARTIAL"", ""POSITION"", ""PRECISION"", ""PREPARE"", ""PRESERVE"", ""PRIMARY"", ""PRIOR"", ""PRIVILEGES"", ""PROCEDURE"", ""PUBLIC"", ""READ"", ""REAL"", ""REFERENCES"", ""RELATIVE"", ""RESTRICT"", ""REVOKE"", ""RIGHT"", ""ROLLBACK"", ""ROWS"", ""SCHEMA"", ""SCROLL"", ""SECOND"", ""SECTION"", ""SELECT"", ""SESSION"", ""SESSION_USER"", ""SET"", ""SIZE"", ""SMALLINT"", ""SOME"", ""SPACE"", ""SQL"", ""SQLCODE"", ""SQLERROR"", ""SQLSTATE"", ""SUBSTRING"", ""SUM"", ""SYSTEM_USER"", ""TABLE"", ""TEMPORARY"", ""THEN"", ""TIME"", ""TIMESTAMP"", ""TIMEZONE_HOUR"", ""TIMEZONE_MINUTE"", ""TO"", ""TRAILING"", ""TRANSACTION"", ""TRANSLATE"", ""TRANSLATION"", ""TRIM"", ""TRUE"", ""UNION"", ""UNIQUE"", ""UNKNOWN"", ""UPDATE"", ""UPPER"", ""USAGE"", ""USER"", ""USING"", ""VALUE"", ""VALUES"", ""VARCHAR"", ""VARYING"", ""VIEW"", ""WHEN"", ""WHENEVER"", ""WHERE"", ""WITH"", ""WORK"", ""WRITE"", ""YEAR"", ""ZONE"" })), result);
	}
	
	/**
	 * Test case for {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)}
	 * 
	 * <p>
	 * Test case for the scenario where the input SQL is not formatted.
	 * </p>
	 */
	@Test
	void testGetKeywords_1() {
		DatabaseMetaData meta = new DatabaseMetaData();
		DefaultSqlFormatter defaultSqlFormatter = new DefaultSqlFormatter();
		Set<String> result = defaultSqlFormatter.getKeywords(meta);
		assertEquals(new HashSet<String>(Arrays.asList(new String[] { ""ABSOLUTE"", ""ACTION"", ""ADD"", ""ALL"", ""ALLOCATE"", ""ALTER"", ""AND"", ""ANY"", ""ARE"", ""AS"", ""ASC"", ""ASSERTION"", ""AT"", ""AUTHORIZATION"", ""AVG"", ""BEGIN"", ""BETWEEN"", ""BIT"", ""BIT_LENGTH"", ""BOTH"", ""BY"", ""CASCADE"", ""CASCADED"", ""CASE"", ""CAST"", ""CATALOG"", ""CHAR"", ""CHARACTER"", ""CHAR_LENGTH"", ""CHARACTER_LENGTH"", ""CHECK"", ""CLOSE"", ""COALESCE"", ""COLLATE"", ""COLLATION"", ""COLUMN"", ""COMMIT"", ""CONNECT"", ""CONNECTION"", ""CONSTRAINT"", ""CONSTRAINTS"", ""CONTINUE"", ""CONVERT"", ""CORRESPONDING"", ""COUNT"", ""CREATE"", ""CROSS"", ""CURRENT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""CURRENT_USER"", ""CURSOR"", ""DATE"", ""DAY"", ""DEALLOCATE"", ""DEC"", ""DECIMAL"", ""DECLARE"", ""DEFAULT"", ""DEFERRABLE"", ""DEFERRED"", ""DELETE"", ""DESC"", ""DESCRIBE"", ""DESCRIPTOR"", ""DIAGNOSTICS"", ""DISCONNECT"", ""DISTINCT"", ""DOMAIN"", ""DOUBLE"", ""DROP"", ""ELSE"", ""END"", ""END - EXEC"", ""ESCAPE"", ""EXCEPT"", ""EXCEPTION"", ""EXEC"", ""EXECUTE"", ""EXISTS"", ""EXTERNAL"", ""EXTRACT"", ""FALSE"", ""FETCH"", ""FIRST"", ""FLOAT"", ""FOR"", ""FOREIGN"", ""FOUND"", ""FROM"", ""FULL"", ""GET"", ""GLOBAL"", ""GO"", ""GOTO"", ""GRANT"", ""GROUP"", ""HAVING"", ""HOUR"", ""IDENTITY"", ""IMMEDIATE"", ""IN"", ""INDICATOR"", ""INITIALLY"", ""INNER"", ""INPUT"", ""INSENSITIVE"", ""INSERT"", ""INT"", ""INTEGER"", ""INTERSECT"", ""INTERVAL"", ""INTO"", ""IS"", ""ISOLATION"", ""JOIN"", ""KEY"", ""LANGUAGE"", ""LAST"", ""LEADING"", ""LEFT"", ""LEVEL"", ""LIKE"", ""LOCAL"", ""LOWER"", ""M"
cmpl-6u8tw4vMxQeVQAZ2jCzAtZ7iK0r8t,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DefaultSqlFormatter_1Test.java,108.62224316596985,length,"// DefaultSqlFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;

/**
 * Default implementation of {@link SqlFormatter}
 *
 * @author John Currier
 */
public class DefaultSqlFormatter implements SqlFormatter {

    private Set<String> keywords;

    private Map<String, Table> tablesByPossibleNames;

    private static String TOKENS = "" \t\n\r\f()<>|,"";

    /**
     * Return a HTML-formatted representation of the specified SQL.
     *
     * @param sql SQL to be formatted
     * @param db Database
     * @return HTML-formatted representation of the specified SQL
     */
    public String format(String sql, Database db, Set<Table> references) {
        StringBuilder formatted = new StringBuilder(sql.length() * 2);
        boolean alreadyFormatted = sql.contains(""\n"") || sql.contains(""\r"");
        if (alreadyFormatted) {
            // apparently already formatted, so dump it as is
            formatted.append(""<div class='viewDefinition preFormatted'>"");
            int len = sql.length();
            for (int i = 0; i < len; i++) {
                char ch = sql.charAt(i);
                // encode everything except whitespace
                if (Character.isWhitespace(ch)) {
                    formatted.append(ch);
                } else {
                    formatted.append(HtmlEncoder.encodeToken(ch));
                }
            }
        } else {
            formatted.append(""  <div class='viewDefinition'>"");
            @SuppressWarnings(""hiding"")
            Set<String> keywords = getKeywords(db.getMetaData());
            StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);
            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();
                if (keywords.contains(token.toUpperCase())) {
                    formatted.append(""<b>"");
                    formatted.append(token);
                    formatted.append(""</b>"");
                } else {
                    formatted.append(HtmlEncoder.encodeToken(token));
                }
            }
        }
        formatted.append(""</div>"");
        references.addAll(getReferencedTables(sql, db));
        return formatted.toString();
    }

    /**
     * Returns a {@link Set} of tables/views that are possibly referenced
     * by the specified SQL.
     *
     * @param sql
     * @param db
     * @return
     */
    protected Set<Table> getReferencedTables(String sql, Database db) {
        Set<Table> referenced = new HashSet<Table>();
        Map<String, Table> tables = getTableMap(db);
        @SuppressWarnings(""hiding"")
        Set<String> keywords = getKeywords(db.getMetaData());
        StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();
            if (!keywords.contains(token.toUpperCase())) {
                Table t = tables.get(token);
                if (t == null) {
                    int lastDot = token.lastIndexOf('.');
                    if (lastDot != -1) {
                        t = tables.get(token.substring(0, lastDot));
                    }
                }
                if (t != null) {
                    referenced.add(t);
                }
            }
        }
        return referenced;
    }

    /**
     * Returns a {@link Map} of all tables/views in the database
     * keyed by several possible ways to refer to the table.
     *
     * @param db
     * @return
     */
    protected Map<String, Table> getTableMap(Database db) {
        if (tablesByPossibleNames == null) {
            tablesByPossibleNames = new CaseInsensitiveMap<Table>();
            tablesByPossibleNames.putAll(getTableMap(db.getTables()));
            tablesByPossibleNames.putAll(getTableMap(db.getViews()));
        }
        return tablesByPossibleNames;
    }

    /**
     * Returns a {@link Map} of the specified tables/views
     * keyed by several possible ways to refer to the table.
     *
     * @param tables
     * @param dbName
     * @return
     */
    protected Map<String, Table> getTableMap(Collection<? extends Table> tables) {
        Map<String, Table> map = new CaseInsensitiveMap<Table>();
        for (Table t : tables) {
            String name = t.getName();
            String container = t.getContainer();
            map.put(name, t);
            map.put(""`"" + name + ""`"", t);
            map.put(""'"" + name + ""'"", t);
            map.put(""\"""" + name + ""\"""", t);
            map.put(container + ""."" + name, t);
            map.put(""`"" + container + ""`.`"" + name + ""`"", t);
            map.put(""'"" + container + ""'.'"" + name + ""'"", t);
            map.put(""\"""" + container + ""\"".\"""" + name + ""\"""", t);
            map.put(""`"" + container + '.' + name + ""`"", t);
            map.put(""'"" + container + '.' + name + ""'"", t);
            map.put(""\"""" + container + '.' + name + ""\"""", t);
        }
        return map;
    }

    /**
     * @param meta
     * @return
     */
    public Set<String> getKeywords(DatabaseMetaData meta) {
        if (keywords == null) {
            keywords = new HashSet<String>(Arrays.asList(new String[] { ""ABSOLUTE"", ""ACTION"", ""ADD"", ""ALL"", ""ALLOCATE"", ""ALTER"", ""AND"", ""ANY"", ""ARE"", ""AS"", ""ASC"", ""ASSERTION"", ""AT"", ""AUTHORIZATION"", ""AVG"", ""BEGIN"", ""BETWEEN"", ""BIT"", ""BIT_LENGTH"", ""BOTH"", ""BY"", ""CASCADE"", ""CASCADED"", ""CASE"", ""CAST"", ""CATALOG"", ""CHAR"", ""CHARACTER"", ""CHAR_LENGTH"", ""CHARACTER_LENGTH"", ""CHECK"", ""CLOSE"", ""COALESCE"", ""COLLATE"", ""COLLATION"", ""COLUMN"", ""COMMIT"", ""CONNECT"", ""CONNECTION"", ""CONSTRAINT"", ""CONSTRAINTS"", ""CONTINUE"", ""CONVERT"", ""CORRESPONDING"", ""COUNT"", ""CREATE"", ""CROSS"", ""CURRENT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""CURRENT_USER"", ""CURSOR"", ""DATE"", ""DAY"", ""DEALLOCATE"", ""DEC"", ""DECIMAL"", ""DECLARE"", ""DEFAULT"", ""DEFERRABLE"", ""DEFERRED"", ""DELETE"", ""DESC"", ""DESCRIBE"", ""DESCRIPTOR"", ""DIAGNOSTICS"", ""DISCONNECT"", ""DISTINCT"", ""DOMAIN"", ""DOUBLE"", ""DROP"", ""ELSE"", ""END"", ""END - EXEC"", ""ESCAPE"", ""EXCEPT"", ""EXCEPTION"", ""EXEC"", ""EXECUTE"", ""EXISTS"", ""EXTERNAL"", ""EXTRACT"", ""FALSE"", ""FETCH"", ""FIRST"", ""FLOAT"", ""FOR"", ""FOREIGN"", ""FOUND"", ""FROM"", ""FULL"", ""GET"", ""GLOBAL"", ""GO"", ""GOTO"", ""GRANT"", ""GROUP"", ""HAVING"", ""HOUR"", ""IDENTITY"", ""IMMEDIATE"", ""IN"", ""INDICATOR"", ""INITIALLY"", ""INNER"", ""INPUT"", ""INSENSITIVE"", ""INSERT"", ""INT"", ""INTEGER"", ""INTERSECT"", ""INTERVAL"", ""INTO"", ""IS"", ""ISOLATION"", ""JOIN"", ""KEY"", ""LANGUAGE"", ""LAST"", ""LEADING"", ""LEFT"", ""LEVEL"", ""LIKE"", ""LOCAL"", ""LOWER"", ""MATCH"", ""MAX"", ""MIN"", ""MINUTE"", ""MODULE"", ""MONTH"", ""NAMES"", ""NATIONAL"", ""NATURAL"", ""NCHAR"", ""NEXT"", ""NO"", ""NOT"", ""NULL"", ""NULLIF"", ""NUMERIC"", ""OCTET_LENGTH"", ""OF"", ""ON"", ""ONLY"", ""OPEN"", ""OPTION"", ""OR"", ""ORDER"", ""OUTER"", ""OUTPUT"", ""OVERLAPS"", ""PAD"", ""PARTIAL"", ""POSITION"", ""PRECISION"", ""PREPARE"", ""PRESERVE"", ""PRIMARY"", ""PRIOR"", ""PRIVILEGES"", ""PROCEDURE"", ""PUBLIC"", ""READ"", ""REAL"", ""REFERENCES"", ""RELATIVE"", ""RESTRICT"", ""REVOKE"", ""RIGHT"", ""ROLLBACK"", ""ROWS"", ""SCHEMA"", ""SCROLL"", ""SECOND"", ""SECTION"", ""SELECT"", ""SESSION"", ""SESSION_USER"", ""SET"", ""SIZE"", ""SMALLINT"", ""SOME"", ""SPACE"", ""SQL"", ""SQLCODE"", ""SQLERROR"", ""SQLSTATE"", ""SUBSTRING"", ""SUM"", ""SYSTEM_USER"", ""TABLE"", ""TEMPORARY"", ""THEN"", ""TIME"", ""TIMESTAMP"", ""TIMEZONE_HOUR"", ""TIMEZONE_MINUTE"", ""TO"", ""TRAILING"", ""TRANSACTION"", ""TRANSLATE"", ""TRANSLATION"", ""TRIM"", ""TRUE"", ""UNION"", ""UNIQUE"", ""UNKNOWN"", ""UPDATE"", ""UPPER"", ""USAGE"", ""USER"", ""USING"", ""VALUE"", ""VALUES"", ""VARCHAR"", ""VARYING"", ""VIEW"", ""WHEN"", ""WHENEVER"", ""WHERE"", ""WITH"", ""WORK"", ""WRITE"", ""YEAR"", ""ZONE"" }));
            try {
                String[] keywordsArray = new String[] { meta.getSQLKeywords(), meta.getSystemFunctions(), meta.getNumericFunctions(), meta.getStringFunctions(), meta.getTimeDateFunctions() };
                for (int i = 0; i < keywordsArray.length; ++i) {
                    StringTokenizer tokenizer = new StringTokenizer(keywordsArray[i].toUpperCase(), "","");
                    while (tokenizer.hasMoreTokens()) {
                        keywords.add(tokenizer.nextToken().trim());
                    }
                }
            } catch (Exception exc) {
                // don't totally fail just because we can't extract these details...
                System.err.println(exc);
            }
        }
        return keywords;
    }
}
","// DefaultSqlFormatter_1Test.java
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultSqlFormatter}.
* It contains ten unit test cases for the {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)} method.
*/
class DefaultSqlFormatter_1Test {","// DefaultSqlFormatter_1Test.java
package net.sourceforge.schemaspy.view;

import java.sql.DatabaseMetaData;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultSqlFormatter}.
* It contains ten unit test cases for the {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)} method.
*/
class DefaultSqlFormatter_1Test {

	/**
	 * Test case for {@link DefaultSqlFormatter#getKeywords(DatabaseMetaData)}
	 * 
	 * @throws Exception
	 */
	@Test
	void testGetKeywords() throws Exception {
		DefaultSqlFormatter fixture = new DefaultSqlFormatter();
		DatabaseMetaData meta = null;
		Set<String> result = fixture.getKeywords(meta);
		assertNotNull(result);
		assertEquals(true, result.contains(""ABSOLUTE""));
		assertEquals(true, result.contains(""ACTION""));
		assertEquals(true, result.contains(""ADD""));
		assertEquals(true, result.contains(""ALL""));
		assertEquals(true, result.contains(""ALLOCATE""));
		assertEquals(true, result.contains(""ALTER""));
		assertEquals(true, result.contains(""AND""));
		assertEquals(true, result.contains(""ANY""));
		assertEquals(true, result.contains(""ARE""));
		assertEquals(true, result.contains(""AS""));
		assertEquals(true, result.contains(""ASC""));
		assertEquals(true, result.contains(""ASSERTION""));
		assertEquals(true, result.contains(""AT""));
		assertEquals(true, result.contains(""AUTHORIZATION""));
		assertEquals(true, result.contains(""AVG""));
		assertEquals(true, result.contains(""BEGIN""));
		assertEquals(true, result.contains(""BETWEEN""));
		assertEquals(true, result.contains(""BIT""));
		assertEquals(true, result.contains(""BIT_LENGTH""));
		assertEquals(true, result.contains(""BOTH""));
		assertEquals(true, result.contains(""BY""));
		assertEquals(true, result.contains(""CASCADE""));
		assertEquals(true, result.contains(""CASCADED""));
		assertEquals(true, result.contains(""CASE""));
		assertEquals(true, result.contains(""CAST""));
		assertEquals(true, result.contains(""CATALOG""));
		assertEquals(true, result.contains(""CHAR""));
		assertEquals(true, result.contains(""CHARACTER""));
		assertEquals(true, result.contains(""CHAR_LENGTH""));
		assertEquals(true, result.contains(""CHARACTER_LENGTH""));
		assertEquals(true, result.contains(""CHECK""));
		assertEquals(true, result.contains(""CLOSE""));
		assertEquals(true, result.contains(""COALESCE""));
		assertEquals(true, result.contains(""COLLATE""));
		assertEquals(true, result.contains(""COLLATION""));
		assertEquals(true, result.contains(""COLUMN""));
		assertEquals(true, result.contains(""COMMIT""));
		assertEquals(true, result.contains(""CONNECT""));
		assertEquals(true, result.contains(""CONNECTION""));
		assertEquals(true, result.contains(""CONSTRAINT""));
		assertEquals(true, result.contains(""CONSTRAINTS""));
		assertEquals(true, result.contains(""CONTINUE""));
		assertEquals(true, result.contains(""CONVERT""));
		assertEquals(true, result.contains(""CORRESPONDING""));
		assertEquals(true, result.contains(""COUNT""));
		assertEquals(true, result.contains(""CREATE""));
		assertEquals(true, result.contains(""CROSS""));
		assertEquals(true, result.contains(""CURRENT""));
		assertEquals(true, result.contains(""CURRENT_DATE""));
		assertEquals(true, result.contains(""CURRENT_TIME""));
		assertEquals(true, result.contains(""CURRENT_TIMESTAMP""));
		assertEquals(true, result.contains(""CURRENT_USER""));
		assertEquals(true, result.contains(""CURSOR""));
		assertEquals(true, result.contains(""DATE""));
		assertEquals(true, result.contains(""DAY""));
		assertEquals(true, result.contains(""DEALLOCATE""));
		assertEquals(true, result.contains(""DEC""));
		assertEquals(true, result.contains(""DECIMAL""));
		assertEquals(true, result.contains(""DECLARE""));
		assertEquals(true, result.contains(""DEFAULT""));
		assertEquals(true, result.contains(""DEFERRABLE""));
		assertEquals(true, result.contains(""DEFERRED""));
		assertEquals(true, result.contains(""DELETE""));
		assertEquals(true, result.contains(""DESC""));
		assertEquals(true, result.contains(""DESCRIBE""));
		assertEquals(true, result.contains(""DESCRIPTOR""));
		assertEquals(true, result.contains(""DIAGNOSTICS""));
		assertEquals(true, result.contains(""DISCONNECT""));
		assertEquals(true, result.contains(""DISTINCT""));
		assertEquals(true, result.contains(""DOMAIN""));
		assertEquals(true, result.contains(""DOUBLE""));
		assertEquals(true, result.contains(""DROP""));
		assertEquals(true, result.contains(""ELSE""));
		assertEquals(true, result.contains(""END""));
		assertEquals(true, result.contains(""END - EXEC""));
		assertEquals(true, result.contains(""ESCAPE""));
		assertEquals(true, result.contains(""EXCEPT""));
		assertEquals(true, result.contains(""EXCEPTION""));
		assertEquals(true, result.contains(""EXEC""));
		assertEquals(true, result.contains(""EXECUTE""));
		assertEquals(true, result.contains(""EXISTS""));
		assertEquals(true, result.contains(""EXTERNAL""));
		assertEquals(true, result.contains(""EXTRACT""));
		assertEquals(true, result.contains(""FALSE""));
		assertEquals(true, result.contains(""FETCH""));
		assertEquals(true, result.contains(""FIRST""));
		assertEquals(true, result.contains(""FLOAT""));
		assertEquals(true, result.contains(""FOR""));
		assertEquals(true, result.contains(""FOREIGN""));
		assertEquals(true, result.contains(""FOUND""));
		assertEquals(true, result.contains(""FROM""));
		assertEquals(true, result.contains(""FULL""));
		assertEquals(true, result.contains(""GET""));
		assertEquals(true, result.contains(""GLOBAL""));
		assertEquals(true, result.contains(""GO""));
		assertEquals(true, result.contains(""GOTO""));
		assertEquals(true, result.contains(""GRANT""));
		assertEquals(true, result.contains(""GROUP""));
		assertEquals(true, result.contains(""HAVING""));
		assertEquals(true, result.contains(""HOUR""));
		assertEquals(true, result.contains(""IDENTITY""));
		assertEquals(true, result.contains(""IMMEDIATE""));
		assertEquals(true, result.contains(""IN""));
		assertEquals(true, result.contains(""INDICATOR""));
		assertEquals(true, result.contains(""INITIALLY""));
		assertEquals(true, result.contains(""INNER""));
		assertEquals(true, result.contains(""INPUT""));
		assertEquals(true, result.contains(""INSENSITIVE""));
		assertEquals(true, result.contains(""INSERT""));
		assertEquals(true, result.contains(""INT""));
		assertEquals(true, result.contains(""INTEGER""));
		assertEquals(true, result.contains(""INTERSECT""));
		assertEquals(true, result.contains(""INTERVAL""));
		assertEquals(true, result.contains(""INTO""));
		assertEquals(true, result.contains(""IS""));
		assertEquals(true, result.contains(""ISOLATION""));
		assertEquals(true, result.contains(""JOIN""));
		assertEquals(true, result.contains(""KEY""));
		assertEquals(true, result.contains(""LANGUAGE""));
		assertEquals(true, result.contains(""LAST""));
		assertEquals(true, result.contains(""LEADING""));
		assertEquals(true, result.contains(""LEFT""));
		assertEquals(true, result.contains(""LEVEL""));
		assertEquals(true, result.contains(""LIKE""));
		assertEquals(true, result.contains(""LOCAL""));
		assertEquals(true, result.contains(""LOWER""));
		assertEquals(true, result.contains(""MATCH""));
		assertEquals(true, result.contains(""MAX""));
		assertEquals(true, result.contains(""MIN""));
		assertEquals(true, result.contains(""MINUTE""));
		assertEquals(true, result.contains(""MODULE""));
		assertEquals(true, result.contains(""MONTH""));
		assertEquals(true, result.contains(""NAMES""));
		assertEquals(true, result.contains(""NATIONAL""));
		assertEquals(true, result.contains(""NATURAL""));
		assertEquals(true, result.contains(""NCHAR""));
		assertEquals(true, result.contains(""NEXT""));
		assertEquals(true, result.contains(""NO""));
		assertEquals(true, result.contains(""NOT""));
		assertEquals(true, result.contains(""NULL""));
		assertEquals(true, result.contains(""NULLIF""));
		assertEquals(true, result.contains(""NUMERIC""));
		assertEquals(true, result.contains(""OCTET_LENGTH""));
		assertEquals(true, result.contains(""OF""));
		assertEquals(true, result.contains(""ON""));
		assertEquals(true, result.contains(""ONLY""));
		assertEquals(true, result.contains(""OPEN""));
		assertEquals(true, result.contains(""OPTION""));
		assertEquals(true, result.contains(""OR""));
		assertEquals(true, result.contains(""ORDER""));
		assertEquals(true, result.contains(""OUTER""));
		assertEquals(true, result.contains(""OUTPUT""));
		assertEquals(true, result.contains(""OVERLAPS""));
		assertEquals(true, result.contains(""PAD""));
		assertEquals(true, result.contains(""PARTIAL""));
		assertEquals(true, result.contains(""POSITION""));
		assertEquals(true, result.contains(""PRECISION""));
		assertEquals(true, result.contains(""PREPARE""));
		assertEquals(true, result.contains(""PRESERVE""));
		assertEquals(true, result.contains(""PRIMARY""));
		assertEquals(true, result.contains(""PRIOR""));
		assertEquals(true, result.contains(""PRIVILEGES""));
		assertEquals(true, result.contains(""PROCEDURE""));
		assertEquals(true, result.contains(""PUBLIC""));
		assertEquals(true, result.contains(""READ""));
		assertEquals(true, result.contains(""REAL""));
		assertEquals(true, result.contains(""REFERENCES""));
		assertEquals(true, result.contains(""RELATIVE""));
		assertEquals(true, result.contains(""RESTRICT""));
		assertEquals(true, result.contains(""REVOKE""));
		assertEquals(true, result.contains(""RIGHT""));
		assertEquals(true, result.contains(""ROLLBACK""));
		assertEquals(true, result.contains(""ROWS""));
		assertEquals(true, result.contains(""SCHEMA""));
		assertEquals(true, result.contains(""SCROLL""));
		assertEquals(true, result.contains(""SECOND""));
		assertEquals(true, result.contains(""SECTION""));
		assertEquals(true, result.contains(""SELECT""));
		assertEquals(true, result.contains(""SESSION""));
		assertEquals(true, result.contains(""SESSION_USER""));
		assertEquals(true, result.contains(""SET""));
		assertEquals(true, result.contains(""SIZE""));
		assertEquals(true, result.contains(""SMALLINT""));
		assertEquals(true, result.contains(""SOME""));
		assertEquals(true, result.contains(""SPACE""));
		assertEquals(true, result.contains(""SQL""));
		assertEquals(true, result.contains(""SQLCODE""));
		assertEquals(true, result.contains(""SQLERROR""));
		assertEquals(true, result.contains(""SQLSTATE""));
		assertEquals(true, result.contains(""SUBSTRING""));
		assertEquals(true, result.contains(""SUM""));
		assertEquals(true, result.contains(""SYSTEM_USER""));
		assertEquals(true, result.contains(""TABLE""));
		assertEquals(true, result.contains(""TEMPORARY""));
		assertEquals(true, result.contains(""THEN""));
		assertEquals(true, result.contains(""TIME""));
		assertEquals(true, result.contains(""TIMESTAMP""));
		assertEquals(true, result.contains(""TIMEZONE_HOUR""));
		assertEquals(true, result.contains(""TIMEZONE_MINUTE""));
		assertEquals(true, result.contains(""TO""));
		assertEquals(true, result.contains(""TRAILING""));
		assertEquals(true, result.contains(""TRANSACTION""));
		assertEquals(true, result.contains(""TRANSLATE""));
		assertEquals(true, result.contains(""TRANSLATION""));
		assertEquals(true, result.contains(""TRIM""));
		assertEquals(true, result.contains(""TRUE""));
		assertEquals(true, result.contains(""UNION""));
		assertEquals(true, result.contains(""UNIQUE""));
		assertEquals(true, result.contains(""UNKNOWN""));
		assertEquals(true, result.contains(""UPDATE""));
		assertEquals(true"
cmpl-6u8vgxx8U4N8vfVwvWqP8Ejxj4VS5,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorFinder_1Test.java,93.92943024635315,length,"// DotConnectorFinder.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;

/**
 * Format table data into .dot format to feed to Graphvis' dot program.
 *
 * @author John Currier
 */
public class DotConnectorFinder {

    private static DotConnectorFinder instance = new DotConnectorFinder();

    /**
     * Singleton - prevent creation
     */
    private DotConnectorFinder() {
    }

    public static DotConnectorFinder getInstance() {
        return instance;
    }

    /**
     * @param table Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    public Set<DotConnector> getRelatedConnectors(Table table, boolean includeImplied) {
        Set<DotConnector> relationships = new HashSet<DotConnector>();
        for (TableColumn column : table.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, null, false, includeImplied));
        }
        return relationships;
    }

    /**
     * Get all the relationships that exist between these two tables.
     *
     * @param table1 Table
     * @param table2 Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    public Set<DotConnector> getRelatedConnectors(Table table1, Table table2, boolean includeExcluded, boolean includeImplied) {
        Set<DotConnector> relationships = new HashSet<DotConnector>();
        for (TableColumn column : table1.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, table2, includeExcluded, includeImplied));
        }
        for (TableColumn column : table2.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, table1, includeExcluded, includeImplied));
        }
        return relationships;
    }

    /**
     * @param column TableColumn
     * @param targetTable Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    private Set<DotConnector> getRelatedConnectors(TableColumn column, Table targetTable, boolean includeExcluded, boolean includeImplied) {
        Set<DotConnector> relatedConnectors = new HashSet<DotConnector>();
        if (!includeExcluded && column.isExcluded())
            return relatedConnectors;
        for (TableColumn parentColumn : column.getParents()) {
            Table parentTable = parentColumn.getTable();
            if (targetTable != null && parentTable != targetTable)
                continue;
            if (targetTable == null && !includeExcluded && parentColumn.isExcluded())
                continue;
            boolean implied = column.getParentConstraint(parentColumn).isImplied();
            if (!implied || includeImplied) {
                relatedConnectors.add(new DotConnector(parentColumn, column, implied));
            }
        }
        for (TableColumn childColumn : column.getChildren()) {
            Table childTable = childColumn.getTable();
            if (targetTable != null && childTable != targetTable)
                continue;
            if (targetTable == null && !includeExcluded && childColumn.isExcluded())
                continue;
            boolean implied = column.getChildConstraint(childColumn).isImplied();
            if (!implied || includeImplied) {
                relatedConnectors.add(new DotConnector(column, childColumn, implied));
            }
        }
        return relatedConnectors;
    }
}
","// DotConnectorFinder_1Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnectorFinder}.
* It contains ten unit test cases for the {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)} method.
*/
class DotConnectorFinder_1Test {","// DotConnectorFinder_1Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnectorFinder}.
* It contains ten unit test cases for the {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)} method.
*/
class DotConnectorFinder_1Test {

	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with no relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_1() {
		Table table = new Table(""testTable"", ""testSchema"");
		table.addColumn(new TableColumn(""testColumn1"", ""testTable"", ""testSchema""));
		table.addColumn(new TableColumn(""testColumn2"", ""testTable"", ""testSchema""));
		table.addColumn(new TableColumn(""testColumn3"", ""testTable"", ""testSchema""));
		Set<DotConnector> expected = new HashSet<DotConnector>();
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with one relationship.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_2() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		column1.addParent(column2);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with two relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_3() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		column1.addParent(column2);
		column1.addParent(column3);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with three relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_4() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		column1.addParent(column2);
		column1.addParent(column3);
		column1.addParent(column4);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		expected.add(new DotConnector(column4, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with four relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_5() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		TableColumn column5 = new TableColumn(""testColumn5"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		table.addColumn(column5);
		column1.addParent(column2);
		column1.addParent(column3);
		column1.addParent(column4);
		column1.addParent(column5);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		expected.add(new DotConnector(column4, column1, false));
		expected.add(new DotConnector(column5, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with five relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_6() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		TableColumn column5 = new TableColumn(""testColumn5"", ""testTable"", ""testSchema"");
		TableColumn column6 = new TableColumn(""testColumn6"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		table.addColumn(column5);
		table.addColumn(column6);
		column1.addParent(column2);
		column1.addParent(column3);
		column1.addParent(column4);
		column1.addParent(column5);
		column1.addParent(column6);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		expected.add(new DotConnector(column4, column1, false));
		expected.add(new DotConnector(column5, column1, false));
		expected.add(new DotConnector(column6, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with six relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_7() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		TableColumn column5 = new TableColumn(""testColumn5"", ""testTable"", ""testSchema"");
		TableColumn column6 = new TableColumn(""testColumn6"", ""testTable"", ""testSchema"");
		TableColumn column7 = new TableColumn(""testColumn7"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		table.addColumn(column5);
		table.addColumn(column6);
		table.addColumn(column7);
		column1.addParent(column2);
		column1.addParent(column3);
		column1.addParent(column4);
		column1.addParent(column5);
		column1.addParent(column6);
		column1.addParent(column7);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		expected.add(new DotConnector(column4, column1, false));
		expected.add(new DotConnector(column5, column1, false));
		expected.add(new DotConnector(column6, column1, false));
		expected.add(new DotConnector(column7, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with seven relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_8() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		TableColumn column5 = new TableColumn(""testColumn5"", ""testTable"", ""testSchema"");
		TableColumn column6 = new TableColumn(""testColumn6"", ""testTable"", ""testSchema"");
		TableColumn column7 = new TableColumn(""testColumn7"", ""testTable"", ""testSchema"");
		TableColumn column8 = new TableColumn(""testColumn8"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		table.addColumn(column5);
		table.addColumn(column6);
		table.addColumn(column7);
		table.addColumn(column8);
		column1.addParent(column2);
		column1.addParent(column3);
		column1.addParent(column4);
		column1.addParent(column5);
		column1.addParent(column6);
		column1.addParent(column7);
		column1.addParent(column8);
		Set<DotConnector> expected = new HashSet<DotConnector>();
		expected.add(new DotConnector(column2, column1, false));
		expected.add(new DotConnector(column3, column1, false));
		expected.add(new DotConnector(column4, column1, false));
		expected.add(new DotConnector(column5, column1, false));
		expected.add(new DotConnector(column6, column1, false));
		expected.add(new DotConnector(column7, column1, false));
		expected.add(new DotConnector(column8, column1, false));
		Set<DotConnector> actual = DotConnectorFinder.getInstance().getRelatedConnectors(table, false);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case for {@link DotConnectorFinder#getRelatedConnectors(Table, boolean)}
	 * <p>
	 * Test if the method returns the correct set of {@link DotConnector}s for a table with eight relationships.
	 * </p>
	 */
	@Test
	void testGetRelatedConnectors_9() {
		Table table = new Table(""testTable"", ""testSchema"");
		TableColumn column1 = new TableColumn(""testColumn1"", ""testTable"", ""testSchema"");
		TableColumn column2 = new TableColumn(""testColumn2"", ""testTable"", ""testSchema"");
		TableColumn column3 = new TableColumn(""testColumn3"", ""testTable"", ""testSchema"");
		TableColumn column4 = new TableColumn(""testColumn4"", ""testTable"", ""testSchema"");
		TableColumn column5 = new TableColumn(""testColumn5"", ""testTable"", ""testSchema"");
		TableColumn column6 = new TableColumn(""testColumn6"", ""testTable"", ""testSchema"");
		TableColumn column7 = new TableColumn(""testColumn7"", ""testTable"", ""testSchema"");
		TableColumn column8 = new TableColumn(""testColumn8"", ""testTable"", ""testSchema"");
		TableColumn column9 = new TableColumn(""testColumn9"", ""testTable"", ""testSchema"");
		table.addColumn(column1);
		table.addColumn(column2);
		table.addColumn(column3);
		table.addColumn(column4);
		table.addColumn(column5);
		table.addColumn(column6);
		table.addColumn(column7);
		table.addColumn(column8);
		table.addColumn(column9);
		column1.addParent(column2);
		column1.addParent(column"
cmpl-6u8xCxxVGUGKSVDBlwhqZufm6BN18,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorFinder_2Test.java,96.74787139892578,length,"// DotConnectorFinder.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;

/**
 * Format table data into .dot format to feed to Graphvis' dot program.
 *
 * @author John Currier
 */
public class DotConnectorFinder {

    private static DotConnectorFinder instance = new DotConnectorFinder();

    /**
     * Singleton - prevent creation
     */
    private DotConnectorFinder() {
    }

    public static DotConnectorFinder getInstance() {
        return instance;
    }

    /**
     * @param table Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    public Set<DotConnector> getRelatedConnectors(Table table, boolean includeImplied) {
        Set<DotConnector> relationships = new HashSet<DotConnector>();
        for (TableColumn column : table.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, null, false, includeImplied));
        }
        return relationships;
    }

    /**
     * Get all the relationships that exist between these two tables.
     *
     * @param table1 Table
     * @param table2 Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    public Set<DotConnector> getRelatedConnectors(Table table1, Table table2, boolean includeExcluded, boolean includeImplied) {
        Set<DotConnector> relationships = new HashSet<DotConnector>();
        for (TableColumn column : table1.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, table2, includeExcluded, includeImplied));
        }
        for (TableColumn column : table2.getColumns()) {
            relationships.addAll(getRelatedConnectors(column, table1, includeExcluded, includeImplied));
        }
        return relationships;
    }

    /**
     * @param column TableColumn
     * @param targetTable Table
     * @throws IOException
     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)
     */
    private Set<DotConnector> getRelatedConnectors(TableColumn column, Table targetTable, boolean includeExcluded, boolean includeImplied) {
        Set<DotConnector> relatedConnectors = new HashSet<DotConnector>();
        if (!includeExcluded && column.isExcluded())
            return relatedConnectors;
        for (TableColumn parentColumn : column.getParents()) {
            Table parentTable = parentColumn.getTable();
            if (targetTable != null && parentTable != targetTable)
                continue;
            if (targetTable == null && !includeExcluded && parentColumn.isExcluded())
                continue;
            boolean implied = column.getParentConstraint(parentColumn).isImplied();
            if (!implied || includeImplied) {
                relatedConnectors.add(new DotConnector(parentColumn, column, implied));
            }
        }
        for (TableColumn childColumn : column.getChildren()) {
            Table childTable = childColumn.getTable();
            if (targetTable != null && childTable != targetTable)
                continue;
            if (targetTable == null && !includeExcluded && childColumn.isExcluded())
                continue;
            boolean implied = column.getChildConstraint(childColumn).isImplied();
            if (!implied || includeImplied) {
                relatedConnectors.add(new DotConnector(column, childColumn, implied));
            }
        }
        return relatedConnectors;
    }
}
","// DotConnectorFinder_2Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnectorFinder}.
* It contains ten unit test cases for the {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)} method.
*/
class DotConnectorFinder_2Test {","// DotConnectorFinder_2Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnectorFinder}.
* It contains ten unit test cases for the {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)} method.
*/
class DotConnectorFinder_2Test {

	/**
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for method {@link DotConnectorFinder#getRelatedConnectors(Table, Table, boolean, boolean)}.
	* Test case 1 for"
cmpl-6u8ylLsX8jvbhrgsAuoZcRDQRaRuW,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnector_0Test.java,93.19506645202637,length,"// DotConnector.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;

/**
 * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.
 *
 * @author John Currier
 */
public class DotConnector implements Comparable<DotConnector> {

    private final TableColumn parentColumn;

    private final Table parentTable;

    private final TableColumn childColumn;

    private final Table childTable;

    private final boolean implied;

    private final boolean bottomJustify;

    private String parentPort;

    private String childPort;

    /**
     * Create an edge that logically connects a child column to a parent column.
     *
     * @param parentColumn TableColumn
     * @param childColumn TableColumn
     * @param implied boolean
     */
    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {
        this.parentColumn = parentColumn;
        this.childColumn = childColumn;
        this.implied = implied;
        parentPort = parentColumn.getName();
        parentTable = parentColumn.getTable();
        childPort = childColumn.getName();
        childTable = childColumn.getTable();
        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();
    }

    /**
     * Returns true if this edge logically ""points to"" the specified table
     *
     * @param possibleParentTable Table
     * @return boolean
     */
    public boolean pointsTo(Table possibleParentTable) {
        return possibleParentTable.equals(parentTable);
    }

    public boolean isImplied() {
        return implied;
    }

    /**
     * By default a parent edge connects to the column name...this lets you
     * connect it the parent's type column instead (e.g. for detailed parents)
     *
     * Yes, I need to find a more appropriate name/metaphor for this method....
     */
    public void connectToParentDetails() {
        parentPort = parentColumn.getName() + "".type"";
    }

    public void connectToParentTitle() {
        //parentPort = parentColumn.getTable().getName() + "".heading"";
        parentPort = ""elipses"";
    }

    public void connectToChildTitle() {
        //childPort = childColumn.getTable().getName() + "".heading"";
        childPort = ""elipses"";
    }

    @Override
    public String toString() {
        StringBuilder edge = new StringBuilder();
        edge.append(""  \"""");
        if (childTable.isRemote()) {
            edge.append(childTable.getContainer());
            edge.append('.');
        }
        edge.append(childTable.getName());
        edge.append(""\"":\"""");
        edge.append(childPort);
        edge.append(""\"":"");
        if (bottomJustify)
            edge.append(""s"");
        edge.append(""w -> \"""");
        if (parentTable.isRemote()) {
            edge.append(parentTable.getContainer());
            edge.append('.');
        }
        edge.append(parentTable.getName());
        edge.append(""\"":\"""");
        edge.append(parentPort);
        edge.append(""\"":"");
        if (bottomJustify)
            edge.append(""s"");
        edge.append(""e "");
        // if enabled makes the diagram unreadable
        // have to figure out how to render these details in a readable manner
        final boolean fullErNotation = false;
        // Thanks to Dan Zingaro for figuring out how to correctly annotate
        // these relationships
        if (fullErNotation) {
            // PK end of connector
            edge.append(""[arrowhead="");
            if (childColumn.isNullable())
                // zero or one parents
                edge.append(""odottee"");
            else
                // one parent
                edge.append(""teetee"");
            edge.append("" dir=both"");
        } else {
            // PK end of connector
            edge.append(""[arrowhead=none"");
            edge.append("" dir=back"");
        }
        // FK end of connector
        edge.append("" arrowtail="");
        if (childColumn.isUnique())
            // zero or one children
            edge.append(""teeodot"");
        else
            // zero or more children
            edge.append(""crowodot"");
        if (implied)
            edge.append("" style=dashed"");
        edge.append(""];"");
        return edge.toString();
    }

    public int compareTo(DotConnector other) {
        int rc = childTable.compareTo(other.childTable);
        if (rc == 0)
            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());
        if (rc == 0)
            rc = parentTable.compareTo(other.parentTable);
        if (rc == 0)
            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());
        if (rc == 0 && implied != other.implied)
            rc = implied ? 1 : -1;
        return rc;
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof DotConnector))
            return false;
        return compareTo((DotConnector) other) == 0;
    }

    @Override
    public int hashCode() {
        int p = parentTable == null ? 0 : parentTable.getName().hashCode();
        int c = childTable == null ? 0 : childTable.getName().hashCode();
        return (p << 16) & c;
    }

    public TableColumn getParentColumn() {
        return parentColumn;
    }

    public Table getParentTable() {
        return parentTable;
    }

    public TableColumn getChildColumn() {
        return childColumn;
    }

    public Table getChildTable() {
        return childTable;
    }
}
","// DotConnector_0Test.java
package net.sourceforge.schemaspy.view;

import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnector}.
* It contains ten unit test cases for the {@link DotConnector#pointsTo(Table)} method.
*/
class DotConnector_0Test {","// DotConnector_0Test.java
package net.sourceforge.schemaspy.view;

import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotConnector}.
* It contains ten unit test cases for the {@link DotConnector#pointsTo(Table)} method.
*/
class DotConnector_0Test {

	/**
	 * Test case for {@link DotConnector#pointsTo(Table)} method.
	 * This test case checks if the method returns true if the specified table is the parent table.
	 */
	@Test
	void testPointsTo_0() {
		TableColumn parentColumn = new TableColumn(""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", ""parentColumn"", """
b5d15814-b7b9-45dc-8f43-43bc126defaa,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotFormatter_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8144 tokens (4144 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DotFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;

/**
 * Format table data into .dot format to feed to Graphvis' dot program.
 *
 * @author John Currier
 */
public class DotFormatter {

    private static DotFormatter instance = new DotFormatter();

    private final int fontSize = Config.getInstance().getFontSize();

    /**
     * Singleton - prevent creation
     */
    private DotFormatter() {
    }

    public static DotFormatter getInstance() {
        return instance;
    }

    /**
     * Write real relationships (excluding implied) associated with the given table.<p>
     * Returns a set of the implied constraints that could have been included but weren't.
     */
    public Set<ForeignKeyConstraint> writeRealRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {
        return writeRelationships(table, twoDegreesOfSeparation, stats, false, dot);
    }

    /**
     * Write implied relationships associated with the given table
     */
    public void writeAllRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {
        writeRelationships(table, twoDegreesOfSeparation, stats, true, dot);
    }

    /**
     * Write relationships associated with the given table.<p>
     * Returns a set of the implied constraints that could have been included but weren't.
     */
    private Set<ForeignKeyConstraint> writeRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, boolean includeImplied, LineWriter dot) throws IOException {
        Set<Table> tablesWritten = new HashSet<Table>();
        Set<ForeignKeyConstraint> skippedImpliedConstraints = new HashSet<ForeignKeyConstraint>();
        DotConnectorFinder finder = DotConnectorFinder.getInstance();
        String diagramName = includeImplied ? ""impliedTwoDegreesRelationshipsDiagram"" : (twoDegreesOfSeparation ? ""twoDegreesRelationshipsDiagram"" : ""oneDegreeRelationshipsDiagram"");
        writeHeader(diagramName, true, dot);
        Set<Table> relatedTables = getImmediateRelatives(table, true, includeImplied, skippedImpliedConstraints);
        Set<DotConnector> connectors = new TreeSet<DotConnector>(finder.getRelatedConnectors(table, includeImplied));
        tablesWritten.add(table);
        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();
        // write immediate relatives first
        for (Table relatedTable : relatedTables) {
            if (!tablesWritten.add(relatedTable))
                // already written
                continue;
            nodes.put(relatedTable, new DotNode(relatedTable, """", new DotNodeConfig(false, false)));
            connectors.addAll(finder.getRelatedConnectors(relatedTable, table, true, includeImplied));
        }
        // connect the edges that go directly to the target table
        // so they go to the target table's type column instead
        for (DotConnector connector : connectors) {
            if (connector.pointsTo(table))
                connector.connectToParentDetails();
        }
        Set<Table> allCousins = new HashSet<Table>();
        Set<DotConnector> allCousinConnectors = new TreeSet<DotConnector>();
        // next write 'cousins' (2nd degree of separation)
        if (twoDegreesOfSeparation) {
            for (Table relatedTable : relatedTables) {
                Set<Table> cousins = getImmediateRelatives(relatedTable, false, includeImplied, skippedImpliedConstraints);
                for (Table cousin : cousins) {
                    if (!tablesWritten.add(cousin))
                        // already written
                        continue;
                    allCousinConnectors.addAll(finder.getRelatedConnectors(cousin, relatedTable, false, includeImplied));
                    nodes.put(cousin, new DotNode(cousin, false, """"));
                }
                allCousins.addAll(cousins);
            }
        }
        // glue together any 'participants' that aren't yet connected
        // note that this is the epitome of nested loops from hell
        List<Table> participants = new ArrayList<Table>(nodes.keySet());
        Iterator<Table> iter = participants.iterator();
        while (iter.hasNext()) {
            Table participantA = iter.next();
            // cut down the combos as quickly as possible
            iter.remove();
            for (Table participantB : participants) {
                for (DotConnector connector : finder.getRelatedConnectors(participantA, participantB, false, includeImplied)) {
                    if (twoDegreesOfSeparation && (allCousins.contains(participantA) || allCousins.contains(participantB))) {
                        allCousinConnectors.add(connector);
                    } else {
                        connectors.add(connector);
                    }
                }
            }
        }
        markExcludedColumns(nodes, stats.getExcludedColumns());
        // now directly connect the loose ends to the title of the
        // 2nd degree of separation tables
        for (DotConnector connector : allCousinConnectors) {
            if (allCousins.contains(connector.getParentTable()) && !relatedTables.contains(connector.getParentTable()))
                connector.connectToParentTitle();
            if (allCousins.contains(connector.getChildTable()) && !relatedTables.contains(connector.getChildTable()))
                connector.connectToChildTitle();
        }
        // include the table itself
        nodes.put(table, new DotNode(table, """"));
        connectors.addAll(allCousinConnectors);
        for (DotConnector connector : connectors) {
            if (connector.isImplied()) {
                DotNode node = nodes.get(connector.getParentTable());
                if (node != null)
                    node.setShowImplied(true);
                node = nodes.get(connector.getChildTable());
                if (node != null)
                    node.setShowImplied(true);
            }
            dot.writeln(connector.toString());
        }
        for (DotNode node : nodes.values()) {
            dot.writeln(node.toString());
            stats.wroteTable(node.getTable());
        }
        dot.writeln(""}"");
        return skippedImpliedConstraints;
    }

    private Set<Table> getImmediateRelatives(Table table, boolean includeExcluded, boolean includeImplied, Set<ForeignKeyConstraint> skippedImpliedConstraints) {
        Set<TableColumn> relatedColumns = new HashSet<TableColumn>();
        for (TableColumn column : table.getColumns()) {
            if (column.isAllExcluded() || (!includeExcluded && column.isExcluded())) {
                continue;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (childColumn.isAllExcluded() || (!includeExcluded && childColumn.isExcluded())) {
                    continue;
                }
                ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);
                if (includeImplied || !constraint.isImplied())
                    relatedColumns.add(childColumn);
                else
                    skippedImpliedConstraints.add(constraint);
            }
            for (TableColumn parentColumn : column.getParents()) {
                if (parentColumn.isAllExcluded() || (!includeExcluded && parentColumn.isExcluded())) {
                    continue;
                }
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (includeImplied || !constraint.isImplied())
                    relatedColumns.add(parentColumn);
                else
                    skippedImpliedConstraints.add(constraint);
            }
        }
        Set<Table> relatedTables = new HashSet<Table>();
        for (TableColumn column : relatedColumns) relatedTables.add(column.getTable());
        relatedTables.remove(table);
        return relatedTables;
    }

    private void writeHeader(String diagramName, boolean showLabel, LineWriter dot) throws IOException {
        dot.writeln(""// dot "" + Dot.getInstance().getVersion() + "" on "" + System.getProperty(""os.name"") + "" "" + System.getProperty(""os.version""));
        dot.writeln(""// SchemaSpy rev "" + new Revision());
        dot.writeln(""digraph \"""" + diagramName + ""\"" {"");
        dot.writeln(""  graph ["");
        boolean rankdirbug = Config.getInstance().isRankDirBugEnabled();
        if (!rankdirbug)
            dot.writeln(""    rankdir=\""RL\"""");
        dot.writeln(""    bgcolor=\"""" + StyleSheet.getInstance().getBodyBackground() + ""\"""");
        if (showLabel) {
            if (rankdirbug)
                dot.writeln(""    label=\""\\nLayout is significantly better without '-rankdirbug' option\"""");
            else
                dot.writeln(""    label=\""\\nGenerated by SchemaSpy\"""");
            dot.writeln(""    labeljust=\""l\"""");
        }
        dot.writeln(""    nodesep=\""0.18\"""");
        dot.writeln(""    ranksep=\""0.46\"""");
        dot.writeln(""    fontname=\"""" + Config.getInstance().getFont() + ""\"""");
        dot.writeln(""    fontsize=\"""" + fontSize + ""\"""");
        dot.writeln(""  ];"");
        dot.writeln(""  node ["");
        dot.writeln(""    fontname=\"""" + Config.getInstance().getFont() + ""\"""");
        dot.writeln(""    fontsize=\"""" + fontSize + ""\"""");
        dot.writeln(""    shape=\""plaintext\"""");
        dot.writeln(""  ];"");
        dot.writeln(""  edge ["");
        dot.writeln(""    arrowsize=\""0.8\"""");
        dot.writeln(""  ];"");
    }

    public void writeRealRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {
        writeRelationships(db, tables, compact, showColumns, false, stats, dot);
    }

    /**
     * Returns <code>true</code> if it wrote any implied relationships
     */
    public boolean writeAllRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {
        return writeRelationships(db, tables, compact, showColumns, true, stats, dot);
    }

    private boolean writeRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, boolean includeImplied, WriteStats stats, LineWriter dot) throws IOException {
        DotConnectorFinder finder = DotConnectorFinder.getInstance();
        DotNodeConfig nodeConfig = showColumns ? new DotNodeConfig(!compact, false) : new DotNodeConfig();
        boolean wroteImplied = false;
        String diagramName;
        if (includeImplied) {
            if (compact)
                diagramName = ""compactImpliedRelationshipsDiagram"";
            else
                diagramName = ""largeImpliedRelationshipsDiagram"";
        } else {
            if (compact)
                diagramName = ""compactRelationshipsDiagram"";
            else
                diagramName = ""largeRelationshipsDiagram"";
        }
        writeHeader(diagramName, true, dot);
        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();
        for (Table table : tables) {
            if (!table.isOrphan(includeImplied)) {
                nodes.put(table, new DotNode(table, ""tables/"", nodeConfig));
            }
        }
        for (Table table : db.getRemoteTables()) {
            nodes.put(table, new DotNode(table, ""tables/"", nodeConfig));
        }
        Set<DotConnector> connectors = new TreeSet<DotConnector>();
        for (DotNode node : nodes.values()) {
            connectors.addAll(finder.getRelatedConnectors(node.getTable(), includeImplied));
        }
        markExcludedColumns(nodes, stats.getExcludedColumns());
        for (DotNode node : nodes.values()) {
            Table table = node.getTable();
            dot.writeln(node.toString());
            stats.wroteTable(table);
            wroteImplied = wroteImplied || (includeImplied && table.isOrphan(false));
        }
        for (DotConnector connector : connectors) {
            dot.writeln(connector.toString());
        }
        dot.writeln(""}"");
        return wroteImplied;
    }

    private void markExcludedColumns(Map<Table, DotNode> nodes, Set<TableColumn> excludedColumns) {
        for (TableColumn column : excludedColumns) {
            DotNode node = nodes.get(column.getTable());
            if (node != null) {
                node.excludeColumn(column);
            }
        }
    }

    public void writeOrphan(Table table, LineWriter dot) throws IOException {
        writeHeader(table.getName(), false, dot);
        dot.writeln(new DotNode(table, true, ""tables/"").toString());
        dot.writeln(""}"");
    }
}
","// DotFormatter_1Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotFormatter}.
* It contains ten unit test cases for the {@link DotFormatter#writeRealRelationships(Table, boolean, WriteStats, LineWriter)} method.
*/
class DotFormatter_1Test {","// DotFormatter_1Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotFormatter}.
* It contains ten unit test cases for the {@link DotFormatter#writeRealRelationships(Table, boolean, WriteStats, LineWriter)} method.
*/
class DotFormatter_1Test {
"
3a714b21-6b51-4f01-ad57-d5aa0874049f,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotFormatter_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8148 tokens (4148 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// DotFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;

/**
 * Format table data into .dot format to feed to Graphvis' dot program.
 *
 * @author John Currier
 */
public class DotFormatter {

    private static DotFormatter instance = new DotFormatter();

    private final int fontSize = Config.getInstance().getFontSize();

    /**
     * Singleton - prevent creation
     */
    private DotFormatter() {
    }

    public static DotFormatter getInstance() {
        return instance;
    }

    /**
     * Write real relationships (excluding implied) associated with the given table.<p>
     * Returns a set of the implied constraints that could have been included but weren't.
     */
    public Set<ForeignKeyConstraint> writeRealRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {
        return writeRelationships(table, twoDegreesOfSeparation, stats, false, dot);
    }

    /**
     * Write implied relationships associated with the given table
     */
    public void writeAllRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {
        writeRelationships(table, twoDegreesOfSeparation, stats, true, dot);
    }

    /**
     * Write relationships associated with the given table.<p>
     * Returns a set of the implied constraints that could have been included but weren't.
     */
    private Set<ForeignKeyConstraint> writeRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, boolean includeImplied, LineWriter dot) throws IOException {
        Set<Table> tablesWritten = new HashSet<Table>();
        Set<ForeignKeyConstraint> skippedImpliedConstraints = new HashSet<ForeignKeyConstraint>();
        DotConnectorFinder finder = DotConnectorFinder.getInstance();
        String diagramName = includeImplied ? ""impliedTwoDegreesRelationshipsDiagram"" : (twoDegreesOfSeparation ? ""twoDegreesRelationshipsDiagram"" : ""oneDegreeRelationshipsDiagram"");
        writeHeader(diagramName, true, dot);
        Set<Table> relatedTables = getImmediateRelatives(table, true, includeImplied, skippedImpliedConstraints);
        Set<DotConnector> connectors = new TreeSet<DotConnector>(finder.getRelatedConnectors(table, includeImplied));
        tablesWritten.add(table);
        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();
        // write immediate relatives first
        for (Table relatedTable : relatedTables) {
            if (!tablesWritten.add(relatedTable))
                // already written
                continue;
            nodes.put(relatedTable, new DotNode(relatedTable, """", new DotNodeConfig(false, false)));
            connectors.addAll(finder.getRelatedConnectors(relatedTable, table, true, includeImplied));
        }
        // connect the edges that go directly to the target table
        // so they go to the target table's type column instead
        for (DotConnector connector : connectors) {
            if (connector.pointsTo(table))
                connector.connectToParentDetails();
        }
        Set<Table> allCousins = new HashSet<Table>();
        Set<DotConnector> allCousinConnectors = new TreeSet<DotConnector>();
        // next write 'cousins' (2nd degree of separation)
        if (twoDegreesOfSeparation) {
            for (Table relatedTable : relatedTables) {
                Set<Table> cousins = getImmediateRelatives(relatedTable, false, includeImplied, skippedImpliedConstraints);
                for (Table cousin : cousins) {
                    if (!tablesWritten.add(cousin))
                        // already written
                        continue;
                    allCousinConnectors.addAll(finder.getRelatedConnectors(cousin, relatedTable, false, includeImplied));
                    nodes.put(cousin, new DotNode(cousin, false, """"));
                }
                allCousins.addAll(cousins);
            }
        }
        // glue together any 'participants' that aren't yet connected
        // note that this is the epitome of nested loops from hell
        List<Table> participants = new ArrayList<Table>(nodes.keySet());
        Iterator<Table> iter = participants.iterator();
        while (iter.hasNext()) {
            Table participantA = iter.next();
            // cut down the combos as quickly as possible
            iter.remove();
            for (Table participantB : participants) {
                for (DotConnector connector : finder.getRelatedConnectors(participantA, participantB, false, includeImplied)) {
                    if (twoDegreesOfSeparation && (allCousins.contains(participantA) || allCousins.contains(participantB))) {
                        allCousinConnectors.add(connector);
                    } else {
                        connectors.add(connector);
                    }
                }
            }
        }
        markExcludedColumns(nodes, stats.getExcludedColumns());
        // now directly connect the loose ends to the title of the
        // 2nd degree of separation tables
        for (DotConnector connector : allCousinConnectors) {
            if (allCousins.contains(connector.getParentTable()) && !relatedTables.contains(connector.getParentTable()))
                connector.connectToParentTitle();
            if (allCousins.contains(connector.getChildTable()) && !relatedTables.contains(connector.getChildTable()))
                connector.connectToChildTitle();
        }
        // include the table itself
        nodes.put(table, new DotNode(table, """"));
        connectors.addAll(allCousinConnectors);
        for (DotConnector connector : connectors) {
            if (connector.isImplied()) {
                DotNode node = nodes.get(connector.getParentTable());
                if (node != null)
                    node.setShowImplied(true);
                node = nodes.get(connector.getChildTable());
                if (node != null)
                    node.setShowImplied(true);
            }
            dot.writeln(connector.toString());
        }
        for (DotNode node : nodes.values()) {
            dot.writeln(node.toString());
            stats.wroteTable(node.getTable());
        }
        dot.writeln(""}"");
        return skippedImpliedConstraints;
    }

    private Set<Table> getImmediateRelatives(Table table, boolean includeExcluded, boolean includeImplied, Set<ForeignKeyConstraint> skippedImpliedConstraints) {
        Set<TableColumn> relatedColumns = new HashSet<TableColumn>();
        for (TableColumn column : table.getColumns()) {
            if (column.isAllExcluded() || (!includeExcluded && column.isExcluded())) {
                continue;
            }
            for (TableColumn childColumn : column.getChildren()) {
                if (childColumn.isAllExcluded() || (!includeExcluded && childColumn.isExcluded())) {
                    continue;
                }
                ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);
                if (includeImplied || !constraint.isImplied())
                    relatedColumns.add(childColumn);
                else
                    skippedImpliedConstraints.add(constraint);
            }
            for (TableColumn parentColumn : column.getParents()) {
                if (parentColumn.isAllExcluded() || (!includeExcluded && parentColumn.isExcluded())) {
                    continue;
                }
                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
                if (includeImplied || !constraint.isImplied())
                    relatedColumns.add(parentColumn);
                else
                    skippedImpliedConstraints.add(constraint);
            }
        }
        Set<Table> relatedTables = new HashSet<Table>();
        for (TableColumn column : relatedColumns) relatedTables.add(column.getTable());
        relatedTables.remove(table);
        return relatedTables;
    }

    private void writeHeader(String diagramName, boolean showLabel, LineWriter dot) throws IOException {
        dot.writeln(""// dot "" + Dot.getInstance().getVersion() + "" on "" + System.getProperty(""os.name"") + "" "" + System.getProperty(""os.version""));
        dot.writeln(""// SchemaSpy rev "" + new Revision());
        dot.writeln(""digraph \"""" + diagramName + ""\"" {"");
        dot.writeln(""  graph ["");
        boolean rankdirbug = Config.getInstance().isRankDirBugEnabled();
        if (!rankdirbug)
            dot.writeln(""    rankdir=\""RL\"""");
        dot.writeln(""    bgcolor=\"""" + StyleSheet.getInstance().getBodyBackground() + ""\"""");
        if (showLabel) {
            if (rankdirbug)
                dot.writeln(""    label=\""\\nLayout is significantly better without '-rankdirbug' option\"""");
            else
                dot.writeln(""    label=\""\\nGenerated by SchemaSpy\"""");
            dot.writeln(""    labeljust=\""l\"""");
        }
        dot.writeln(""    nodesep=\""0.18\"""");
        dot.writeln(""    ranksep=\""0.46\"""");
        dot.writeln(""    fontname=\"""" + Config.getInstance().getFont() + ""\"""");
        dot.writeln(""    fontsize=\"""" + fontSize + ""\"""");
        dot.writeln(""  ];"");
        dot.writeln(""  node ["");
        dot.writeln(""    fontname=\"""" + Config.getInstance().getFont() + ""\"""");
        dot.writeln(""    fontsize=\"""" + fontSize + ""\"""");
        dot.writeln(""    shape=\""plaintext\"""");
        dot.writeln(""  ];"");
        dot.writeln(""  edge ["");
        dot.writeln(""    arrowsize=\""0.8\"""");
        dot.writeln(""  ];"");
    }

    public void writeRealRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {
        writeRelationships(db, tables, compact, showColumns, false, stats, dot);
    }

    /**
     * Returns <code>true</code> if it wrote any implied relationships
     */
    public boolean writeAllRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {
        return writeRelationships(db, tables, compact, showColumns, true, stats, dot);
    }

    private boolean writeRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, boolean includeImplied, WriteStats stats, LineWriter dot) throws IOException {
        DotConnectorFinder finder = DotConnectorFinder.getInstance();
        DotNodeConfig nodeConfig = showColumns ? new DotNodeConfig(!compact, false) : new DotNodeConfig();
        boolean wroteImplied = false;
        String diagramName;
        if (includeImplied) {
            if (compact)
                diagramName = ""compactImpliedRelationshipsDiagram"";
            else
                diagramName = ""largeImpliedRelationshipsDiagram"";
        } else {
            if (compact)
                diagramName = ""compactRelationshipsDiagram"";
            else
                diagramName = ""largeRelationshipsDiagram"";
        }
        writeHeader(diagramName, true, dot);
        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();
        for (Table table : tables) {
            if (!table.isOrphan(includeImplied)) {
                nodes.put(table, new DotNode(table, ""tables/"", nodeConfig));
            }
        }
        for (Table table : db.getRemoteTables()) {
            nodes.put(table, new DotNode(table, ""tables/"", nodeConfig));
        }
        Set<DotConnector> connectors = new TreeSet<DotConnector>();
        for (DotNode node : nodes.values()) {
            connectors.addAll(finder.getRelatedConnectors(node.getTable(), includeImplied));
        }
        markExcludedColumns(nodes, stats.getExcludedColumns());
        for (DotNode node : nodes.values()) {
            Table table = node.getTable();
            dot.writeln(node.toString());
            stats.wroteTable(table);
            wroteImplied = wroteImplied || (includeImplied && table.isOrphan(false));
        }
        for (DotConnector connector : connectors) {
            dot.writeln(connector.toString());
        }
        dot.writeln(""}"");
        return wroteImplied;
    }

    private void markExcludedColumns(Map<Table, DotNode> nodes, Set<TableColumn> excludedColumns) {
        for (TableColumn column : excludedColumns) {
            DotNode node = nodes.get(column.getTable());
            if (node != null) {
                node.excludeColumn(column);
            }
        }
    }

    public void writeOrphan(Table table, LineWriter dot) throws IOException {
        writeHeader(table.getName(), false, dot);
        dot.writeln(new DotNode(table, true, ""tables/"").toString());
        dot.writeln(""}"");
    }
}
","// DotFormatter_2Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotFormatter}.
* It contains ten unit test cases for the {@link DotFormatter#writeAllRelationships(Database, Collection, boolean, boolean, WriteStats, LineWriter)} method.
*/
class DotFormatter_2Test {","// DotFormatter_2Test.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.Revision;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DotFormatter}.
* It contains ten unit test cases for the {@link DotFormatter#writeAllRelationships(Database, Collection, boolean, boolean, WriteStats, LineWriter)} method.
*/
class DotFormatter_2Test {
"
cmpl-6u92DSfo9upKQ87fXbxbZlKY7nyrF,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlAnomaliesPage.java,112.0509865283966,length,"// HtmlAnomaliesPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * This page lists all of the 'things that might not be quite right'
 * about the schema.
 *
 * @author John Currier
 */
public class HtmlAnomaliesPage extends HtmlFormatter {

    private static HtmlAnomaliesPage instance = new HtmlAnomaliesPage();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlAnomaliesPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlAnomaliesPage getInstance() {
        return instance;
    }

    public void write(Database database, Collection<Table> tables, List<? extends ForeignKeyConstraint> impliedConstraints, LineWriter out) throws IOException {
        writeHeader(database, out);
        writeImpliedConstraints(impliedConstraints, out);
        writeTablesWithoutIndexes(DbAnalyzer.getTablesWithoutIndexes(new HashSet<Table>(tables)), out);
        writeUniqueNullables(DbAnalyzer.getMustBeUniqueNullableColumns(new HashSet<Table>(tables)), out);
        writeTablesWithOneColumn(DbAnalyzer.getTablesWithOneColumn(tables), out);
        writeTablesWithIncrementingColumnNames(DbAnalyzer.getTablesWithIncrementingColumnNames(tables), out);
        writeDefaultNullStrings(DbAnalyzer.getDefaultNullStringColumns(new HashSet<Table>(tables)), out);
        writeFooter(out);
    }

    private void writeHeader(Database database, LineWriter html) throws IOException {
        writeHeader(database, null, ""Anomalies"", html);
        html.writeln(""<table width='100%'>"");
        if (sourceForgeLogoEnabled())
            html.writeln(""  <tr><td class='container' align='right' valign='top' colspan='2'><a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a></td></tr>"");
        html.writeln(""  <tr><td class='container'><b>Things that might not be 'quite right' about your schema:</b></td></tr>"");
        html.writeln(""</table>"");
        html.writeln(""<ul>"");
    }

    private void writeImpliedConstraints(List<? extends ForeignKeyConstraint> impliedConstraints, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.writeln(""<b>Columns whose name and type imply a relationship to another table's primary key:</b>"");
        int numDetected = 0;
        for (ForeignKeyConstraint impliedConstraint : impliedConstraints) {
            Table childTable = impliedConstraint.getChildTable();
            if (!childTable.isView()) {
                ++numDetected;
            }
        }
        if (numDetected > 0) {
            out.writeln(""<table class='dataTable' border='1' rules='groups'>"");
            out.writeln(""<colgroup>"");
            out.writeln(""<colgroup>"");
            out.writeln(""<thead align='left'>"");
            out.writeln(""<tr>"");
            out.writeln(""  <th>Child Column</th>"");
            out.writeln(""  <th>Implied Parent Column</th>"");
            out.writeln(""</tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (ForeignKeyConstraint impliedConstraint : impliedConstraints) {
                Table childTable = impliedConstraint.getChildTable();
                if (!childTable.isView()) {
                    out.writeln("" <tr>"");
                    out.write(""  <td class='detail'>"");
                    String tableName = childTable.getName();
                    out.write(""<a href='tables/"");
                    out.write(urlEncode(tableName));
                    out.write("".html'>"");
                    out.write(tableName);
                    out.write(""</a>."");
                    out.write(ForeignKeyConstraint.toString(impliedConstraint.getChildColumns()));
                    out.writeln(""</td>"");
                    out.write(""  <td class='detail'>"");
                    tableName = impliedConstraint.getParentTable().getName();
                    out.write(""<a href='tables/"");
                    out.write(urlEncode(tableName));
                    out.write("".html'>"");
                    out.write(tableName);
                    out.write(""</a>."");
                    out.write(ForeignKeyConstraint.toString(impliedConstraint.getParentColumns()));
                    out.writeln(""</td>"");
                    out.writeln("" </tr>"");
                }
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
        }
        writeSummary(numDetected, out);
        out.writeln(""<p></li>"");
    }

    private void writeUniqueNullables(List<TableColumn> uniqueNullables, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.writeln(""<b>Columns that are flagged as both 'nullable' and 'must be unique':</b>"");
        writeColumnBasedAnomaly(uniqueNullables, out);
        out.writeln(""<p></li>"");
    }

    private void writeTablesWithoutIndexes(List<Table> unindexedTables, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.writeln(""<b>Tables without indexes:</b>"");
        if (!unindexedTables.isEmpty()) {
            out.writeln(""<table class='dataTable' border='1' rules='groups'>"");
            out.writeln(""<colgroup>"");
            if (displayNumRows)
                out.writeln(""<colgroup>"");
            out.writeln(""<thead align='left'>"");
            out.writeln(""<tr>"");
            out.write(""  <th>Table</th>"");
            if (displayNumRows)
                out.write(""<th>Rows</th>"");
            out.writeln();
            out.writeln(""</tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (Table table : unindexedTables) {
                out.writeln("" <tr>"");
                out.write(""  <td class='detail'>"");
                out.write(""<a href='tables/"");
                out.write(urlEncode(table.getName()));
                out.write("".html'>"");
                out.write(table.getName());
                out.write(""</a>"");
                out.writeln(""</td>"");
                if (displayNumRows) {
                    out.write(""  <td class='detail' align='right'>"");
                    if (table.getNumRows() >= 0)
                        out.write(String.valueOf(NumberFormat.getIntegerInstance().format(table.getNumRows())));
                    else
                        out.write(""&nbsp;"");
                    out.writeln(""</td>"");
                }
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
        }
        writeSummary(unindexedTables.size(), out);
        out.writeln(""<p></li>"");
    }

    private void writeTablesWithIncrementingColumnNames(List<Table> tables, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.writeln(""<b>Tables with incrementing column names, potentially indicating denormalization:</b>"");
        if (!tables.isEmpty()) {
            out.writeln(""<table class='dataTable' border='1' rules='groups'>"");
            out.writeln(""<thead align='left'>"");
            out.writeln(""<tr>"");
            out.writeln(""  <th>Table</th>"");
            out.writeln(""</tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (Table table : tables) {
                out.writeln("" <tr>"");
                out.write(""  <td class='detail'>"");
                out.write(""<a href='tables/"");
                out.write(urlEncode(table.getName()));
                out.write("".html'>"");
                out.write(table.getName());
                out.write(""</a>"");
                out.writeln(""</td>"");
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
        }
        writeSummary(tables.size(), out);
        out.writeln(""<p></li>"");
    }

    private void writeTablesWithOneColumn(List<Table> tables, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.write(""<b>Tables that contain a single column:</b>"");
        if (!tables.isEmpty()) {
            out.writeln(""<table class='dataTable' border='1' rules='groups'>"");
            out.writeln(""<colgroup>"");
            out.writeln(""<colgroup>"");
            out.writeln(""<thead align='left'>"");
            out.writeln(""<tr>"");
            out.writeln(""  <th>Table</th>"");
            out.writeln(""  <th>Column</th>"");
            out.writeln(""</tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (Table table : tables) {
                out.writeln("" <tr>"");
                out.write(""  <td class='detail'>"");
                out.write(""<a href='tables/"");
                out.write(urlEncode(table.getName()));
                out.write("".html'>"");
                out.write(table.getName());
                out.write(""</a></td><td class='detail'>"");
                out.write(table.getColumns().get(0).toString());
                out.writeln(""</td>"");
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
        }
        writeSummary(tables.size(), out);
        out.writeln(""<p></li>"");
    }

    private void writeDefaultNullStrings(List<TableColumn> uniqueNullables, LineWriter out) throws IOException {
        out.writeln(""<li>"");
        out.writeln(""<b>Columns whose default value is the word 'NULL' or 'null', but the SQL NULL value may have been intended:</b>"");
        writeColumnBasedAnomaly(uniqueNullables, out);
        out.writeln(""<p></li>"");
    }

    private void writeColumnBasedAnomaly(List<TableColumn> columns, LineWriter out) throws IOException {
        if (!columns.isEmpty()) {
            out.writeln(""<table class='dataTable' border='1' rules='groups'>"");
            out.writeln(""<thead align='left'>"");
            out.writeln(""<tr>"");
            out.writeln(""  <th>Column</th>"");
            out.writeln(""</tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (TableColumn column : columns) {
                out.writeln("" <tr>"");
                out.write(""  <td class='detail'>"");
                String tableName = column.getTable().getName();
                out.write(""<a href='tables/"");
                out.write(urlEncode(tableName));
                out.write("".html'>"");
                out.write(tableName);
                out.write(""</a>."");
                out.write(column.getName());
                out.writeln(""</td>"");
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
        }
        writeSummary(columns.size(), out);
    }

    private void writeSummary(int numAnomalies, LineWriter out) throws IOException {
        switch(numAnomalies) {
            case 0:
                out.write(""<br>Anomaly not detected"");
                break;
            case 1:
                out.write(""1 instance of anomaly detected"");
                break;
            default:
                out.write(numAnomalies + "" instances of anomaly detected"");
        }
    }

    @Override
    protected void writeFooter(LineWriter out) throws IOException {
        out.writeln(""</ul>"");
        super.writeFooter(out);
    }

    @Override
    protected boolean isAnomaliesPage() {
        return true;
    }
}
","// HtmlAnomaliesPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlAnomaliesPage}.
* It contains ten unit test cases for the {@link HtmlAnomaliesPage#getInstance()} method.
*/
class HtmlAnomaliesPageTest {","// HtmlAnomaliesPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlAnomaliesPage}.
* It contains ten unit test cases for the {@link HtmlAnomaliesPage#getInstance()} method.
*/
class HtmlAnomaliesPageTest {

	/**
	* Test case for {@link HtmlAnomaliesPage#getInstance()} method.
	* This test case checks if the method returns the same instance of the class.
	*/
	@Test
	void testGetInstance() {
		HtmlAnomaliesPage instance1 = HtmlAnomaliesPage.getInstance();
		HtmlAnomaliesPage instance2 = HtmlAnomaliesPage.getInstance();
		assertSame(instance1, instance2);
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter2() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase2() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection2() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList2() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter3() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase3() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection3() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList3() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter4() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase4() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection4() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList4() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter5() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase5() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection5() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList5() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter6() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase6() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection6() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList6() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter7() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, null));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Database} is null.
	*/
	@Test
	void testWriteWithNullDatabase7() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(null, null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link Collection} is null.
	*/
	@Test
	void testWriteWithNullCollection7() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), null, null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList7() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write(new Database(), new HashSet<Table>(), null, new LineWriter()));
	}
	
	/**
	* Test case for {@link HtmlAnomaliesPage#write(Database, Collection, List, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter8() {
		HtmlAnomaliesPage instance = HtmlAnomaliesPage.getInstance();
		assertThrows(IOException.class, () -> instance.write("
d172c5a5-7105-4d08-9104-efbea4b0edb2,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlColumnsPage.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9319 tokens (5319 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HtmlColumnsPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.Table.ByColumnIdComparator;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that lists all of the columns in the schema,
 * allowing the end user to sort by column's attributes.
 *
 * @author John Currier
 */
public class HtmlColumnsPage extends HtmlFormatter {

    private static HtmlColumnsPage instance = new HtmlColumnsPage();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlColumnsPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlColumnsPage getInstance() {
        return instance;
    }

    /**
     * Returns details about the columns that are displayed on this page.
     *
     * @return
     */
    public Map<String, ColumnInfo> getColumnInfos() {
        // build a collection of all possible column details
        Map<String, ColumnInfo> avails = new HashMap<String, ColumnInfo>();
        avails.put(""id"", new ColumnInfo(""Id"", new ByColumnIdComparator()));
        avails.put(""table"", new ColumnInfo(""Table"", new ByTableComparator()));
        avails.put(""column"", new ColumnInfo(""Column"", new ByColumnComparator()));
        avails.put(""type"", new ColumnInfo(""Type"", new ByTypeComparator()));
        avails.put(""size"", new ColumnInfo(""Size"", new BySizeComparator()));
        avails.put(""nulls"", new ColumnInfo(""Nulls"", new ByNullableComparator()));
        avails.put(""auto"", new ColumnInfo(""Auto"", new ByAutoUpdateComparator()));
        avails.put(""default"", new ColumnInfo(""Default"", new ByDefaultValueComparator()));
        avails.put(""children"", new ColumnInfo(""Children"", new ByChildrenComparator()));
        avails.put(""parents"", new ColumnInfo(""Parents"", new ByParentsComparator()));
        avails.put(""comments"", new ColumnInfo(""Comments"", new ByCommentsComparator()));
        // now put the ones requested in the order requested
        // LinkedHashMap maintains insertion order
        Map<String, ColumnInfo> infos = new LinkedHashMap<String, ColumnInfo>();
        for (String detail : Config.getInstance().getColumnDetails()) {
            ColumnInfo info = avails.get(detail);
            if (info == null)
                throw new IllegalArgumentException(""Undefined column detail requested: '"" + detail + ""'. Valid details: "" + avails.keySet());
            infos.put(detail, info);
        }
        return infos;
    }

    public class ColumnInfo {

        private final String columnName;

        private final Comparator<TableColumn> comparator;

        private ColumnInfo(String columnName, Comparator<TableColumn> comparator) {
            this.columnName = columnName;
            this.comparator = comparator;
        }

        public String getColumnName() {
            return columnName;
        }

        public String getLocation() {
            return getLocation(columnName);
        }

        public String getLocation(String colName) {
            return ""columns.by"" + colName + "".html"";
        }

        private Comparator<TableColumn> getComparator() {
            return comparator;
        }

        @Override
        public String toString() {
            return getLocation();
        }
    }

    public void write(Database database, Collection<Table> tables, ColumnInfo columnInfo, LineWriter html) throws IOException {
        Set<TableColumn> columns = new TreeSet<TableColumn>(columnInfo.getComparator());
        Set<TableColumn> primaryColumns = new HashSet<TableColumn>();
        Set<TableColumn> indexedColumns = new HashSet<TableColumn>();
        for (Table table : tables) {
            columns.addAll(table.getColumns());
            primaryColumns.addAll(table.getPrimaryColumns());
            for (TableIndex index : table.getIndexes()) {
                indexedColumns.addAll(index.getColumns());
            }
        }
        writeHeader(database, columns.size(), columnInfo, html);
        HtmlTablePage formatter = HtmlTablePage.getInstance();
        for (TableColumn column : columns) {
            formatter.writeColumn(column, column.getTable().getName(), primaryColumns, indexedColumns, true, false, html);
        }
        writeFooter(html);
    }

    private void writeHeader(Database db, int numberOfColumns, ColumnInfo selectedColumn, LineWriter html) throws IOException {
        writeHeader(db, null, ""Columns"", html);
        html.writeln(""<table width='100%' border='0'>"");
        html.writeln(""<tr><td class='container'>"");
        writeGeneratedOn(db.getConnectTime(), html);
        html.writeln(""</td><td class='container' rowspan='2' align='right' valign='top'>"");
        writeLegend(false, false, html);
        html.writeln(""</td></tr>"");
        html.writeln(""<tr valign='top'><td class='container' align='left' valign='top'>"");
        html.writeln(""<p>"");
        html.writeln(""<form name='options' action=''>"");
        if (Config.getInstance().getColumnDetails().contains(""comments""))
            html.writeln("" <label for='showComments'><input type=checkbox id='showComments'>Comments</label>"");
        html.writeln("" <label for='showLegend'><input type=checkbox checked id='showLegend'>Legend</label>"");
        html.writeln(""</form>"");
        html.writeln(""</table>"");
        html.writeln(""<div class='indent'>"");
        html.write(""<b>"");
        html.write(db.getName());
        if (db.getSchema() != null) {
            html.write('.');
            html.write(db.getSchema());
        } else if (db.getCatalog() != null) {
            html.write('.');
            html.write(db.getCatalog());
        }
        html.write("" contains "");
        html.write(String.valueOf(numberOfColumns));
        html.write("" columns</b> - click on heading to sort:"");
        Collection<Table> tables = db.getTables();
        boolean hasTableIds = tables.size() > 0 && tables.iterator().next().getId() != null;
        writeMainTableHeader(hasTableIds, selectedColumn, html);
        html.writeln(""<tbody valign='top'>"");
    }

    public void writeMainTableHeader(boolean hasTableIds, ColumnInfo selectedColumn, LineWriter out) throws IOException {
        boolean onColumnsPage = selectedColumn != null;
        List<String> details = null;
        out.writeln(""<a name='columns'></a>"");
        out.writeln(""<table id='columns' class='dataTable' border='1' rules='groups'>"");
        if (onColumnsPage) {
            details = new ArrayList<String>(Config.getInstance().getColumnDetails());
            if (!hasTableIds)
                // simplify subsequent logic by yanking it now
                details.remove(""id"");
            for (String detail : details) {
                if (detail.equals(""comments""))
                    out.writeln(""<colgroup class='comment'>"");
                else
                    out.writeln(""<colgroup>"");
            }
        } else {
            int numCols = hasTableIds ? 9 : 8;
            for (int i = 0; i < numCols; ++i) {
                out.writeln(""<colgroup>"");
            }
            out.writeln(""<colgroup class='comment'>"");
        }
        out.writeln(""<thead align='left'>"");
        out.writeln(""<tr>"");
        if (onColumnsPage) {
            Map<String, String> headings = new HashMap<String, String>();
            headings.put(""id"", getTH(selectedColumn, ""ID"", null, ""right""));
            headings.put(""table"", getTH(selectedColumn, ""Table"", null, null));
            headings.put(""column"", getTH(selectedColumn, ""Column"", null, null));
            headings.put(""type"", getTH(selectedColumn, ""Type"", null, null));
            headings.put(""size"", getTH(selectedColumn, ""Size"", null, null));
            headings.put(""nulls"", getTH(selectedColumn, ""Nulls"", ""Are nulls allowed?"", null));
            headings.put(""auto"", getTH(selectedColumn, ""Auto"", ""Is column automatically updated?"", null));
            headings.put(""default"", getTH(selectedColumn, ""Default"", ""Default value"", null));
            headings.put(""children"", getTH(selectedColumn, ""Children"", ""Columns in tables that reference this column"", null));
            headings.put(""parents"", getTH(selectedColumn, ""Parents"", ""Columns in tables that are referenced by this column"", null));
            headings.put(""comments"", ""<th title='Comments' class='comment'><span class='notSortedByColumn'>Comments</span></th>"");
            // output the headings in the order specified
            if (details != null) {
                // redundant, but keeps compiler happy
                for (String detail : details) {
                    out.writeln(headings.get(detail));
                }
            }
        } else {
            if (hasTableIds)
                out.writeln(getTH(selectedColumn, ""ID"", null, ""right""));
            out.writeln(getTH(selectedColumn, ""Column"", null, null));
            out.writeln(getTH(selectedColumn, ""Type"", null, null));
            out.writeln(getTH(selectedColumn, ""Size"", null, null));
            out.writeln(getTH(selectedColumn, ""Nulls"", ""Are nulls allowed?"", null));
            out.writeln(getTH(selectedColumn, ""Auto"", ""Is column automatically updated?"", null));
            out.writeln(getTH(selectedColumn, ""Default"", ""Default value"", null));
            out.writeln(getTH(selectedColumn, ""Children"", ""Columns in tables that reference this column"", null));
            out.writeln(getTH(selectedColumn, ""Parents"", ""Columns in tables that are referenced by this column"", null));
            out.writeln(""  <th title='Comments' class='comment'><span class='notSortedByColumn'>Comments</span></th>"");
        }
        out.writeln(""</tr>"");
        out.writeln(""</thead>"");
    }

    private String getTH(ColumnInfo selectedColumn, String columnName, String title, String align) {
        StringBuilder buf = new StringBuilder(""  <th"");
        if (align != null) {
            buf.append("" align='"");
            buf.append(align);
            buf.append(""'"");
        }
        if (title != null) {
            buf.append("" title='"");
            buf.append(title);
            buf.append(""'"");
        }
        if (selectedColumn != null) {
            if (selectedColumn.getColumnName().equals(columnName)) {
                buf.append("" class='sortedByColumn'>"");
                buf.append(columnName);
            } else {
                buf.append("" class='notSortedByColumn'>"");
                buf.append(""<a href='"");
                buf.append(selectedColumn.getLocation(columnName));
                buf.append(""#columns'><span class='notSortedByColumn'>"");
                buf.append(columnName);
                buf.append(""</span></a>"");
            }
        } else {
            buf.append('>');
            buf.append(columnName);
        }
        buf.append(""</th>"");
        return buf.toString();
    }

    @Override
    protected void writeFooter(LineWriter html) throws IOException {
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
        html.writeln(""</div>"");
        super.writeFooter(html);
    }

    @Override
    protected boolean isColumnsPage() {
        return true;
    }

    private class ByColumnComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getName().compareToIgnoreCase(column2.getName());
            if (rc == 0)
                rc = column1.getTable().compareTo(column2.getTable());
            return rc;
        }
    }

    private class ByTableComparator implements Comparator<TableColumn> {

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getTable().compareTo(column2.getTable());
            if (rc == 0)
                rc = column1.getName().compareToIgnoreCase(column2.getName());
            return rc;
        }
    }

    private class ByTypeComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> bySize = new BySizeComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getType().compareToIgnoreCase(column2.getType());
            if (rc == 0) {
                rc = bySize.compare(column1, column2);
            }
            return rc;
        }
    }

    private class ByCommentsComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byType = new ByTypeComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            String comment1 = column1.getComments();
            if (comment1 == null)
                comment1 = """";
            String comment2 = column1.getComments();
            if (comment2 == null)
                comment2 = """";
            int rc = comment1.compareToIgnoreCase(comment2);
            if (rc == 0) {
                rc = byType.compare(column1, column2);
            }
            return rc;
        }
    }

    private class BySizeComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byColumn = new ByColumnComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.getLength() - column2.getLength();
            if (rc == 0) {
                rc = column1.getDecimalDigits() - column2.getDecimalDigits();
                if (rc == 0)
                    rc = byColumn.compare(column1, column2);
            }
            return rc;
        }
    }

    private class ByNullableComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byColumn = new ByColumnComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.isNullable() == column2.isNullable() ? 0 : column1.isNullable() ? -1 : 1;
            if (rc == 0)
                rc = byColumn.compare(column1, column2);
            return rc;
        }
    }

    private class ByAutoUpdateComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byColumn = new ByColumnComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            int rc = column1.isAutoUpdated() == column2.isAutoUpdated() ? 0 : column1.isAutoUpdated() ? -1 : 1;
            if (rc == 0)
                rc = byColumn.compare(column1, column2);
            return rc;
        }
    }

    private class ByDefaultValueComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byNullable = new ByNullableComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            String value1 = String.valueOf(column1.getDefaultValue());
            String value2 = String.valueOf(column2.getDefaultValue());
            int rc = value1.compareToIgnoreCase(value2);
            if (rc == 0)
                rc = byNullable.compare(column1, column2);
            return rc;
        }
    }

    private class ByChildrenComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byColumn = new ByColumnComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            Set<String> childTables1 = new TreeSet<String>();
            Set<String> childTables2 = new TreeSet<String>();
            for (TableColumn column : column1.getChildren()) {
                if (!column.getParentConstraint(column1).isImplied())
                    childTables1.add(column.getTable().getName());
            }
            for (TableColumn column : column2.getChildren()) {
                if (!column.getParentConstraint(column2).isImplied())
                    childTables2.add(column.getTable().getName());
            }
            int rc = childTables1.toString().compareToIgnoreCase(childTables2.toString());
            if (rc == 0)
                rc = byColumn.compare(column1, column2);
            return rc;
        }
    }

    private class ByParentsComparator implements Comparator<TableColumn> {

        private final Comparator<TableColumn> byColumn = new ByColumnComparator();

        public int compare(TableColumn column1, TableColumn column2) {
            Set<String> parentTables1 = new TreeSet<String>();
            Set<String> parentTables2 = new TreeSet<String>();
            for (TableColumn column : column1.getParents()) {
                if (!column.getChildConstraint(column1).isImplied())
                    parentTables1.add(column.getTable().getName() + '.' + column.getTable().getSchema());
            }
            for (TableColumn column : column2.getParents()) {
                if (!column.getChildConstraint(column2).isImplied())
                    parentTables2.add(column.getTable().getName() + '.' + column.getTable().getSchema());
            }
            int rc = parentTables1.toString().compareToIgnoreCase(parentTables2.toString());
            if (rc == 0)
                rc = byColumn.compare(column1, column2);
            return rc;
        }
    }
}
","// HtmlColumnsPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.Table.ByColumnIdComparator;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlColumnsPage}.
* It contains ten unit test cases for the {@link HtmlColumnsPage#getInstance()} method.
*/
class HtmlColumnsPageTest {","// HtmlColumnsPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.Table.ByColumnIdComparator;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlColumnsPage}.
* It contains ten unit test cases for the {@link HtmlColumnsPage#getInstance()} method.
*/
class HtmlColumnsPageTest {
"
cmpl-6u94zWBQ7wQjHN3lywt25PR5nPMfC,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlConstraintsPage.java,37.78170871734619,stop,"// HtmlConstraintsPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that lists all of the constraints in the schema
 *
 * @author John Currier
 */
public class HtmlConstraintsPage extends HtmlFormatter {

    private static HtmlConstraintsPage instance = new HtmlConstraintsPage();

    private int columnCounter;

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlConstraintsPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlConstraintsPage getInstance() {
        return instance;
    }

    public void write(Database database, List<ForeignKeyConstraint> constraints, Collection<Table> tables, LineWriter html) throws IOException {
        writeHeader(database, html);
        writeForeignKeyConstraints(constraints, html);
        writeCheckConstraints(tables, html);
        writeFooter(html);
    }

    private void writeHeader(Database database, LineWriter html) throws IOException {
        writeHeader(database, null, ""Constraints"", html);
        html.writeln(""<div class='indent'>"");
    }

    @Override
    protected void writeFooter(LineWriter html) throws IOException {
        html.writeln(""</div>"");
        super.writeFooter(html);
    }

    /**
     * Write specified foreign key constraints
     *
     * @param constraints List
     * @param html LineWriter
     * @throws IOException
     */
    private void writeForeignKeyConstraints(List<ForeignKeyConstraint> constraints, LineWriter html) throws IOException {
        Set<ForeignKeyConstraint> constraintsByName = new TreeSet<ForeignKeyConstraint>();
        constraintsByName.addAll(constraints);
        html.writeln(""<table width='100%'>"");
        html.writeln(""<tr><td class='container' valign='bottom'><b>"");
        html.write(String.valueOf(constraintsByName.size()));
        html.writeln("" Foreign Key Constraints:</b>"");
        html.writeln(""</td><td class='container' align='right'>"");
        if (sourceForgeLogoEnabled())
            html.writeln(""  <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a>"");
        html.writeln(""</td></tr>"");
        html.writeln(""</table><br>"");
        html.writeln(""<table class='dataTable' border='1' rules='groups'>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<thead align='left'>"");
        html.writeln(""<tr>"");
        html.writeln(""  <th>Constraint Name</th>"");
        html.writeln(""  <th>Child Column</th>"");
        html.writeln(""  <th>Parent Column</th>"");
        html.writeln(""  <th>Delete Rule</th>"");
        html.writeln(""</tr>"");
        html.writeln(""</thead>"");
        html.writeln(""<tbody>"");
        for (ForeignKeyConstraint constraint : constraintsByName) {
            writeForeignKeyConstraint(constraint, html);
        }
        if (constraints.size() == 0) {
            html.writeln("" <tr>"");
            html.writeln(""  <td class='detail' valign='top' colspan='4'>None detected</td>"");
            html.writeln("" </tr>"");
        }
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
    }

    /**
     * Write specified foreign key constraint
     *
     * @param constraint ForeignKeyConstraint
     * @param html LineWriter
     * @throws IOException
     */
    private void writeForeignKeyConstraint(ForeignKeyConstraint constraint, LineWriter html) throws IOException {
        boolean even = columnCounter++ % 2 == 0;
        if (even)
            html.writeln(""  <tr class='even'>"");
        else
            html.writeln(""  <tr class='odd'>"");
        html.write(""  <td class='detail'>"");
        html.write(constraint.getName());
        html.writeln(""</td>"");
        html.write(""  <td class='detail'>"");
        for (Iterator<TableColumn> iter = constraint.getChildColumns().iterator(); iter.hasNext(); ) {
            TableColumn column = iter.next();
            html.write(""<a href='tables/"");
            html.write(urlEncode(column.getTable().getName()));
            html.write("".html'>"");
            html.write(column.getTable().getName());
            html.write(""</a>"");
            html.write(""."");
            html.write(column.getName());
            if (iter.hasNext())
                html.write(""<br>"");
        }
        html.writeln(""</td>"");
        html.write(""  <td class='detail'>"");
        for (Iterator<TableColumn> iter = constraint.getParentColumns().iterator(); iter.hasNext(); ) {
            TableColumn column = iter.next();
            html.write(""<a href='tables/"");
            html.write(urlEncode(column.getTable().getName()));
            html.write("".html'>"");
            html.write(column.getTable().getName());
            html.write(""</a>"");
            html.write(""."");
            html.write(column.getName());
            if (iter.hasNext())
                html.write(""<br>"");
        }
        html.writeln(""</td>"");
        html.write(""  <td class='detail'>"");
        String ruleText = constraint.getDeleteRuleDescription();
        String ruleName = constraint.getDeleteRuleName();
        html.write(""<span title='"" + ruleText + ""'>"" + ruleName + ""&nbsp;</span>"");
        html.writeln(""</td>"");
        html.writeln("" </tr>"");
    }

    /**
     * Write check constraints associated with the specified tables
     *
     * @param tables Collection
     * @param html LineWriter
     * @throws IOException
     */
    public void writeCheckConstraints(Collection<Table> tables, LineWriter html) throws IOException {
        html.writeln(""<a name='checkConstraints'></a><p>"");
        html.writeln(""<b>Check Constraints:</b>"");
        html.writeln(""<TABLE class='dataTable' border='1' rules='groups'>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<thead align='left'>"");
        html.writeln(""<tr>"");
        html.writeln(""  <th>Table</th>"");
        html.writeln(""  <th>Constraint Name</th>"");
        html.writeln(""  <th>Constraint</th>"");
        html.writeln(""</tr>"");
        html.writeln(""</thead>"");
        html.writeln(""<tbody>"");
        List<Table> tablesByName = DbAnalyzer.sortTablesByName(new ArrayList<Table>(tables));
        int constraintsWritten = 0;
        // iter over all tables...only ones with check constraints will write anything
        for (Table table : tablesByName) {
            constraintsWritten += writeCheckConstraints(table, html);
        }
        if (constraintsWritten == 0) {
            html.writeln("" <tr>"");
            html.writeln(""  <td class='detail' valign='top' colspan='3'>None detected</td>"");
            html.writeln("" </tr>"");
        }
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
    }

    /**
     * Write check constraints associated with the specified table (if any)
     *
     * @param table Table
     * @param html LineWriter
     * @throws IOException
     * @return int
     */
    private int writeCheckConstraints(Table table, LineWriter html) throws IOException {
        // constraint name -> text pairs
        Map<String, String> constraints = table.getCheckConstraints();
        int constraintsWritten = 0;
        for (String name : constraints.keySet()) {
            html.writeln("" <tr>"");
            html.write(""  <td class='detail' valign='top'><a href='tables/"");
            html.write(urlEncode(table.getName()));
            html.write("".html'>"");
            html.write(table.getName());
            html.write(""</a></td>"");
            html.write(""  <td class='detail' valign='top'>"");
            html.write(name);
            html.writeln(""</td>"");
            html.write(""  <td class='detail'>"");
            html.write(HtmlEncoder.encodeString(constraints.get(name).toString()));
            html.writeln(""</td>"");
            html.writeln("" </tr>"");
            ++constraintsWritten;
        }
        return constraintsWritten;
    }

    @Override
    protected boolean isConstraintsPage() {
        return true;
    }
}
","// HtmlConstraintsPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlConstraintsPage}.
* It contains ten unit test cases for the {@link HtmlConstraintsPage#getInstance()} method.
*/
class HtmlConstraintsPageTest {","// HtmlConstraintsPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.DbAnalyzer;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlConstraintsPage}.
* It contains ten unit test cases for the {@link HtmlConstraintsPage#getInstance()} method.
*/
class HtmlConstraintsPageTest {

	/**
	* Test case for {@link HtmlConstraintsPage#getInstance()} method.
	* This test case checks if the method returns the same instance of the class.
	*/
	@Test
	void testGetInstance() {
		HtmlConstraintsPage instance1 = HtmlConstraintsPage.getInstance();
		HtmlConstraintsPage instance2 = HtmlConstraintsPage.getInstance();
		assertSame(instance1, instance2);
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#write(Database, List, Collection, LineWriter)} method.
	* This test case checks if the method writes the header of the page.
	*/
	@Test
	void testWriteHeader() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""<html>""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#write(Database, List, Collection, LineWriter)} method.
	* This test case checks if the method writes the footer of the page.
	*/
	@Test
	void testWriteFooter() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""</html>""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#write(Database, List, Collection, LineWriter)} method.
	* This test case checks if the method writes the foreign key constraints.
	*/
	@Test
	void testWriteForeignKeyConstraints() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""Foreign Key Constraints:""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#write(Database, List, Collection, LineWriter)} method.
	* This test case checks if the method writes the check constraints.
	*/
	@Test
	void testWriteCheckConstraints() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""Check Constraints:""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#writeForeignKeyConstraint(ForeignKeyConstraint, LineWriter)} method.
	* This test case checks if the method writes the foreign key constraint.
	*/
	@Test
	void testWriteForeignKeyConstraint() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""Foreign Key Constraints:""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#writeCheckConstraints(Collection, LineWriter)} method.
	* This test case checks if the method writes the check constraints.
	*/
	@Test
	void testWriteCheckConstraints2() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""Check Constraints:""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#writeCheckConstraints(Table, LineWriter)} method.
	* This test case checks if the method writes the check constraints.
	*/
	@Test
	void testWriteCheckConstraints3() throws IOException {
		Database database = new Database(""database"", ""url"", ""driver"", ""user"", ""password"", ""catalog"", ""schema"");
		List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();
		Collection<Table> tables = new ArrayList<Table>();
		LineWriter html = new LineWriter();
		HtmlConstraintsPage.getInstance().write(database, constraints, tables, html);
		assertTrue(html.toString().contains(""Check Constraints:""));
	}
	
	/**
	* Test case for {@link HtmlConstraintsPage#isConstraintsPage()} method.
	* This test case checks if the method returns true.
	*/
	@Test
	void testIsConstraintsPage() {
		assertTrue(HtmlConstraintsPage.getInstance().isConstraintsPage());
	}
	
}"
5ca03351-e87a-4956-910a-fccbd557d020,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlMainIndexPage.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8984 tokens (4984 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HtmlMainIndexPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The main index that contains all tables and views that were evaluated
 *
 * @author John Currier
 */
public class HtmlMainIndexPage extends HtmlFormatter {

    private static HtmlMainIndexPage instance = new HtmlMainIndexPage();

    private final NumberFormat integerFormatter = NumberFormat.getIntegerInstance();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlMainIndexPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlMainIndexPage getInstance() {
        return instance;
    }

    public void write(Database database, Collection<Table> tables, Collection<Table> remotes, LineWriter html) throws IOException {
        Comparator<Table> sorter = new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.compareTo(table2);
            }
        };
        // sort tables and remotes by name
        Collection<Table> tmp = new TreeSet<Table>(sorter);
        tmp.addAll(tables);
        tables = tmp;
        tmp = new TreeSet<Table>(sorter);
        tmp.addAll(remotes);
        remotes = tmp;
        tmp = null;
        boolean showIds = false;
        int numViews = 0;
        boolean hasComments = false;
        for (Table table : tables) {
            if (table.isView())
                ++numViews;
            showIds |= table.getId() != null;
            if (table.getComments() != null)
                hasComments = true;
        }
        writeLocalsHeader(database, tables.size() - numViews, numViews, showIds, hasComments, html);
        int numTableCols = 0;
        int numViewCols = 0;
        long numRows = 0;
        for (Table table : tables) {
            writeLineItem(table, showIds, html);
            if (!table.isView())
                numTableCols += table.getColumns().size();
            else
                numViewCols += table.getColumns().size();
            numRows += table.getNumRows() > 0 ? table.getNumRows() : 0;
        }
        writeLocalsFooter(tables.size() - numViews, numTableCols, numViews, numViewCols, numRows, html);
        if (!remotes.isEmpty()) {
            writeRemotesHeader(database, showIds, hasComments, html);
            for (Table table : remotes) {
                writeLineItem(table, showIds, html);
            }
            writeRemotesFooter(html);
        }
        writeFooter(html);
    }

    private void writeLocalsHeader(Database db, int numberOfTables, int numberOfViews, boolean showIds, boolean hasComments, LineWriter html) throws IOException {
        List<String> javascript = new ArrayList<String>();
        // we can't use the hard-coded even odd technique that we use
        // everywhere else because we're dynamically changing the visibility
        // of tables/views within the list
        javascript.add(""$(function(){"");
        javascript.add(""  associate($('#showTables'), $('.tbl'));"");
        javascript.add(""  associate($('#showViews'),  $('.view'));"");
        javascript.add(""  jQuery.fn.alternateRowColors = function() {"");
        javascript.add(""    $('tbody tr:visible').each(function(i) {"");
        javascript.add(""      if (i % 2 == 0) {"");
        javascript.add(""        $(this).removeClass('even').addClass('odd');"");
        javascript.add(""      } else {"");
        javascript.add(""        $(this).removeClass('odd').addClass('even');"");
        javascript.add(""      }"");
        javascript.add(""    });"");
        javascript.add(""    return this;"");
        javascript.add(""  };"");
        javascript.add(""  $('#showTables, #showViews').click(function() {"");
        javascript.add(""    $('table.dataTable').alternateRowColors();"");
        javascript.add(""  });"");
        javascript.add(""  $('table.dataTable').alternateRowColors();"");
        javascript.add(""})"");
        writeHeader(db, null, null, javascript, html);
        html.writeln(""<table width='100%'>"");
        html.writeln("" <tr><td class='container'>"");
        writeGeneratedOn(db.getConnectTime(), html);
        html.writeln("" </td></tr>"");
        html.writeln("" <tr>"");
        html.write(""  <td class='container'>Database Type: "");
        html.write(db.getDatabaseProduct());
        html.writeln(""  </td>"");
        html.writeln(""  <td class='container' align='right' valign='top' rowspan='3'>"");
        if (sourceForgeLogoEnabled())
            html.writeln(""    <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a><br>"");
        html.writeln(""    <br>"");
        html.writeln(""  </td>"");
        html.writeln("" </tr>"");
        html.writeln("" <tr>"");
        html.write(""  <td class='container'>"");
        String xmlName = db.getName();
        if (db.getSchema() != null)
            xmlName += '.' + db.getSchema();
        else if (db.getCatalog() != null)
            xmlName += '.' + db.getCatalog();
        html.write(""<br><a href='"" + xmlName + "".xml' title='XML Representation'>XML Representation</a>"");
        html.write(""<br><a href='insertionOrder.txt' title='Useful for loading data into a database'>Insertion Order</a>&nbsp;"");
        html.write(""<a href='deletionOrder.txt' title='Useful for purging data from a database'>Deletion Order</a>"");
        html.writeln(""</td>"");
        html.writeln("" </tr>"");
        html.writeln(""</table>"");
        html.writeln(""<div class='indent'>"");
        html.write(""<p>"");
        html.write(""<b>"");
        if (numberOfViews == 0) {
            html.writeln(""<label for='showTables' style='display:none;'><input type='checkbox' id='showTables' checked></label>"");
        } else if (numberOfTables == 0) {
            html.writeln(""<label for='showViews' style='display:none;'><input type='checkbox' id='showViews' checked></label>"");
        } else {
            html.write(""<label for='showTables'><input type='checkbox' id='showTables' checked>Tables</label>"");
            html.write("" <label for='showViews'><input type='checkbox' id='showViews' checked>Views</label>"");
        }
        html.writeln("" <label for='showComments'><input type=checkbox "" + (hasComments ? ""checked "" : """") + ""id='showComments'>Comments</label>"");
        html.writeln(""</b>"");
        html.writeln(""<table class='dataTable' border='1' rules='groups'>"");
        int numGroups = 4 + (showIds ? 1 : 0) + (displayNumRows ? 1 : 0);
        for (int i = 0; i < numGroups; ++i) html.writeln(""<colgroup>"");
        html.writeln(""<colgroup class='comment'>"");
        html.writeln(""<thead align='left'>"");
        html.writeln(""<tr>"");
        String tableHeading;
        if (numberOfViews == 0)
            tableHeading = ""Table"";
        else if (numberOfTables == 0)
            tableHeading = ""View"";
        else
            tableHeading = ""Table / View"";
        html.writeln(""  <th valign='bottom'>"" + tableHeading + ""</th>"");
        if (showIds)
            html.writeln(""  <th align='center' valign='bottom'>ID</th>"");
        html.writeln(""  <th align='right' valign='bottom'>Children</th>"");
        html.writeln(""  <th align='right' valign='bottom'>Parents</th>"");
        html.writeln(""  <th align='right' valign='bottom'>Columns</th>"");
        if (displayNumRows)
            html.writeln(""  <th align='right' valign='bottom'>Rows</th>"");
        html.writeln(""  <th class='comment' align='left' valign='bottom'>Comments</th>"");
        html.writeln(""</tr>"");
        html.writeln(""</thead>"");
        html.writeln(""<tbody>"");
    }

    private void writeRemotesHeader(Database db, boolean showIds, boolean hasComments, LineWriter html) throws IOException {
        html.writeln(""<p><br><b>Related tables in other schemas</b>"");
        html.writeln(""<table class='dataTable' border='1' rules='groups'>"");
        int numGroups = 3 + (showIds ? 1 : 0);
        for (int i = 0; i < numGroups; ++i) html.writeln(""<colgroup>"");
        html.writeln(""<colgroup class='comment'>"");
        html.writeln(""<thead align='left'>"");
        html.writeln(""<tr>"");
        html.writeln(""  <th rowspan='2'>Table</th>"");
        if (showIds)
            html.writeln(""  <th align='center' valign='bottom' rowspan='2'>ID</th>"");
        html.writeln(""  <th valign='bottom' colspan='2' style='text-align: center;'>In this schema</th>"");
        html.writeln(""  <th class='comment' align='left' valign='bottom' rowspan='2'>Comments</th>"");
        html.writeln(""</tr>"");
        html.writeln(""<tr>"");
        html.writeln(""  <th align='right' valign='bottom'>Children</th>"");
        html.writeln(""  <th align='right' valign='bottom'>Parents</th>"");
        html.writeln(""</tr>"");
        html.writeln(""</thead>"");
        html.writeln(""<tbody>"");
    }

    private void writeLineItem(Table table, boolean showIds, LineWriter html) throws IOException {
        html.write("" <tr class='"" + (table.isView() ? ""view"" : ""tbl"") + ""' valign='top'>"");
        html.write(""  <td class='detail'>"");
        String tableName = table.getName();
        if (table.isRemote() && !Config.getInstance().isOneOfMultipleSchemas()) {
            html.write(table.getContainer());
            html.write('.');
            html.write(tableName);
        } else {
            if (table.isRemote()) {
                html.write(""<a href='../"" + urlEncode(table.getContainer()) + ""/index.html'>"");
                html.write(table.getContainer());
                html.write(""</a>."");
            }
            html.write(""<a href='tables/"");
            if (table.isRemote()) {
                html.write(""../../"" + urlEncode(table.getContainer()) + ""/tables/"");
            }
            html.write(urlEncode(tableName));
            html.write("".html'>"");
            html.write(tableName);
            html.write(""</a>"");
        }
        html.writeln(""</td>"");
        if (showIds) {
            html.write(""  <td class='detail' align='right'>"");
            Object id = table.getId();
            if (id != null)
                html.write(String.valueOf(id));
            else
                html.writeln(""&nbsp;"");
            html.writeln(""</td>"");
        }
        html.write(""  <td class='detail' align='right'>"");
        int numRelatives = table.getNumNonImpliedChildren();
        if (numRelatives != 0)
            html.write(String.valueOf(integerFormatter.format(numRelatives)));
        html.writeln(""</td>"");
        html.write(""  <td class='detail' align='right'>"");
        numRelatives = table.getNumNonImpliedParents();
        if (numRelatives != 0)
            html.write(String.valueOf(integerFormatter.format(numRelatives)));
        html.writeln(""</td>"");
        if (!table.isRemote()) {
            html.write(""  <td class='detail' align='right'>"");
            html.write(String.valueOf(integerFormatter.format(table.getColumns().size())));
            html.writeln(""</td>"");
            if (displayNumRows) {
                html.write(""  <td class='detail' align='right'>"");
                if (!table.isView()) {
                    if (table.getNumRows() >= 0)
                        html.write(String.valueOf(integerFormatter.format(table.getNumRows())));
                    else
                        html.write(""<span title='Row count not available'>&nbsp;</span>"");
                } else
                    html.write(""<span title='Views contain no real rows'>view</span>"");
                html.writeln(""</td>"");
            }
        }
        html.write(""  <td class='comment detail'>"");
        String comments = table.getComments();
        if (comments != null) {
            if (encodeComments)
                for (int i = 0; i < comments.length(); ++i) html.write(HtmlEncoder.encodeToken(comments.charAt(i)));
            else
                html.write(comments);
        }
        html.writeln(""</td>"");
        html.writeln(""  </tr>"");
    }

    protected void writeLocalsFooter(int numTables, int numTableCols, int numViews, int numViewCols, long numRows, LineWriter html) throws IOException {
        html.writeln(""  <tr>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        if (displayNumRows)
            html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='comment detail'>&nbsp;</td>"");
        html.writeln(""  </tr>"");
        String name = numTables == 1 ? "" Table"" : "" Tables"";
        html.writeln(""  <tr class='tbl'>"");
        html.writeln(""    <td class='detail'><b>"" + integerFormatter.format(numTables) + name + ""</b></td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail' align='right'><b>"" + integerFormatter.format(numTableCols) + ""</b></td>"");
        if (displayNumRows)
            html.writeln(""    <td class='detail' align='right'><b>"" + integerFormatter.format(numRows) + ""</b></td>"");
        html.writeln(""    <td class='comment detail'>&nbsp;</td>"");
        html.writeln(""  </tr>"");
        name = numViews == 1 ? "" View"" : "" Views"";
        html.writeln(""  <tr class='view'>"");
        html.writeln(""    <td class='detail'><b>"" + integerFormatter.format(numViews) + name + ""</b></td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='detail' align='right'><b>"" + integerFormatter.format(numViewCols) + ""</b></td>"");
        if (displayNumRows)
            html.writeln(""    <td class='detail'>&nbsp;</td>"");
        html.writeln(""    <td class='comment detail'>&nbsp;</td>"");
        html.writeln(""  </tr>"");
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
    }

    protected void writeRemotesFooter(LineWriter html) throws IOException {
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
    }

    @Override
    protected boolean isMainIndex() {
        return true;
    }
}
","// HtmlMainIndexPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlMainIndexPage}.
* It contains ten unit test cases for the {@link HtmlMainIndexPage#getInstance()} method.
*/
class HtmlMainIndexPageTest {","// HtmlMainIndexPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlMainIndexPage}.
* It contains ten unit test cases for the {@link HtmlMainIndexPage#getInstance()} method.
*/
class HtmlMainIndexPageTest {
"
cmpl-6u970MLY1twSH8WYklhtwa85uttca,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlMultipleSchemasIndexPage.java,104.8954803943634,length,"// HtmlMultipleSchemasIndexPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that contains links to the various schemas that were analyzed
 *
 * @author John Currier
 */
public class HtmlMultipleSchemasIndexPage extends HtmlFormatter {

    private static HtmlMultipleSchemasIndexPage instance = new HtmlMultipleSchemasIndexPage();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlMultipleSchemasIndexPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlMultipleSchemasIndexPage getInstance() {
        return instance;
    }

    public void write(String dbName, List<String> populatedSchemas, DatabaseMetaData meta, LineWriter index) throws IOException {
        writeHeader(dbName, meta, populatedSchemas.size(), false, populatedSchemas.get(0).toString(), index);
        for (String schema : populatedSchemas) {
            writeLineItem(schema, index);
        }
        writeFooter(index);
    }

    private void writeHeader(String databaseName, DatabaseMetaData meta, int numberOfSchemas, boolean showIds, String aSchema, LineWriter html) throws IOException {
        String connectTime = new SimpleDateFormat(""EEE MMM dd HH:mm z yyyy"").format(new Date());
        html.writeln(""<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>"");
        html.writeln(""<html>"");
        html.writeln(""<head>"");
        html.write(""  <title>SchemaSpy Analysis"");
        if (databaseName != null) {
            html.write("" of Database "");
            html.write(databaseName);
        }
        html.writeln(""</title>"");
        html.write(""  <link rel=stylesheet href='"");
        html.write(aSchema);
        html.writeln(""/schemaSpy.css' type='text/css'>"");
        html.writeln(""  <meta HTTP-EQUIV='Content-Type' CONTENT='text/html; charset="" + Config.getInstance().getCharset() + ""'>"");
        html.writeln(""</head>"");
        html.writeln(""<body>"");
        writeTableOfContents(html);
        html.writeln(""<div class='content' style='clear:both;'>"");
        html.writeln(""<table width='100%' border='0' cellpadding='0'>"");
        html.writeln("" <tr>"");
        html.write(""  <td class='heading' valign='top'><h1>"");
        html.write(""SchemaSpy Analysis"");
        if (databaseName != null) {
            html.write("" of Database "");
            html.write(databaseName);
        }
        html.writeln(""</h1></td>"");
        html.writeln(""  <td class='heading' align='right' valign='top' title='John Currier - Creator of Cool Tools'><span class='indent'>Generated by</span><br><span class='indent'><span class='signature'><a href='http://schemaspy.sourceforge.net' target='_blank'>SchemaSpy</a></span></span></td>"");
        html.writeln("" </tr>"");
        html.writeln(""</table>"");
        html.writeln(""<table width='100%'>"");
        html.writeln("" <tr><td class='container'>"");
        writeGeneratedOn(connectTime, html);
        html.writeln("" </td></tr>"");
        html.writeln("" <tr>"");
        html.write(""  <td class='container'>"");
        if (meta != null) {
            html.write(""Database Type: "");
            html.write(getDatabaseProduct(meta));
        }
        html.writeln(""  </td>"");
        html.writeln(""  <td class='container' align='right' valign='top' rowspan='3'>"");
        if (sourceForgeLogoEnabled())
            html.writeln(""    <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a><br>"");
        html.write(""    <br>"");
        html.writeln(""  </td>"");
        html.writeln("" </tr>"");
        html.writeln(""</table>"");
        html.writeln(""<div class='indent'>"");
        html.write(""<b>"");
        html.write(String.valueOf(numberOfSchemas));
        if (databaseName != null)
            html.write("" Schema"");
        else
            html.write("" Database"");
        html.write(numberOfSchemas == 1 ? """" : ""s"");
        html.writeln("":</b>"");
        html.writeln(""<TABLE class='dataTable' border='1' rules='groups'>"");
        html.writeln(""<colgroup>"");
        html.writeln(""<thead align='left'>"");
        html.writeln(""<tr>"");
        html.write(""  <th valign='bottom'>"");
        if (databaseName != null)
            html.write(""Schema"");
        else
            html.write(""Database"");
        html.writeln(""</th>"");
        if (showIds)
            html.writeln(""  <th align='center' valign='bottom'>ID</th>"");
        html.writeln(""</tr>"");
        html.writeln(""</thead>"");
        html.writeln(""<tbody>"");
    }

    private void writeLineItem(String schema, LineWriter index) throws IOException {
        index.writeln("" <tr>"");
        index.write(""  <td class='detail'><a href='"");
        index.write(schema);
        index.write(""/index.html'>"");
        index.write(schema);
        index.writeln(""</a></td>"");
        index.writeln("" </tr>"");
    }

    @Override
    protected void writeTableOfContents(LineWriter html) throws IOException {
        // have to use a table to deal with a horizontal scrollbar showing up inappropriately
        html.writeln(""<table id='headerHolder' cellspacing='0' cellpadding='0'><tr><td>"");
        html.writeln(""<div id='header'>"");
        html.writeln("" <ul>"");
        html.writeln(""  <li id='current'><a href='index.html' title='All user schemas in the database'>Schemas</a></li>"");
        html.writeln(""  <li><a href='http://sourceforge.net/donate/index.php?group_id=137197' title='Please help keep SchemaSpy alive' target='_blank'>Donate</a></li>"");
        html.writeln("" </ul>"");
        html.writeln(""</div>"");
        html.writeln(""</td></tr></table>"");
    }

    @Override
    protected void writeFooter(LineWriter html) throws IOException {
        html.writeln(""</tbody>"");
        html.writeln(""</table>"");
        super.writeFooter(html);
    }

    /**
     * Copy / paste from Database, but we can't use Database here...
     *
     * @param meta DatabaseMetaData
     * @return String
     */
    private String getDatabaseProduct(DatabaseMetaData meta) {
        try {
            return meta.getDatabaseProductName() + "" - "" + meta.getDatabaseProductVersion();
        } catch (SQLException exc) {
            return """";
        }
    }
}
","// HtmlMultipleSchemasIndexPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlMultipleSchemasIndexPage}.
* It contains ten unit test cases for the {@link HtmlMultipleSchemasIndexPage#getInstance()} method.
*/
class HtmlMultipleSchemasIndexPageTest {","// HtmlMultipleSchemasIndexPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlMultipleSchemasIndexPage}.
* It contains ten unit test cases for the {@link HtmlMultipleSchemasIndexPage#getInstance()} method.
*/
class HtmlMultipleSchemasIndexPageTest {

	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#getInstance()} method.
	* This test case checks if the method returns an instance of the {@link HtmlMultipleSchemasIndexPage} class.
	*/
	@Test
	void testGetInstance() {
		assertTrue(HtmlMultipleSchemasIndexPage.getInstance() instanceof HtmlMultipleSchemasIndexPage);
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link LineWriter} is null.
	*/
	@Test
	void testWriteWithNullLineWriter() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""dbName"", null, null, null);
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link List} is null.
	*/
	@Test
	void testWriteWithNullList() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""dbName"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link DatabaseMetaData} is null.
	*/
	@Test
	void testWriteWithNullDatabaseMetaData() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""dbName"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is null.
	*/
	@Test
	void testWriteWithNullString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(null, null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is empty.
	*/
	@Test
	void testWriteWithEmptyString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write("""", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is blank.
	*/
	@Test
	void testWriteWithBlankString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write("" "", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a tab.
	*/
	@Test
	void testWriteWithTabString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\t"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a new line.
	*/
	@Test
	void testWriteWithNewLineString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\n"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a carriage return.
	*/
	@Test
	void testWriteWithCarriageReturnString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\r"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a form feed.
	*/
	@Test
	void testWriteWithFormFeedString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\f"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a carriage return new line.
	*/
	@Test
	void testWriteWithCarriageReturnNewLineString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\r\n"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a next line.
	*/
	@Test
	void testWriteWithNextLineString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u0085"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a next line.
	*/
	@Test
	void testWriteWithLineSeparatorString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2028"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a paragraph separator.
	*/
	@Test
	void testWriteWithParagraphSeparatorString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2029"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a space.
	*/
	@Test
	void testWriteWithSpaceString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write("" "", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithNonBreakingSpaceString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u00A0"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithOghamSpaceMarkString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u1680"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithEnQuadString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2000"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithEmQuadString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2001"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithEnSpaceString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2002"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithEmSpaceString() {
		assertThrows(IOException.class, () -> {
			HtmlMultipleSchemasIndexPage.getInstance().write(""\u2003"", null, null, new LineWriter() {
				@Override
				public void writeln(String line) throws IOException {
					throw new IOException();
				}
			});
		});
	}
	
	/**
	* Test case for {@link HtmlMultipleSchemasIndexPage#write(String, List, DatabaseMetaData, LineWriter)} method.
	* This test case checks if the method throws an {@link IOException} when the {@link String} is a non-breaking space.
	*/
	@Test
	void testWriteWithThreePerEmSpaceString() {
		assertThrows(IOException.class, () ->"
cmpl-6u98h5tqgrCIqRNiHX08lAHVDrPpb,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlOrphansPage_0Test.java,103.64001393318176,length,"// HtmlOrphansPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that contains the all tables that aren't related to others (orphans)
 *
 * @author John Currier
 */
public class HtmlOrphansPage extends HtmlDiagramFormatter {

    private static HtmlOrphansPage instance = new HtmlOrphansPage();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlOrphansPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlOrphansPage getInstance() {
        return instance;
    }

    public boolean write(Database db, List<Table> orphanTables, File diagramDir, LineWriter html) throws IOException {
        Dot dot = getDot();
        if (dot == null)
            return false;
        Set<Table> orphansWithImpliedRelationships = new HashSet<Table>();
        for (Table table : orphanTables) {
            if (!table.isOrphan(true)) {
                orphansWithImpliedRelationships.add(table);
            }
        }
        writeHeader(db, ""Utility Tables"", !orphansWithImpliedRelationships.isEmpty(), html);
        html.writeln(""<a name='diagram'>"");
        try {
            StringBuilder maps = new StringBuilder(64 * 1024);
            for (Table table : orphanTables) {
                String dotBaseFilespec = table.getName();
                File dotFile = new File(diagramDir, dotBaseFilespec + "".1degree.dot"");
                File imgFile = new File(diagramDir, dotBaseFilespec + "".1degree."" + dot.getFormat());
                LineWriter dotOut = new LineWriter(dotFile, Config.DOT_CHARSET);
                DotFormatter.getInstance().writeOrphan(table, dotOut);
                dotOut.close();
                try {
                    maps.append(dot.generateDiagram(dotFile, imgFile));
                } catch (Dot.DotFailure dotFailure) {
                    System.err.println(dotFailure);
                    return false;
                }
                html.write(""  <img src='diagrams/orphans/"" + imgFile.getName() + ""' usemap='#"" + table + ""' border='0' alt='' align='top'"");
                if (orphansWithImpliedRelationships.contains(table))
                    html.write("" class='impliedNotOrphan'"");
                html.writeln("">"");
            }
            html.write(maps.toString());
            return true;
        } finally {
            html.writeln(""</a>"");
            writeFooter(html);
        }
    }

    private void writeHeader(Database db, String title, boolean hasImpliedRelationships, LineWriter html) throws IOException {
        writeHeader(db, null, title, html);
        html.writeln(""<table class='container' width='100%'>"");
        html.writeln(""<tr><td class='container'>"");
        writeGeneratedOn(db.getConnectTime(), html);
        html.writeln(""</td>"");
        html.writeln(""<td class='container' align='right' valign='top' rowspan='2'>"");
        writeLegend(false, html);
        html.writeln(""</td></tr>"");
        html.writeln(""<tr><td class='container' align='left' valign='top'>"");
        if (hasImpliedRelationships) {
            html.writeln(""<form action=''>"");
            html.writeln("" <label for='removeImpliedOrphans'><input type=checkbox id='removeImpliedOrphans'>"");
            html.writeln(""  Hide tables with implied relationships</label>"");
            html.writeln(""</form>"");
        }
        html.writeln(""</td></tr></table>"");
    }

    @Override
    protected boolean isOrphansPage() {
        return true;
    }
}
","// HtmlOrphansPage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlOrphansPage}.
* It contains ten unit test cases for the {@link HtmlOrphansPage#getInstance()} method.
*/
class HtmlOrphansPage_0Test {","// HtmlOrphansPage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlOrphansPage}.
* It contains ten unit test cases for the {@link HtmlOrphansPage#getInstance()} method.
*/
class HtmlOrphansPage_0Test {

	/**
	 * Test method for {@link HtmlOrphansPage#getInstance()}.
	 * 
	 * Test case for the method {@link HtmlOrphansPage#getInstance()}.
	 * 
	 * <p>
	 * <b>Precondition:</b>
	 * </p>
	 * 
	 * <p>
	 * <b>Postcondition:</b>
	 * </p>
	 * 
	 * @throws IOException
	 *             if an IOException occurs
	 */
	@Test
	void testGetInstance() throws IOException {
		HtmlOrphansPage result = HtmlOrphansPage.getInstance();
		assertNotNull(result);
	}

	/**
	 * Test method for {@link HtmlOrphansPage#write(Database, List, File, LineWriter)}.
	 * 
	 * Test case for the method {@link HtmlOrphansPage#write(Database, List, File, LineWriter)}.
	 * 
	 * <p>
	 * <b>Precondition:</b>
	 * </p>
	 * 
	 * <p>
	 * <b>Postcondition:</b>
	 * </p>
	 * 
	 * @throws IOException
	 *             if an IOException occurs
	 */
	@Test
	void testWrite() throws IOException {
		Database db = new Database(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null"
cmpl-6u9ANRHbDzvoZortwrRwlmIZWcAhs,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlRelationshipsPage_0Test.java,100.3829414844513,length,"// HtmlRelationshipsPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that contains the overview entity relationship diagrams.
 *
 * @author John Currier
 */
public class HtmlRelationshipsPage extends HtmlDiagramFormatter {

    private static final HtmlRelationshipsPage instance = new HtmlRelationshipsPage();

    private static final boolean fineEnabled = Logger.getLogger(HtmlRelationshipsPage.class.getName()).isLoggable(Level.FINE);

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlRelationshipsPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlRelationshipsPage getInstance() {
        return instance;
    }

    public boolean write(Database db, File diagramDir, String dotBaseFilespec, boolean hasRealRelationships, boolean hasImpliedRelationships, Set<TableColumn> excludedColumns, LineWriter html) {
        try {
            Dot dot = getDot();
            if (dot == null) {
                writeHeader(db, null, ""All Relationships"", html);
                html.writeln(""<div class='content'>"");
                writeInvalidGraphvizInstallation(html);
                html.writeln(""</div>"");
                writeFooter(html);
                return false;
            }
            File compactRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + "".real.compact.dot"");
            File compactRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + "".real.compact."" + dot.getFormat());
            File largeRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + "".real.large.dot"");
            File largeRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + "".real.large."" + dot.getFormat());
            File compactImpliedDotFile = new File(diagramDir, dotBaseFilespec + "".implied.compact.dot"");
            File compactImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + "".implied.compact."" + dot.getFormat());
            File largeImpliedDotFile = new File(diagramDir, dotBaseFilespec + "".implied.large.dot"");
            File largeImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + "".implied.large."" + dot.getFormat());
            writeHeader(db, ""All Relationships"", hasRealRelationships, hasImpliedRelationships, html);
            html.writeln(""<table width=\""100%\""><tr><td class=\""container\"">"");
            if (hasRealRelationships) {
                if (!fineEnabled)
                    System.out.print(""."");
                html.writeln(dot.generateDiagram(compactRelationshipsDotFile, compactRelationshipsDiagramFile));
                html.writeln(""  <a name='diagram'><img id='realCompactImg' src='diagrams/summary/"" + compactRelationshipsDiagramFile.getName() + ""' usemap='#compactRelationshipsDiagram' class='diagram' border='0' alt=''></a>"");
                // we've run into instances where the first diagrams get generated, but then
                // dot fails on the second one...try to recover from that scenario 'somewhat'
                // gracefully
                try {
                    if (!fineEnabled)
                        System.out.print(""."");
                    html.writeln(dot.generateDiagram(largeRelationshipsDotFile, largeRelationshipsDiagramFile));
                    html.writeln(""  <a name='diagram'><img id='realLargeImg' src='diagrams/summary/"" + largeRelationshipsDiagramFile.getName() + ""' usemap='#largeRelationshipsDiagram' class='diagram' border='0' alt=''></a>"");
                } catch (Dot.DotFailure dotFailure) {
                    System.err.println(""dot failed to generate all of the relationships diagrams:"");
                    System.err.println(dotFailure);
                    System.err.println(""...but the relationships page may still be usable."");
                }
            }
            try {
                if (hasImpliedRelationships) {
                    if (!fineEnabled)
                        System.out.print(""."");
                    html.writeln(dot.generateDiagram(compactImpliedDotFile, compactImpliedDiagramFile));
                    html.writeln(""  <a name='diagram'><img id='impliedCompactImg' src='diagrams/summary/"" + compactImpliedDiagramFile.getName() + ""' usemap='#compactImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>"");
                    if (!fineEnabled)
                        System.out.print(""."");
                    html.writeln(dot.generateDiagram(largeImpliedDotFile, largeImpliedDiagramFile));
                    html.writeln(""  <a name='diagram'><img id='impliedLargeImg' src='diagrams/summary/"" + largeImpliedDiagramFile.getName() + ""' usemap='#largeImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>"");
                }
            } catch (Dot.DotFailure dotFailure) {
                System.err.println(""dot failed to generate all of the relationships diagrams:"");
                System.err.println(dotFailure);
                System.err.println(""...but the relationships page may still be usable."");
            }
            if (!fineEnabled)
                System.out.print(""."");
            html.writeln(""</td></tr></table>"");
            writeExcludedColumns(excludedColumns, null, html);
            writeFooter(html);
            return true;
        } catch (Dot.DotFailure dotFailure) {
            System.err.println(dotFailure);
            return false;
        } catch (IOException ioExc) {
            ioExc.printStackTrace();
            return false;
        }
    }

    private void writeHeader(Database db, String title, boolean hasRealRelationships, boolean hasImpliedRelationships, LineWriter html) throws IOException {
        writeHeader(db, null, title, html);
        html.writeln(""<table class='container' width='100%'>"");
        html.writeln(""<tr><td class='container'>"");
        writeGeneratedOn(db.getConnectTime(), html);
        html.writeln(""</td>"");
        html.writeln(""<td class='container' align='right' valign='top' rowspan='2'>"");
        writeLegend(false, html);
        html.writeln(""</td></tr>"");
        if (!hasRealRelationships) {
            html.writeln(""<tr><td class='container' align='left' valign='top'>"");
            if (hasImpliedRelationships) {
                html.writeln(""No 'real' Foreign Key relationships were detected in the schema.<br>"");
                html.writeln(""Displayed relationships are implied by a column's name/type/size matching another table's primary key.<p>"");
            } else
                html.writeln(""No relationships were detected in the schema."");
            html.writeln(""</td></tr>"");
        }
        html.writeln(""<tr><td class='container' align='left' valign='top'>"");
        html.writeln(""<form name='options' action=''>"");
        if (hasImpliedRelationships) {
            html.write(""  <span "");
            // if no real relationships then hide the 'implied' checkbox and make it 'checked'
            if (!hasRealRelationships)
                html.write(""style=\""display:none\"" "");
            html.writeln(""title=\""Show relationships implied by column name/type/size matching another table's primary key\"">"");
            html.write(""    <label for='implied'><input type='checkbox' id='implied'"" + (hasRealRelationships ? """" : "" checked"") + '>');
            html.writeln(""Implied relationships</label>"");
            html.writeln(""  </span>"");
        }
        if (hasRealRelationships || hasImpliedRelationships) {
            html.writeln(""  <span title=\""By default only columns that are primary keys, foreign keys or indexes are shown\"">"");
            html.write(""    <label for='showNonKeys'><input type='checkbox' id='showNonKeys'>"");
            html.writeln(""All columns</label>"");
            html.writeln(""  </span>"");
        }
        html.writeln(""</form>"");
        html.writeln(""</td></tr></table>"");
    }

    @Override
    protected boolean isRelationshipsPage() {
        return true;
    }
}
","// HtmlRelationshipsPage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRelationshipsPage}.
* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.
*/
class HtmlRelationshipsPage_0Test {","// HtmlRelationshipsPage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRelationshipsPage}.
* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.
*/
class HtmlRelationshipsPage_0Test {

	/**
	* Test case for {@link HtmlRelationshipsPage#getInstance()} method.
	* Test data: {@link HtmlRelationshipsPage#getInstance()} method.
	* Expected result: {@link HtmlRelationshipsPage#getInstance()} method returns an instance of {@link HtmlRelationshipsPage}.
	*/
	@Test
	void testGetInstance() {
		HtmlRelationshipsPage result = HtmlRelationshipsPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method returns true.
	*/
	@Test
	void testWrite() {
		Database db = null;
		File diagramDir = null;
		String dotBaseFilespec = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		Set<TableColumn> excludedColumns = null;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.write(db, diagramDir, dotBaseFilespec, hasRealRelationships, hasImpliedRelationships, excludedColumns, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_0Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method returns true.
	*/
	@Test
	void testWriteHeader() {
		Database db = null;
		String title = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.writeHeader(db, title, hasRealRelationships, hasImpliedRelationships, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_0Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Test data: {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Expected result: {@link HtmlRelationshipsPage#isRelationshipsPage()} method returns true.
	*/
	@Test
	void testIsRelationshipsPage() {
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = instance.isRelationshipsPage();
		assertTrue(result);
	}
	
}

// HtmlRelationshipsPage_1Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRelationshipsPage}.
* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.
*/
class HtmlRelationshipsPage_1Test {
		
	/**
	* Test case for {@link HtmlRelationshipsPage#getInstance()} method.
	* Test data: {@link HtmlRelationshipsPage#getInstance()} method.
	* Expected result: {@link HtmlRelationshipsPage#getInstance()} method returns an instance of {@link HtmlRelationshipsPage}.
	*/
	@Test
	void testGetInstance() {
		HtmlRelationshipsPage result = HtmlRelationshipsPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method returns true.
	*/
	@Test
	void testWrite() {
		Database db = null;
		File diagramDir = null;
		String dotBaseFilespec = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		Set<TableColumn> excludedColumns = null;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.write(db, diagramDir, dotBaseFilespec, hasRealRelationships, hasImpliedRelationships, excludedColumns, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_1Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method returns true.
	*/
	@Test
	void testWriteHeader() {
		Database db = null;
		String title = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.writeHeader(db, title, hasRealRelationships, hasImpliedRelationships, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_1Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Test data: {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Expected result: {@link HtmlRelationshipsPage#isRelationshipsPage()} method returns true.
	*/
	@Test
	void testIsRelationshipsPage() {
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = instance.isRelationshipsPage();
		assertTrue(result);
	}
	
}

// HtmlRelationshipsPage_2Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRelationshipsPage}.
* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.
*/
class HtmlRelationshipsPage_2Test {
		
	/**
	* Test case for {@link HtmlRelationshipsPage#getInstance()} method.
	* Test data: {@link HtmlRelationshipsPage#getInstance()} method.
	* Expected result: {@link HtmlRelationshipsPage#getInstance()} method returns an instance of {@link HtmlRelationshipsPage}.
	*/
	@Test
	void testGetInstance() {
		HtmlRelationshipsPage result = HtmlRelationshipsPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method returns true.
	*/
	@Test
	void testWrite() {
		Database db = null;
		File diagramDir = null;
		String dotBaseFilespec = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		Set<TableColumn> excludedColumns = null;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.write(db, diagramDir, dotBaseFilespec, hasRealRelationships, hasImpliedRelationships, excludedColumns, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_2Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method returns true.
	*/
	@Test
	void testWriteHeader() {
		Database db = null;
		String title = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.writeHeader(db, title, hasRealRelationships, hasImpliedRelationships, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_2Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Test data: {@link HtmlRelationshipsPage#isRelationshipsPage()} method.
	* Expected result: {@link HtmlRelationshipsPage#isRelationshipsPage()} method returns true.
	*/
	@Test
	void testIsRelationshipsPage() {
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = instance.isRelationshipsPage();
		assertTrue(result);
	}
	
}

// HtmlRelationshipsPage_3Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRelationshipsPage}.
* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.
*/
class HtmlRelationshipsPage_3Test {
		
	/**
	* Test case for {@link HtmlRelationshipsPage#getInstance()} method.
	* Test data: {@link HtmlRelationshipsPage#getInstance()} method.
	* Expected result: {@link HtmlRelationshipsPage#getInstance()} method returns an instance of {@link HtmlRelationshipsPage}.
	*/
	@Test
	void testGetInstance() {
		HtmlRelationshipsPage result = HtmlRelationshipsPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method returns true.
	*/
	@Test
	void testWrite() {
		Database db = null;
		File diagramDir = null;
		String dotBaseFilespec = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		Set<TableColumn> excludedColumns = null;
		LineWriter html = null;
		HtmlRelationshipsPage instance = HtmlRelationshipsPage.getInstance();
		boolean result = false;
		try {
			result = instance.write(db, diagramDir, dotBaseFilespec, hasRealRelationships, hasImpliedRelationships, excludedColumns, html);
		} catch (IOException e) {
			Logger.getLogger(HtmlRelationshipsPage_3Test.class.getName()).log(Level.SEVERE, null, e);
		}
		assertTrue(result);
	}
	
	/**
	* Test case for {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Test data: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method.
	* Expected result: {@link HtmlRelationshipsPage#writeHeader(Database, String, boolean, boolean, LineWriter)} method returns true.
	*/
	@Test
	void testWriteHeader() {
		Database db = null;
		String title = null;
		boolean hasRealRelationships = false;
		boolean hasImpliedRelationships = false;
		LineWriter html = null;"
cmpl-6u9BzeOBD5WIk6Gu1HRfkYUV21YCA,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlRoutinesPage.java,85.91145277023315,length,"// HtmlRoutinesPage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Routine;
import net.sourceforge.schemaspy.model.RoutineParameter;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that lists all of the routines (stored procedures and functions)
 * in the schema.
 *
 * @author John Currier
 */
public class HtmlRoutinesPage extends HtmlFormatter {

    private static HtmlRoutinesPage instance = new HtmlRoutinesPage();

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlRoutinesPage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlRoutinesPage getInstance() {
        return instance;
    }

    public void write(Database db, LineWriter html) throws IOException {
        Collection<Routine> routines = new TreeSet<Routine>(db.getRoutines());
        writeHeader(db, routines, html);
        for (Routine routine : routines) {
            write(routine, html);
        }
        writeFooter(html);
    }

    private void writeHeader(Database db, Collection<Routine> routines, LineWriter html) throws IOException {
        writeHeader(db, null, ""Procedures and Functions"", html);
        html.writeln(""<table width='100%'>"");
        html.writeln("" <tr>"");
        html.write(""  <td class='container'>"");
        writeGeneratedOn(db.getConnectTime(), html);
        html.writeln(""  </td>"");
        if (sourceForgeLogoEnabled())
            html.writeln(""  <td class='container' align='right' valign='top' colspan='2'><a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a></td>"");
        html.writeln("" </tr>"");
        html.writeln("" <tr>"");
        html.writeln(""  <td class='container'>"");
        int numProcs = 0;
        int numFuncs = 0;
        for (Routine routine : routines) {
            String type = routine.getType().toLowerCase();
            if (type.startsWith(""proc""))
                ++numProcs;
            else if (type.startsWith(""func""))
                ++numFuncs;
        }
        html.write(""   <br><b>"");
        html.write(db.getName());
        if (db.getSchema() != null) {
            html.write('.');
            html.write(db.getSchema());
        } else if (db.getCatalog() != null) {
            html.write('.');
            html.write(db.getCatalog());
        }
        html.write("" contains "" + numProcs + "" procedures and "" + numFuncs + "" functions:"");
        html.write(""</b><br><div class='indent'>"");
        for (Routine routine : routines) {
            html.write(""<a href='#"" + routine.getName() + ""'>"" + routine.getName() + ""</a>&nbsp;&nbsp;"");
        }
        html.writeln(""</div>"");
        html.writeln(""  </td>"");
        html.writeln("" </tr>"");
        html.writeln("" <tr><td colspan='3'>"");
    }

    private void write(Routine routine, LineWriter html) throws IOException {
        html.writeln(""  <br><a id='"" + routine.getName() + ""'></a><hr>"");
        html.write(""  <br><code><b>"" + routine.getType() + "" "" + routine.getName());
        html.write('(');
        List<RoutineParameter> params = routine.getParameters();
        Iterator<RoutineParameter> iter = params.iterator();
        while (iter.hasNext()) {
            RoutineParameter param = iter.next();
            if (param.getMode() != null) {
                html.write(param.getMode());
                html.write(' ');
            }
            if (param.getName() != null) {
                html.write(param.getName());
                html.write(' ');
            }
            if (param.getType() != null) {
                html.write(param.getType());
            }
            if (iter.hasNext())
                html.write("", "");
        }
        html.write("") "");
        if (routine.getReturnType() != null) {
            html.write(""RETURNS "");
            html.writeln(routine.getReturnType());
        }
        html.writeln(""</b><br>"");
        String indent = ""   &nbsp;&nbsp;&nbsp;"";
        if (routine.getDefinitionLanguage() != null && routine.getDefinitionLanguage().length() > 0)
            html.writeln(indent + ""LANGUAGE "" + routine.getDefinitionLanguage() + ""<br>"");
        if (routine.getType().toLowerCase().startsWith(""func"")) {
            // applies to return characteristics of functions only
            html.write(indent);
            if (!routine.isDeterministic())
                html.write(""NOT "");
            html.writeln(""DETERMINISTIC<br>"");
        }
        if (routine.getDataAccess() != null && routine.getDataAccess().length() > 0)
            html.writeln(indent + routine.getDataAccess() + ""<br>"");
        if (routine.getSecurityType() != null && routine.getSecurityType().length() > 0)
            html.writeln(indent + ""SQL SECURITY "" + routine.getSecurityType() + ""<br>"");
        if (routine.getComment() != null && routine.getComment().length() > 0)
            html.writeln(indent + ""COMMENT '"" + routine.getComment() + ""'<br>"");
        html.writeln(""</code><pre>"");
        html.writeln(routine.getDefinition());
        html.writeln(""</pre>"");
    }

    @Override
    protected void writeFooter(LineWriter html) throws IOException {
        html.writeln(""</td></tr></table>"");
        super.writeFooter(html);
    }

    @Override
    protected boolean isRoutinesPage() {
        return true;
    }
}
","// HtmlRoutinesPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Routine;
import net.sourceforge.schemaspy.model.RoutineParameter;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRoutinesPage}.
* It contains ten unit test cases for the {@link HtmlRoutinesPage#getInstance()} method.
*/
class HtmlRoutinesPageTest {","// HtmlRoutinesPageTest.java
package net.sourceforge.schemaspy.view;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.Routine;
import net.sourceforge.schemaspy.model.RoutineParameter;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlRoutinesPage}.
* It contains ten unit test cases for the {@link HtmlRoutinesPage#getInstance()} method.
*/
class HtmlRoutinesPageTest {

	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is null.
	*/
	@Test
	void testGetInstance_1() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_2() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_3() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_4() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_5() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_6() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_7() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_8() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_9() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#getInstance()} method.
	* It tests the case when the instance is not null.
	*/
	@Test
	void testGetInstance_10() {
		HtmlRoutinesPage result = HtmlRoutinesPage.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is null.
	*/
	@Test
	void testWrite_1() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = null;
		LineWriter html = null;
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the html is null.
	*/
	@Test
	void testWrite_2() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = null;
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_3() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_4() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_5() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_6() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_7() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_8() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_9() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Database, LineWriter)} method.
	* It tests the case when the db is not null and html is not null.
	*/
	@Test
	void testWrite_10() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		LineWriter html = new LineWriter();
		fixture.write(db, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is null.
	*/
	@Test
	void testWriteHeader_1() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = null;
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = null;
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the routines is null.
	*/
	@Test
	void testWriteHeader_2() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = null;
		LineWriter html = null;
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the html is null.
	*/
	@Test
	void testWriteHeader_3() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = null;
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_4() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_5() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_6() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_7() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_8() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_9() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#writeHeader(Database, Collection, LineWriter)} method.
	* It tests the case when the db is not null and routines is not null and html is not null.
	*/
	@Test
	void testWriteHeader_10() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Database db = new Database();
		Collection<Routine> routines = new TreeSet<Routine>();
		LineWriter html = new LineWriter();
		fixture.writeHeader(db, routines, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Routine, LineWriter)} method.
	* It tests the case when the routine is null.
	*/
	@Test
	void testWrite_11() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Routine routine = null;
		LineWriter html = null;
		fixture.write(routine, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Routine, LineWriter)} method.
	* It tests the case when the html is null.
	*/
	@Test
	void testWrite_12() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Routine routine = new Routine();
		LineWriter html = null;
		fixture.write(routine, html);
	}
	
	/**
	* Test case for {@link HtmlRoutinesPage#write(Routine, LineWriter)} method.
	* It tests the case when the routine is not null and html is not null.
	*/
	@Test
	void testWrite_13() throws IOException {
		HtmlRoutinesPage fixture = HtmlRoutinesPage.getInstance();
		Routine routine = new Routine();
		LineWriter html = new LineWriter();
		fixture.write(routine, html);
	}
	
	/**
	* Test case"
5066086f-528a-4c68-ae15-836037146448,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlTablePage_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10895 tokens (6895 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HtmlTablePage.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.model.View;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * The page that contains the details of a specific table or view
 *
 * @author John Currier
 */
public class HtmlTablePage extends HtmlFormatter {

    private static final HtmlTablePage instance = new HtmlTablePage();

    private int columnCounter = 0;

    private final Map<String, String> defaultValueAliases = new HashMap<String, String>();

    {
        // DB2
        defaultValueAliases.put(""CURRENT TIMESTAMP"", ""now"");
        // DB2
        defaultValueAliases.put(""CURRENT TIME"", ""now"");
        // DB2
        defaultValueAliases.put(""CURRENT DATE"", ""now"");
        // Oracle
        defaultValueAliases.put(""SYSDATE"", ""now"");
        // Oracle
        defaultValueAliases.put(""CURRENT_DATE"", ""now"");
    }

    /**
     * Singleton: Don't allow instantiation
     */
    private HtmlTablePage() {
    }

    /**
     * Singleton accessor
     *
     * @return the singleton instance
     */
    public static HtmlTablePage getInstance() {
        return instance;
    }

    public WriteStats write(Database db, Table table, File outputDir, WriteStats stats, LineWriter out) throws IOException {
        File diagramsDir = new File(outputDir, ""diagrams"");
        boolean hasImplied = generateDots(table, diagramsDir, stats);
        writeHeader(db, table, null, out);
        out.writeln(""<table width='100%' border='0'>"");
        out.writeln(""<tr valign='top'><td class='container' align='left' valign='top'>"");
        writeHeader(table, hasImplied, out);
        out.writeln(""</td><td class='container' rowspan='2' align='right' valign='top'>"");
        writeLegend(true, out);
        out.writeln(""</td><tr valign='top'><td class='container' align='left' valign='top'>"");
        writeMainTable(table, out);
        writeNumRows(db, table, out);
        out.writeln(""</td></tr></table>"");
        writeCheckConstraints(table, out);
        writeIndexes(table, out);
        writeView(table, db, out);
        writeDiagram(table, stats, diagramsDir, out);
        writeFooter(out);
        return stats;
    }

    private void writeHeader(Table table, boolean hasImplied, LineWriter html) throws IOException {
        html.writeln(""<form name='options' action=''>"");
        if (hasImplied) {
            html.write("" <label for='implied'><input type=checkbox id='implied'"");
            if (table.isOrphan(false))
                html.write("" checked"");
            html.writeln("">Implied relationships</label>"");
        }
        // initially show comments if any of the columns contain comments
        boolean showCommentsInitially = false;
        for (TableColumn column : table.getColumns()) {
            if (column.getComments() != null) {
                showCommentsInitially = true;
                break;
            }
        }
        html.writeln("" <label for='showRelatedCols'><input type=checkbox id='showRelatedCols'>Related columns</label>"");
        html.writeln("" <label for='showConstNames'><input type=checkbox id='showConstNames'>Constraints</label>"");
        html.writeln("" <label for='showComments'><input type=checkbox "" + (showCommentsInitially ? ""checked "" : """") + ""id='showComments'>Comments</label>"");
        html.writeln("" <label for='showLegend'><input type=checkbox checked id='showLegend'>Legend</label>"");
        html.writeln(""</form>"");
    }

    public void writeMainTable(Table table, LineWriter out) throws IOException {
        HtmlColumnsPage.getInstance().writeMainTableHeader(table.getId() != null, null, out);
        out.writeln(""<tbody valign='top'>"");
        Set<TableColumn> primaries = new HashSet<TableColumn>(table.getPrimaryColumns());
        Set<TableColumn> indexedColumns = new HashSet<TableColumn>();
        for (TableIndex index : table.getIndexes()) {
            indexedColumns.addAll(index.getColumns());
        }
        boolean showIds = table.getId() != null;
        for (TableColumn column : table.getColumns()) {
            writeColumn(column, null, primaries, indexedColumns, false, showIds, out);
        }
        out.writeln(""</tbody>"");
        out.writeln(""</table>"");
    }

    public void writeColumn(TableColumn column, String tableName, Set<TableColumn> primaries, Set<TableColumn> indexedColumns, boolean slim, boolean showIds, LineWriter out) throws IOException {
        boolean even = columnCounter++ % 2 == 0;
        if (even)
            out.writeln(""<tr class='even'>"");
        else
            out.writeln(""<tr class='odd'>"");
        if (showIds) {
            out.write("" <td class='detail' align='right'>"");
            out.write(String.valueOf(column.getId()));
            out.writeln(""</td>"");
        }
        if (tableName != null) {
            out.write("" <td class='detail'><a href='tables/"");
            out.write(urlEncode(tableName));
            out.write("".html'>"");
            out.write(tableName);
            out.writeln(""</a></td>"");
        }
        if (primaries.contains(column))
            out.write("" <td class='primaryKey' title='Primary Key'>"");
        else if (indexedColumns.contains(column))
            out.write("" <td class='indexedColumn' title='Indexed'>"");
        else
            out.write("" <td class='detail'>"");
        out.write(column.getName());
        out.writeln(""</td>"");
        out.write("" <td class='detail'>"");
        out.write(column.getType().toLowerCase());
        out.writeln(""</td>"");
        out.write("" <td class='detail' align='right'>"");
        out.write(column.getDetailedSize());
        out.writeln(""</td>"");
        out.write("" <td class='detail' align='center'"");
        if (column.isNullable())
            out.write("" title='nullable'>&nbsp;&radic;&nbsp;"");
        else
            out.write("">"");
        out.writeln(""</td>"");
        out.write("" <td class='detail' align='center'"");
        if (column.isAutoUpdated()) {
            out.write("" title='Automatically updated by the database'>&nbsp;&radic;&nbsp;"");
        } else {
            out.write("">"");
        }
        out.writeln(""</td>"");
        Object defaultValue = column.getDefaultValue();
        if (defaultValue != null || column.isNullable()) {
            Object alias = defaultValueAliases.get(String.valueOf(defaultValue).trim());
            if (alias != null) {
                out.write("" <td class='detail' align='right' title='"");
                out.write(String.valueOf(defaultValue));
                out.write(""'><i>"");
                out.write(alias.toString());
                out.writeln(""</i></td>"");
            } else {
                out.write("" <td class='detail' align='right'>"");
                out.write(String.valueOf(defaultValue));
                out.writeln(""</td>"");
            }
        } else {
            out.writeln("" <td class='detail'></td>"");
        }
        if (!slim) {
            out.write("" <td class='detail'>"");
            String path = tableName == null ? """" : ""tables/"";
            writeRelatives(column, false, path, even, out);
            out.writeln(""</td>"");
            out.write("" <td class='detail'>"");
            writeRelatives(column, true, path, even, out);
            out.writeln("" </td>"");
        }
        out.write("" <td class='comment detail'>"");
        String comments = column.getComments();
        if (comments != null) {
            if (encodeComments)
                for (int i = 0; i < comments.length(); ++i) out.write(HtmlEncoder.encodeToken(comments.charAt(i)));
            else
                out.write(comments);
        }
        out.writeln(""</td>"");
        out.writeln(""</tr>"");
    }

    /**
     * Write our relatives
     * @param tableName String
     * @param baseRelative TableColumn
     * @param dumpParents boolean
     * @param out LineWriter
     * @throws IOException
     */
    private void writeRelatives(TableColumn baseRelative, boolean dumpParents, String path, boolean even, LineWriter out) throws IOException {
        Set<TableColumn> columns = dumpParents ? baseRelative.getParents() : baseRelative.getChildren();
        final int numColumns = columns.size();
        final String evenOdd = (even ? ""even"" : ""odd"");
        if (numColumns > 0) {
            out.newLine();
            out.writeln(""  <table border='0' width='100%' cellspacing='0' cellpadding='0'>"");
        }
        for (TableColumn column : columns) {
            Table columnTable = column.getTable();
            String columnTableName = columnTable.getName();
            ForeignKeyConstraint constraint = dumpParents ? column.getChildConstraint(baseRelative) : column.getParentConstraint(baseRelative);
            if (constraint.isImplied())
                out.writeln(""   <tr class='impliedRelationship relative "" + evenOdd + ""' valign='top'>"");
            else
                out.writeln(""   <tr class='relative "" + evenOdd + ""' valign='top'>"");
            out.write(""    <td class='relatedTable detail' title=\"""");
            out.write(constraint.toString());
            out.write(""\"">"");
            if (columnTable.isRemote() && !Config.getInstance().isOneOfMultipleSchemas()) {
                out.write(columnTable.getContainer());
                out.write('.');
                out.write(columnTableName);
            } else {
                if (columnTable.isRemote()) {
                    out.write(""<a href='"");
                    out.write(path);
                    out.write(""../../"" + urlEncode(columnTable.getContainer()) + ""/index.html'>"");
                    out.write(columnTable.getContainer());
                    out.write(""</a>."");
                }
                out.write(""<a href='"");
                out.write(path);
                if (columnTable.isRemote()) {
                    out.write(""../../"" + urlEncode(columnTable.getContainer()) + ""/tables/"");
                }
                out.write(urlEncode(columnTableName));
                out.write("".html'>"");
                out.write(columnTableName);
                out.write(""</a>"");
            }
            out.write(""<span class='relatedKey'>."");
            out.write(column.getName());
            out.writeln(""</span>"");
            out.writeln(""    </td>"");
            out.write(""    <td class='constraint detail'>"");
            out.write(constraint.getName());
            String ruleText = constraint.getDeleteRuleDescription();
            if (ruleText.length() > 0) {
                String ruleAlias = constraint.getDeleteRuleAlias();
                out.write(""<span title='"" + ruleText + ""'>&nbsp;"" + ruleAlias + ""</span>"");
            }
            out.writeln(""</td>"");
            out.writeln(""   </tr>"");
        }
        if (numColumns > 0) {
            out.writeln(""  </table>"");
        }
    }

    private void writeNumRows(Database db, Table table, LineWriter out) throws IOException {
        out.write(""<p title='"" + table.getColumns().size() + "" columns'>"");
        if (displayNumRows && table.getNumRows() >= 0) {
            out.write(""Table contained "" + NumberFormat.getIntegerInstance().format(table.getNumRows()) + "" rows at "");
        } else {
            out.write(""Analyzed at "");
        }
        out.write(db.getConnectTime());
        out.writeln(""<p/>"");
    }

    private void writeCheckConstraints(Table table, LineWriter out) throws IOException {
        Map<String, String> constraints = table.getCheckConstraints();
        if (constraints != null && !constraints.isEmpty()) {
            out.writeln(""<div class='indent'>"");
            out.writeln(""<b>Requirements (check constraints):</b>"");
            out.writeln(""<table class='dataTable' border='1' rules='groups'><colgroup><colgroup>"");
            out.writeln(""<thead>"");
            out.writeln("" <tr>"");
            out.writeln(""  <th>Constraint</th>"");
            out.writeln(""  <th class='constraint' style='text-align:left;'>Constraint Name</th>"");
            out.writeln("" </tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            for (String name : constraints.keySet()) {
                out.writeln("" <tr>"");
                out.write(""  <td class='detail'>"");
                out.write(HtmlEncoder.encodeString(constraints.get(name).toString()));
                out.writeln(""</td>"");
                out.write(""  <td class='constraint' style='text-align:left;'>"");
                out.write(name);
                out.writeln(""</td>"");
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table></div><p>"");
        }
    }

    private void writeIndexes(Table table, LineWriter out) throws IOException {
        boolean showId = table.getId() != null;
        Set<TableIndex> indexes = table.getIndexes();
        if (indexes != null && !indexes.isEmpty()) {
            // see if we've got any strangeness so we can have the correct number of colgroups
            boolean containsAnomalies = false;
            for (TableIndex index : indexes) {
                containsAnomalies = index.isUniqueNullable();
                if (containsAnomalies)
                    break;
            }
            out.writeln(""<div class='indent'>"");
            out.writeln(""<b>Indexes:</b>"");
            out.writeln(""<table class='dataTable' border='1' rules='groups'><colgroup><colgroup><colgroup><colgroup>"" + (showId ? ""<colgroup>"" : """") + (containsAnomalies ? ""<colgroup>"" : """"));
            out.writeln(""<thead>"");
            out.writeln("" <tr>"");
            if (showId)
                out.writeln(""  <th>ID</th>"");
            out.writeln(""  <th>Column(s)</th>"");
            out.writeln(""  <th>Type</th>"");
            out.writeln(""  <th>Sort</th>"");
            out.writeln(""  <th class='constraint' style='text-align:left;'>Constraint Name</th>"");
            if (containsAnomalies)
                out.writeln(""  <th>Anomalies</th>"");
            out.writeln("" </tr>"");
            out.writeln(""</thead>"");
            out.writeln(""<tbody>"");
            // sort primary keys first
            indexes = new TreeSet<TableIndex>(indexes);
            for (TableIndex index : indexes) {
                out.writeln("" <tr>"");
                if (showId) {
                    out.write(""  <td class='detail' align='right'>"");
                    out.write(String.valueOf(index.getId()));
                    out.writeln(""</td>"");
                }
                if (index.isPrimaryKey())
                    out.write(""  <td class='primaryKey'>"");
                else
                    out.write(""  <td class='indexedColumn'>"");
                String columns = index.getColumnsAsString();
                if (columns.startsWith(""+""))
                    columns = columns.substring(1);
                out.write(columns);
                out.writeln(""</td>"");
                out.write(""  <td class='detail'>"");
                out.write(index.getType());
                out.writeln(""</td>"");
                out.write(""  <td class='detail' style='text-align:left;'>"");
                Iterator<TableColumn> columnsIter = index.getColumns().iterator();
                while (columnsIter.hasNext()) {
                    TableColumn column = columnsIter.next();
                    if (index.isAscending(column))
                        out.write(""<span title='Ascending'>Asc</span>"");
                    else
                        out.write(""<span title='Descending'>Desc</span>"");
                    if (columnsIter.hasNext())
                        out.write(""/"");
                }
                out.writeln(""</td>"");
                out.write(""  <td class='constraint' style='text-align:left;'>"");
                out.write(index.getName());
                out.writeln(""</td>"");
                if (index.isUniqueNullable()) {
                    if (index.getColumns().size() == 1)
                        out.writeln(""  <td class='detail'>This unique column is also nullable</td>"");
                    else
                        out.writeln(""  <td class='detail'>These unique columns are also nullable</td>"");
                } else if (containsAnomalies) {
                    out.writeln(""  <td>&nbsp;</td>"");
                }
                out.writeln("" </tr>"");
            }
            out.writeln(""</tbody>"");
            out.writeln(""</table>"");
            out.writeln(""</div>"");
        }
    }

    private void writeView(Table table, Database db, LineWriter out) throws IOException {
        String sql;
        if (table.isView() && (sql = table.getViewSql()) != null) {
            Map<String, Table> tables = new CaseInsensitiveMap<Table>();
            for (Table t : db.getTables()) tables.put(t.getName(), t);
            for (View v : db.getViews()) tables.put(v.getName(), v);
            Set<Table> references = new TreeSet<Table>();
            String formatted = Config.getInstance().getSqlFormatter().format(sql, db, references);
            out.writeln(""<div class='indent spacer'>"");
            out.writeln(""  View Definition:"");
            out.writeln(formatted);
            out.writeln(""</div>"");
            out.writeln(""<div class='spacer'>&nbsp;</div>"");
            if (!references.isEmpty()) {
                out.writeln(""<div class='indent'>"");
                out.writeln(""  Possibly Referenced Tables/Views:"");
                out.writeln(""  <div class='viewReferences'>"");
                out.write(""  "");
                for (Table t : references) {
                    out.write(""<a href='"");
                    out.write(urlEncode(t.getName()));
                    out.write("".html'>"");
                    out.write(t.getName());
                    out.write(""</a>&nbsp;"");
                }
                out.writeln(""  </div>"");
                out.writeln(""</div><p/>"");
            }
        }
    }

    /**
     * Generate the .dot file(s) to represent the specified table's relationships.
     *
     * Generates a <TABLENAME>.dot if the table has real relatives.
     *
     * Also generates a <TABLENAME>.implied2degrees.dot if the table has implied relatives within
     * two degrees of separation.
     *
     * @param table Table
     * @param diagramsDir File
     * @throws IOException
     * @return boolean <code>true</code> if the table has implied relatives within two
     *                 degrees of separation.
     */
    private boolean generateDots(Table table, File diagramDir, WriteStats stats) throws IOException {
        Dot dot = Dot.getInstance();
        String extension = dot == null ? ""png"" : dot.getFormat();
        File oneDegreeDotFile = new File(diagramDir, table.getName() + "".1degree.dot"");
        File oneDegreeDiagramFile = new File(diagramDir, table.getName() + "".1degree."" + extension);
        File twoDegreesDotFile = new File(diagramDir, table.getName() + "".2degrees.dot"");
        File twoDegreesDiagramFile = new File(diagramDir, table.getName() + "".2degrees."" + extension);
        File impliedDotFile = new File(diagramDir, table.getName() + "".implied2degrees.dot"");
        File impliedDiagramFile = new File(diagramDir, table.getName() + "".implied2degrees."" + extension);
        // delete before we start because we'll use the existence of these files to determine
        // if they should be turned into pngs & presented
        oneDegreeDotFile.delete();
        oneDegreeDiagramFile.delete();
        twoDegreesDotFile.delete();
        twoDegreesDiagramFile.delete();
        impliedDotFile.delete();
        impliedDiagramFile.delete();
        if (table.getMaxChildren() + table.getMaxParents() > 0) {
            Set<ForeignKeyConstraint> impliedConstraints;
            DotFormatter formatter = DotFormatter.getInstance();
            LineWriter dotOut = new LineWriter(oneDegreeDotFile, Config.DOT_CHARSET);
            WriteStats oneStats = new WriteStats(stats);
            formatter.writeRealRelationships(table, false, oneStats, dotOut);
            dotOut.close();
            dotOut = new LineWriter(twoDegreesDotFile, Config.DOT_CHARSET);
            WriteStats twoStats = new WriteStats(stats);
            impliedConstraints = formatter.writeRealRelationships(table, true, twoStats, dotOut);
            dotOut.close();
            if (oneStats.getNumTablesWritten() + oneStats.getNumViewsWritten() == twoStats.getNumTablesWritten() + twoStats.getNumViewsWritten()) {
                // no different than before, so don't show it
                twoDegreesDotFile.delete();
            }
            if (!impliedConstraints.isEmpty()) {
                dotOut = new LineWriter(impliedDotFile, Config.DOT_CHARSET);
                formatter.writeAllRelationships(table, true, stats, dotOut);
                dotOut.close();
                return true;
            }
        }
        return false;
    }

    private void writeDiagram(Table table, WriteStats stats, File diagramsDir, LineWriter html) throws IOException {
        if (table.getMaxChildren() + table.getMaxParents() > 0) {
            html.writeln(""<table width='100%' border='0'><tr><td class='container'>"");
            if (HtmlTableDiagrammer.getInstance().write(table, diagramsDir, html)) {
                html.writeln(""</td></tr></table>"");
                writeExcludedColumns(stats.getExcludedColumns(), table, html);
            } else {
                html.writeln(""</td></tr></table><p>"");
                writeInvalidGraphvizInstallation(html);
            }
        }
    }

    @Override
    protected String getPathToRoot() {
        return ""../"";
    }
}
","// HtmlTablePage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.model.View;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlTablePage}.
* It contains ten unit test cases for the {@link HtmlTablePage#getInstance()} method.
*/
class HtmlTablePage_0Test {","// HtmlTablePage_0Test.java
package net.sourceforge.schemaspy.view;

import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.Database;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.model.View;
import net.sourceforge.schemaspy.util.CaseInsensitiveMap;
import net.sourceforge.schemaspy.util.Dot;
import net.sourceforge.schemaspy.util.HtmlEncoder;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HtmlTablePage}.
* It contains ten unit test cases for the {@link HtmlTablePage#getInstance()} method.
*/
class HtmlTablePage_0Test {
"
cmpl-6u9ELPMTqTJUm1vxscwoflK444yth,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/StyleSheet.java,96.51479458808899,length,"// StyleSheet.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * Represents our CSS style sheet (CSS) with accessors for important
 * data from that style sheet.
 * The idea is that the CSS that will be used to render the HTML pages
 * also determines the colors used in the generated ER diagrams.
 *
 * @author John Currier
 */
public class StyleSheet {

    private static StyleSheet instance;

    private final String css;

    private String bodyBackgroundColor;

    private String tableHeadBackgroundColor;

    private String tableBackgroundColor;

    private String linkColor;

    private String linkVisitedColor;

    private String primaryKeyBackgroundColor;

    private String indexedColumnBackgroundColor;

    private String selectedTableBackgroundColor;

    private String excludedColumnBackgroundColor;

    private final List<String> ids = new ArrayList<String>();

    private StyleSheet(BufferedReader cssReader) throws IOException {
        String lineSeparator = System.getProperty(""line.separator"");
        StringBuilder data = new StringBuilder();
        String line;
        while ((line = cssReader.readLine()) != null) {
            data.append(line);
            data.append(lineSeparator);
        }
        css = data.toString();
        int startComment = data.indexOf(""/*"");
        while (startComment != -1) {
            int endComment = data.indexOf(""*/"");
            data.replace(startComment, endComment + 2, """");
            startComment = data.indexOf(""/*"");
        }
        StringTokenizer tokenizer = new StringTokenizer(data.toString(), ""{}"");
        String id = null;
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken().trim();
            if (id == null) {
                id = token.toLowerCase();
                ids.add(id);
            } else {
                Map<String, String> attribs = parseAttributes(token);
                if (id.equals("".content""))
                    bodyBackgroundColor = attribs.get(""background"");
                else if (id.equals(""th""))
                    tableHeadBackgroundColor = attribs.get(""background-color"");
                else if (id.equals(""td""))
                    tableBackgroundColor = attribs.get(""background-color"");
                else if (id.equals("".primarykey""))
                    primaryKeyBackgroundColor = attribs.get(""background"");
                else if (id.equals("".indexedcolumn""))
                    indexedColumnBackgroundColor = attribs.get(""background"");
                else if (id.equals("".selectedtable""))
                    selectedTableBackgroundColor = attribs.get(""background"");
                else if (id.equals("".excludedcolumn""))
                    excludedColumnBackgroundColor = attribs.get(""background"");
                else if (id.equals(""a:link""))
                    linkColor = attribs.get(""color"");
                else if (id.equals(""a:visited""))
                    linkVisitedColor = attribs.get(""color"");
                id = null;
            }
        }
    }

    /**
     * Singleton accessor
     *
     * @return the singleton
     * @throws ParseException
     */
    public static StyleSheet getInstance() throws ParseException {
        if (instance == null) {
            try {
                instance = new StyleSheet(new BufferedReader(getReader(Config.getInstance().getCss())));
            } catch (IOException exc) {
                throw new ParseException(exc);
            }
        }
        return instance;
    }

    /**
     * Returns a {@link Reader} that can be used to read the contents
     * of the specified css.<p>
     * Search order is
     * <ol>
     * <li><code>cssName</code> as an explicitly-defined file</li>
     * <li><code>cssName</code> as a file in the user's home directory</li>
     * <li><code>cssName</code> as a resource from the class path</li>
     * </ol>
     *
     * @param cssName
     * @return
     * @throws IOException
     */
    private static Reader getReader(String cssName) throws IOException {
        File cssFile = new File(cssName);
        if (cssFile.exists())
            return new FileReader(cssFile);
        cssFile = new File(System.getProperty(""user.dir""), cssName);
        if (cssFile.exists())
            return new FileReader(cssFile);
        InputStream cssStream = StyleSheet.class.getClassLoader().getResourceAsStream(cssName);
        if (cssStream == null)
            throw new ParseException(""Unable to find requested style sheet: "" + cssName);
        return new InputStreamReader(cssStream);
    }

    private Map<String, String> parseAttributes(String data) {
        Map<String, String> attribs = new HashMap<String, String>();
        try {
            StringTokenizer attrTokenizer = new StringTokenizer(data, "";"");
            while (attrTokenizer.hasMoreTokens()) {
                StringTokenizer pairTokenizer = new StringTokenizer(attrTokenizer.nextToken(), "":"");
                String attribute = pairTokenizer.nextToken().trim().toLowerCase();
                String value = pairTokenizer.nextToken().trim().toLowerCase();
                attribs.put(attribute, value);
            }
        } catch (NoSuchElementException badToken) {
            System.err.println(""Failed to extract attributes from '"" + data + ""'"");
            throw badToken;
        }
        return attribs;
    }

    /**
     * Write the contents of the original css to <code>out</code>.
     *
     * @param out
     * @throws IOException
     */
    public void write(LineWriter out) throws IOException {
        out.write(css);
    }

    public String getBodyBackground() {
        if (bodyBackgroundColor == null)
            throw new MissingCssPropertyException("".content"", ""background"");
        return bodyBackgroundColor;
    }

    public String getTableBackground() {
        if (tableBackgroundColor == null)
            throw new MissingCssPropertyException(""td"", ""background-color"");
        return tableBackgroundColor;
    }

    public String getTableHeadBackground() {
        if (tableHeadBackgroundColor == null)
            throw new MissingCssPropertyException(""th"", ""background-color"");
        return tableHeadBackgroundColor;
    }

    public String getPrimaryKeyBackground() {
        if (primaryKeyBackgroundColor == null)
            throw new MissingCssPropertyException("".primaryKey"", ""background"");
        return primaryKeyBackgroundColor;
    }

    public String getIndexedColumnBackground() {
        if (indexedColumnBackgroundColor == null)
            throw new MissingCssPropertyException("".indexedColumn"", ""background"");
        return indexedColumnBackgroundColor;
    }

    public String getSelectedTableBackground() {
        if (selectedTableBackgroundColor == null)
            throw new MissingCssPropertyException("".selectedTable"", ""background"");
        return selectedTableBackgroundColor;
    }

    public String getExcludedColumnBackgroundColor() {
        if (excludedColumnBackgroundColor == null)
            throw new MissingCssPropertyException("".excludedColumn"", ""background"");
        return excludedColumnBackgroundColor;
    }

    public String getLinkColor() {
        if (linkColor == null)
            throw new MissingCssPropertyException(""a:link"", ""color"");
        return linkColor;
    }

    public String getLinkVisitedColor() {
        if (linkVisitedColor == null)
            throw new MissingCssPropertyException(""a:visited"", ""color"");
        return linkVisitedColor;
    }

    /**
     * Indicates that a css property was missing
     */
    public static class MissingCssPropertyException extends InvalidConfigurationException {

        private static final long serialVersionUID = 1L;

        /**
         * @param cssSection name of the css section
         * @param propName name of the missing property in that section
         */
        public MissingCssPropertyException(String cssSection, String propName) {
            super(""Required property '"" + propName + ""' was not found for the definition of '"" + cssSection + ""' in "" + Config.getInstance().getCss());
        }
    }

    /**
     * Indicates an exception in parsing the css
     */
    public static class ParseException extends InvalidConfigurationException {

        private static final long serialVersionUID = 1L;

        /**
         * @param cause root exception that caused the failure
         */
        public ParseException(Exception cause) {
            super(cause);
        }

        /**
         * @param msg textual description of the failure
         */
        public ParseException(String msg) {
            super(msg);
        }
    }
}
","// StyleSheetTest.java
package net.sourceforge.schemaspy.view;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StyleSheet}.
* It contains ten unit test cases for the {@link StyleSheet#getInstance()} method.
*/
class StyleSheetTest {","// StyleSheetTest.java
package net.sourceforge.schemaspy.view;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.LineWriter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StyleSheet}.
* It contains ten unit test cases for the {@link StyleSheet#getInstance()} method.
*/
class StyleSheetTest {

	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is not found.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssNotFound() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""notFound.css"");
		assertThrows(ParseException.class, () -> {
			StyleSheet.getInstance();
		});
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the current directory.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInCurrentDirectory() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the user's home directory.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInUserHomeDirectory() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_2() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_3() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_4() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_5() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_6() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_7() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_8() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_9() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
	
	/**
	 * Test case for {@link StyleSheet#getInstance()} method.
	 * It tests the case when the css file is found in the class path.
	 * @throws ParseException
	 */
	@Test
	void testGetInstance_cssFoundInClassPath_10() throws ParseException {
		Config config = Config.getInstance();
		config.setCss(""test.css"");
		StyleSheet.getInstance();
	}
}

// StyleSheet.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import net.sourceforge.schemaspy.Config;
import net.sourceforge.schemaspy.model.InvalidConfigurationException;
import net.sourceforge.schemaspy.util.LineWriter;

/**
 * Represents our CSS style sheet (CSS) with accessors for important
 * data from that style sheet.
 * The idea is that the CSS that will be used to render the HTML pages
 * also determines the colors used in the generated ER diagrams.
 *
 * @author John Currier
 */
public class StyleSheet {

    private static StyleSheet instance;

    private final String css;

    private String bodyBackgroundColor;

    private String tableHeadBackgroundColor;

    private String tableBackgroundColor;

    private String linkColor;

    private String linkVisitedColor;

    private String primaryKeyBackgroundColor;

    private String indexedColumnBackgroundColor;

    private String selectedTableBackgroundColor;

    private String excludedColumnBackgroundColor;

    private final List<String> ids = new ArrayList<String>();

    private StyleSheet(BufferedReader cssReader) throws IOException {
        String lineSeparator = System.getProperty(""line.separator"");
        StringBuilder data = new StringBuilder();
        String line;
        while ((line = cssReader.readLine()) != null) {
            data.append(line);
            data.append(lineSeparator);
        }
        css = data.toString();
        int startComment = data.indexOf(""/*"");
        while (startComment != -1) {
            int endComment = data.indexOf(""*/"");
            data.replace(startComment, endComment + 2, """");
            startComment = data.indexOf(""/*"");
        }
        StringTokenizer tokenizer = new StringTokenizer(data.toString(), ""{}"");
        String id = null;
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken().trim();
            if (id == null) {
                id = token.toLowerCase();
                ids.add(id);
            } else {
                Map<String, String> attribs = parseAttributes(token);
                if (id.equals("".content""))
                    bodyBackgroundColor = attribs.get(""background"");
                else if (id.equals(""th""))
                    tableHeadBackgroundColor = attribs.get(""background-color"");
                else if (id.equals(""td""))
                    tableBackgroundColor = attribs.get(""background-color"");
                else if (id.equals("".primarykey""))
                    primaryKeyBackgroundColor = attribs.get(""background"");
                else if (id.equals("".indexedcolumn""))
                    indexedColumnBackgroundColor = attribs.get(""background"");
                else if (id.equals("".selectedtable""))
                    selectedTableBackgroundColor = attribs.get(""background"");
                else if (id.equals("".excludedcolumn""))
                    excludedColumnBackgroundColor = attribs.get(""background"");
                else if (id.equals(""a:link""))
                    linkColor = attribs.get(""color"");
                else if (id.equals(""a:visited""))
                    linkVisitedColor = attribs.get(""color"");
                id = null;
            }
        }
    }

    /**
     * Singleton accessor
     *
     * @return the singleton
     * @throws ParseException
     */
    public static StyleSheet getInstance() throws ParseException {
        if (instance == null) {
            try {
                instance = new StyleSheet(new BufferedReader(getReader(Config.getInstance().getCss())));
            } catch (IOException exc) {
                throw new ParseException(exc);
            }
        }
        return instance;
    }

    /**
     * Returns a {@link Reader} that can be used to read the contents
     * of the specified css.<p>
     * Search order is
     * <ol>
     * <li><code>cssName</code> as an explicitly-defined file</li>
     * <li><code>cssName</code> as a file in the user's home directory</li>
     * <li><code>cssName</code> as a resource from the class path</li>
     * </ol>
     *
     * @param cssName
     * @return
     * @throws IOException
     */
    private static Reader getReader(String cssName) throws IOException {
        File cssFile = new File(cssName);
        if (cssFile.exists())
            return new FileReader(cssFile);
        cssFile = new File(System.getProperty(""user.dir""), cssName);
        if (cssFile.exists())
            return new FileReader(cssFile);
        InputStream cssStream = StyleSheet.class.getClassLoader().getResourceAsStream(cssName);
        if (cssStream == null)
            throw new ParseException(""Unable to find requested style sheet: "" + cssName);
        return new InputStreamReader(cssStream);
    }

    private Map<String, String> parseAttributes(String data) {
        Map<String, String> attribs = new HashMap<String, String>();
        try {
            StringTokenizer attrTokenizer = new StringTokenizer(data, "";"");
            while (attrTokenizer.hasMoreTokens()) {
                StringTokenizer pairTokenizer = new StringTokenizer(attrTokenizer.nextToken(), "":"");
                String attribute = pairTokenizer.nextToken().trim().toLowerCase();
                String value = pairTokenizer.nextToken().trim().toLowerCase();
                attribs.put(attribute, value);
            }
        } catch (NoSuchElementException badToken) {
            System.err.println(""Failed to extract attributes from '"" + data + ""'"");
            throw badToken;
        }
        return attribs;
    }

    /**
     * Write the contents of the original css to <code>out</code>.
     *
     * @param out
     * @throws IOException
     */
    public void write(LineWriter out) throws IOException {
        out.write(css);
    }

    public String getBodyBackground() {
        if (bodyBackgroundColor == null)
            throw new MissingCssPropertyException("".content"", ""background"");
        return bodyBackgroundColor;
    }

    public String getTableBackground() {
        if (tableBackgroundColor == null)
            throw new MissingCssPropertyException(""td"", ""background-color"");
        return tableBackgroundColor;
    }

    public String getTableHeadBackground() {
        if (tableHeadBackgroundColor == null)
            throw new MissingCssPropertyException(""th"", ""background-color"");
        return tableHeadBackgroundColor;
    }

    public String getPrimaryKeyBackground() {
        if (primaryKeyBackgroundColor == null)
            throw new MissingCssPropertyException("".primaryKey"", ""background"");
        return primaryKeyBackgroundColor;
    }

    public String getIndexedColumnBackground() {
        if (indexedColumnBackgroundColor == null)
            throw new MissingCssPropertyException("".indexedColumn"", ""background"");
        return indexedColumnBackgroundColor;
    }

    public String getSelectedTableBackground() {
        if (selectedTableBackgroundColor == null)
            throw new MissingCssPropertyException("".selectedTable"", ""background"");
        return selectedTableBackgroundColor;
    }

    public String getExcludedColumnBackgroundColor() {
        if (excludedColumnBackgroundColor == null)
            throw new MissingCssPropertyException("".excludedColumn"", ""background"");
        return excludedColumnBackgroundColor;
    }

    public String getLinkColor() {
        if (linkColor == null)
            throw new MissingCssPropertyException(""a:link"", ""color"");
        return linkColor;
    }

    public String getLinkVisitedColor() {
        if (linkVisitedColor == null)
            throw new MissingCssPropertyException(""a:visited"", ""color"");
        return linkVisitedColor;
    }

    /**
     * Indicates that a css property was missing
     */
    public static class MissingCssPropertyException extends InvalidConfigurationException {

        private static final long serialVersionUID = 1L;

        /**
         * @param cssSection name of the css section
         * @param propName name of the missing property in that section
         */
        public MissingCssPropertyException(String cssSection, String propName) {
            super(""Required property '"" + propName + ""' was not found for the definition of '"" + cssSection + ""' in "" + Config.getInstance().getCss());
        }
    }

    /**
     * Indicates an exception in parsing the css
     */
    public static class Par"
cmpl-6u9FucteL3E1TmMCwhuCAQM7bk59Y,/EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/XmlTableFormatter.java,28.46770143508911,,"// XmlTableFormatter.java
/*
 * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier
 *
 * SchemaSpy is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * SchemaSpy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sourceforge.schemaspy.view;

import java.util.Collection;
import java.util.Comparator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.DOMUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

/**
 * Formats {@link Table}s into an XML DOM tree.
 *
 * @author John Currier
 */
public class XmlTableFormatter {

    private static final XmlTableFormatter instance = new XmlTableFormatter();

    // valid chars came from http://www.w3.org/TR/REC-xml/#charsets
    // and attempting to match 0x10000-0x10FFFF with the \p Unicode escapes
    // (from http://www.regular-expressions.info/unicode.html)
    private static final Pattern validXmlChars = Pattern.compile(""^[ -\uD7FF\uE000-\uFFFD\\p{L}\\p{M}\\p{Z}\\p{S}\\p{N}\\p{P}]*$"");

    /**
     * Singleton...don't allow instantiation
     */
    private XmlTableFormatter() {
    }

    /**
     * Singleton accessor
     *
     * @return
     */
    public static XmlTableFormatter getInstance() {
        return instance;
    }

    /**
     * Append the specified tables to the XML node
     *
     * @param schemaNode
     * @param tables
     */
    public void appendTables(Element schemaNode, Collection<Table> tables) {
        Set<Table> byName = new TreeSet<Table>(new Comparator<Table>() {

            public int compare(Table table1, Table table2) {
                return table1.getName().compareToIgnoreCase(table2.getName());
            }
        });
        byName.addAll(tables);
        Document document = schemaNode.getOwnerDocument();
        Element tablesNode = document.createElement(""tables"");
        schemaNode.appendChild(tablesNode);
        for (Table table : byName) appendTable(tablesNode, table);
    }

    /**
     * Append table details to the XML node
     *
     * @param tablesNode
     * @param table
     */
    private void appendTable(Element tablesNode, Table table) {
        Document document = tablesNode.getOwnerDocument();
        Element tableNode = document.createElement(""table"");
        tablesNode.appendChild(tableNode);
        if (table.getId() != null)
            DOMUtil.appendAttribute(tableNode, ""id"", String.valueOf(table.getId()));
        DOMUtil.appendAttribute(tableNode, ""catalog"", table.getCatalog());
        DOMUtil.appendAttribute(tableNode, ""schema"", table.getSchema());
        DOMUtil.appendAttribute(tableNode, ""name"", table.getName());
        if (table.getNumRows() >= 0)
            DOMUtil.appendAttribute(tableNode, ""numRows"", String.valueOf(table.getNumRows()));
        DOMUtil.appendAttribute(tableNode, ""type"", table.isView() ? ""VIEW"" : ""TABLE"");
        DOMUtil.appendAttribute(tableNode, ""remarks"", table.getComments() == null ? """" : table.getComments());
        appendColumns(tableNode, table);
        appendPrimaryKeys(tableNode, table);
        appendIndexes(tableNode, table);
        appendCheckConstraints(tableNode, table);
        appendView(tableNode, table);
    }

    /**
     * Append all columns in the table to the XML node
     *
     * @param tableNode
     * @param table
     */
    private void appendColumns(Element tableNode, Table table) {
        for (TableColumn column : table.getColumns()) {
            appendColumn(tableNode, column);
        }
    }

    /**
     * Append column details to the XML node
     *
     * @param tableNode
     * @param column
     * @return
     */
    private Node appendColumn(Node tableNode, TableColumn column) {
        Document document = tableNode.getOwnerDocument();
        Node columnNode = document.createElement(""column"");
        tableNode.appendChild(columnNode);
        DOMUtil.appendAttribute(columnNode, ""id"", String.valueOf(column.getId()));
        DOMUtil.appendAttribute(columnNode, ""name"", column.getName());
        DOMUtil.appendAttribute(columnNode, ""type"", column.getType());
        DOMUtil.appendAttribute(columnNode, ""size"", String.valueOf(column.getLength()));
        DOMUtil.appendAttribute(columnNode, ""digits"", String.valueOf(column.getDecimalDigits()));
        DOMUtil.appendAttribute(columnNode, ""nullable"", String.valueOf(column.isNullable()));
        DOMUtil.appendAttribute(columnNode, ""autoUpdated"", String.valueOf(column.isAutoUpdated()));
        if (column.getDefaultValue() != null) {
            String defaultValue = column.getDefaultValue().toString();
            if (isBinary(defaultValue)) {
                // we're run into a binary default value, convert it to its hex equivalent
                defaultValue = asBinary(defaultValue);
                // and indicate that it's been converted
                DOMUtil.appendAttribute(columnNode, ""defaultValueIsBinary"", ""true"");
            }
            DOMUtil.appendAttribute(columnNode, ""defaultValue"", defaultValue);
        }
        DOMUtil.appendAttribute(columnNode, ""remarks"", column.getComments() == null ? """" : column.getComments());
        for (TableColumn childColumn : column.getChildren()) {
            Node childNode = document.createElement(""child"");
            Table table = childColumn.getTable();
            columnNode.appendChild(childNode);
            ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);
            DOMUtil.appendAttribute(childNode, ""foreignKey"", constraint.getName());
            DOMUtil.appendAttribute(childNode, ""catalog"", table.getCatalog());
            DOMUtil.appendAttribute(childNode, ""schema"", table.getSchema());
            DOMUtil.appendAttribute(childNode, ""table"", table.getName());
            DOMUtil.appendAttribute(childNode, ""column"", childColumn.getName());
            DOMUtil.appendAttribute(childNode, ""implied"", String.valueOf(constraint.isImplied()));
            DOMUtil.appendAttribute(childNode, ""onDeleteCascade"", String.valueOf(constraint.isCascadeOnDelete()));
        }
        for (TableColumn parentColumn : column.getParents()) {
            Node parentNode = document.createElement(""parent"");
            Table table = parentColumn.getTable();
            columnNode.appendChild(parentNode);
            ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);
            DOMUtil.appendAttribute(parentNode, ""foreignKey"", constraint.getName());
            DOMUtil.appendAttribute(parentNode, ""catalog"", table.getCatalog());
            DOMUtil.appendAttribute(parentNode, ""schema"", table.getSchema());
            DOMUtil.appendAttribute(parentNode, ""table"", table.getName());
            DOMUtil.appendAttribute(parentNode, ""column"", parentColumn.getName());
            DOMUtil.appendAttribute(parentNode, ""implied"", String.valueOf(constraint.isImplied()));
            DOMUtil.appendAttribute(parentNode, ""onDeleteCascade"", String.valueOf(constraint.isCascadeOnDelete()));
        }
        return columnNode;
    }

    /**
     * Append primary key details to the XML node
     *
     * @param tableNode
     * @param table
     */
    private void appendPrimaryKeys(Element tableNode, Table table) {
        Document document = tableNode.getOwnerDocument();
        int index = 1;
        for (TableColumn primaryKeyColumn : table.getPrimaryColumns()) {
            Node primaryKeyNode = document.createElement(""primaryKey"");
            tableNode.appendChild(primaryKeyNode);
            DOMUtil.appendAttribute(primaryKeyNode, ""column"", primaryKeyColumn.getName());
            DOMUtil.appendAttribute(primaryKeyNode, ""sequenceNumberInPK"", String.valueOf(index++));
        }
    }

    /**
     * Append check constraint details to the XML node
     *
     * @param tableNode
     * @param table
     */
    private void appendCheckConstraints(Element tableNode, Table table) {
        Document document = tableNode.getOwnerDocument();
        Map<String, String> constraints = table.getCheckConstraints();
        if (constraints != null && !constraints.isEmpty()) {
            for (String name : constraints.keySet()) {
                Node constraintNode = document.createElement(""checkConstraint"");
                tableNode.appendChild(constraintNode);
                DOMUtil.appendAttribute(constraintNode, ""name"", name);
                DOMUtil.appendAttribute(constraintNode, ""constraint"", constraints.get(name).toString());
            }
        }
    }

    /**
     * Append index details to the XML node
     *
     * @param tableNode
     * @param table
     */
    private void appendIndexes(Node tableNode, Table table) {
        boolean showId = table.getId() != null;
        Set<TableIndex> indexes = table.getIndexes();
        if (indexes != null && !indexes.isEmpty()) {
            // sort primary keys first
            indexes = new TreeSet<TableIndex>(indexes);
            Document document = tableNode.getOwnerDocument();
            for (TableIndex index : indexes) {
                Node indexNode = document.createElement(""index"");
                if (showId)
                    DOMUtil.appendAttribute(indexNode, ""id"", String.valueOf(index.getId()));
                DOMUtil.appendAttribute(indexNode, ""name"", index.getName());
                DOMUtil.appendAttribute(indexNode, ""unique"", String.valueOf(index.isUnique()));
                for (TableColumn column : index.getColumns()) {
                    Node columnNode = document.createElement(""column"");
                    DOMUtil.appendAttribute(columnNode, ""name"", column.getName());
                    DOMUtil.appendAttribute(columnNode, ""ascending"", String.valueOf(index.isAscending(column)));
                    indexNode.appendChild(columnNode);
                }
                tableNode.appendChild(indexNode);
            }
        }
    }

    /**
     * Append view SQL to the XML node
     *
     * @param tableNode
     * @param table
     */
    private void appendView(Element tableNode, Table table) {
        String sql;
        if (table.isView() && (sql = table.getViewSql()) != null) {
            DOMUtil.appendAttribute(tableNode, ""viewSql"", sql);
        }
    }

    /**
     * Returns <code>true</code> if the string contains binary data
     * (chars that are invalid for XML) per http://www.w3.org/TR/REC-xml/#charsets
     *
     * @param str
     * @return
     */
    private static boolean isBinary(String str) {
        return !validXmlChars.matcher(str).matches();
    }

    /**
     * Turns a string into its hex equivalent.
     * Intended to be used when {@link #isBinary(String)} returns <code>true</code>.
     *
     * @param str
     * @return
     */
    private String asBinary(String str) {
        byte[] bytes = str.getBytes();
        StringBuilder buf = new StringBuilder(bytes.length * 2);
        for (int i = 0; i < bytes.length; ++i) {
            buf.append(String.format(""%02X"", bytes[i]));
        }
        return buf.toString();
    }
}
","// XmlTableFormatterTest.java
package net.sourceforge.schemaspy.view;

import java.util.Collection;
import java.util.Comparator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.DOMUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlTableFormatter}.
* It contains ten unit test cases for the {@link XmlTableFormatter#getInstance()} method.
*/
class XmlTableFormatterTest {","// XmlTableFormatterTest.java
package net.sourceforge.schemaspy.view;

import java.util.Collection;
import java.util.Comparator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;
import net.sourceforge.schemaspy.model.ForeignKeyConstraint;
import net.sourceforge.schemaspy.model.Table;
import net.sourceforge.schemaspy.model.TableColumn;
import net.sourceforge.schemaspy.model.TableIndex;
import net.sourceforge.schemaspy.util.DOMUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XmlTableFormatter}.
* It contains ten unit test cases for the {@link XmlTableFormatter#getInstance()} method.
*/
class XmlTableFormatterTest {

	/**
	 * Test case for {@link XmlTableFormatter#getInstance()}
	 * 
	 * @see XmlTableFormatter#getInstance()
	 */
	@Test
	void testGetInstance() {
		XmlTableFormatter result = XmlTableFormatter.getInstance();
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendTables(Element, Collection)}
	 * 
	 * @see XmlTableFormatter#appendTables(Element, Collection)
	 */
	@Test
	void testAppendTables() {
		Element schemaNode = null;
		Collection<Table> tables = null;
		XmlTableFormatter.getInstance().appendTables(schemaNode, tables);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendTable(Element, Table)}
	 * 
	 * @see XmlTableFormatter#appendTable(Element, Table)
	 */
	@Test
	void testAppendTable() {
		Element tablesNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendTable(tablesNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendColumns(Element, Table)}
	 * 
	 * @see XmlTableFormatter#appendColumns(Element, Table)
	 */
	@Test
	void testAppendColumns() {
		Element tableNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendColumns(tableNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendColumn(Node, TableColumn)}
	 * 
	 * @see XmlTableFormatter#appendColumn(Node, TableColumn)
	 */
	@Test
	void testAppendColumn() {
		Node tableNode = null;
		TableColumn column = null;
		Node result = XmlTableFormatter.getInstance().appendColumn(tableNode, column);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendPrimaryKeys(Element, Table)}
	 * 
	 * @see XmlTableFormatter#appendPrimaryKeys(Element, Table)
	 */
	@Test
	void testAppendPrimaryKeys() {
		Element tableNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendPrimaryKeys(tableNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendCheckConstraints(Element, Table)}
	 * 
	 * @see XmlTableFormatter#appendCheckConstraints(Element, Table)
	 */
	@Test
	void testAppendCheckConstraints() {
		Element tableNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendCheckConstraints(tableNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendIndexes(Node, Table)}
	 * 
	 * @see XmlTableFormatter#appendIndexes(Node, Table)
	 */
	@Test
	void testAppendIndexes() {
		Node tableNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendIndexes(tableNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#appendView(Element, Table)}
	 * 
	 * @see XmlTableFormatter#appendView(Element, Table)
	 */
	@Test
	void testAppendView() {
		Element tableNode = null;
		Table table = null;
		XmlTableFormatter.getInstance().appendView(tableNode, table);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#isBinary(String)}
	 * 
	 * @see XmlTableFormatter#isBinary(String)
	 */
	@Test
	void testIsBinary() {
		String str = """";
		boolean result = XmlTableFormatter.isBinary(str);
		assertFalse(result);
	}
	
	/**
	 * Test case for {@link XmlTableFormatter#asBinary(String)}
	 * 
	 * @see XmlTableFormatter#asBinary(String)
	 */
	@Test
	void testAsBinary() {
		String str = """";
		String result = XmlTableFormatter.getInstance().asBinary(str);
		assertNotNull(result);
	}
}"
