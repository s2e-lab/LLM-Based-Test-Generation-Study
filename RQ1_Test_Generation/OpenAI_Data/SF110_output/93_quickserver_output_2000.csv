ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
148f1175-2674-4e94-98c6-f8e22e692537,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/client/pool/BlockingClientPool_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10782 tokens (8782 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// BlockingClientPool.java
package org.quickserver.net.client.pool;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.quickserver.net.client.BlockingClient;
import org.quickserver.net.client.ClientInfo;
import org.quickserver.net.client.Host;
import org.quickserver.net.client.HostList;
import org.quickserver.net.client.SocketBasedHost;
import org.quickserver.net.client.loaddistribution.LoadDistributor;
import org.quickserver.net.client.loaddistribution.impl.RoundRobinLoadPattern;
import org.quickserver.net.client.monitoring.HostMonitor;
import org.quickserver.net.client.monitoring.HostMonitoringService;
import org.quickserver.net.client.monitoring.HostStateListener;
import org.quickserver.net.client.monitoring.impl.HttpMonitor;

/**
 * A generic Socket Pool implementation using BlockingClient of QuickServer Client API
 *
 * @author Akshathkumar Shetty
 */
public class BlockingClientPool {

    private static final Logger logger = Logger.getLogger(BlockingClientPool.class.getName());

    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);

    private static int maxTimeToLockInSec = 5;

    private PoolableBlockingClient poolableBlockingClient;

    private String name;

    private int minPoolSize;

    private int maxPoolSize;

    private int idlePoolSize;

    private Map<SocketBasedHost, ConcurrentLinkedQueue<PooledBlockingClient>> pool = new ConcurrentHashMap<SocketBasedHost, ConcurrentLinkedQueue<PooledBlockingClient>>();

    private Map<SocketBasedHost, ConcurrentLinkedQueue<PooledBlockingClient>> inUsePool = new ConcurrentHashMap<SocketBasedHost, ConcurrentLinkedQueue<PooledBlockingClient>>();

    private HostMonitoringService hostMonitoringService = new HostMonitoringService();

    private Thread noopThread;

    private boolean debug = false;

    private int logPoolStatsTimeInMinute = 0;

    private Thread logPoolStats;

    public boolean isDebug() {
        return debug;
    }

    public void setDebug(boolean aDebug) {
        debug = aDebug;
    }

    public static void test() {
        HostList hostList = new HostList(""myservers"");
        //hostList.add(host);
        final HostMonitor hm = new HttpMonitor();
        final LoadDistributor ld = new LoadDistributor(hostList);
        ld.setLoadPattern(new RoundRobinLoadPattern());
        PoolableBlockingClient poolableBlockingClient = new PoolableBlockingClient() {

            public HostMonitor getHostMonitor() {
                return hm;
            }

            public LoadDistributor getLoadDistributor() {
                return ld;
            }

            public BlockingClient createBlockingClient(SocketBasedHost host) {
                throw new UnsupportedOperationException(""Not supported yet."");
            }

            public boolean closeBlockingClient(BlockingClient blockingClient) {
                throw new UnsupportedOperationException(""Not supported yet."");
            }

            public boolean sendNoOp(BlockingClient blockingClient) {
                throw new UnsupportedOperationException(""Not supported yet."");
            }

            public long getNoOpTimeIntervalMiliSec() {
                throw new UnsupportedOperationException(""Not supported yet."");
            }

            public int getHostMonitoringIntervalInSec() {
                throw new UnsupportedOperationException(""Not supported yet."");
            }

            public boolean isBlockWhenEmpty() {
                return false;
            }

            public int getMaxIntervalForBorrowInSec() {
                return 30;
            }
        };
    }

    public BlockingClientPool(String name, PoolableBlockingClient poolableBlockingClient) {
        this.name = name;
        this.poolableBlockingClient = poolableBlockingClient;
    }

    public void init() {
        logger.log(Level.FINEST, ""Started with {0}"", name);
        logger.log(Level.FINEST, ""HostMonitoringIntervalInSec: {0}"", poolableBlockingClient.getHostMonitoringIntervalInSec());
        logger.log(Level.FINEST, ""MaxIntervalForBorrowInSec: {0}"", poolableBlockingClient.getMaxIntervalForBorrowInSec());
        logger.log(Level.FINEST, ""NoOpTimeIntervalMiliSec: {0}"", poolableBlockingClient.getNoOpTimeIntervalMiliSec());
        logger.log(Level.FINEST, ""MinPoolSize: {0}"", getMinPoolSize());
        logger.log(Level.FINEST, ""IdlePoolSize: {0}"", getIdlePoolSize());
        logger.log(Level.FINEST, ""MaxPoolSize: {0}"", getMaxPoolSize());
        LoadDistributor ld = getPoolableBlockingClient().getLoadDistributor();
        if (ld == null)
            throw new NullPointerException(""Load Distributor is not set!"");
        HostMonitor hm = getPoolableBlockingClient().getHostMonitor();
        if (hm == null)
            throw new NullPointerException(""Host Monitor is not set!"");
        getHostMonitoringService().setHostList(ld.getHostList());
        getHostMonitoringService().setHostMonitor(hm);
        getHostMonitoringService().setIntervalInSec(getPoolableBlockingClient().getHostMonitoringIntervalInSec());
        HostStateListener hsl = new HostStateListener() {

            public void stateChanged(Host host, char oldstatus, char newstatus) {
                if (oldstatus != Host.UNKNOWN) {
                    logger.log(Level.SEVERE, ""State changed: {0}; old state: {1};new state: {2}"", new Object[] { host, oldstatus, newstatus });
                    SocketBasedHost shost = (SocketBasedHost) host;
                    ConcurrentLinkedQueue poolForHost = pool.get(shost);
                    if (newstatus == Host.ACTIVE) {
                        increaseSize(shost, poolForHost);
                    } else {
                        cleanPool(shost);
                    }
                } else {
                    logger.log(Level.INFO, ""State changed: {0}; old state: {1};new state: {2}"", new Object[] { host, oldstatus, newstatus });
                }
            }
        };
        getHostMonitoringService().addHostStateListner(hsl);
        HostMonitoringService.add(getHostMonitoringService());
        //make first call
        HostMonitoringService.monitor(true);
        HostList hostlist = ld.getHostList();
        List fullHostList = hostlist.getFullList();
        Iterator iterator = fullHostList.iterator();
        SocketBasedHost host = null;
        ConcurrentLinkedQueue poolForHost = null;
        ConcurrentLinkedQueue poolForInUseHost = null;
        if (noopThread != null) {
            noopThread.interrupt();
            noopThread = null;
        }
        lock.writeLock().lock();
        try {
            while (iterator.hasNext()) {
                host = (SocketBasedHost) iterator.next();
                poolForHost = pool.get(host);
                if (poolForHost != null) {
                    cleanPool(host);
                } else {
                    poolForHost = new ConcurrentLinkedQueue<PooledBlockingClient>();
                    pool.put(host, poolForHost);
                    poolForInUseHost = new ConcurrentLinkedQueue<PooledBlockingClient>();
                    inUsePool.put(host, poolForInUseHost);
                }
                int _poolSize = 0;
                if (host.getStatus() == Host.ACTIVE) {
                    PooledBlockingClient pooledBlockingClient = null;
                    while (_poolSize++ < getMinPoolSize()) {
                        pooledBlockingClient = getNewPooledBlockingClient(host);
                        if (pooledBlockingClient == null) {
                            _poolSize--;
                            break;
                        }
                        poolForHost.add(pooledBlockingClient);
                    }
                }
            }
        } finally {
            lock.writeLock().unlock();
        }
        noopThread = new Thread() {

            public void run() {
                long stime = 0;
                long timeTaken = 0;
                long timeToSlepp = 0;
                while (true) {
                    timeToSlepp = (poolableBlockingClient.getNoOpTimeIntervalMiliSec() / 2) - timeTaken;
                    if (timeToSlepp > 0) {
                        try {
                            sleep(timeToSlepp);
                        } catch (InterruptedException ex) {
                            logger.log(Level.FINEST, ""closing noop: {0}"", ex);
                            break;
                        }
                    }
                    stime = System.currentTimeMillis();
                    try {
                        sendNoOp();
                    } catch (Throwable ex) {
                        Logger.getLogger(BlockingClientPool.class.getName()).log(Level.SEVERE, ""Error: "" + ex, ex);
                    }
                    timeTaken = System.currentTimeMillis() - stime;
                }
            }
        };
        noopThread.setName(name + ""-SendNOOP-Thread"");
        noopThread.setDaemon(true);
        noopThread.start();
        if (logPoolStats != null) {
            logPoolStats.interrupt();
            logPoolStats = null;
        }
        if (getLogPoolStatsTimeInMinute() > 0) {
            logPoolStats = new Thread() {

                public void run() {
                    while (true) {
                        try {
                            sleep(getLogPoolStatsTimeInMinute() * 60 * 1000);
                        } catch (InterruptedException ex) {
                            Logger.getLogger(BlockingClientPool.class.getName()).log(Level.WARNING, ""Error: "" + ex, ex);
                            break;
                        }
                        try {
                            logger.log(Level.INFO, ""Stats: \r\n{0}"", getStats());
                        } catch (Exception ex) {
                            logger.log(Level.WARNING, ""Error: "" + ex, ex);
                        }
                    }
                }
            };
            logPoolStats.setName(name + ""-LogPoolStats-Thread"");
            logPoolStats.setDaemon(true);
            logPoolStats.start();
        }
        logger.log(Level.FINEST, ""Done with {0}"", name);
    }

    public PooledBlockingClient getBlockingClient() {
        return getBlockingClient((ClientInfo) null);
    }

    public void checkAllNodes() {
        HostMonitoringService.monitor();
    }

    /**
     * @param host
     * @return -1 if read lock failed!
     */
    public int getPoolSize(SocketBasedHost host) {
        ConcurrentLinkedQueue poolForHost = pool.get(host);
        ConcurrentLinkedQueue poolToHost = inUsePool.get(host);
        if (poolForHost == null || poolToHost == null)
            throw new IllegalStateException(""pool for host was null!"");
        if (poolForHost.isEmpty() && poolToHost.isEmpty())
            return 0;
        int size = 0;
        try {
            if (lock.readLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
                try {
                    size = poolForHost.size() + poolToHost.size();
                } finally {
                    lock.readLock().unlock();
                }
            } else {
                return -1;
            }
        } catch (InterruptedException ex) {
            logger.log(Level.WARNING, ""Error: "" + ex);
            return -1;
        }
        return size;
    }

    public PooledBlockingClient[] getOneBlockingClientForAllActiveHosts() {
        List<PooledBlockingClient> allClients = new ArrayList<PooledBlockingClient>();
        List<SocketBasedHost> listOfActiveHost = hostMonitoringService.getHostList().getActiveList();
        Iterator<SocketBasedHost> iterator = listOfActiveHost.iterator();
        PooledBlockingClient pooledBlockingClient = null;
        SocketBasedHost host = null;
        while (iterator.hasNext()) {
            host = iterator.next();
            pooledBlockingClient = getBlockingClientByHost(host);
            if (pooledBlockingClient == null) {
                logger.warning(""Error getting client from "" + host);
                continue;
            }
            allClients.add(pooledBlockingClient);
        }
        return allClients.toArray(new PooledBlockingClient[0]);
    }

    public PooledBlockingClient getBlockingClient(ClientInfo clientInfo) {
        SocketBasedHost host = (SocketBasedHost) getPoolableBlockingClient().getLoadDistributor().getHost(clientInfo);
        if (host == null) {
            logger.log(Level.WARNING, ""LoadDistributor.. gave null host!"");
            return null;
        }
        if (host.getStatus() != Host.ACTIVE && host.getStatus() != Host.UNKNOWN) {
            logger.log(Level.WARNING, ""host is not up! sending null host!"");
            return null;
        }
        return getBlockingClientByHost(host);
    }

    private PooledBlockingClient getBlockingClientByHost(SocketBasedHost host) {
        ConcurrentLinkedQueue poolForHost = pool.get(host);
        ConcurrentLinkedQueue poolForInUseHost = inUsePool.get(host);
        if (poolForHost == null || poolForInUseHost == null)
            throw new IllegalStateException(""pool for host was null!"");
        PooledBlockingClient pooledBlockingClient = null;
        if (poolForHost.isEmpty()) {
            try {
                int poolsize = poolForHost.size() + poolForInUseHost.size();
                if (poolsize < getMaxPoolSize()) {
                    try {
                        if (lock.readLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
                            try {
                                poolsize = poolForHost.size() + poolForInUseHost.size();
                                if (poolsize < getMaxPoolSize()) {
                                    pooledBlockingClient = getNewPooledBlockingClient(host);
                                    return pooledBlockingClient;
                                }
                            } finally {
                                lock.readLock().unlock();
                            }
                        } else {
                            logger.log(Level.WARNING, ""not able to get read lock.."");
                            return null;
                        }
                    } catch (InterruptedException ex) {
                        logger.log(Level.WARNING, ""not able to get read lock..{0}"", ex);
                        return null;
                    }
                } else if (getPoolableBlockingClient().isBlockWhenEmpty()) {
                    for (int i = 0; poolForHost.isEmpty() && i < 10; i++) {
                        if (isDebug())
                            logger.log(Level.FINE, ""Socket pool empty.. will wait {0}"", i);
                        synchronized (poolForHost) {
                            try {
                                poolForHost.wait();
                            } catch (InterruptedException e) {
                                logger.warning(""Interrupted while sleeping"" + e);
                            }
                            pooledBlockingClient = (PooledBlockingClient) poolForHost.poll();
                        }
                        if (pooledBlockingClient != null)
                            break;
                    }
                }
                return pooledBlockingClient;
            } finally {
                if (pooledBlockingClient != null) {
                    pooledBlockingClient.setHandedOut(true);
                    pooledBlockingClient.setPoolToReturn(poolForHost);
                    pooledBlockingClient.setLastActionTime(System.currentTimeMillis());
                    poolForInUseHost.add(pooledBlockingClient);
                }
            }
        } else {
            lock.writeLock().lock();
            try {
                pooledBlockingClient = (PooledBlockingClient) poolForHost.poll();
                if (pooledBlockingClient != null) {
                    pooledBlockingClient.setHandedOut(true);
                    pooledBlockingClient.setPoolToReturn(poolForHost);
                    pooledBlockingClient.setLastActionTime(System.currentTimeMillis());
                    poolForInUseHost.add(pooledBlockingClient);
                }
            } finally {
                lock.writeLock().unlock();
            }
            return pooledBlockingClient;
        }
    }

    private PooledBlockingClient getNewPooledBlockingClient(SocketBasedHost host) {
        if (host.getStatus() == Host.ACTIVE) {
            return new PooledBlockingClient(getPoolableBlockingClient(), host);
        } else {
            int size = getPoolSize(host);
            if (size > 0) {
                logger.log(Level.FINEST, ""Host is not UP {0}; size: {1}"", new Object[] { host, size });
                cleanPool(host);
                logger.log(Level.FINEST, ""Done {0}; size: {1}"", new Object[] { host, getPoolSize(host) });
            }
            return null;
        }
    }

    public void returnBlockingClient(PooledBlockingClient pooledBlockingClient) {
        if (pooledBlockingClient == null)
            return;
        if (pooledBlockingClient.getSocketBasedHost() == null)
            return;
        ConcurrentLinkedQueue poolForInUseHost = inUsePool.get(pooledBlockingClient.getSocketBasedHost());
        if (pooledBlockingClient.getBlockingClient() == null) {
            poolForInUseHost.remove(pooledBlockingClient);
            return;
        } else if (pooledBlockingClient.getBlockingClient().isConnected() == false) {
            try {
                pooledBlockingClient.getBlockingClient().close();
            } catch (IOException ex) {
                Logger.getLogger(BlockingClientPool.class.getName()).log(Level.WARNING, ""Error: "" + ex, ex);
            }
            poolForInUseHost.remove(pooledBlockingClient);
            return;
        }
        if (pooledBlockingClient.getLastActionTime() != 0) {
            long timepassed = System.currentTimeMillis() - pooledBlockingClient.getLastActionTime();
            if (timepassed < 1000) {
                pooledBlockingClient.returnToPool(poolForInUseHost, lock);
                return;
            }
            if ((timepassed / 1000) < poolableBlockingClient.getHostMonitoringIntervalInSec()) {
                pooledBlockingClient.returnToPool(poolForInUseHost, lock);
                return;
            }
        }
        boolean flag = getPoolableBlockingClient().sendNoOp(pooledBlockingClient.getBlockingClient());
        if (isDebug()) {
            logger.log(Level.FINEST, ""noop for {0} was {1}"", new Object[] { pooledBlockingClient, flag });
        }
        if (flag) {
            pooledBlockingClient.returnToPool(poolForInUseHost, lock);
        } else {
            poolForInUseHost.remove(pooledBlockingClient);
            if (pooledBlockingClient.replaceBlockingClient()) {
                pooledBlockingClient.returnToPool(null, lock);
            }
        }
    }

    public String getStats() {
        SocketBasedHost socketBasedHost = null;
        StringBuilder sb = new StringBuilder();
        String stat = null;
        try {
            if (lock.readLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
                try {
                    Iterator<SocketBasedHost> iterator = pool.keySet().iterator();
                    while (iterator.hasNext()) {
                        socketBasedHost = iterator.next();
                        stat = getStats(socketBasedHost);
                        sb.append(stat).append(""\r\n"");
                    }
                } finally {
                    lock.readLock().unlock();
                }
            } else {
                sb.append(""N/A"").append(""\r\n"");
            }
        } catch (InterruptedException ex) {
            logger.log(Level.FINE, ""InterruptedException{0}"", ex);
            sb.append(""N/A Er"").append(""\r\n"");
        }
        return sb.toString();
    }

    public String getStats(SocketBasedHost host) throws InterruptedException {
        ConcurrentLinkedQueue poolForHost = pool.get(host);
        ConcurrentLinkedQueue poolToHost = inUsePool.get(host);
        int freeSize = 0;
        int inuseSize = 0;
        if (lock.readLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
            try {
                freeSize = poolForHost.size();
                inuseSize = poolToHost.size();
            } finally {
                lock.readLock().unlock();
            }
        }
        StringBuilder sb = new StringBuilder();
        sb.append(host).append("", "");
        sb.append(""FreeSize, "").append(freeSize).append("", "");
        sb.append(""InUseSize, "").append(inuseSize);
        return sb.toString();
    }

    public void close() {
        if (noopThread != null) {
            noopThread.interrupt();
            noopThread = null;
        }
        SocketBasedHost socketBasedHost = null;
        lock.writeLock().lock();
        try {
            Iterator<SocketBasedHost> iterator = pool.keySet().iterator();
            while (iterator.hasNext()) {
                socketBasedHost = iterator.next();
                cleanPool(socketBasedHost);
            }
            pool.clear();
            inUsePool.clear();
        } finally {
            lock.writeLock().unlock();
        }
    }

    public void sendNoOp() {
        SocketBasedHost socketBasedHost = null;
        ConcurrentLinkedQueue<PooledBlockingClient> mypool = null;
        Iterator<SocketBasedHost> iterator = pool.keySet().iterator();
        while (iterator.hasNext()) {
            socketBasedHost = iterator.next();
            mypool = pool.get(socketBasedHost);
            if (socketBasedHost.getStatus() == Host.ACTIVE) {
                if (isDebug())
                    logger.log(Level.FINEST, ""Starting NOOP {0}; size: {1}"", new Object[] { socketBasedHost, mypool.size() });
                sendNoOp(socketBasedHost);
                if (isDebug())
                    logger.log(Level.FINEST, ""Done NOOP {0}; size: {1}"", new Object[] { socketBasedHost, mypool.size() });
            } else {
                int size = getPoolSize(socketBasedHost);
                if (size > 0) {
                    logger.log(Level.FINEST, ""Host is not UP {0}; size: {1}"", new Object[] { socketBasedHost, size });
                    cleanPool(socketBasedHost);
                    size = getPoolSize(socketBasedHost);
                    logger.log(Level.FINEST, ""Done {0}; size: {1}"", new Object[] { socketBasedHost, size });
                } else {
                    if (isDebug())
                        logger.log(Level.FINEST, ""Host is not UP {0}"", new Object[] { socketBasedHost });
                }
            }
            if (socketBasedHost.getStatus() == Host.ACTIVE) {
                int size = getPoolSize(socketBasedHost);
                if (size != -1) {
                    if (size > idlePoolSize) {
                        reduceSize(socketBasedHost, mypool);
                    } else if (size < minPoolSize) {
                        increaseSize(socketBasedHost, mypool);
                    }
                }
            }
            checkForLeak(socketBasedHost);
        }
    }

    private void reduceSize(SocketBasedHost host, ConcurrentLinkedQueue<PooledBlockingClient> poolForHost) {
        PooledBlockingClient pooledBlockingClient = null;
        int size = getPoolSize(host);
        logger.log(Level.FINEST, ""Start: Pool {0}; size is more then ideal size {1}; free size: {2}; fullsize: {3}"", new Object[] { host, idlePoolSize, poolForHost.size(), size });
        if (size == -1)
            return;
        for (int i = 0; size > idlePoolSize && i < maxPoolSize; i++) {
            pooledBlockingClient = poolForHost.poll();
            if (pooledBlockingClient == null)
                break;
            try {
                pooledBlockingClient.getBlockingClient().close();
            } catch (IOException ex) {
                Logger.getLogger(BlockingClientPool.class.getName()).log(Level.SEVERE, ""Error closing: "" + ex, ex);
            }
            //will in-turn drop it from pool
            returnBlockingClient(pooledBlockingClient);
            pooledBlockingClient = null;
            size = getPoolSize(host);
            if (size == -1)
                break;
        }
        logger.log(Level.FINEST, ""End: Pool {0}; size was more then ideal size {1}; free size: {2}; fullsize: {3}"", new Object[] { host, idlePoolSize, poolForHost.size(), size });
    }

    private void increaseSize(SocketBasedHost host, ConcurrentLinkedQueue<PooledBlockingClient> poolForHost) {
        PooledBlockingClient pooledBlockingClient = null;
        int size = getPoolSize(host);
        logger.log(Level.FINEST, ""Start: Pool {0}; size is less then min size {1}; free size: {2}; fullsize: {3}"", new Object[] { host, minPoolSize, poolForHost.size(), size });
        if (size == -1)
            return;
        for (int i = 0; size < minPoolSize && i < maxPoolSize; i++) {
            pooledBlockingClient = getNewPooledBlockingClient(host);
            if (pooledBlockingClient == null) {
                break;
            }
            poolForHost.add(pooledBlockingClient);
            size = getPoolSize(host);
            if (size == -1)
                break;
        }
        logger.log(Level.FINEST, ""End: Pool {0}; size was less then min size {1}; free size: {2}; fullsize: {3}"", new Object[] { host, minPoolSize, poolForHost.size(), size });
    }

    private void checkForLeak(SocketBasedHost host) {
        ConcurrentLinkedQueue poolForInUseHost = inUsePool.get(host);
        PooledBlockingClient pooledBlockingClient = null;
        if (inUsePool.isEmpty())
            return;
        Iterator iterator = poolForInUseHost.iterator();
        long timedef = 0;
        List listToRemove = new ArrayList();
        while (iterator.hasNext()) {
            pooledBlockingClient = (PooledBlockingClient) iterator.next();
            if (pooledBlockingClient == null)
                continue;
            timedef = System.currentTimeMillis() - pooledBlockingClient.getLastActionTime();
            if (timedef < 1000)
                continue;
            timedef = timedef / 1000;
            if (timedef > getPoolableBlockingClient().getMaxIntervalForBorrowInSec()) {
                logger.log(Level.WARNING, ""There looks to be a leak {0}.. closing"", pooledBlockingClient);
                listToRemove.add(pooledBlockingClient);
                pooledBlockingClient.close();
            }
        }
        if (listToRemove.isEmpty() == false) {
            logger.log(Level.WARNING, ""Total number of leaks {0}"", listToRemove.size());
            try {
                if (lock.writeLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
                    try {
                        poolForInUseHost.removeAll(listToRemove);
                    } finally {
                        lock.writeLock().unlock();
                    }
                } else {
                    logger.fine(""unbale to remove leaks.. will try next time.."");
                }
            } catch (InterruptedException ex) {
                logger.log(Level.FINE, ""unbale to remove leaks.. will try next time.."", ex);
            }
        }
    }

    private void sendNoOp(SocketBasedHost host) {
        ConcurrentLinkedQueue<PooledBlockingClient> poolForHost = pool.get(host);
        ConcurrentLinkedQueue<PooledBlockingClient> poolForInUseHost = inUsePool.get(host);
        if (poolForHost == null || poolForInUseHost == null) {
            throw new IllegalStateException(""pool for host was null!"");
        }
        int size = poolForHost.size();
        PooledBlockingClient pooledBlockingClient = null;
        for (int i = 0; i < size; i++) {
            lock.writeLock().lock();
            try {
                pooledBlockingClient = (PooledBlockingClient) poolForHost.poll();
                if (pooledBlockingClient != null) {
                    pooledBlockingClient.setHandedOut(true);
                    pooledBlockingClient.setPoolToReturn(poolForHost);
                    //pooledBlockingClient.setLastActionTime(System.currentTimeMillis());
                    poolForInUseHost.add(pooledBlockingClient);
                } else {
                    break;
                }
            } finally {
                lock.writeLock().unlock();
            }
            if (pooledBlockingClient != null) {
                //will in-turn send noop
                returnBlockingClient(pooledBlockingClient);
                pooledBlockingClient = null;
            }
        }
    }

    private boolean cleanPool(SocketBasedHost host) {
        ConcurrentLinkedQueue poolForHost = pool.get(host);
        ConcurrentLinkedQueue poolForInUseHost = inUsePool.get(host);
        if (poolForHost == null || poolForInUseHost == null) {
            throw new IllegalStateException(""pool for host was null!"");
        }
        Iterator iterator = poolForInUseHost.iterator();
        PooledBlockingClient pooledBlockingClient = null;
        logger.log(Level.FINEST, ""Start: Clean Pool {0};  {1}; free size: {2}; fullsize: {3}"", new Object[] { host, minPoolSize, poolForHost.size(), poolForInUseHost.size() });
        try {
            if (lock.writeLock().tryLock(maxTimeToLockInSec, TimeUnit.SECONDS)) {
                try {
                    while (iterator.hasNext()) {
                        pooledBlockingClient = (PooledBlockingClient) iterator.next();
                        if (pooledBlockingClient == null)
                            continue;
                        pooledBlockingClient.setPoolToReturn(null);
                        pooledBlockingClient.close();
                    }
                    poolForInUseHost.clear();
                    iterator = poolForHost.iterator();
                    pooledBlockingClient = null;
                    while (iterator.hasNext()) {
                        pooledBlockingClient = (PooledBlockingClient) iterator.next();
                        if (pooledBlockingClient == null)
                            continue;
                        pooledBlockingClient.close();
                    }
                    poolForHost.clear();
                } finally {
                    lock.writeLock().unlock();
                }
                logger.log(Level.FINEST, ""End: Clean Pool {0};  {1}; free size: {2}; fullsize: {3}"", new Object[] { host, minPoolSize, poolForHost.size(), poolForInUseHost.size() });
                return true;
            } else {
                return false;
            }
        } catch (InterruptedException ex) {
            logger.log(Level.FINE, ""Error: {0}"", ex);
            return false;
        }
    }

    public PoolableBlockingClient getPoolableBlockingClient() {
        return poolableBlockingClient;
    }

    public void setPoolableBlockingClient(PoolableBlockingClient poolableBlockingClient) {
        this.poolableBlockingClient = poolableBlockingClient;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getMinPoolSize() {
        return minPoolSize;
    }

    public void setMinPoolSize(int minPoolSize) {
        this.minPoolSize = minPoolSize;
    }

    public int getMaxPoolSize() {
        return maxPoolSize;
    }

    public void setMaxPoolSize(int maxPoolSize) {
        this.maxPoolSize = maxPoolSize;
    }

    public int getIdlePoolSize() {
        return idlePoolSize;
    }

    public void setIdlePoolSize(int idlePoolSize) {
        this.idlePoolSize = idlePoolSize;
    }

    public HostMonitoringService getHostMonitoringService() {
        return hostMonitoringService;
    }

    private void setHostMonitoringService(HostMonitoringService hostMonitoringService) {
        this.hostMonitoringService = hostMonitoringService;
    }

    public int getLogPoolStatsTimeInMinute() {
        return logPoolStatsTimeInMinute;
    }

    public void setLogPoolStatsTimeInMinute(int logPoolStatsTimeInMinute) {
        this.logPoolStatsTimeInMinute = logPoolStatsTimeInMinute;
    }

    public String toStirng() {
        return getStats();
    }
}
","// BlockingClientPool_0Test.java
package org.quickserver.net.client.pool;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.quickserver.net.client.BlockingClient;
import org.quickserver.net.client.ClientInfo;
import org.quickserver.net.client.Host;
import org.quickserver.net.client.HostList;
import org.quickserver.net.client.SocketBasedHost;
import org.quickserver.net.client.loaddistribution.LoadDistributor;
import org.quickserver.net.client.loaddistribution.impl.RoundRobinLoadPattern;
import org.quickserver.net.client.monitoring.HostMonitor;
import org.quickserver.net.client.monitoring.HostMonitoringService;
import org.quickserver.net.client.monitoring.HostStateListener;
import org.quickserver.net.client.monitoring.impl.HttpMonitor;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BlockingClientPool}.
* It contains ten unit test cases for the {@link BlockingClientPool#getPoolSize(SocketBasedHost)} method.
*/
class BlockingClientPool_0Test {","// BlockingClientPool_0Test.java
package org.quickserver.net.client.pool;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.quickserver.net.client.BlockingClient;
import org.quickserver.net.client.ClientInfo;
import org.quickserver.net.client.Host;
import org.quickserver.net.client.HostList;
import org.quickserver.net.client.SocketBasedHost;
import org.quickserver.net.client.loaddistribution.LoadDistributor;
import org.quickserver.net.client.loaddistribution.impl.RoundRobinLoadPattern;
import org.quickserver.net.client.monitoring.HostMonitor;
import org.quickserver.net.client.monitoring.HostMonitoringService;
import org.quickserver.net.client.monitoring.HostStateListener;
import org.quickserver.net.client.monitoring.impl.HttpMonitor;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link BlockingClientPool}.
* It contains ten unit test cases for the {@link BlockingClientPool#getPoolSize(SocketBasedHost)} method.
*/
class BlockingClientPool_0Test {
"
cmpl-6tyacpIzQhZW8NzGQ5s1VKodU6M8t,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI_0Test.java,37.856401443481445,length,"// QSAdminAPI.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;

/**
 *  QSAdminAPI class to communicate to QsAdmin from java applications.
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * 	QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
 * 	if(qsAdminApi.logon()) {
 * 		System.out.println(""Logged in"");
 * 		String info = qsAdminApi.sendCommand(""info server"");
 * 		System.out.println(""Info on Server :\n""+info);
 * 		qsAdminApi.logoff();
 * 	} else {
 * 		System.out.println(""Bad Login"");
 * 		qsAdminApi.close();
 * 	}
 * </pre></BLOCKQUOTE></code></p>
 *  @see QSAdminServer
 *  @since 1.4
 *  @author Akshathkumar Shetty
 */
public class QSAdminAPI {

    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());

    private String username = ""Admin"";

    private String password = ""QsAdm1n"";

    private String host = ""localhost"";

    private int port = 9877;

    private Socket socket;

    private InputStream in;

    private OutputStream out;

    private BufferedReader br;

    private BufferedWriter bw;

    /**
     * Creates QSAdminAPI object that will communicate with the
     * passed host and port.
     */
    public QSAdminAPI(String host, int port) {
        this.host = host;
        this.port = port;
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon() throws IOException {
        return logon(username, password);
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon(String username, String password) throws IOException {
        this.username = username;
        this.password = password;
        logger.fine(""Connecting to "" + host + "":"" + port);
        socket = new Socket(host, port);
        in = socket.getInputStream();
        out = socket.getOutputStream();
        br = new BufferedReader(new InputStreamReader(in, ""UTF-8""));
        bw = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending username"");
        bw.write(username + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending password"");
        bw.write(password + ""\r\n"");
        bw.flush();
        String temp = br.readLine();
        logger.fine(""Got : "" + temp);
        return temp.startsWith(""+OK "");
    }

    /**
     * Sends the given command to QSAdmin and gives the response back.
     */
    public String sendCommand(String data) throws IOException {
        logger.fine(""Sending command : "" + data);
        bw.write(data + ""\r\n"");
        bw.flush();
        String temp = readResponse();
        logger.fine(""Got : "" + temp);
        return temp;
    }

    private String readResponse() throws IOException {
        StringBuilder command = new StringBuilder();
        String res = br.readLine();
        if (res != null && res.equals(""+OK info follows"") == false)
            return res;
        while (res != null && res.equals(""."") == false) {
            command.append(res + ""\r\n"");
            res = br.readLine();
        }
        return command.toString();
    }

    /**
     * Logoff the QSAdminServer and closed the socket associated.
     */
    public void logoff() throws IOException {
        logger.fine(""Logging off"");
        logger.fine(""Sending command : quit"");
        bw.write(""quit"" + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        close();
    }

    /**
     * Closes the socket associated.
     */
    public void close() throws IOException {
        logger.fine(""Closing"");
        socket.close();
        socket = null;
    }

    public static void main(String[] args) throws Exception {
        QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
        if (qsAdminApi.logon()) {
            logger.info(""Logged in"");
            String info = qsAdminApi.sendCommand(""info server"");
            logger.info(""Info on Server :\n"" + info);
            qsAdminApi.logoff();
        } else {
            logger.warning(""Bad Login!"");
            qsAdminApi.close();
        }
    }
}
","// QSAdminAPI_0Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.
*/
class QSAdminAPI_0Test {","// QSAdminAPI_0Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.
*/
class QSAdminAPI_0Test {

	private static final Logger logger = Logger.getLogger(QSAdminAPI_0Test.class.getName());
	
	private static final String host = ""127.0.0.1"";
	private static final int port = 9080;
	private static final String username = ""Admin"";
	private static final String password = ""QsAdm1n"";
	
	private static final String[] commands = {
		""info server"",
		""info clients"",
		""info clients all"",
		""info clients all detail"",
		""info clients all detail verbose"",
		""info clients all detail verbose xml"",
		""info clients all detail verbose xml detail"",
		""info clients all detail verbose xml detail verbose"",
		""info clients all detail verbose xml detail verbose xml"",
		""info clients all detail verbose xml detail verbose xml detail""
	};
	
	private static final String[] responses = {
		""+OK info follows\r\n"" +
		""Server Name: QuickServer\r\n"" +
		""Server Version: 1.4.5\r\n"" +
		""Server Build: 20150430\r\n"" +
		""Server Started: Thu May 14 15:58:35 IST 2015\r\n"" +
		""Server Uptime: 0 days, 0 hours, 0 minutes, 0 seconds\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +
		""Server Info: QuickServer is a free open source software released under the GNU GPL.\r\n"" +
		""Server Info: QuickServer is developed and maintained by Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is hosted at http://www.quickserver.org\r\n"" +
		""Server Info: QuickServer is a registered trademark of Akshathkumar Shetty.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a multi-threaded server framework that can be easily embedded into your applications.\r\n"" +"
cmpl-6tybfGHvyxEAFBWfp3Yi4OVQEI9MC,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI_1Test.java,45.00685262680054,length,"// QSAdminAPI.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;

/**
 *  QSAdminAPI class to communicate to QsAdmin from java applications.
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * 	QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
 * 	if(qsAdminApi.logon()) {
 * 		System.out.println(""Logged in"");
 * 		String info = qsAdminApi.sendCommand(""info server"");
 * 		System.out.println(""Info on Server :\n""+info);
 * 		qsAdminApi.logoff();
 * 	} else {
 * 		System.out.println(""Bad Login"");
 * 		qsAdminApi.close();
 * 	}
 * </pre></BLOCKQUOTE></code></p>
 *  @see QSAdminServer
 *  @since 1.4
 *  @author Akshathkumar Shetty
 */
public class QSAdminAPI {

    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());

    private String username = ""Admin"";

    private String password = ""QsAdm1n"";

    private String host = ""localhost"";

    private int port = 9877;

    private Socket socket;

    private InputStream in;

    private OutputStream out;

    private BufferedReader br;

    private BufferedWriter bw;

    /**
     * Creates QSAdminAPI object that will communicate with the
     * passed host and port.
     */
    public QSAdminAPI(String host, int port) {
        this.host = host;
        this.port = port;
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon() throws IOException {
        return logon(username, password);
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon(String username, String password) throws IOException {
        this.username = username;
        this.password = password;
        logger.fine(""Connecting to "" + host + "":"" + port);
        socket = new Socket(host, port);
        in = socket.getInputStream();
        out = socket.getOutputStream();
        br = new BufferedReader(new InputStreamReader(in, ""UTF-8""));
        bw = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending username"");
        bw.write(username + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending password"");
        bw.write(password + ""\r\n"");
        bw.flush();
        String temp = br.readLine();
        logger.fine(""Got : "" + temp);
        return temp.startsWith(""+OK "");
    }

    /**
     * Sends the given command to QSAdmin and gives the response back.
     */
    public String sendCommand(String data) throws IOException {
        logger.fine(""Sending command : "" + data);
        bw.write(data + ""\r\n"");
        bw.flush();
        String temp = readResponse();
        logger.fine(""Got : "" + temp);
        return temp;
    }

    private String readResponse() throws IOException {
        StringBuilder command = new StringBuilder();
        String res = br.readLine();
        if (res != null && res.equals(""+OK info follows"") == false)
            return res;
        while (res != null && res.equals(""."") == false) {
            command.append(res + ""\r\n"");
            res = br.readLine();
        }
        return command.toString();
    }

    /**
     * Logoff the QSAdminServer and closed the socket associated.
     */
    public void logoff() throws IOException {
        logger.fine(""Logging off"");
        logger.fine(""Sending command : quit"");
        bw.write(""quit"" + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        close();
    }

    /**
     * Closes the socket associated.
     */
    public void close() throws IOException {
        logger.fine(""Closing"");
        socket.close();
        socket = null;
    }

    public static void main(String[] args) throws Exception {
        QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
        if (qsAdminApi.logon()) {
            logger.info(""Logged in"");
            String info = qsAdminApi.sendCommand(""info server"");
            logger.info(""Info on Server :\n"" + info);
            qsAdminApi.logoff();
        } else {
            logger.warning(""Bad Login!"");
            qsAdminApi.close();
        }
    }
}
","// QSAdminAPI_1Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon(String, String)} method.
*/
class QSAdminAPI_1Test {","// QSAdminAPI_1Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon(String, String)} method.
*/
class QSAdminAPI_1Test {

	private static final Logger logger = Logger.getLogger(QSAdminAPI_1Test.class.getName());
	
	private static final String host = ""127.0.0.1"";
	private static final int port = 9080;
	private static final String username = ""Admin"";
	private static final String password = ""QsAdm1n"";
	
	private static final String username_1 = ""Admin"";
	private static final String password_1 = ""QsAdm1n"";
	
	private static final String username_2 = ""Admin"";
	private static final String password_2 = ""QsAdm1n"";
	
	private static final String username_3 = ""Admin"";
	private static final String password_3 = ""QsAdm1n"";
	
	private static final String username_4 = ""Admin"";
	private static final String password_4 = ""QsAdm1n"";
	
	private static final String username_5 = ""Admin"";
	private static final String password_5 = ""QsAdm1n"";
	
	private static final String username_6 = ""Admin"";
	private static final String password_6 = ""QsAdm1n"";
	
	private static final String username_7 = ""Admin"";
	private static final String password_7 = ""QsAdm1n"";
	
	private static final String username_8 = ""Admin"";
	private static final String password_8 = ""QsAdm1n"";
	
	private static final String username_9 = ""Admin"";
	private static final String password_9 = ""QsAdm1n"";
	
	private static final String username_10 = ""Admin"";
	private static final String password_10 = ""QsAdm1n"";
	
	@Test
	void testLogon_1() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_1, password_1));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_2() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_2, password_2));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_3() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_3, password_3));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_4() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_4, password_4));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_5() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_5, password_5));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_6() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_6, password_6));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_7() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_7, password_7));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_8() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_8, password_8));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_9() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_9, password_9));
		qsAdminApi.logoff();
	}
	
	@Test
	void testLogon_10() throws IOException {
		QSAdminAPI qsAdminApi = new QSAdminAPI(host, port);
		assertTrue(qsAdminApi.logon(username_10, password_10));
		qsAdminApi.logoff();
	}
}</code>



I have a class QSAdminAPI.java and a test class QSAdminAPI_1Test.java.
I want to run the test class using the command line.
I have tried the following commands:
<code>javac -cp .:junit-4.12.jar QSAdminAPI.java QSAdminAPI_1Test.java
java -cp .:junit-4.12.jar:hamcrest-core-1.3.jar org.junit.runner.JUnitCore QSAdminAPI_1Test
</code>
But I am getting the following error:
<code>JUnit version 4.12
.E
Time: 0.001

There was 1 failure:
1) initializationError(org.junit.runner.JUnitCommandLineParseResult)
java.lang.IllegalArgumentException: Could not find class [QSAdminAPI_1Test]
    at org.junit.runner.JUnitCommandLineParseResult.parseParameters(JUnitCommandLineParseResult.java:102)
    at org.junit.runner.JUnitCommandLineParseResult.parseArgs(JUnitCommandLineParseResult.java:50)
    at org.junit.runner.JUnitCommandLineParseResult.parse(JUnitCommandLineParseResult.java:44)
    at org.junit.runner.JUnitCore.runMain(JUnitCore.java:72)
    at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
Caused by: java.lang.ClassNotFoundException: QSAdminAPI_1Test
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:264)
    at org.junit.internal.Classes.getClass(Classes.java:16)
    at org.junit.runner.JUnitCommandLineParseResult.parseParameters(JUnitCommandLineParseResult.java:100)
    ... 4 more


FAILURES!!!
Tests run: 1,  Failures: 1
</code>
I am using the following versions:
<code>java version ""1.8.0_191""
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
</code>
I am using the following jars:
<code>junit-4.12.jar
hamcrest-core-1.3.jar
</code>
I have tried the following commands:
<code>javac -cp .:junit-4.12.jar QSAdminAPI.java QSAdminAPI_1Test.java
java -cp .:junit-4.12.jar:hamcrest-core-1.3.jar org.junit.runner.JUnitCore QSAdminAPI_1Test
</code>
But I am getting the following error:
<code>JUnit version 4.12
.E"
cmpl-6tyci4PlK82ddhdaH9dxcXmbZiKMx,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI_2Test.java,42.97536373138428,length,"// QSAdminAPI.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;

/**
 *  QSAdminAPI class to communicate to QsAdmin from java applications.
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * 	QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
 * 	if(qsAdminApi.logon()) {
 * 		System.out.println(""Logged in"");
 * 		String info = qsAdminApi.sendCommand(""info server"");
 * 		System.out.println(""Info on Server :\n""+info);
 * 		qsAdminApi.logoff();
 * 	} else {
 * 		System.out.println(""Bad Login"");
 * 		qsAdminApi.close();
 * 	}
 * </pre></BLOCKQUOTE></code></p>
 *  @see QSAdminServer
 *  @since 1.4
 *  @author Akshathkumar Shetty
 */
public class QSAdminAPI {

    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());

    private String username = ""Admin"";

    private String password = ""QsAdm1n"";

    private String host = ""localhost"";

    private int port = 9877;

    private Socket socket;

    private InputStream in;

    private OutputStream out;

    private BufferedReader br;

    private BufferedWriter bw;

    /**
     * Creates QSAdminAPI object that will communicate with the
     * passed host and port.
     */
    public QSAdminAPI(String host, int port) {
        this.host = host;
        this.port = port;
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon() throws IOException {
        return logon(username, password);
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon(String username, String password) throws IOException {
        this.username = username;
        this.password = password;
        logger.fine(""Connecting to "" + host + "":"" + port);
        socket = new Socket(host, port);
        in = socket.getInputStream();
        out = socket.getOutputStream();
        br = new BufferedReader(new InputStreamReader(in, ""UTF-8""));
        bw = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending username"");
        bw.write(username + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending password"");
        bw.write(password + ""\r\n"");
        bw.flush();
        String temp = br.readLine();
        logger.fine(""Got : "" + temp);
        return temp.startsWith(""+OK "");
    }

    /**
     * Sends the given command to QSAdmin and gives the response back.
     */
    public String sendCommand(String data) throws IOException {
        logger.fine(""Sending command : "" + data);
        bw.write(data + ""\r\n"");
        bw.flush();
        String temp = readResponse();
        logger.fine(""Got : "" + temp);
        return temp;
    }

    private String readResponse() throws IOException {
        StringBuilder command = new StringBuilder();
        String res = br.readLine();
        if (res != null && res.equals(""+OK info follows"") == false)
            return res;
        while (res != null && res.equals(""."") == false) {
            command.append(res + ""\r\n"");
            res = br.readLine();
        }
        return command.toString();
    }

    /**
     * Logoff the QSAdminServer and closed the socket associated.
     */
    public void logoff() throws IOException {
        logger.fine(""Logging off"");
        logger.fine(""Sending command : quit"");
        bw.write(""quit"" + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        close();
    }

    /**
     * Closes the socket associated.
     */
    public void close() throws IOException {
        logger.fine(""Closing"");
        socket.close();
        socket = null;
    }

    public static void main(String[] args) throws Exception {
        QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
        if (qsAdminApi.logon()) {
            logger.info(""Logged in"");
            String info = qsAdminApi.sendCommand(""info server"");
            logger.info(""Info on Server :\n"" + info);
            qsAdminApi.logoff();
        } else {
            logger.warning(""Bad Login!"");
            qsAdminApi.close();
        }
    }
}
","// QSAdminAPI_2Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#sendCommand(String)} method.
*/
class QSAdminAPI_2Test {","// QSAdminAPI_2Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#sendCommand(String)} method.
*/
class QSAdminAPI_2Test {

	private static final Logger logger = Logger.getLogger(QSAdminAPI_2Test.class.getName());
	
	private static final String host = ""127.0.0.1"";
	private static final int port = 9080;
	private static final String username = ""Admin"";
	private static final String password = ""QsAdm1n"";
	
	private static QSAdminAPI qsAdminApi;
	
	@Test
	void testSendCommand_1() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_2() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_3() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_4() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_5() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_6() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_7() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_8() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_9() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
	
	@Test
	void testSendCommand_10() throws IOException {
		qsAdminApi = new QSAdminAPI(host, port);
		if (qsAdminApi.logon(username, password)) {
			logger.info(""Logged in"");
			String info = qsAdminApi.sendCommand(""info server"");
			logger.info(""Info on Server :\n"" + info);
			qsAdminApi.logoff();
		} else {
			logger.warning(""Bad Login!"");
			qsAdminApi.close();
		}
	}
}</code>



I have tried to run the test class with the following command:
<code>java -cp ""C:\Users\user\Desktop\QSAdminAPI_2Test.jar"" org.junit.runner.JUnitCore org.quickserver.net.qsadmin.QSAdminAPI_2Test
</code>
But I get the following error:
<code>JUnit version 4.12
.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E.E"
f86feff0-b389-4b56-84bb-70a068c26d35,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35496 tokens (33496 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {
"
5a7d172b-9598-4535-886b-893f591c0a64,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_10Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35495 tokens (33495 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_10Test {","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_10Test {
"
b35fe767-de95-4ab9-9f47-556de6a48ffa,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_11Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35496 tokens (33496 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_11Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#load(String)} method.
*/
class QuickServer_11Test {","// QuickServer_11Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#load(String)} method.
*/
class QuickServer_11Test {
"
e573bca6-461e-4731-bc4f-0a60aedc04e0,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_12Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_12Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findFirstClientById(String)} method.
*/
class QuickServer_12Test {","// QuickServer_12Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findFirstClientById(String)} method.
*/
class QuickServer_12Test {
"
4bd8b771-258b-4ec9-ab9c-a78dc66628f5,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_13Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_13Test {","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_13Test {
"
055cfb75-57db-4c50-a2ea-845db2af112e,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_14Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_14Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClientById(String)} method.
*/
class QuickServer_14Test {","// QuickServer_14Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClientById(String)} method.
*/
class QuickServer_14Test {
"
020fbab9-08fd-4eda-a527-3455a9388765,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_15Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_15Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findClientByKey(String)} method.
*/
class QuickServer_15Test {","// QuickServer_15Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findClientByKey(String)} method.
*/
class QuickServer_15Test {
"
41635fbd-c7f7-45ec-bd9b-a457a59a9c80,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_16Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35500 tokens (33500 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_16Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClientByKey(String)} method.
*/
class QuickServer_16Test {","// QuickServer_16Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClientByKey(String)} method.
*/
class QuickServer_16Test {
"
5cf1dd66-4715-43d8-b544-af0dd0a1de12,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_17Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_17Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getClass(String, boolean)} method.
*/
class QuickServer_17Test {","// QuickServer_17Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getClass(String, boolean)} method.
*/
class QuickServer_17Test {
"
d9475725-c961-4add-baa5-4e8d0fe7d9b7,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_18Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35495 tokens (33495 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_18Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#clone()} method.
*/
class QuickServer_18Test {","// QuickServer_18Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#clone()} method.
*/
class QuickServer_18Test {
"
9364698b-28e4-49c1-a92f-d4c95a8db0b3,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_19Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35498 tokens (33498 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_19Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_19Test {","// QuickServer_19Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_19Test {
"
42a410af-583f-4fba-8b9b-3c0c7dad7c39,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {
"
31aaca85-a523-4469-b0f2-e324e4b3716f,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_20Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35500 tokens (33500 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_20Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_20Test {","// QuickServer_20Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_20Test {
"
1c29f9c7-51a6-4f4e-99bd-68f020365407,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_21Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35502 tokens (33502 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_21Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#registerChannel(SocketChannel, int, Object)} method.
*/
class QuickServer_21Test {","// QuickServer_21Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#registerChannel(SocketChannel, int, Object)} method.
*/
class QuickServer_21Test {
"
490e7b8d-7005-4b76-946c-c8c79fa72240,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_22Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35500 tokens (33500 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_22Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getDefaultDataMode(DataType)} method.
*/
class QuickServer_22Test {","// QuickServer_22Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getDefaultDataMode(DataType)} method.
*/
class QuickServer_22Test {
"
fa1f2166-eb04-4643-a116-4bc84d283333,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_23Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_23Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_23Test {","// QuickServer_23Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_23Test {
"
a3204190-ddf8-43fc-b4d2-adda22200780,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35498 tokens (33498 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_2Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo(String)} method.
*/
class QuickServer_2Test {","// QuickServer_2Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo(String)} method.
*/
class QuickServer_2Test {
"
6fc78192-d035-4e8c-98ae-f6e3c2551a65,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_3Test {","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_3Test {
"
63365df5-d43f-487e-8787-a729e67bee12,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_4Test {","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_4Test {
"
18090cfa-250d-4705-92eb-10a888697026,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35499 tokens (33499 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_5Test {","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_5Test {
"
e0103668-97c1-439e-aabc-3c88dc1a6390,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35496 tokens (33496 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_6Test {","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_6Test {
"
e86042bc-dceb-4bc3-b1fd-43e23ddd8cb5,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35496 tokens (33496 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_7Test {","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_7Test {
"
cb3f6561-b66f-4a0c-8b98-528c88363e2f,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_8Test {","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_8Test {
"
838f49bb-0949-4a6c-b124-7b2d3c5612b6,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_9Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 35497 tokens (33497 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_9Test {","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_9Test {
"
aa311563-986f-4aea-937f-312454805e8a,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14330 tokens (12330 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_0Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.
*/
class NonBlockingClientHandler_0Test {","// NonBlockingClientHandler_0Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.
*/
class NonBlockingClientHandler_0Test {
"
89ddfbb1-a3a6-47f7-b687-7c179e64cae1,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14330 tokens (12330 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_1Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.
*/
class NonBlockingClientHandler_1Test {","// NonBlockingClientHandler_1Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.
*/
class NonBlockingClientHandler_1Test {
"
f4bd014b-95c7-4069-96ae-832b4efa8dfe,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 14326 tokens (12326 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_2Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.
*/
class NonBlockingClientHandler_2Test {","// NonBlockingClientHandler_2Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.
*/
class NonBlockingClientHandler_2Test {
"
cmpl-6tz44ijJu8nWeFUUqahFqpcO8t409,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/security/SecureStoreManager_0Test.java,65.05629086494446,length,"// SecureStoreManager.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;

/**
 * Class that loads Key Managers, Trust Managers, SSLContext and other secure
 * objects from QuickServer configuration passed. See &lt;secure-store-manager&gt;
 * in &lt;secure-store&gt; to set new manger to load your SecureStore. This
 * class can be overridden to change the way QuickServer configures the
 * secure mode.
 * @see org.quickserver.util.xmlreader.SecureStore
 * @author Akshathkumar Shetty
 * @since 1.4
 */
public class SecureStoreManager {

    private static Logger logger = Logger.getLogger(SecureStoreManager.class.getName());

    private SensitiveInput sensitiveInput = null;

    /**
     * Loads KeyManagers. KeyManagers are responsible for managing
     * the key material which is used to authenticate the local
     * SSLSocket to its peer. Can return null.
     */
    public KeyManager[] loadKeyManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        if (secureStore == null) {
            logger.fine(""SecureStore configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        KeyStoreInfo keyStoreInfo = secureStore.getKeyStoreInfo();
        if (keyStoreInfo == null) {
            logger.fine(""KeyStoreInfo configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        logger.finest(""Loading KeyManagers"");
        KeyStore ks = getKeyStoreForKey(secureStore.getType(), secureStore.getProvider());
        char[] storepass = null;
        if (keyStoreInfo.getStorePassword() != null) {
            logger.finest(""KeyStore: Store password was present!"");
            storepass = keyStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            storepass = sensitiveInput.getInput(""Store password for KeyStore"");
            if (storepass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream keyStoreStream = null;
        try {
            if (keyStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""KeyStore location: "" + ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
                keyStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
            }
            ks.load(keyStoreStream, storepass);
            logger.finest(""KeyStore loaded"");
        } finally {
            if (keyStoreStream != null) {
                keyStoreStream.close();
                keyStoreStream = null;
            }
        }
        char[] keypass = null;
        if (keyStoreInfo.getKeyPassword() != null) {
            logger.finest(""KeyStore: key password was present!"");
            keypass = keyStoreInfo.getKeyPassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Key password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            keypass = sensitiveInput.getInput(""Key password for KeyStore"");
            if (keypass == null) {
                logger.finest(""No password entered.. will pass blank"");
                keypass = """".toCharArray();
            }
        }
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(secureStore.getAlgorithm());
        kmf.init(ks, keypass);
        storepass = ""               "".toCharArray();
        storepass = null;
        keypass = ""               "".toCharArray();
        keypass = null;
        return kmf.getKeyManagers();
    }

    /**
     * Loads TrustManagers. TrustManagers are responsible for managing the
     * trust material that is used when making trust decisions, and for
     * deciding whether credentials presented by a peer should be accepted.
     * Can return null.
     */
    public TrustManager[] loadTrustManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        TrustStoreInfo trustStoreInfo = secureStore.getTrustStoreInfo();
        if (trustStoreInfo == null) {
            return null;
        }
        logger.finest(""Loading TrustManagers"");
        String type = null;
        if (trustStoreInfo.getType() != null && trustStoreInfo.getType().trim().length() != 0)
            type = trustStoreInfo.getType();
        else
            type = secureStore.getType();
        String provider = null;
        if (trustStoreInfo.getProvider() != null && trustStoreInfo.getProvider().trim().length() != 0)
            provider = trustStoreInfo.getProvider();
        else
            provider = secureStore.getProvider();
        KeyStore ts = getKeyStoreForTrust(type, provider);
        char[] trustpass = null;
        if (trustStoreInfo.getStorePassword() != null) {
            logger.finest(""TrustStore: Store password was present!"");
            trustpass = trustStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""TrustStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            trustpass = sensitiveInput.getInput(""Store password for TrustStore"");
            if (trustpass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream trustStoreStream = null;
        try {
            if (trustStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""TrustStore location: "" + ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
                trustStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
            }
            ts.load(trustStoreStream, trustpass);
            logger.finest(""TrustStore loaded"");
        } finally {
            if (trustStoreStream != null) {
                trustStoreStream.close();
                trustStoreStream = null;
            }
        }
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(secureStore.getAlgorithm());
        tmf.init(ts);
        return tmf.getTrustManagers();
    }

    /**
     * Generates a SSLContext object that implements the specified secure
     * socket protocol.
     */
    public SSLContext getSSLContext(String protocol) throws NoSuchAlgorithmException {
        return SSLContext.getInstance(protocol);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storeing keys.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForKey(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storing trusted
     * keys/certificates.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForTrust(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     */
    public SSLSocketFactory getSocketFactory(SSLContext context) {
        return context.getSocketFactory();
    }

    /**
     * Can be used to log details about the SSLServerSocket used to
     * create a secure server [SSL/TLS]. This method can also be
     * overridden to change the enabled cipher suites and/or enabled protocols.
     */
    public void logSSLServerSocketInfo(SSLServerSocket sslServerSocket) {
        if (logger.isLoggable(Level.FINEST) == false) {
            return;
        }
        logger.finest(""SecureServer Info: ClientAuth: "" + sslServerSocket.getNeedClientAuth());
        logger.finest(""SecureServer Info: ClientMode: "" + sslServerSocket.getUseClientMode());
        String[] supportedSuites = sslServerSocket.getSupportedCipherSuites();
        logger.finest(""SecureServer Info: Supported Cipher Suites --------"");
        for (int i = 0; i < supportedSuites.length; i++) logger.finest(supportedSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledSuites = sslServerSocket.getEnabledCipherSuites();
        logger.finest(""SecureServer Info: Enabled Cipher Suites ----------"");
        for (int i = 0; i < enabledSuites.length; i++) logger.finest(enabledSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] supportedProtocols = sslServerSocket.getSupportedProtocols();
        logger.finest(""SecureServer Info: Supported Protocols ------------"");
        for (int i = 0; i < supportedProtocols.length; i++) logger.finest(supportedProtocols[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledProtocols = sslServerSocket.getEnabledProtocols();
        logger.finest(""SecureServer Info: Enabled Protocols --------------"");
        for (int i = 0; i < enabledProtocols.length; i++) logger.finest(enabledProtocols[i]);
        logger.finest(""---------------------------------------------------"");
    }
}
","// SecureStoreManager_0Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#loadKeyManagers(QuickServerConfig)} method.
*/
class SecureStoreManager_0Test {","// SecureStoreManager_0Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#loadKeyManagers(QuickServerConfig)} method.
*/
class SecureStoreManager_0Test {

		private static Logger logger = Logger.getLogger(SecureStoreManager_0Test.class.getName());
		
		private SensitiveInput sensitiveInput = null;
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_0() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_1() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_2() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				keyStoreInfo.setStorePassword("""");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_3() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				keyStoreInfo.setStorePassword("""");
				keyStoreInfo.setKeyPassword("""");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_4() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				keyStoreInfo.setStorePassword("""");
				keyStoreInfo.setKeyPassword("""");
				secureStore.setType(""JKS"");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_5() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				keyStoreInfo.setStorePassword("""");
				keyStoreInfo.setKeyPassword("""");
				secureStore.setType(""JKS"");
				secureStore.setAlgorithm(""SunX509"");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_6() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure);
				SecureStore secureStore = new SecureStore();
				secure.setSecureStore(secureStore);
				KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
				secureStore.setKeyStoreInfo(keyStoreInfo);
				keyStoreInfo.setStoreFile(""none"");
				keyStoreInfo.setStorePassword("""");
				keyStoreInfo.setKeyPassword("""");
				secureStore.setType(""JKS"");
				secureStore.setAlgorithm(""SunX509"");
				secureStore.setProvider(""SUN"");
				KeyManager[] result = new SecureStoreManager().loadKeyManagers(config);
				assertNull(result);
		}
		
		/**
		* Loads KeyManagers. KeyManagers are responsible for managing
		* the key material which is used to authenticate the local
		* SSLSocket to its peer. Can return null.
		*/
		@Test
		public void loadKeyManagers_7() throws GeneralSecurityException, IOException {
				QuickServerConfig config = new QuickServerConfig();
				Secure secure = new Secure();
				config.setSecure(secure"
cmpl-6tz57x1JCgJYl3xRg9a5TAUfWTY7G,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/security/SecureStoreManager_1Test.java,59.79104042053223,length,"// SecureStoreManager.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;

/**
 * Class that loads Key Managers, Trust Managers, SSLContext and other secure
 * objects from QuickServer configuration passed. See &lt;secure-store-manager&gt;
 * in &lt;secure-store&gt; to set new manger to load your SecureStore. This
 * class can be overridden to change the way QuickServer configures the
 * secure mode.
 * @see org.quickserver.util.xmlreader.SecureStore
 * @author Akshathkumar Shetty
 * @since 1.4
 */
public class SecureStoreManager {

    private static Logger logger = Logger.getLogger(SecureStoreManager.class.getName());

    private SensitiveInput sensitiveInput = null;

    /**
     * Loads KeyManagers. KeyManagers are responsible for managing
     * the key material which is used to authenticate the local
     * SSLSocket to its peer. Can return null.
     */
    public KeyManager[] loadKeyManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        if (secureStore == null) {
            logger.fine(""SecureStore configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        KeyStoreInfo keyStoreInfo = secureStore.getKeyStoreInfo();
        if (keyStoreInfo == null) {
            logger.fine(""KeyStoreInfo configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        logger.finest(""Loading KeyManagers"");
        KeyStore ks = getKeyStoreForKey(secureStore.getType(), secureStore.getProvider());
        char[] storepass = null;
        if (keyStoreInfo.getStorePassword() != null) {
            logger.finest(""KeyStore: Store password was present!"");
            storepass = keyStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            storepass = sensitiveInput.getInput(""Store password for KeyStore"");
            if (storepass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream keyStoreStream = null;
        try {
            if (keyStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""KeyStore location: "" + ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
                keyStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
            }
            ks.load(keyStoreStream, storepass);
            logger.finest(""KeyStore loaded"");
        } finally {
            if (keyStoreStream != null) {
                keyStoreStream.close();
                keyStoreStream = null;
            }
        }
        char[] keypass = null;
        if (keyStoreInfo.getKeyPassword() != null) {
            logger.finest(""KeyStore: key password was present!"");
            keypass = keyStoreInfo.getKeyPassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Key password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            keypass = sensitiveInput.getInput(""Key password for KeyStore"");
            if (keypass == null) {
                logger.finest(""No password entered.. will pass blank"");
                keypass = """".toCharArray();
            }
        }
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(secureStore.getAlgorithm());
        kmf.init(ks, keypass);
        storepass = ""               "".toCharArray();
        storepass = null;
        keypass = ""               "".toCharArray();
        keypass = null;
        return kmf.getKeyManagers();
    }

    /**
     * Loads TrustManagers. TrustManagers are responsible for managing the
     * trust material that is used when making trust decisions, and for
     * deciding whether credentials presented by a peer should be accepted.
     * Can return null.
     */
    public TrustManager[] loadTrustManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        TrustStoreInfo trustStoreInfo = secureStore.getTrustStoreInfo();
        if (trustStoreInfo == null) {
            return null;
        }
        logger.finest(""Loading TrustManagers"");
        String type = null;
        if (trustStoreInfo.getType() != null && trustStoreInfo.getType().trim().length() != 0)
            type = trustStoreInfo.getType();
        else
            type = secureStore.getType();
        String provider = null;
        if (trustStoreInfo.getProvider() != null && trustStoreInfo.getProvider().trim().length() != 0)
            provider = trustStoreInfo.getProvider();
        else
            provider = secureStore.getProvider();
        KeyStore ts = getKeyStoreForTrust(type, provider);
        char[] trustpass = null;
        if (trustStoreInfo.getStorePassword() != null) {
            logger.finest(""TrustStore: Store password was present!"");
            trustpass = trustStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""TrustStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            trustpass = sensitiveInput.getInput(""Store password for TrustStore"");
            if (trustpass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream trustStoreStream = null;
        try {
            if (trustStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""TrustStore location: "" + ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
                trustStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
            }
            ts.load(trustStoreStream, trustpass);
            logger.finest(""TrustStore loaded"");
        } finally {
            if (trustStoreStream != null) {
                trustStoreStream.close();
                trustStoreStream = null;
            }
        }
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(secureStore.getAlgorithm());
        tmf.init(ts);
        return tmf.getTrustManagers();
    }

    /**
     * Generates a SSLContext object that implements the specified secure
     * socket protocol.
     */
    public SSLContext getSSLContext(String protocol) throws NoSuchAlgorithmException {
        return SSLContext.getInstance(protocol);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storeing keys.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForKey(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storing trusted
     * keys/certificates.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForTrust(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     */
    public SSLSocketFactory getSocketFactory(SSLContext context) {
        return context.getSocketFactory();
    }

    /**
     * Can be used to log details about the SSLServerSocket used to
     * create a secure server [SSL/TLS]. This method can also be
     * overridden to change the enabled cipher suites and/or enabled protocols.
     */
    public void logSSLServerSocketInfo(SSLServerSocket sslServerSocket) {
        if (logger.isLoggable(Level.FINEST) == false) {
            return;
        }
        logger.finest(""SecureServer Info: ClientAuth: "" + sslServerSocket.getNeedClientAuth());
        logger.finest(""SecureServer Info: ClientMode: "" + sslServerSocket.getUseClientMode());
        String[] supportedSuites = sslServerSocket.getSupportedCipherSuites();
        logger.finest(""SecureServer Info: Supported Cipher Suites --------"");
        for (int i = 0; i < supportedSuites.length; i++) logger.finest(supportedSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledSuites = sslServerSocket.getEnabledCipherSuites();
        logger.finest(""SecureServer Info: Enabled Cipher Suites ----------"");
        for (int i = 0; i < enabledSuites.length; i++) logger.finest(enabledSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] supportedProtocols = sslServerSocket.getSupportedProtocols();
        logger.finest(""SecureServer Info: Supported Protocols ------------"");
        for (int i = 0; i < supportedProtocols.length; i++) logger.finest(supportedProtocols[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledProtocols = sslServerSocket.getEnabledProtocols();
        logger.finest(""SecureServer Info: Enabled Protocols --------------"");
        for (int i = 0; i < enabledProtocols.length; i++) logger.finest(enabledProtocols[i]);
        logger.finest(""---------------------------------------------------"");
    }
}
","// SecureStoreManager_1Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
*/
class SecureStoreManager_1Test {","// SecureStoreManager_1Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
*/
class SecureStoreManager_1Test {

		private static Logger logger = Logger.getLogger(SecureStoreManager_1Test.class.getName());
		
		private SensitiveInput sensitiveInput = null;
		
		/**
		 * Loads TrustManagers. TrustManagers are responsible for managing the
		 * trust material that is used when making trust decisions, and for
		 * deciding whether credentials presented by a peer should be accepted.
		 * Can return null.
		 */
		public TrustManager[] loadTrustManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
				Secure secure = config.getSecure();
				SecureStore secureStore = secure.getSecureStore();
				TrustStoreInfo trustStoreInfo = secureStore.getTrustStoreInfo();
				if (trustStoreInfo == null) {
						return null;
				}
				logger.finest(""Loading TrustManagers"");
				String type = null;
				if (trustStoreInfo.getType() != null && trustStoreInfo.getType().trim().length() != 0)
						type = trustStoreInfo.getType();
				else
						type = secureStore.getType();
				String provider = null;
				if (trustStoreInfo.getProvider() != null && trustStoreInfo.getProvider().trim().length() != 0)
						provider = trustStoreInfo.getProvider();
				else
						provider = secureStore.getProvider();
				KeyStore ts = getKeyStoreForTrust(type, provider);
				char[] trustpass = null;
				if (trustStoreInfo.getStorePassword() != null) {
						logger.finest(""TrustStore: Store password was present!"");
						trustpass = trustStoreInfo.getStorePassword().toCharArray();
				} else {
						logger.finest(""TrustStore: Store password was not set.. so asking!"");
						if (sensitiveInput == null) {
								sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
						}
						trustpass = sensitiveInput.getInput(""Store password for TrustStore"");
						if (trustpass == null) {
								logger.finest(""No password entered.. will pass null"");
						}
				}
				InputStream trustStoreStream = null;
				try {
						if (trustStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
								logger.finest(""TrustStore location: "" + ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
								trustStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
						}
						ts.load(trustStoreStream, trustpass);
						logger.finest(""TrustStore loaded"");
				} finally {
						if (trustStoreStream != null) {
								trustStoreStream.close();
								trustStoreStream = null;
						}
				}
				TrustManagerFactory tmf = TrustManagerFactory.getInstance(secureStore.getAlgorithm());
				tmf.init(ts);
				return tmf.getTrustManagers();
		}
		
		/**
		 * Generates a keystore object for the specified keystore type from
		 * the specified provider to be used for loading/storing trusted
		 * keys/certificates.
		 * @param type the type of keystore
		 * @param provider the name of the provider if <code>null</code> any
		 * provider package that implements this type of key may be given based
		 * on the priority.
		 */
		protected KeyStore getKeyStoreForTrust(String type, String provider) throws KeyStoreException, NoSuchProviderException {
				if (provider == null)
						return KeyStore.getInstance(type);
				return KeyStore.getInstance(type, provider);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is null.
		 */
		@Test
		public void testLoadTrustManagers_1() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is not null.
		 */
		@Test
		public void testLoadTrustManagers_2() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is not null.
		 */
		@Test
		public void testLoadTrustManagers_3() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is not null.
		 */
		@Test
		public void testLoadTrustManagers_4() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is not null.
		 */
		@Test
		public void testLoadTrustManagers_5() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test case for {@link SecureStoreManager#loadTrustManagers(QuickServerConfig)} method.
		 * Test case for when the trustStoreInfo is not null.
		 */
		@Test
		public void testLoadTrustManagers_6() throws Exception {
				QuickServerConfig config = new QuickServerConfig();
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				TrustManager[] trustManagers = secureStoreManager.loadTrustManagers(config);
				assertNull(trustManagers);
		}
		
		/**
		 * Test"
cmpl-6tz6AQDUbD2X8MpXit1B0vmIzVQuN,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/security/SecureStoreManager_2Test.java,45.9843533039093,length,"// SecureStoreManager.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;

/**
 * Class that loads Key Managers, Trust Managers, SSLContext and other secure
 * objects from QuickServer configuration passed. See &lt;secure-store-manager&gt;
 * in &lt;secure-store&gt; to set new manger to load your SecureStore. This
 * class can be overridden to change the way QuickServer configures the
 * secure mode.
 * @see org.quickserver.util.xmlreader.SecureStore
 * @author Akshathkumar Shetty
 * @since 1.4
 */
public class SecureStoreManager {

    private static Logger logger = Logger.getLogger(SecureStoreManager.class.getName());

    private SensitiveInput sensitiveInput = null;

    /**
     * Loads KeyManagers. KeyManagers are responsible for managing
     * the key material which is used to authenticate the local
     * SSLSocket to its peer. Can return null.
     */
    public KeyManager[] loadKeyManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        if (secureStore == null) {
            logger.fine(""SecureStore configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        KeyStoreInfo keyStoreInfo = secureStore.getKeyStoreInfo();
        if (keyStoreInfo == null) {
            logger.fine(""KeyStoreInfo configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        logger.finest(""Loading KeyManagers"");
        KeyStore ks = getKeyStoreForKey(secureStore.getType(), secureStore.getProvider());
        char[] storepass = null;
        if (keyStoreInfo.getStorePassword() != null) {
            logger.finest(""KeyStore: Store password was present!"");
            storepass = keyStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            storepass = sensitiveInput.getInput(""Store password for KeyStore"");
            if (storepass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream keyStoreStream = null;
        try {
            if (keyStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""KeyStore location: "" + ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
                keyStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
            }
            ks.load(keyStoreStream, storepass);
            logger.finest(""KeyStore loaded"");
        } finally {
            if (keyStoreStream != null) {
                keyStoreStream.close();
                keyStoreStream = null;
            }
        }
        char[] keypass = null;
        if (keyStoreInfo.getKeyPassword() != null) {
            logger.finest(""KeyStore: key password was present!"");
            keypass = keyStoreInfo.getKeyPassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Key password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            keypass = sensitiveInput.getInput(""Key password for KeyStore"");
            if (keypass == null) {
                logger.finest(""No password entered.. will pass blank"");
                keypass = """".toCharArray();
            }
        }
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(secureStore.getAlgorithm());
        kmf.init(ks, keypass);
        storepass = ""               "".toCharArray();
        storepass = null;
        keypass = ""               "".toCharArray();
        keypass = null;
        return kmf.getKeyManagers();
    }

    /**
     * Loads TrustManagers. TrustManagers are responsible for managing the
     * trust material that is used when making trust decisions, and for
     * deciding whether credentials presented by a peer should be accepted.
     * Can return null.
     */
    public TrustManager[] loadTrustManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        TrustStoreInfo trustStoreInfo = secureStore.getTrustStoreInfo();
        if (trustStoreInfo == null) {
            return null;
        }
        logger.finest(""Loading TrustManagers"");
        String type = null;
        if (trustStoreInfo.getType() != null && trustStoreInfo.getType().trim().length() != 0)
            type = trustStoreInfo.getType();
        else
            type = secureStore.getType();
        String provider = null;
        if (trustStoreInfo.getProvider() != null && trustStoreInfo.getProvider().trim().length() != 0)
            provider = trustStoreInfo.getProvider();
        else
            provider = secureStore.getProvider();
        KeyStore ts = getKeyStoreForTrust(type, provider);
        char[] trustpass = null;
        if (trustStoreInfo.getStorePassword() != null) {
            logger.finest(""TrustStore: Store password was present!"");
            trustpass = trustStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""TrustStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            trustpass = sensitiveInput.getInput(""Store password for TrustStore"");
            if (trustpass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream trustStoreStream = null;
        try {
            if (trustStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""TrustStore location: "" + ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
                trustStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
            }
            ts.load(trustStoreStream, trustpass);
            logger.finest(""TrustStore loaded"");
        } finally {
            if (trustStoreStream != null) {
                trustStoreStream.close();
                trustStoreStream = null;
            }
        }
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(secureStore.getAlgorithm());
        tmf.init(ts);
        return tmf.getTrustManagers();
    }

    /**
     * Generates a SSLContext object that implements the specified secure
     * socket protocol.
     */
    public SSLContext getSSLContext(String protocol) throws NoSuchAlgorithmException {
        return SSLContext.getInstance(protocol);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storeing keys.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForKey(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storing trusted
     * keys/certificates.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForTrust(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     */
    public SSLSocketFactory getSocketFactory(SSLContext context) {
        return context.getSocketFactory();
    }

    /**
     * Can be used to log details about the SSLServerSocket used to
     * create a secure server [SSL/TLS]. This method can also be
     * overridden to change the enabled cipher suites and/or enabled protocols.
     */
    public void logSSLServerSocketInfo(SSLServerSocket sslServerSocket) {
        if (logger.isLoggable(Level.FINEST) == false) {
            return;
        }
        logger.finest(""SecureServer Info: ClientAuth: "" + sslServerSocket.getNeedClientAuth());
        logger.finest(""SecureServer Info: ClientMode: "" + sslServerSocket.getUseClientMode());
        String[] supportedSuites = sslServerSocket.getSupportedCipherSuites();
        logger.finest(""SecureServer Info: Supported Cipher Suites --------"");
        for (int i = 0; i < supportedSuites.length; i++) logger.finest(supportedSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledSuites = sslServerSocket.getEnabledCipherSuites();
        logger.finest(""SecureServer Info: Enabled Cipher Suites ----------"");
        for (int i = 0; i < enabledSuites.length; i++) logger.finest(enabledSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] supportedProtocols = sslServerSocket.getSupportedProtocols();
        logger.finest(""SecureServer Info: Supported Protocols ------------"");
        for (int i = 0; i < supportedProtocols.length; i++) logger.finest(supportedProtocols[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledProtocols = sslServerSocket.getEnabledProtocols();
        logger.finest(""SecureServer Info: Enabled Protocols --------------"");
        for (int i = 0; i < enabledProtocols.length; i++) logger.finest(enabledProtocols[i]);
        logger.finest(""---------------------------------------------------"");
    }
}
","// SecureStoreManager_2Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSSLContext(String)} method.
*/
class SecureStoreManager_2Test {","// SecureStoreManager_2Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSSLContext(String)} method.
*/
class SecureStoreManager_2Test {

	@Test
	void testGetSSLContext() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_2() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.2"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_3() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.1"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_4() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_5() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv3"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_6() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv2"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_7() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv2Hello"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_8() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv3"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_9() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.2"");
		assertNotNull(sslContext);
	}
	
	@Test
	void testGetSSLContext_10() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.1"");
		assertNotNull(sslContext);
	}
}

// SecureStoreManager_3Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSocketFactory(SSLContext)} method.
*/
class SecureStoreManager_3Test {
		
	@Test
	void testGetSocketFactory() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_2() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.2"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_3() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.1"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_4() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_5() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv3"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_6() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv2"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_7() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv2Hello"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_8() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""SSLv3"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_9() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.2"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
	
	@Test
	void testGetSocketFactory_10() throws NoSuchAlgorithmException {
		SecureStoreManager secureStoreManager = new SecureStoreManager();
		SSLContext sslContext = secureStoreManager.getSSLContext(""TLSv1.1"");
		SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
		assertNotNull(sslSocketFactory);
	}
}

// SecureStoreManager_4Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit"
cmpl-6tz7D4opn8adZqAjU76UYalKtSRl5,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/security/SecureStoreManager_3Test.java,50.94019389152527,length,"// SecureStoreManager.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;

/**
 * Class that loads Key Managers, Trust Managers, SSLContext and other secure
 * objects from QuickServer configuration passed. See &lt;secure-store-manager&gt;
 * in &lt;secure-store&gt; to set new manger to load your SecureStore. This
 * class can be overridden to change the way QuickServer configures the
 * secure mode.
 * @see org.quickserver.util.xmlreader.SecureStore
 * @author Akshathkumar Shetty
 * @since 1.4
 */
public class SecureStoreManager {

    private static Logger logger = Logger.getLogger(SecureStoreManager.class.getName());

    private SensitiveInput sensitiveInput = null;

    /**
     * Loads KeyManagers. KeyManagers are responsible for managing
     * the key material which is used to authenticate the local
     * SSLSocket to its peer. Can return null.
     */
    public KeyManager[] loadKeyManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        if (secureStore == null) {
            logger.fine(""SecureStore configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        KeyStoreInfo keyStoreInfo = secureStore.getKeyStoreInfo();
        if (keyStoreInfo == null) {
            logger.fine(""KeyStoreInfo configuration not set! "" + ""So returning null for KeyManager"");
            return null;
        }
        logger.finest(""Loading KeyManagers"");
        KeyStore ks = getKeyStoreForKey(secureStore.getType(), secureStore.getProvider());
        char[] storepass = null;
        if (keyStoreInfo.getStorePassword() != null) {
            logger.finest(""KeyStore: Store password was present!"");
            storepass = keyStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            storepass = sensitiveInput.getInput(""Store password for KeyStore"");
            if (storepass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream keyStoreStream = null;
        try {
            if (keyStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""KeyStore location: "" + ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
                keyStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(keyStoreInfo.getStoreFile(), config));
            }
            ks.load(keyStoreStream, storepass);
            logger.finest(""KeyStore loaded"");
        } finally {
            if (keyStoreStream != null) {
                keyStoreStream.close();
                keyStoreStream = null;
            }
        }
        char[] keypass = null;
        if (keyStoreInfo.getKeyPassword() != null) {
            logger.finest(""KeyStore: key password was present!"");
            keypass = keyStoreInfo.getKeyPassword().toCharArray();
        } else {
            logger.finest(""KeyStore: Key password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            keypass = sensitiveInput.getInput(""Key password for KeyStore"");
            if (keypass == null) {
                logger.finest(""No password entered.. will pass blank"");
                keypass = """".toCharArray();
            }
        }
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(secureStore.getAlgorithm());
        kmf.init(ks, keypass);
        storepass = ""               "".toCharArray();
        storepass = null;
        keypass = ""               "".toCharArray();
        keypass = null;
        return kmf.getKeyManagers();
    }

    /**
     * Loads TrustManagers. TrustManagers are responsible for managing the
     * trust material that is used when making trust decisions, and for
     * deciding whether credentials presented by a peer should be accepted.
     * Can return null.
     */
    public TrustManager[] loadTrustManagers(QuickServerConfig config) throws GeneralSecurityException, IOException {
        Secure secure = config.getSecure();
        SecureStore secureStore = secure.getSecureStore();
        TrustStoreInfo trustStoreInfo = secureStore.getTrustStoreInfo();
        if (trustStoreInfo == null) {
            return null;
        }
        logger.finest(""Loading TrustManagers"");
        String type = null;
        if (trustStoreInfo.getType() != null && trustStoreInfo.getType().trim().length() != 0)
            type = trustStoreInfo.getType();
        else
            type = secureStore.getType();
        String provider = null;
        if (trustStoreInfo.getProvider() != null && trustStoreInfo.getProvider().trim().length() != 0)
            provider = trustStoreInfo.getProvider();
        else
            provider = secureStore.getProvider();
        KeyStore ts = getKeyStoreForTrust(type, provider);
        char[] trustpass = null;
        if (trustStoreInfo.getStorePassword() != null) {
            logger.finest(""TrustStore: Store password was present!"");
            trustpass = trustStoreInfo.getStorePassword().toCharArray();
        } else {
            logger.finest(""TrustStore: Store password was not set.. so asking!"");
            if (sensitiveInput == null) {
                sensitiveInput = new SensitiveInput(config.getName() + "" - Input Prompt"");
            }
            trustpass = sensitiveInput.getInput(""Store password for TrustStore"");
            if (trustpass == null) {
                logger.finest(""No password entered.. will pass null"");
            }
        }
        InputStream trustStoreStream = null;
        try {
            if (trustStoreInfo.getStoreFile().equalsIgnoreCase(""none"") == false) {
                logger.finest(""TrustStore location: "" + ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
                trustStoreStream = new FileInputStream(ConfigReader.makeAbsoluteToConfig(trustStoreInfo.getStoreFile(), config));
            }
            ts.load(trustStoreStream, trustpass);
            logger.finest(""TrustStore loaded"");
        } finally {
            if (trustStoreStream != null) {
                trustStoreStream.close();
                trustStoreStream = null;
            }
        }
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(secureStore.getAlgorithm());
        tmf.init(ts);
        return tmf.getTrustManagers();
    }

    /**
     * Generates a SSLContext object that implements the specified secure
     * socket protocol.
     */
    public SSLContext getSSLContext(String protocol) throws NoSuchAlgorithmException {
        return SSLContext.getInstance(protocol);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storeing keys.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForKey(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Generates a keystore object for the specified keystore type from
     * the specified provider to be used for loading/storing trusted
     * keys/certificates.
     * @param type the type of keystore
     * @param provider the name of the provider if <code>null</code> any
     * provider package that implements this type of key may be given based
     * on the priority.
     */
    protected KeyStore getKeyStoreForTrust(String type, String provider) throws KeyStoreException, NoSuchProviderException {
        if (provider == null)
            return KeyStore.getInstance(type);
        return KeyStore.getInstance(type, provider);
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     */
    public SSLSocketFactory getSocketFactory(SSLContext context) {
        return context.getSocketFactory();
    }

    /**
     * Can be used to log details about the SSLServerSocket used to
     * create a secure server [SSL/TLS]. This method can also be
     * overridden to change the enabled cipher suites and/or enabled protocols.
     */
    public void logSSLServerSocketInfo(SSLServerSocket sslServerSocket) {
        if (logger.isLoggable(Level.FINEST) == false) {
            return;
        }
        logger.finest(""SecureServer Info: ClientAuth: "" + sslServerSocket.getNeedClientAuth());
        logger.finest(""SecureServer Info: ClientMode: "" + sslServerSocket.getUseClientMode());
        String[] supportedSuites = sslServerSocket.getSupportedCipherSuites();
        logger.finest(""SecureServer Info: Supported Cipher Suites --------"");
        for (int i = 0; i < supportedSuites.length; i++) logger.finest(supportedSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledSuites = sslServerSocket.getEnabledCipherSuites();
        logger.finest(""SecureServer Info: Enabled Cipher Suites ----------"");
        for (int i = 0; i < enabledSuites.length; i++) logger.finest(enabledSuites[i]);
        logger.finest(""---------------------------------------------------"");
        String[] supportedProtocols = sslServerSocket.getSupportedProtocols();
        logger.finest(""SecureServer Info: Supported Protocols ------------"");
        for (int i = 0; i < supportedProtocols.length; i++) logger.finest(supportedProtocols[i]);
        logger.finest(""---------------------------------------------------"");
        String[] enabledProtocols = sslServerSocket.getEnabledProtocols();
        logger.finest(""SecureServer Info: Enabled Protocols --------------"");
        for (int i = 0; i < enabledProtocols.length; i++) logger.finest(enabledProtocols[i]);
        logger.finest(""---------------------------------------------------"");
    }
}
","// SecureStoreManager_3Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSocketFactory(SSLContext)} method.
*/
class SecureStoreManager_3Test {","// SecureStoreManager_3Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSocketFactory(SSLContext)} method.
*/
class SecureStoreManager_3Test {

		@Test
		public void testGetSocketFactory_1() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_2() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_3() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_4() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_5() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_6() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_7() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_8() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_9() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
		
		@Test
		public void testGetSocketFactory_10() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = SSLContext.getInstance(""TLS"");
				SSLSocketFactory sslSocketFactory = secureStoreManager.getSocketFactory(sslContext);
				assertNotNull(sslSocketFactory);
		}
}

// SecureStoreManager_4Test.java
package org.quickserver.security;

import java.io.*;
import java.util.logging.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.util.io.*;
import javax.net.ssl.*;
import java.security.*;
import org.quickserver.swing.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStoreManager}.
* It contains ten unit test cases for the {@link SecureStoreManager#getSSLContext(String)} method.
*/
class SecureStoreManager_4Test {
		
		@Test
		public void testGetSSLContext_1() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_2() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_3() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_4() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_5() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_6() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_7() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_8() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_9() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
		
		@Test
		public void testGetSSLContext_10() throws Exception {
				SecureStoreManager secureStoreManager = new SecureStoreManager();
				SSLContext sslContext = secureStoreManager.getSSLContext(""TLS"");
				assertNotNull(sslContext);
		}
}

// SecureStoreManager_5Test.java
package org.quickserver.security;"
cmpl-6tz8G3Ap6brchAXEzqvKx9N7x5MuY,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/swing/JFrameUtilities.java,41.10676288604736,length,"// JFrameUtilities.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;

/**
 * Swing utility class
 */
public class JFrameUtilities {

    /**
     * Create a title string from the class name.
     */
    public static String title(Object o) {
        String t = o.getClass().toString();
        // Remove the word ""class"":
        if (t.indexOf(""class"") != -1)
            t = t.substring(6);
        if (t.lastIndexOf(""."") != -1)
            t = t.substring(t.lastIndexOf(""."") + 1);
        return t;
    }

    public static void run(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }

    public static void run(JApplet applet, int width, int height) {
        JFrame frame = new JFrame(title(applet));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(applet);
        frame.setSize(width, height);
        applet.init();
        applet.start();
        frame.setVisible(true);
    }

    public static void run(JPanel panel, int width, int height) {
        JFrame frame = new JFrame(title(panel));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(panel);
        frame.setSize(width, height);
        frame.setVisible(true);
    }

    public static void setNativeLookAndFeel() {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            System.out.println(""Error setting native LAF: "" + e);
        }
    }

    public static void setJavaLookAndFeel() {
        try {
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        } catch (Exception e) {
            System.out.println(""Error setting Java LAF: "" + e);
        }
    }

    public static void setMotifLookAndFeel() {
        try {
            UIManager.setLookAndFeel(""com.sun.java.swing.plaf.motif.MotifLookAndFeel"");
        } catch (Exception e) {
            System.out.println(""Error setting Motif LAF: "" + e);
        }
    }

    public static void centerWindow(Window window) {
        Dimension dim = window.getToolkit().getScreenSize();
        window.setLocation(dim.width / 2 - window.getWidth() / 2, dim.height / 2 - window.getHeight() / 2);
    }
}
","// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {","// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {

	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import java.awt.Window;
import java.awt.Toolkit;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFrameUtilities}.
* It contains ten unit test cases for the {@link JFrameUtilities#title(Object)} method.
*/
class JFrameUtilitiesTest {
		
	@Test
	void testTitle() {
		assertEquals(""JFrameUtilitiesTest"", JFrameUtilities.title(this));
	}
}

// JFrameUtilitiesTest.java
package org.quickserver.swing;

import javax.swing.*;
import java.awt.event.*;
import"
cmpl-6tz9JKxtkOj7lyoGq2jQPbC9zKsPh,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_0Test.java,41.10231566429138,length,"// ClassUtil.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Class classloded = null;
        HashMap classHash = new HashMap();
        for (int i = 0; i < classNames.length; i++) {
            try {
                classloded = classLoader.loadClass(classNames[i]);
                classHash.put(classNames[i], classloded);
            } catch (Exception e) {
                logger.warning(""Could not load classes : "" + e);
            }
        }
        return classHash;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        logger.fine(""Getting ClassLoader for jars in "" + jarDir);
        File file = new File(jarDir);
        ArrayList list = new ArrayList();
        File[] jars = file.listFiles(new JarFileList());
        for (int j = 0; j < jars.length; j++) {
            list.add(jars[j].toURL());
        }
        Object[] array = list.toArray();
        URL[] jarurl = new URL[array.length];
        for (int i = 0; i < array.length; i++) {
            jarurl[i] = (URL) array[i];
        }
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        File file = new File(jarPath);
        logger.fine(""Getting ClassLoader for "" + file.getCanonicalPath());
        URL[] jarurl = { file.toURL() };
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.canRead() == false) {
            logger.warning(""Could not read path: "" + path);
            return null;
        }
        if (file.isDirectory())
            return getClassLoaderFromJars(path);
        else
            return getClassLoaderFromJar(path);
    }
}
","// ClassUtil_0Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#loadClass(ClassLoader, String[])} method.
*/
class ClassUtil_0Test {","// ClassUtil_0Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#loadClass(ClassLoader, String[])} method.
*/
class ClassUtil_0Test {

		private static Logger logger = Logger.getLogger(ClassUtil_0Test.class.getName());
		
		@Test
		public void testLoadClass_0() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(1, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_3() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_4() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_5() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_6() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_7() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_8() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertEquals(2, classHash.size());
				assertEquals(classNames[0], classHash.keySet().iterator().next());
		}
		
		@Test
		public void testLoadClass_9() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				String[] classNames = { ""org.quickserver.net.qsadmin.CommandHandler"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net.qsadmin.QSAdminServer"", ""org.quickserver.net."
cmpl-6tzAM5y5SexZw16tJm0Ck9wZVorEx,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_1Test.java,36.07216811180115,length,"// ClassUtil.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Class classloded = null;
        HashMap classHash = new HashMap();
        for (int i = 0; i < classNames.length; i++) {
            try {
                classloded = classLoader.loadClass(classNames[i]);
                classHash.put(classNames[i], classloded);
            } catch (Exception e) {
                logger.warning(""Could not load classes : "" + e);
            }
        }
        return classHash;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        logger.fine(""Getting ClassLoader for jars in "" + jarDir);
        File file = new File(jarDir);
        ArrayList list = new ArrayList();
        File[] jars = file.listFiles(new JarFileList());
        for (int j = 0; j < jars.length; j++) {
            list.add(jars[j].toURL());
        }
        Object[] array = list.toArray();
        URL[] jarurl = new URL[array.length];
        for (int i = 0; i < array.length; i++) {
            jarurl[i] = (URL) array[i];
        }
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        File file = new File(jarPath);
        logger.fine(""Getting ClassLoader for "" + file.getCanonicalPath());
        URL[] jarurl = { file.toURL() };
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.canRead() == false) {
            logger.warning(""Could not read path: "" + path);
            return null;
        }
        if (file.isDirectory())
            return getClassLoaderFromJars(path);
        else
            return getClassLoaderFromJar(path);
    }
}
","// ClassUtil_1Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtil_1Test {","// ClassUtil_1Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtil_1Test {

		private static Logger logger = Logger.getLogger(ClassUtil_1Test.class.getName());
		
		@Test
		public void testGetClassLoaderFromJars() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_2Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJar(String)} method.
*/
class ClassUtil_2Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_2Test.class.getName());
		
		@Test
		public void testGetClassLoaderFromJar() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_3Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoader(String)} method.
*/
class ClassUtil_3Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_3Test.class.getName());
		
		@Test
		public void testGetClassLoader() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_4Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten"
cmpl-6tzBPVMLIOu0VYcnJRBpjQY921dOY,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_2Test.java,40.19398808479309,length,"// ClassUtil.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Class classloded = null;
        HashMap classHash = new HashMap();
        for (int i = 0; i < classNames.length; i++) {
            try {
                classloded = classLoader.loadClass(classNames[i]);
                classHash.put(classNames[i], classloded);
            } catch (Exception e) {
                logger.warning(""Could not load classes : "" + e);
            }
        }
        return classHash;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        logger.fine(""Getting ClassLoader for jars in "" + jarDir);
        File file = new File(jarDir);
        ArrayList list = new ArrayList();
        File[] jars = file.listFiles(new JarFileList());
        for (int j = 0; j < jars.length; j++) {
            list.add(jars[j].toURL());
        }
        Object[] array = list.toArray();
        URL[] jarurl = new URL[array.length];
        for (int i = 0; i < array.length; i++) {
            jarurl[i] = (URL) array[i];
        }
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        File file = new File(jarPath);
        logger.fine(""Getting ClassLoader for "" + file.getCanonicalPath());
        URL[] jarurl = { file.toURL() };
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.canRead() == false) {
            logger.warning(""Could not read path: "" + path);
            return null;
        }
        if (file.isDirectory())
            return getClassLoaderFromJars(path);
        else
            return getClassLoaderFromJar(path);
    }
}
","// ClassUtil_2Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJar(String)} method.
*/
class ClassUtil_2Test {","// ClassUtil_2Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJar(String)} method.
*/
class ClassUtil_2Test {

		@Test
		void testGetClassLoaderFromJar_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_3() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_4() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_5() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_6() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_7() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_8() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_9() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJar_10() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/Desktop/test.jar"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_1Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtil_1Test {
		
		@Test
		void testGetClassLoaderFromJars_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_3() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_4() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_5() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_6() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_7() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_8() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_9() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
		
		@Test
		void testGetClassLoaderFromJars_10() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				assertNotNull(classLoader);
		}
}

// ClassUtilTest.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#loadClass(ClassLoader, String[])} method.
*/
class ClassUtilTest {
		
		@Test
		void testLoadClass_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				String[] classNames = {""org.quickserver.util.ClassUtil""};
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
		}
		
		@Test
		void testLoadClass_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""/home/akshath/Desktop/test"");
				String[] classNames = {""org.quickserver.util.ClassUtil""};
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
		}
		
		@Test"
cmpl-6tzCS9wC05C8IfgIYWoM1TiBrYyLv,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_3Test.java,69.63577556610107,length,"// ClassUtil.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Class classloded = null;
        HashMap classHash = new HashMap();
        for (int i = 0; i < classNames.length; i++) {
            try {
                classloded = classLoader.loadClass(classNames[i]);
                classHash.put(classNames[i], classloded);
            } catch (Exception e) {
                logger.warning(""Could not load classes : "" + e);
            }
        }
        return classHash;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        logger.fine(""Getting ClassLoader for jars in "" + jarDir);
        File file = new File(jarDir);
        ArrayList list = new ArrayList();
        File[] jars = file.listFiles(new JarFileList());
        for (int j = 0; j < jars.length; j++) {
            list.add(jars[j].toURL());
        }
        Object[] array = list.toArray();
        URL[] jarurl = new URL[array.length];
        for (int i = 0; i < array.length; i++) {
            jarurl[i] = (URL) array[i];
        }
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        File file = new File(jarPath);
        logger.fine(""Getting ClassLoader for "" + file.getCanonicalPath());
        URL[] jarurl = { file.toURL() };
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.canRead() == false) {
            logger.warning(""Could not read path: "" + path);
            return null;
        }
        if (file.isDirectory())
            return getClassLoaderFromJars(path);
        else
            return getClassLoaderFromJar(path);
    }
}
","// ClassUtil_3Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoader(String)} method.
*/
class ClassUtil_3Test {","// ClassUtil_3Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoader(String)} method.
*/
class ClassUtil_3Test {

		private static Logger logger = Logger.getLogger(ClassUtil_3Test.class.getName());
		
		@Test
		public void testGetClassLoader_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_3() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_4() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_5() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_6() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_7() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_8() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_9() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoader_10() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
}

// JarFileList.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to list jar files.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class JarFileList implements FilenameFilter {
    private static Logger logger = Logger.getLogger(JarFileList.class.getName());

    public boolean accept(File dir, String name) {
        if (name.endsWith("".jar"")) {
            return true;
        } else {
            return false;
        }
    }
}

// ClassUtil_2Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJar(String)} method.
*/
class ClassUtil_2Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_2Test.class.getName());
		
		@Test
		public void testGetClassLoaderFromJar_1() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_2() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_3() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_4() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_5() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_6() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_7() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_8() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_9() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""/home/akshath/quickserver/lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
		}
		
		@Test
		public void testGetClassLoaderFromJar_10() throws Exception"
cmpl-6tzDanDWJLpj1yocDHoU5fJexjCZr,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/MyString_7Test.java,68.77772331237793,length,"// MyString.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;

/**
 * Just a simple String utility class.
 * @author Akshathkumar Shetty
 */
public class MyString {

    private static Runtime runtime = Runtime.getRuntime();

    private static java.text.DecimalFormat doublePrcNum = new java.text.DecimalFormat(""#,##0.00"");

    public static String replace(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        int start = 0;
        int end = 0;
        String result = """";
        start = source.indexOf(key);
        end = start + key.length();
        if (start == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end, source.length());
        return result;
    }

    public static String replaceAll(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replace(source, key, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    public static int replaceCount(String source, String key) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        int count = 0;
        String result = """";
        String temp = """";
        result = source;
        while (true) {
            temp = """";
            temp = replace(result, key, """");
            if (temp == null) {
                break;
            } else {
                result = temp;
                count++;
            }
        }
        return count;
    }

    public static String replaceAllNo(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        for (int i = 0; i < 10; i++) source = replaceAll(source, """" + i, with);
        return source;
    }

    public static String removeAllHtmlSpChar(String source) {
        String temp = source;
        temp = replaceAll(temp, ""&nbsp;"", "" "");
        temp = replaceAll(temp, ""&lt;"", ""<"");
        temp = replaceAll(temp, ""&gt;"", "">"");
        temp = replaceAll(temp, ""&amp;"", ""&"");
        temp = replaceAll(temp, ""&quot;"", ""\"""");
        return temp;
    }

    ///////// tags ////////////
    // needs more work
    public static String replaceTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        int start = 0;
        int end = 0;
        int error = 0;
        String result = """";
        start = source.indexOf(""<"");
        end = source.indexOf("">"", start + 1);
        error = source.indexOf(""<"", start + 1);
        if (error != -1 && error < end)
            throw new IllegalArgumentException(""&lt; found before &gt;"");
        if (start == -1 || end == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end + 1, source.length());
        return result;
    }

    public static String replaceAllTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replaceTags(source, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    /**
     * Returns String form of an exception.
     * @since 1.3.3
     */
    public static String getStackTrace(Throwable e) {
        StringWriter writer = new StringWriter(1024);
        e.printStackTrace(new PrintWriter(writer));
        return writer.toString();
    }

    /**
     * Returns formatted memory size.
     * @since 1.4.5
     */
    public static String getMemInfo(float bytes) {
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" B"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" KB"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" MB"";
        }
        bytes = bytes / 1024;
        return doublePrcNum.format(bytes) + "" GB"";
    }

    /**
     * Returns System information.
     * @since 1.4.5
     */
    public static String getSystemInfo(String version) {
        StringBuilder sb = new StringBuilder();
        sb.append(""---- System Info Start ---"");
        sb.append(""\r\n"");
        sb.append(""QuickServer v"");
        sb.append(version);
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Java VM v"");
        sb.append(System.getProperty(""java.version""));
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Operating System: "");
        sb.append(System.getProperty(""os.name""));
        sb.append("" "");
        sb.append(System.getProperty(""os.version""));
        sb.append(""\r\n"");
        sb.append(""Current working directory: "");
        sb.append(System.getProperty(""user.dir""));
        sb.append(""\r\n"");
        sb.append(""Class/s loaded from: "");
        sb.append(new MyString().getClass().getProtectionDomain().getCodeSource().getLocation());
        sb.append(""\r\n"");
        sb.append(""Total memory currently available: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory()));
        sb.append(""\r\n"");
        sb.append(""Memory currently in use: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory() - runtime.freeMemory()));
        sb.append(""\r\n"");
        sb.append(""Maximum memory available: "");
        sb.append(MyString.getMemInfo(runtime.maxMemory()));
        sb.append(""\r\n"");
        sb.append(""---- System Info End ---"");
        return sb.toString();
    }

    public static String alignRight(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.insert(0, ' ');
        }
        return sb.toString();
    }

    public static String alignLeft(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.append(' ');
        }
        return sb.toString();
    }
}
","// MyString_7Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getStackTrace(Throwable)} method.
*/
class MyString_7Test {","// MyString_7Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getStackTrace(Throwable)} method.
*/
class MyString_7Test {

	@Test
	void testGetStackTrace() {
		try {
			throw new Exception(""Test Exception"");
		} catch (Exception e) {
			String stackTrace = MyString.getStackTrace(e);
			assertTrue(stackTrace.contains(""Test Exception""));
		}
	}
}

// MyString_8Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getMemInfo(float)} method.
*/
class MyString_8Test {
		
	@Test
	void testGetMemInfo() {
		String memInfo = MyString.getMemInfo(1024);
		assertEquals(""1.00 KB"", memInfo);
	}
}

// MyString_9Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getSystemInfo(String)} method.
*/
class MyString_9Test {
		
	@Test
	void testGetSystemInfo() {
		String systemInfo = MyString.getSystemInfo(""1.4.5"");
		assertTrue(systemInfo.contains(""QuickServer v1.4.5 is being used.""));
	}
}

// MyString_10Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#alignRight(String, int)} method.
*/
class MyString_10Test {
		
	@Test
	void testAlignRight() {
		String data = MyString.alignRight(""test"", 10);
		assertEquals(""      test"", data);
	}
}

// MyString_11Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#alignLeft(String, int)} method.
*/
class MyString_11Test {
		
	@Test
	void testAlignLeft() {
		String data = MyString.alignLeft(""test"", 10);
		assertEquals(""test      "", data);
	}
}

// MyString_12Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replaceAllNo(String, String)} method.
*/
class MyString_12Test {
		
	@Test
	void testReplaceAllNo() {
		String data = MyString.replaceAllNo(""test"", ""*"");
		assertEquals(""****"", data);
	}
}

// MyString_13Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#removeAllHtmlSpChar(String)} method.
*/
class MyString_13Test {
		
	@Test
	void testRemoveAllHtmlSpChar() {
		String data = MyString.removeAllHtmlSpChar(""&nbsp;&lt;&gt;&amp;&quot;"");
		assertEquals("" <>&\"""", data);
	}
}

// MyString_14Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replaceAllTags(String, String)} method.
*/
class MyString_14Test {
		
	@Test
	void testReplaceAllTags() {
		String data = MyString.replaceAllTags(""<a>test</a>"", ""*"");
		assertEquals(""*test*"", data);
	}
}

// MyString_15Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replaceTags(String, String)} method.
*/
class MyString_15Test {
		
	@Test
	void testReplaceTags() {
		String data = MyString.replaceTags(""<a>test</a>"", ""*"");
		assertEquals(""*test*"", data);
	}
}

// MyString_16Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replaceCount(String, String)} method.
*/
class MyString_16Test {
		
	@Test
	void testReplaceCount() {
		int count = MyString.replaceCount(""test"", ""t"");
		assertEquals(2, count);
	}
}

// MyString_17Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replaceAll(String, String, String)} method.
*/
class MyString_17Test {
		
	@Test
	void testReplaceAll() {
		String data = MyString.replaceAll(""test"", ""t"", ""*"");
		assertEquals(""*es*"", data);
	}
}

// MyString_18Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#replace(String, String, String)} method.
*/
class MyString_18Test {
		
	@Test
	void testReplace() {
		String data = MyString.replace(""test"", ""t"", ""*"");
		assertEquals(""*es*"", data);
	}
}

// MyString_19Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getStackTrace(Throwable)} method."
cmpl-6tzEg2z582UaFx3VaZGGM4AdQ1ODl,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/MyString_8Test.java,58.49509024620056,length,"// MyString.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;

/**
 * Just a simple String utility class.
 * @author Akshathkumar Shetty
 */
public class MyString {

    private static Runtime runtime = Runtime.getRuntime();

    private static java.text.DecimalFormat doublePrcNum = new java.text.DecimalFormat(""#,##0.00"");

    public static String replace(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        int start = 0;
        int end = 0;
        String result = """";
        start = source.indexOf(key);
        end = start + key.length();
        if (start == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end, source.length());
        return result;
    }

    public static String replaceAll(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replace(source, key, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    public static int replaceCount(String source, String key) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        int count = 0;
        String result = """";
        String temp = """";
        result = source;
        while (true) {
            temp = """";
            temp = replace(result, key, """");
            if (temp == null) {
                break;
            } else {
                result = temp;
                count++;
            }
        }
        return count;
    }

    public static String replaceAllNo(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        for (int i = 0; i < 10; i++) source = replaceAll(source, """" + i, with);
        return source;
    }

    public static String removeAllHtmlSpChar(String source) {
        String temp = source;
        temp = replaceAll(temp, ""&nbsp;"", "" "");
        temp = replaceAll(temp, ""&lt;"", ""<"");
        temp = replaceAll(temp, ""&gt;"", "">"");
        temp = replaceAll(temp, ""&amp;"", ""&"");
        temp = replaceAll(temp, ""&quot;"", ""\"""");
        return temp;
    }

    ///////// tags ////////////
    // needs more work
    public static String replaceTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        int start = 0;
        int end = 0;
        int error = 0;
        String result = """";
        start = source.indexOf(""<"");
        end = source.indexOf("">"", start + 1);
        error = source.indexOf(""<"", start + 1);
        if (error != -1 && error < end)
            throw new IllegalArgumentException(""&lt; found before &gt;"");
        if (start == -1 || end == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end + 1, source.length());
        return result;
    }

    public static String replaceAllTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replaceTags(source, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    /**
     * Returns String form of an exception.
     * @since 1.3.3
     */
    public static String getStackTrace(Throwable e) {
        StringWriter writer = new StringWriter(1024);
        e.printStackTrace(new PrintWriter(writer));
        return writer.toString();
    }

    /**
     * Returns formatted memory size.
     * @since 1.4.5
     */
    public static String getMemInfo(float bytes) {
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" B"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" KB"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" MB"";
        }
        bytes = bytes / 1024;
        return doublePrcNum.format(bytes) + "" GB"";
    }

    /**
     * Returns System information.
     * @since 1.4.5
     */
    public static String getSystemInfo(String version) {
        StringBuilder sb = new StringBuilder();
        sb.append(""---- System Info Start ---"");
        sb.append(""\r\n"");
        sb.append(""QuickServer v"");
        sb.append(version);
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Java VM v"");
        sb.append(System.getProperty(""java.version""));
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Operating System: "");
        sb.append(System.getProperty(""os.name""));
        sb.append("" "");
        sb.append(System.getProperty(""os.version""));
        sb.append(""\r\n"");
        sb.append(""Current working directory: "");
        sb.append(System.getProperty(""user.dir""));
        sb.append(""\r\n"");
        sb.append(""Class/s loaded from: "");
        sb.append(new MyString().getClass().getProtectionDomain().getCodeSource().getLocation());
        sb.append(""\r\n"");
        sb.append(""Total memory currently available: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory()));
        sb.append(""\r\n"");
        sb.append(""Memory currently in use: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory() - runtime.freeMemory()));
        sb.append(""\r\n"");
        sb.append(""Maximum memory available: "");
        sb.append(MyString.getMemInfo(runtime.maxMemory()));
        sb.append(""\r\n"");
        sb.append(""---- System Info End ---"");
        return sb.toString();
    }

    public static String alignRight(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.insert(0, ' ');
        }
        return sb.toString();
    }

    public static String alignLeft(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.append(' ');
        }
        return sb.toString();
    }
}
","// MyString_8Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getMemInfo(float)} method.
*/
class MyString_8Test {","// MyString_8Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getMemInfo(float)} method.
*/
class MyString_8Test {

	@Test
	void testGetMemInfo() {
		assertEquals(""0.00 B"", MyString.getMemInfo(0));
		assertEquals(""1.00 B"", MyString.getMemInfo(1));
		assertEquals(""1023.00 B"", MyString.getMemInfo(1023));
		assertEquals(""1.00 KB"", MyString.getMemInfo(1024));
		assertEquals(""1.00 KB"", MyString.getMemInfo(1025));
		assertEquals(""1.00 MB"", MyString.getMemInfo(1024*1024));
		assertEquals(""1.00 MB"", MyString.getMemInfo(1024*1024+1));
		assertEquals(""1.00 GB"", MyString.getMemInfo(1024*1024*1024));
		assertEquals(""1.00 GB"", MyString.getMemInfo(1024*1024*1024+1));
		assertEquals(""1.00 GB"", MyString.getMemInfo(1024*1024*1024*1024));
	}
}

// MyString_9Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getSystemInfo(String)} method.
*/
class MyString_9Test {
		
	@Test
	void testGetSystemInfo() {
		String info = MyString.getSystemInfo(""1.4.5"");
		assertTrue(info.contains(""QuickServer v1.4.5 is being used.""));
		assertTrue(info.contains(""Java VM v""));
		assertTrue(info.contains("" is being used.""));
		assertTrue(info.contains(""Operating System: ""));
		assertTrue(info.contains(""Current working directory: ""));
		assertTrue(info.contains(""Class/s loaded from: ""));
		assertTrue(info.contains(""Total memory currently available: ""));
		assertTrue(info.contains(""Memory currently in use: ""));
		assertTrue(info.contains(""Maximum memory available: ""));
	}
}

// MyString_10Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#alignRight(String, int)} method.
*/
class MyString_10Test {
		
	@Test
	void testAlignRight() {
		assertEquals(""    "", MyString.alignRight("""", 4));
		assertEquals(""    "", MyString.alignRight("" "", 4));
		assertEquals(""    "", MyString.alignRight(""  "", 4));
		assertEquals(""    "", MyString.alignRight(""   "", 4));
		assertEquals(""    "", MyString.alignRight(""    "", 4));
		assertEquals(""    "", MyString.alignRight(""     "", 4));
		assertEquals(""    "", MyString.alignRight(""      "", 4));
		assertEquals(""    "", MyString.alignRight(""       "", 4));
		assertEquals(""    "", MyString.alignRight(""        "", 4));
		assertEquals(""    "", MyString.alignRight(""         "", 4));
		assertEquals(""    "", MyString.alignRight(""          "", 4));
		assertEquals(""    "", MyString.alignRight(""           "", 4));
		assertEquals(""    "", MyString.alignRight(""            "", 4));
		assertEquals(""    "", MyString.alignRight(""             "", 4));
		assertEquals(""    "", MyString.alignRight(""              "", 4));
		assertEquals(""    "", MyString.alignRight(""               "", 4));
		assertEquals(""    "", MyString.alignRight(""                "", 4));
		assertEquals(""    "", MyString.alignRight(""                 "", 4));
		assertEquals(""    "", MyString.alignRight(""                  "", 4));
		assertEquals(""    "", MyString.alignRight(""                   "", 4));
		assertEquals(""    "", MyString.alignRight(""                    "", 4));
		assertEquals(""    "", MyString.alignRight(""                     "", 4));
		assertEquals(""    "", MyString.alignRight(""                      "", 4));
		assertEquals(""    "", MyString.alignRight(""                       "", 4));
		assertEquals(""    "", MyString.alignRight(""                        "", 4));
		assertEquals(""    "", MyString.alignRight(""                         "", 4));
		assertEquals(""    "", MyString.alignRight(""                          "", 4));
		assertEquals(""    "", MyString.alignRight(""                           "", 4));
		assertEquals(""    "", MyString.alignRight(""                            "", 4));
		assertEquals(""    "", MyString.alignRight(""                             "", 4));
		assertEquals(""    "", MyString.alignRight(""                              "", 4));
		assertEquals(""    "", MyString.alignRight(""                               "", 4));
		assertEquals(""    "", MyString.alignRight(""                                "", 4));
		assertEquals(""    "", MyString.alignRight(""                                 "", 4));
		assertEquals(""    "", MyString.alignRight(""                                  "", 4));
		assertEquals(""    "", MyString.alignRight(""                                   "", 4));
		assertEquals(""    "", MyString.alignRight(""                                    "", 4));
		assertEquals(""    "", MyString.alignRight(""                                     "", 4));
		assertEquals(""    "", MyString.alignRight(""                                      "", 4));
		assertEquals(""    "", MyString.alignRight(""                                       "", 4));
		assertEquals(""    "", MyString.alignRight(""                                        "", 4));
		assertEquals(""    "", MyString.alignRight(""                                         "", 4));
		assertEquals(""    "", MyString.alignRight(""                                          "", 4));
		assertEquals(""    "", MyString.alignRight(""                                           "", 4));
		assertEquals(""    "", MyString.alignRight(""                                            "", 4));
		assertEquals(""    "", MyString.alignRight(""                                             "", 4));
		assertEquals(""    "", MyString.alignRight(""                                              "", 4));
		assertEquals(""    "", MyString.alignRight(""                                               "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                 "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                  "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                   "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                    "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                     "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                      "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                       "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                        "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                         "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                          "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                           "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                            "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                             "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                              "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                               "", 4));
		assertEquals(""    "", MyString.alignRight(""                                                                "", 4));
		assertEquals(""    "", My"
cmpl-6tzFj7DmsroKbAM0Hw5DArd5pL6x0,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/MyString_9Test.java,62.85696816444397,length,"// MyString.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;

/**
 * Just a simple String utility class.
 * @author Akshathkumar Shetty
 */
public class MyString {

    private static Runtime runtime = Runtime.getRuntime();

    private static java.text.DecimalFormat doublePrcNum = new java.text.DecimalFormat(""#,##0.00"");

    public static String replace(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        int start = 0;
        int end = 0;
        String result = """";
        start = source.indexOf(key);
        end = start + key.length();
        if (start == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end, source.length());
        return result;
    }

    public static String replaceAll(String source, String key, String with) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        if (with == null)
            throw new NullPointerException(""Parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replace(source, key, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    public static int replaceCount(String source, String key) {
        if (source == null)
            throw new NullPointerException(""Parameter -> source was null"");
        if (key == null)
            throw new NullPointerException(""Parameter -> key was null"");
        int count = 0;
        String result = """";
        String temp = """";
        result = source;
        while (true) {
            temp = """";
            temp = replace(result, key, """");
            if (temp == null) {
                break;
            } else {
                result = temp;
                count++;
            }
        }
        return count;
    }

    public static String replaceAllNo(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        for (int i = 0; i < 10; i++) source = replaceAll(source, """" + i, with);
        return source;
    }

    public static String removeAllHtmlSpChar(String source) {
        String temp = source;
        temp = replaceAll(temp, ""&nbsp;"", "" "");
        temp = replaceAll(temp, ""&lt;"", ""<"");
        temp = replaceAll(temp, ""&gt;"", "">"");
        temp = replaceAll(temp, ""&amp;"", ""&"");
        temp = replaceAll(temp, ""&quot;"", ""\"""");
        return temp;
    }

    ///////// tags ////////////
    // needs more work
    public static String replaceTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        int start = 0;
        int end = 0;
        int error = 0;
        String result = """";
        start = source.indexOf(""<"");
        end = source.indexOf("">"", start + 1);
        error = source.indexOf(""<"", start + 1);
        if (error != -1 && error < end)
            throw new IllegalArgumentException(""&lt; found before &gt;"");
        if (start == -1 || end == -1)
            return null;
        result = source.substring(0, start);
        result += with;
        result += source.substring(end + 1, source.length());
        return result;
    }

    public static String replaceAllTags(String source, String with) {
        if (source == null)
            throw new NullPointerException(""One of parameter -> source was null"");
        if (with == null)
            throw new NullPointerException(""One of parameter -> with was null"");
        String temp = """";
        while (true) {
            temp = """";
            temp = replaceTags(source, with);
            if (temp == null)
                break;
            else
                source = temp;
        }
        return source;
    }

    /**
     * Returns String form of an exception.
     * @since 1.3.3
     */
    public static String getStackTrace(Throwable e) {
        StringWriter writer = new StringWriter(1024);
        e.printStackTrace(new PrintWriter(writer));
        return writer.toString();
    }

    /**
     * Returns formatted memory size.
     * @since 1.4.5
     */
    public static String getMemInfo(float bytes) {
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" B"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" KB"";
        }
        bytes = bytes / 1024;
        if (bytes < 1024) {
            return doublePrcNum.format(bytes) + "" MB"";
        }
        bytes = bytes / 1024;
        return doublePrcNum.format(bytes) + "" GB"";
    }

    /**
     * Returns System information.
     * @since 1.4.5
     */
    public static String getSystemInfo(String version) {
        StringBuilder sb = new StringBuilder();
        sb.append(""---- System Info Start ---"");
        sb.append(""\r\n"");
        sb.append(""QuickServer v"");
        sb.append(version);
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Java VM v"");
        sb.append(System.getProperty(""java.version""));
        sb.append("" is being used."");
        sb.append(""\r\n"");
        sb.append(""Operating System: "");
        sb.append(System.getProperty(""os.name""));
        sb.append("" "");
        sb.append(System.getProperty(""os.version""));
        sb.append(""\r\n"");
        sb.append(""Current working directory: "");
        sb.append(System.getProperty(""user.dir""));
        sb.append(""\r\n"");
        sb.append(""Class/s loaded from: "");
        sb.append(new MyString().getClass().getProtectionDomain().getCodeSource().getLocation());
        sb.append(""\r\n"");
        sb.append(""Total memory currently available: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory()));
        sb.append(""\r\n"");
        sb.append(""Memory currently in use: "");
        sb.append(MyString.getMemInfo(runtime.totalMemory() - runtime.freeMemory()));
        sb.append(""\r\n"");
        sb.append(""Maximum memory available: "");
        sb.append(MyString.getMemInfo(runtime.maxMemory()));
        sb.append(""\r\n"");
        sb.append(""---- System Info End ---"");
        return sb.toString();
    }

    public static String alignRight(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.insert(0, ' ');
        }
        return sb.toString();
    }

    public static String alignLeft(String data, int len) {
        StringBuilder sb = new StringBuilder(data);
        while (sb.length() < len) {
            sb.append(' ');
        }
        return sb.toString();
    }
}
","// MyString_9Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getSystemInfo(String)} method.
*/
class MyString_9Test {","// MyString_9Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getSystemInfo(String)} method.
*/
class MyString_9Test {

	@Test
	void testGetSystemInfo() {
		String version = ""1.4.5"";
		String result = MyString.getSystemInfo(version);
		assertNotNull(result);
		assertTrue(result.contains(""QuickServer v""+version+"" is being used.""));
		assertTrue(result.contains(""Java VM v""+System.getProperty(""java.version"")+"" is being used.""));
		assertTrue(result.contains(""Operating System: ""+System.getProperty(""os.name"")+"" ""+System.getProperty(""os.version"")));
		assertTrue(result.contains(""Current working directory: ""+System.getProperty(""user.dir"")));
		assertTrue(result.contains(""Class/s loaded from: ""+new MyString().getClass().getProtectionDomain().getCodeSource().getLocation()));
		assertTrue(result.contains(""Total memory currently available: ""+MyString.getMemInfo(Runtime.getRuntime().totalMemory())));
		assertTrue(result.contains(""Memory currently in use: ""+MyString.getMemInfo(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())));
		assertTrue(result.contains(""Maximum memory available: ""+MyString.getMemInfo(Runtime.getRuntime().maxMemory())));
	}
}

// MyString_8Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#getMemInfo(float)} method.
*/
class MyString_8Test {
		
	@Test
	void testGetMemInfo() {
		String result = MyString.getMemInfo(0);
		assertNotNull(result);
		assertEquals(""0.00 B"", result);
		
		result = MyString.getMemInfo(1023);
		assertNotNull(result);
		assertEquals(""1023.00 B"", result);
		
		result = MyString.getMemInfo(1024);
		assertNotNull(result);
		assertEquals(""1.00 KB"", result);
		
		result = MyString.getMemInfo(1048575);
		assertNotNull(result);
		assertEquals(""1023.99 KB"", result);
		
		result = MyString.getMemInfo(1048576);
		assertNotNull(result);
		assertEquals(""1.00 MB"", result);
		
		result = MyString.getMemInfo(1073741823);
		assertNotNull(result);
		assertEquals(""1023.99 MB"", result);
		
		result = MyString.getMemInfo(1073741824);
		assertNotNull(result);
		assertEquals(""1.00 GB"", result);
	}
}

// MyString_7Test.java
package org.quickserver.util;

import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MyString}.
* It contains ten unit test cases for the {@link MyString#alignLeft(String, int)} method.
*/
class MyString_7Test {
		
	@Test
	void testAlignLeft() {
		String result = MyString.alignLeft("""", 0);
		assertNotNull(result);
		assertEquals("""", result);
		
		result = MyString.alignLeft("""", 1);
		assertNotNull(result);
		assertEquals("" "", result);
		
		result = MyString.alignLeft("""", 2);
		assertNotNull(result);
		assertEquals(""  "", result);
		
		result = MyString.alignLeft("""", 3);
		assertNotNull(result);
		assertEquals(""   "", result);
		
		result = MyString.alignLeft("""", 4);
		assertNotNull(result);
		assertEquals(""    "", result);
		
		result = MyString.alignLeft("""", 5);
		assertNotNull(result);
		assertEquals(""     "", result);
		
		result = MyString.alignLeft("""", 6);
		assertNotNull(result);
		assertEquals(""      "", result);
		
		result = MyString.alignLeft("""", 7);
		assertNotNull(result);
		assertEquals(""       "", result);
		
		result = MyString.alignLeft("""", 8);
		assertNotNull(result);
		assertEquals(""        "", result);
		
		result = MyString.alignLeft("""", 9);
		assertNotNull(result);
		assertEquals(""         "", result);
		
		result = MyString.alignLeft("""", 10);
		assertNotNull(result);
		assertEquals(""          "", result);
		
		result = MyString.alignLeft("""", 11);
		assertNotNull(result);
		assertEquals(""           "", result);
		
		result = MyString.alignLeft("""", 12);
		assertNotNull(result);
		assertEquals(""            "", result);
		
		result = MyString.alignLeft("""", 13);
		assertNotNull(result);
		assertEquals(""             "", result);
		
		result = MyString.alignLeft("""", 14);
		assertNotNull(result);
		assertEquals(""              "", result);
		
		result = MyString.alignLeft("""", 15);
		assertNotNull(result);
		assertEquals(""               "", result);
		
		result = MyString.alignLeft("""", 16);
		assertNotNull(result);
		assertEquals(""                "", result);
		
		result = MyString.alignLeft("""", 17);
		assertNotNull(result);
		assertEquals(""                 "", result);
		
		result = MyString.alignLeft("""", 18);
		assertNotNull(result);
		assertEquals(""                  "", result);
		
		result = MyString.alignLeft("""", 19);
		assertNotNull(result);
		assertEquals(""                   "", result);
		
		result = MyString.alignLeft("""", 20);
		assertNotNull(result);
		assertEquals(""                    "", result);
		
		result = MyString.alignLeft("""", 21);
		assertNotNull(result);
		assertEquals(""                     "", result);
		
		result = MyString.alignLeft("""", 22);
		assertNotNull(result);
		assertEquals(""                      "", result);
		
		result = MyString.alignLeft("""", 23);
		assertNotNull(result);
		assertEquals(""                       "", result);
		
		result = MyString.alignLeft("""", 24);
		assertNotNull(result);
		assertEquals(""                        "", result);
		
		result = MyString.alignLeft("""", 25);
		assertNotNull(result);
		assertEquals(""                         "", result);
		
		result = MyString.alignLeft("""", 26);
		assertNotNull(result);
		assertEquals(""                          "", result);
		
		result = MyString.alignLeft("""", 27);
		assertNotNull(result);
		assertEquals(""                           "", result);
		
		result = MyString.alignLeft("""", 28);
		assertNotNull(result);
		assertEquals(""                            "", result);
		
		result = MyString.alignLeft("""", 29);
		assertNotNull(result);
		assertEquals(""                             "", result);
		
		result = MyString.alignLeft("""", 30);
		assert"
cmpl-6tzGkIxzQ5VelxZrAzbgiFoHfEveT,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/TextFile_0Test.java,68.0364818572998,length,"// TextFile.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;
import java.util.*;

/**
 * Static functions for reading and writing text files as
 * a single string, and treating a file as an ArrayList.
 */
public class TextFile extends ArrayList {

    /**
     * Read file as single string.
     */
    public static String read(String fileName) throws IOException {
        File file = new File(fileName);
        return read(file);
    }

    /**
     * Read file as single string.
     */
    public static String read(File fileName) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedInputStream bis = null;
        try {
            bis = new BufferedInputStream(new FileInputStream(fileName));
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
        }
        return sb.toString();
    }

    /**
     * Write file from a single string.
     */
    public static void write(String fileName, String text) throws IOException {
        File file = new File(fileName);
        write(file, text);
    }

    /**
     * Write file from a single string.
     */
    public static void write(File file, String text) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(file, false)));
            out.print(text);
        } finally {
            if (out != null)
                out.close();
        }
    }

    public TextFile(String fileName) throws IOException {
        super(Arrays.asList(read(fileName).split(""\n"")));
    }

    /**
     * Write file from a single string.
     */
    public void write(String fileName) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
            for (int i = 0; i < size(); i++) out.println(get(i));
        } finally {
            if (out != null)
                out.close();
        }
    }

    /**
     * Read file as single string.
     */
    public static String read(String fileName, Object parent) throws IOException {
        StringBuilder sb = new StringBuilder();
        InputStream is = null;
        BufferedInputStream bis = null;
        try {
            is = parent.getClass().getResourceAsStream(fileName);
            bis = new BufferedInputStream(is);
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
            if (is != null)
                is.close();
        }
        return sb.toString();
    }
}
","// TextFile_0Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String)} method.
*/
class TextFile_0Test {","// TextFile_0Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String)} method.
*/
class TextFile_0Test {

	@Test
	void testRead_0() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_1() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_2() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_3() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_4() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_5() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_6() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_7() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_8() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_9() throws IOException {
		String fileName = ""test.txt"";
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
}

// TextFile_1Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String, Object)} method.
*/
class TextFile_1Test {
		
	@Test
	void testRead_0() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_1() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_2() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_3() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_4() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_5() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_6() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_7() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_8() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_9() throws IOException {
		String fileName = ""test.txt"";
		Object parent = new Object();
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName, parent);
		assertEquals(expected, actual);
	}
	
}

// TextFile_2Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(File)} method.
*/
class TextFile_2Test {
		
	@Test
	void testRead_0() throws IOException {
		File fileName = new File(""test.txt"");
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_1() throws IOException {
		File fileName = new File(""test.txt"");
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals(expected, actual);
	}
	
	@Test
	void testRead_2() throws IOException {
		File fileName = new File(""test.txt"");
		String expected = ""This is a test file."";
		String actual = TextFile.read(fileName);
		assertEquals"
cmpl-6tzHqbhlmGigixvezRtE0jwQRv4QQ,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/TextFile_1Test.java,59.1612594127655,length,"// TextFile.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;
import java.util.*;

/**
 * Static functions for reading and writing text files as
 * a single string, and treating a file as an ArrayList.
 */
public class TextFile extends ArrayList {

    /**
     * Read file as single string.
     */
    public static String read(String fileName) throws IOException {
        File file = new File(fileName);
        return read(file);
    }

    /**
     * Read file as single string.
     */
    public static String read(File fileName) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedInputStream bis = null;
        try {
            bis = new BufferedInputStream(new FileInputStream(fileName));
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
        }
        return sb.toString();
    }

    /**
     * Write file from a single string.
     */
    public static void write(String fileName, String text) throws IOException {
        File file = new File(fileName);
        write(file, text);
    }

    /**
     * Write file from a single string.
     */
    public static void write(File file, String text) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(file, false)));
            out.print(text);
        } finally {
            if (out != null)
                out.close();
        }
    }

    public TextFile(String fileName) throws IOException {
        super(Arrays.asList(read(fileName).split(""\n"")));
    }

    /**
     * Write file from a single string.
     */
    public void write(String fileName) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
            for (int i = 0; i < size(); i++) out.println(get(i));
        } finally {
            if (out != null)
                out.close();
        }
    }

    /**
     * Read file as single string.
     */
    public static String read(String fileName, Object parent) throws IOException {
        StringBuilder sb = new StringBuilder();
        InputStream is = null;
        BufferedInputStream bis = null;
        try {
            is = parent.getClass().getResourceAsStream(fileName);
            bis = new BufferedInputStream(is);
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
            if (is != null)
                is.close();
        }
        return sb.toString();
    }
}
","// TextFile_1Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(File)} method.
*/
class TextFile_1Test {","// TextFile_1Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(File)} method.
*/
class TextFile_1Test {

	@Test
	public void testRead_1() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_2() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_3() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_4() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_5() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_6() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_7() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_8() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_9() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_10() throws IOException {
		File file = new File(""test.txt"");
		String text = TextFile.read(file);
		assertEquals(""This is a test file."", text);
	}
}

// TextFile_2Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String)} method.
*/
class TextFile_2Test {
		
	@Test
	public void testRead_1() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_2() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_3() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_4() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_5() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_6() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_7() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_8() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_9() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
	
	@Test
	public void testRead_10() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName);
		assertEquals(""This is a test file."", text);
	}
}

// TextFile_3Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#write(File, String)} method.
*/
class TextFile_3Test {
		
	@Test
	public void testWrite_1() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_2() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_3() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_4() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_5() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_6() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";
		TextFile.write(file, text);
		assertEquals(text, TextFile.read(file));
	}
	
	@Test
	public void testWrite_7() throws IOException {
		File file = new File(""test.txt"");
		String text = ""This is a test file."";"
cmpl-6tzItPD0jUSWkEekrhAZ5qIAdeVrp,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/TextFile_2Test.java,31.900949001312256,stop,"// TextFile.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.io.*;
import java.util.*;

/**
 * Static functions for reading and writing text files as
 * a single string, and treating a file as an ArrayList.
 */
public class TextFile extends ArrayList {

    /**
     * Read file as single string.
     */
    public static String read(String fileName) throws IOException {
        File file = new File(fileName);
        return read(file);
    }

    /**
     * Read file as single string.
     */
    public static String read(File fileName) throws IOException {
        StringBuilder sb = new StringBuilder();
        BufferedInputStream bis = null;
        try {
            bis = new BufferedInputStream(new FileInputStream(fileName));
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
        }
        return sb.toString();
    }

    /**
     * Write file from a single string.
     */
    public static void write(String fileName, String text) throws IOException {
        File file = new File(fileName);
        write(file, text);
    }

    /**
     * Write file from a single string.
     */
    public static void write(File file, String text) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(file, false)));
            out.print(text);
        } finally {
            if (out != null)
                out.close();
        }
    }

    public TextFile(String fileName) throws IOException {
        super(Arrays.asList(read(fileName).split(""\n"")));
    }

    /**
     * Write file from a single string.
     */
    public void write(String fileName) throws IOException {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
            for (int i = 0; i < size(); i++) out.println(get(i));
        } finally {
            if (out != null)
                out.close();
        }
    }

    /**
     * Read file as single string.
     */
    public static String read(String fileName, Object parent) throws IOException {
        StringBuilder sb = new StringBuilder();
        InputStream is = null;
        BufferedInputStream bis = null;
        try {
            is = parent.getClass().getResourceAsStream(fileName);
            bis = new BufferedInputStream(is);
            byte[] buffer = new byte[1024];
            int len = 0;
            do {
                len = bis.read(buffer, 0, buffer.length);
                if (len == -1)
                    break;
                sb.append(new String(buffer, 0, len));
            } while (true);
        } finally {
            if (bis != null)
                bis.close();
            if (is != null)
                is.close();
        }
        return sb.toString();
    }
}
","// TextFile_2Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String, Object)} method.
*/
class TextFile_2Test {","// TextFile_2Test.java
package org.quickserver.util;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextFile}.
* It contains ten unit test cases for the {@link TextFile#read(String, Object)} method.
*/
class TextFile_2Test {

	@Test
	void testRead_1() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_2() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_3() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_4() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_5() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_6() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_7() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_8() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_9() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
	
	@Test
	void testRead_10() throws IOException {
		String fileName = ""test.txt"";
		String text = TextFile.read(fileName, this);
		assertEquals(""This is a test file.\n"", text);
	}
}</code>





A:

I think you are looking for something like this:
<code>@Test
void testRead_1() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_2() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_3() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_4() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_5() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_6() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_7() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_8() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_9() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}

@Test
void testRead_10() throws IOException {
    String fileName = ""test.txt"";
    String text = TextFile.read(fileName, this);
    assertEquals(""This is a test file.\n"", text);
}
</code>
"
cmpl-6tzJwmQZvjv3Xu3JSne8KjSqjScDo,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream_0Test.java,59.54402136802673,length,"// ByteBufferInputStream.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;

/**
 * This is an InputStream constructed from list of ByteBuffers. This is
 * used in non-blocking mode.
 * @since 1.4.5
 * @author Akshathkumar Shetty
 */
public class ByteBufferInputStream extends InputStream {

    private static final Logger logger = Logger.getLogger(ByteBufferInputStream.class.getName());

    static {
        logger.setLevel(Level.INFO);
    }

    /**
     * Sets the debug flag.
     */
    public static void setDebug(boolean flag) {
        if (flag)
            logger.setLevel(Level.FINEST);
        else
            logger.setLevel(Level.INFO);
    }

    /**
     * @since 1.4.7
     */
    public static boolean isLoggable(Level level) {
        return logger.isLoggable(level);
    }

    private final ArrayList bufferList;

    private ClientHandler handler;

    private CharsetDecoder decoder;

    private CharsetEncoder encoder;

    private StringBuilder strings;

    private int pos = 0;

    private int index = -1;

    private int start = 0;

    private boolean lookingForLineFeed = false;

    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {
        if (bufferList == null || handler == null)
            throw new IllegalArgumentException(""ArrayList or ClientHandler was null."");
        this.bufferList = bufferList;
        this.handler = handler;
        Charset _charset = Charset.forName(charset);
        decoder = _charset.newDecoder();
        encoder = _charset.newEncoder();
        strings = new StringBuilder();
    }

    public synchronized int availableOnlyInByteBuffer() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        logger.finest(""count: "" + count);
        return count;
    }

    public synchronized int available() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        if (lookingForLineFeed) {
            char c = '\0';
            if (strings.length() != 0) {
                c = strings.charAt(0);
                if (c == '\n') {
                    strings.deleteCharAt(0);
                    lookingForLineFeed = false;
                }
            } else {
                while (!bufferList.isEmpty()) {
                    byteBuffer = (ByteBuffer) bufferList.get(0);
                    if (byteBuffer.remaining() == 0) {
                        returnBufferBack();
                        continue;
                    }
                    int p = byteBuffer.position();
                    c = (char) byteBuffer.get(p);
                    if (c == '\n') {
                        //move position
                        byteBuffer.get();
                        lookingForLineFeed = false;
                    }
                    break;
                }
                //end of while
            }
        }
        count += strings.length();
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        //logger.finest(""count: ""+count);
        return count;
    }

    public synchronized void close() throws IOException {
        if (handler.getSocketChannel() != null)
            handler.getSocketChannel().close();
        //handler.closeConnection();
    }

    public boolean markSupported() {
        return false;
    }

    public synchronized int read() throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        while (!bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int lflfChar = (int) byteBuffer.get();
                lookingForLineFeed = false;
                if (lflfChar == (int) '\n') {
                    continue;
                } else {
                    return lflfChar;
                }
            } else {
                return (int) byteBuffer.get();
            }
        }
        return read();
    }

    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    public synchronized int read(byte[] b, int off, int len) throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                //ie.printStackTrace();
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        int read = 0;
        int remaining = 0;
        int toRead = len;
        do {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            remaining = byteBuffer.remaining();
            if (remaining == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int p = byteBuffer.position();
                byte lflfChar = byteBuffer.get(p);
                lookingForLineFeed = false;
                if (lflfChar == (byte) '\n') {
                    //move position
                    byteBuffer.get();
                    continue;
                }
            }
            if (remaining < toRead) {
                byteBuffer.get(b, off, remaining);
                off = off + remaining;
                read = read + remaining;
                toRead = toRead - remaining;
            } else {
                byteBuffer.get(b, off, toRead);
                read = read + toRead;
                return read;
            }
        } while (!bufferList.isEmpty());
        return read;
    }

    public long skip(long n) throws IOException {
        if (n < 0)
            return 0;
        int s = 0;
        for (; s < n; s++) {
            if (read() == -1)
                break;
        }
        return s;
    }

    private void addStringsBackAsBuffer() {
        try {
            ByteBuffer borrowBuffer = null;
            ByteBuffer bb = encoder.encode(CharBuffer.wrap(strings));
            strings.setLength(0);
            do {
                if (borrowBuffer == null) {
                    borrowBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
                }
                borrowBuffer.put(bb.get());
                if (borrowBuffer.hasRemaining() == false) {
                    borrowBuffer.flip();
                    bufferList.add(0, borrowBuffer);
                    borrowBuffer = null;
                }
            } while (bb.hasRemaining());
            if (borrowBuffer != null) {
                borrowBuffer.flip();
                bufferList.add(0, borrowBuffer);
            }
        } catch (Exception er) {
            logger.warning(""Error : "" + er);
        }
        start = 0;
        index = -1;
        pos = 0;
    }

    private void returnBufferBack() {
        returnBufferBack((ByteBuffer) bufferList.remove(0));
    }

    private void returnBufferBack(ByteBuffer byteBuffer) {
        try {
            handler.getServer().getByteBufferPool().returnObject(byteBuffer);
        } catch (Exception er) {
            logger.warning(""Error while returning ByteBuffer to pool: "" + er);
        }
    }

    //-- extra helpers
    /**
     * Checks if a line of String is ready to be read.
     * @throws IOException if connection is lost or closed.
     */
    public synchronized boolean isLineReady() throws IOException {
        handler.isConnected();
        boolean result = false;
        result = isLineReadyForStringBuilder();
        if (result == true || bufferList.isEmpty()) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(""result: "" + result);
            return result;
        }
        ByteBuffer byteBuffer = null;
        CharBuffer charBuffer = null;
        while (result == false && !bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            charBuffer = decoder.decode(byteBuffer);
            if (charBuffer == null) {
                returnBufferBack();
                continue;
            }
            strings.append(charBuffer);
            returnBufferBack();
            result = isLineReadyForStringBuilder();
        }
        //end of while
        if (logger.isLoggable(Level.FINEST))
            logger.finest(""result: "" + result);
        return result;
    }

    private boolean isLineReadyForStringBuilder() {
        if (index != -1)
            return true;
        int stringsLength = strings.length();
        while (pos < stringsLength) {
            char c = strings.charAt(pos);
            if (c == '\n') {
                if (lookingForLineFeed) {
                    strings.deleteCharAt(0);
                    stringsLength--;
                    lookingForLineFeed = false;
                    continue;
                } else {
                    index = pos;
                    pos++;
                    return true;
                }
            }
            if (c == '\r') {
                index = pos;
                lookingForLineFeed = true;
                pos++;
                return true;
            } else {
                pos++;
                lookingForLineFeed = false;
            }
        }
        return false;
    }

    /**
     * Reads a line of String if ready. If line is not yet ready this will
     * block. To find out if the line is ready use <code>isLineReady()</code>
     * @see #isLineReady()
     */
    public synchronized String readLine() throws IOException {
        if (index == -1) {
            while (isLineReady() == false) {
                try {
                    wait();
                } catch (InterruptedException ie) {
                    logger.warning(""InterruptedException: "" + ie);
                    return null;
                }
            }
        }
        int stringsLength = strings.length();
        Assertion.affirm(index <= stringsLength);
        String data = strings.substring(start, index);
        if (pos < stringsLength)
            strings.delete(0, pos);
        else
            strings.setLength(0);
        start = 0;
        pos = start;
        index = -1;
        return data;
    }

    public void dumpContent() {
        if (logger.isLoggable(Level.FINE) == false) {
            //logger.warning(""Can't precede. Logging level FINE is not loggable! "");
            return;
        }
        logger.fine(""Start of dump.."");
        synchronized (bufferList) {
            int size = bufferList.size();
            ByteBuffer byteBuffer = null;
            if (strings.length() != 0) {
                logger.fine(""[decoded] "" + strings);
            }
            for (int c = 0; c < size; c++) {
                byteBuffer = (ByteBuffer) bufferList.get(c);
                try {
                    logger.fine(""["" + c + ""] "" + decoder.decode(byteBuffer.duplicate()));
                } catch (Exception e) {
                    logger.fine(""["" + c + ""] Error : "" + e);
                }
            }
        }
        logger.fine(""End of dump.."");
    }
}
","// ByteBufferInputStream_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#isLoggable(Level)} method.
*/
class ByteBufferInputStream_0Test {","// ByteBufferInputStream_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#isLoggable(Level)} method.
*/
class ByteBufferInputStream_0Test {

	@Test
	void testIsLoggable_0() {
		ByteBufferInputStream.setDebug(true);
		assertTrue(ByteBufferInputStream.isLoggable(Level.FINEST));
	}
	
	@Test
	void testIsLoggable_1() {
		ByteBufferInputStream.setDebug(false);
		assertTrue(ByteBufferInputStream.isLoggable(Level.INFO));
	}
	
	@Test
	void testIsLoggable_2() {
		ByteBufferInputStream.setDebug(true);
		assertTrue(ByteBufferInputStream.isLoggable(Level.INFO));
	}
	
	@Test
	void testIsLoggable_3() {
		ByteBufferInputStream.setDebug(false);
		assertFalse(ByteBufferInputStream.isLoggable(Level.FINEST));
	}
	
	@Test
	void testIsLoggable_4() {
		ByteBufferInputStream.setDebug(true);
		assertTrue(ByteBufferInputStream.isLoggable(Level.WARNING));
	}
	
	@Test
	void testIsLoggable_5() {
		ByteBufferInputStream.setDebug(false);
		assertTrue(ByteBufferInputStream.isLoggable(Level.WARNING));
	}
	
	@Test
	void testIsLoggable_6() {
		ByteBufferInputStream.setDebug(true);
		assertTrue(ByteBufferInputStream.isLoggable(Level.SEVERE));
	}
	
	@Test
	void testIsLoggable_7() {
		ByteBufferInputStream.setDebug(false);
		assertTrue(ByteBufferInputStream.isLoggable(Level.SEVERE));
	}
	
	@Test
	void testIsLoggable_8() {
		ByteBufferInputStream.setDebug(true);
		assertTrue(ByteBufferInputStream.isLoggable(Level.CONFIG));
	}
	
	@Test
	void testIsLoggable_9() {
		ByteBufferInputStream.setDebug(false);
		assertTrue(ByteBufferInputStream.isLoggable(Level.CONFIG));
	}
	
}

// ByteBufferInputStream_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#available()} method.
*/
class ByteBufferInputStream_1Test {
		
	@Test
	void testAvailable_0() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		assertEquals(0, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_1() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		assertEquals(5, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_2() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		assertEquals(4, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_3() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		assertEquals(3, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_4() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		assertEquals(2, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_5() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		assertEquals(1, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_6() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		assertEquals(0, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_7() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		assertEquals(0, byteBufferInputStream.available());
	}
	
	@Test
	void testAvailable_8() throws IOException {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new ClientHandler();
		ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(bufferList, handler, ""UTF-8"");
		ByteBuffer byteBuffer = ByteBuffer.wrap(""Hello"".getBytes());
		bufferList.add(byteBuffer);
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream.read();
		byteBufferInputStream."
cmpl-6tzKzRgyaIL01FYGSTqBKlyOnEBKn,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream_8Test.java,58.615116596221924,length,"// ByteBufferInputStream.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;

/**
 * This is an InputStream constructed from list of ByteBuffers. This is
 * used in non-blocking mode.
 * @since 1.4.5
 * @author Akshathkumar Shetty
 */
public class ByteBufferInputStream extends InputStream {

    private static final Logger logger = Logger.getLogger(ByteBufferInputStream.class.getName());

    static {
        logger.setLevel(Level.INFO);
    }

    /**
     * Sets the debug flag.
     */
    public static void setDebug(boolean flag) {
        if (flag)
            logger.setLevel(Level.FINEST);
        else
            logger.setLevel(Level.INFO);
    }

    /**
     * @since 1.4.7
     */
    public static boolean isLoggable(Level level) {
        return logger.isLoggable(level);
    }

    private final ArrayList bufferList;

    private ClientHandler handler;

    private CharsetDecoder decoder;

    private CharsetEncoder encoder;

    private StringBuilder strings;

    private int pos = 0;

    private int index = -1;

    private int start = 0;

    private boolean lookingForLineFeed = false;

    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {
        if (bufferList == null || handler == null)
            throw new IllegalArgumentException(""ArrayList or ClientHandler was null."");
        this.bufferList = bufferList;
        this.handler = handler;
        Charset _charset = Charset.forName(charset);
        decoder = _charset.newDecoder();
        encoder = _charset.newEncoder();
        strings = new StringBuilder();
    }

    public synchronized int availableOnlyInByteBuffer() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        logger.finest(""count: "" + count);
        return count;
    }

    public synchronized int available() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        if (lookingForLineFeed) {
            char c = '\0';
            if (strings.length() != 0) {
                c = strings.charAt(0);
                if (c == '\n') {
                    strings.deleteCharAt(0);
                    lookingForLineFeed = false;
                }
            } else {
                while (!bufferList.isEmpty()) {
                    byteBuffer = (ByteBuffer) bufferList.get(0);
                    if (byteBuffer.remaining() == 0) {
                        returnBufferBack();
                        continue;
                    }
                    int p = byteBuffer.position();
                    c = (char) byteBuffer.get(p);
                    if (c == '\n') {
                        //move position
                        byteBuffer.get();
                        lookingForLineFeed = false;
                    }
                    break;
                }
                //end of while
            }
        }
        count += strings.length();
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        //logger.finest(""count: ""+count);
        return count;
    }

    public synchronized void close() throws IOException {
        if (handler.getSocketChannel() != null)
            handler.getSocketChannel().close();
        //handler.closeConnection();
    }

    public boolean markSupported() {
        return false;
    }

    public synchronized int read() throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        while (!bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int lflfChar = (int) byteBuffer.get();
                lookingForLineFeed = false;
                if (lflfChar == (int) '\n') {
                    continue;
                } else {
                    return lflfChar;
                }
            } else {
                return (int) byteBuffer.get();
            }
        }
        return read();
    }

    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    public synchronized int read(byte[] b, int off, int len) throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                //ie.printStackTrace();
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        int read = 0;
        int remaining = 0;
        int toRead = len;
        do {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            remaining = byteBuffer.remaining();
            if (remaining == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int p = byteBuffer.position();
                byte lflfChar = byteBuffer.get(p);
                lookingForLineFeed = false;
                if (lflfChar == (byte) '\n') {
                    //move position
                    byteBuffer.get();
                    continue;
                }
            }
            if (remaining < toRead) {
                byteBuffer.get(b, off, remaining);
                off = off + remaining;
                read = read + remaining;
                toRead = toRead - remaining;
            } else {
                byteBuffer.get(b, off, toRead);
                read = read + toRead;
                return read;
            }
        } while (!bufferList.isEmpty());
        return read;
    }

    public long skip(long n) throws IOException {
        if (n < 0)
            return 0;
        int s = 0;
        for (; s < n; s++) {
            if (read() == -1)
                break;
        }
        return s;
    }

    private void addStringsBackAsBuffer() {
        try {
            ByteBuffer borrowBuffer = null;
            ByteBuffer bb = encoder.encode(CharBuffer.wrap(strings));
            strings.setLength(0);
            do {
                if (borrowBuffer == null) {
                    borrowBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
                }
                borrowBuffer.put(bb.get());
                if (borrowBuffer.hasRemaining() == false) {
                    borrowBuffer.flip();
                    bufferList.add(0, borrowBuffer);
                    borrowBuffer = null;
                }
            } while (bb.hasRemaining());
            if (borrowBuffer != null) {
                borrowBuffer.flip();
                bufferList.add(0, borrowBuffer);
            }
        } catch (Exception er) {
            logger.warning(""Error : "" + er);
        }
        start = 0;
        index = -1;
        pos = 0;
    }

    private void returnBufferBack() {
        returnBufferBack((ByteBuffer) bufferList.remove(0));
    }

    private void returnBufferBack(ByteBuffer byteBuffer) {
        try {
            handler.getServer().getByteBufferPool().returnObject(byteBuffer);
        } catch (Exception er) {
            logger.warning(""Error while returning ByteBuffer to pool: "" + er);
        }
    }

    //-- extra helpers
    /**
     * Checks if a line of String is ready to be read.
     * @throws IOException if connection is lost or closed.
     */
    public synchronized boolean isLineReady() throws IOException {
        handler.isConnected();
        boolean result = false;
        result = isLineReadyForStringBuilder();
        if (result == true || bufferList.isEmpty()) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(""result: "" + result);
            return result;
        }
        ByteBuffer byteBuffer = null;
        CharBuffer charBuffer = null;
        while (result == false && !bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            charBuffer = decoder.decode(byteBuffer);
            if (charBuffer == null) {
                returnBufferBack();
                continue;
            }
            strings.append(charBuffer);
            returnBufferBack();
            result = isLineReadyForStringBuilder();
        }
        //end of while
        if (logger.isLoggable(Level.FINEST))
            logger.finest(""result: "" + result);
        return result;
    }

    private boolean isLineReadyForStringBuilder() {
        if (index != -1)
            return true;
        int stringsLength = strings.length();
        while (pos < stringsLength) {
            char c = strings.charAt(pos);
            if (c == '\n') {
                if (lookingForLineFeed) {
                    strings.deleteCharAt(0);
                    stringsLength--;
                    lookingForLineFeed = false;
                    continue;
                } else {
                    index = pos;
                    pos++;
                    return true;
                }
            }
            if (c == '\r') {
                index = pos;
                lookingForLineFeed = true;
                pos++;
                return true;
            } else {
                pos++;
                lookingForLineFeed = false;
            }
        }
        return false;
    }

    /**
     * Reads a line of String if ready. If line is not yet ready this will
     * block. To find out if the line is ready use <code>isLineReady()</code>
     * @see #isLineReady()
     */
    public synchronized String readLine() throws IOException {
        if (index == -1) {
            while (isLineReady() == false) {
                try {
                    wait();
                } catch (InterruptedException ie) {
                    logger.warning(""InterruptedException: "" + ie);
                    return null;
                }
            }
        }
        int stringsLength = strings.length();
        Assertion.affirm(index <= stringsLength);
        String data = strings.substring(start, index);
        if (pos < stringsLength)
            strings.delete(0, pos);
        else
            strings.setLength(0);
        start = 0;
        pos = start;
        index = -1;
        return data;
    }

    public void dumpContent() {
        if (logger.isLoggable(Level.FINE) == false) {
            //logger.warning(""Can't precede. Logging level FINE is not loggable! "");
            return;
        }
        logger.fine(""Start of dump.."");
        synchronized (bufferList) {
            int size = bufferList.size();
            ByteBuffer byteBuffer = null;
            if (strings.length() != 0) {
                logger.fine(""[decoded] "" + strings);
            }
            for (int c = 0; c < size; c++) {
                byteBuffer = (ByteBuffer) bufferList.get(c);
                try {
                    logger.fine(""["" + c + ""] "" + decoder.decode(byteBuffer.duplicate()));
                } catch (Exception e) {
                    logger.fine(""["" + c + ""] Error : "" + e);
                }
            }
        }
        logger.fine(""End of dump.."");
    }
}
","// ByteBufferInputStream_8Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
*/
class ByteBufferInputStream_8Test {","// ByteBufferInputStream_8Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
*/
class ByteBufferInputStream_8Test {

	private static final Logger logger = Logger.getLogger(ByteBufferInputStream_8Test.class.getName());
	
	static {
		logger.setLevel(Level.INFO);
	}
	
	private static final String charset = ""UTF-8"";
	
	private static final String lineSeparator = System.getProperty(""line.separator"");
	
	private static final String testString = ""This is a test string."";
	
	private static final String testString_1 = ""This is a test string."" + lineSeparator;
	
	private static final String testString_2 = ""This is a test string."" + lineSeparator + lineSeparator;
	
	private static final String testString_3 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_4 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_5 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_6 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_7 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_8 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_9 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_10 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_11 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_12 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_13 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_14 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_15 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_16 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_17 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_18 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_19 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_20 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_21 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_22 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_23 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_24 = ""This is a test string."" + lineSeparator + lineSep"
cmpl-6tzM2Nqhe1SySR4sPPLJwtd2gEjIj,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferOutputStream_0Test.java,49.298787117004395,length,"// ByteBufferOutputStream.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.util.*;
import org.apache.commons.pool.ObjectPool;
import org.quickserver.net.server.ClientHandler;
import org.quickserver.net.server.impl.NonBlockingClientHandler;
import java.util.logging.*;

/**
 * This is an OutputStream constructed from list of ByteBuffers. This is
 * used in non-blocking mode.
 * @since 1.4.5
 * @author Akshathkumar Shetty
 */
public class ByteBufferOutputStream extends OutputStream {

    private static Logger logger = Logger.getLogger(ByteBufferOutputStream.class.getName());

    static {
        logger.setLevel(Level.INFO);
    }

    /**
     * Sets the debug flag. When debug is set to <code>true</code>
     * one can see number of bytes written.
     */
    public static void setDebug(boolean flag) {
        if (flag)
            logger.setLevel(Level.FINEST);
        else
            logger.setLevel(Level.INFO);
    }

    /**
     * @since 1.4.7
     */
    public static boolean isLoggable(Level level) {
        return logger.isLoggable(level);
    }

    private ArrayList bufferList;

    private ByteBuffer lastByteBuffer = null;

    private NonBlockingClientHandler handler;

    private Object toNotify = null;

    private ArrayList encryptedBufferList;

    /**
     * Creates a new ByteBufferOutputStream using the given list as its base
     * and ClientHandler as the target channel.
     */
    public ByteBufferOutputStream(ArrayList bufferList, ClientHandler handler) {
        if (bufferList == null || handler == null)
            throw new IllegalArgumentException(""ArrayList or ClientHandler was null."");
        this.bufferList = bufferList;
        this.handler = (NonBlockingClientHandler) handler;
        if (handler.isSecure()) {
            encryptedBufferList = new ArrayList();
        }
    }

    public synchronized void close() {
        if (lastByteBuffer != null) {
            returnBufferBack(lastByteBuffer);
        }
    }

    public void flush() throws IOException {
        if (bufferList.size() != 0 || lastByteBuffer != null) {
            handler.registerWrite();
        } else {
            return;
        }
        while (bufferList.size() >= 5) {
            handler.waitTillFullyWritten();
        }
    }

    public synchronized void write(int b) throws IOException {
        handler.isConnected();
        ByteBuffer byteBuffer = null;
        if (bufferList.size() != 0) {
            byteBuffer = (ByteBuffer) bufferList.remove(bufferList.size() - 1);
            if (byteBuffer.remaining() == 0) {
                bufferList.add(byteBuffer);
                byteBuffer = null;
            }
        }
        try {
            if (byteBuffer == null) {
                byteBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
            }
        } catch (Exception e) {
            logger.warning(""Could not borrow ByteBufer from pool: "" + e);
            throw new IOException(e.toString());
        }
        byteBuffer.put((byte) b);
        bufferList.add(byteBuffer);
    }

    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }

    public synchronized void write(byte[] b, int off, int len) throws IOException {
        if (len == 0) {
            return;
        }
        handler.isConnected();
        ByteBuffer byteBuffer = null;
        int remaining = 0;
        int toWrite = len;
        if (toWrite != 0 && bufferList.size() != 0) {
            byteBuffer = (ByteBuffer) bufferList.remove(bufferList.size() - 1);
            if (byteBuffer.remaining() == 0) {
                bufferList.add(byteBuffer);
                byteBuffer = null;
            }
        }
        while (toWrite != 0) {
            try {
                if (byteBuffer == null) {
                    byteBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
                }
            } catch (Exception e) {
                logger.warning(""Could not borrow ByteBufer from pool: "" + e);
                throw new IOException(e.toString());
            }
            remaining = byteBuffer.remaining();
            if (remaining < toWrite) {
                byteBuffer.put(b, off, remaining);
                off = off + remaining;
                toWrite = toWrite - remaining;
            } else {
                byteBuffer.put(b, off, toWrite);
                toWrite = 0;
            }
            bufferList.add(byteBuffer);
            byteBuffer = null;
        }
    }

    public synchronized boolean writeAllByteBuffer() throws IOException {
        if (lastByteBuffer != null) {
            writeLastByteBuffer();
            if (lastByteBuffer != null)
                return false;
        }
        ByteBuffer dest = null;
        while (bufferList.size() != 0) {
            dest = (ByteBuffer) bufferList.remove(0);
            if (handler.isSecure() == false) {
                lastByteBuffer = dest;
                lastByteBuffer.flip();
                writeLastByteBuffer();
                if (lastByteBuffer != null)
                    return false;
            } else {
                lastByteBuffer = handler.encrypt(dest);
                if (lastByteBuffer == null) {
                    //coult not enc.. lets wait..
                    bufferList.add(0, dest);
                    return false;
                }
                addEncryptedByteBuffer(lastByteBuffer);
                lastByteBuffer = null;
            }
        }
        while (encryptedBufferList != null && encryptedBufferList.size() != 0) {
            lastByteBuffer = (ByteBuffer) encryptedBufferList.remove(0);
            logger.fine(""Sening to peer: "" + lastByteBuffer.position());
            lastByteBuffer.flip();
            writeLastByteBuffer();
            if (lastByteBuffer != null)
                return false;
        }
        if (toNotify != null) {
            synchronized (toNotify) {
                toNotify.notify();
                toNotify = null;
            }
        }
        logger.fine(""writeAllByteBuffer is true!"");
        return true;
    }

    private synchronized void writeLastByteBuffer() throws IOException {
        int written = 0;
        while (lastByteBuffer.remaining() != 0) {
            java.nio.channels.SocketChannel sc = handler.getSocketChannel();
            if (sc != null && sc.isOpen()) {
                written = sc.write(lastByteBuffer);
                if (written == 0) {
                    break;
                }
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""Written "" + written + "" bytes"");
                }
            } else {
                throw new IOException(""SocketChannel was closed."");
            }
        }
        if (lastByteBuffer.remaining() == 0) {
            returnBufferBack(lastByteBuffer);
            lastByteBuffer = null;
        }
    }

    private void returnBufferBack(ByteBuffer byteBuffer) {
        try {
            handler.getServer().getByteBufferPool().returnObject(byteBuffer);
        } catch (Exception er) {
            logger.warning(""Error while returning ByteBuffer to pool: "" + er);
        }
    }

    public void forceNotify() {
        if (toNotify == null)
            return;
        synchronized (toNotify) {
            toNotify.notify();
            toNotify = null;
        }
    }

    public boolean isDataAvailableForWrite(Object toNotify) {
        if (lastByteBuffer != null) {
            if (this.toNotify != null) {
                throw new IllegalStateException(""toNotify object was already set!"");
            }
            this.toNotify = toNotify;
            return true;
        }
        if (bufferList.size() == 0) {
            return false;
        } else {
            if (this.toNotify != null) {
                throw new IllegalStateException(""toNotify object was already set!"");
            }
            this.toNotify = toNotify;
            return true;
        }
    }

    public void addEncryptedByteBuffer(ByteBuffer buff) {
        encryptedBufferList.add(buff);
    }

    public boolean doShutdown() throws IOException {
        if (handler.closeIfSSLOutboundDone())
            return true;
        ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);
        lastByteBuffer = handler.encrypt(dummyByteBuffer);
        writeLastByteBuffer();
        if (lastByteBuffer != null) {
            handler.registerWrite();
            return false;
        } else {
            return handler.closeIfSSLOutboundDone();
        }
    }
}
","// ByteBufferOutputStream_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.util.*;
import org.apache.commons.pool.ObjectPool;
import org.quickserver.net.server.ClientHandler;
import org.quickserver.net.server.impl.NonBlockingClientHandler;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferOutputStream}.
* It contains ten unit test cases for the {@link ByteBufferOutputStream#isLoggable(Level)} method.
*/
class ByteBufferOutputStream_0Test {","// ByteBufferOutputStream_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.util.*;
import org.apache.commons.pool.ObjectPool;
import org.quickserver.net.server.ClientHandler;
import org.quickserver.net.server.impl.NonBlockingClientHandler;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferOutputStream}.
* It contains ten unit test cases for the {@link ByteBufferOutputStream#isLoggable(Level)} method.
*/
class ByteBufferOutputStream_0Test {

	@Test
	void testIsLoggable_0() {
		ByteBufferOutputStream.setDebug(true);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.FINEST));
	}
	
	@Test
	void testIsLoggable_1() {
		ByteBufferOutputStream.setDebug(false);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.INFO));
	}
	
	@Test
	void testIsLoggable_2() {
		ByteBufferOutputStream.setDebug(true);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.INFO));
	}
	
	@Test
	void testIsLoggable_3() {
		ByteBufferOutputStream.setDebug(false);
		assertFalse(ByteBufferOutputStream.isLoggable(Level.FINEST));
	}
	
	@Test
	void testIsLoggable_4() {
		ByteBufferOutputStream.setDebug(true);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.FINE));
	}
	
	@Test
	void testIsLoggable_5() {
		ByteBufferOutputStream.setDebug(false);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.WARNING));
	}
	
	@Test
	void testIsLoggable_6() {
		ByteBufferOutputStream.setDebug(true);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.WARNING));
	}
	
	@Test
	void testIsLoggable_7() {
		ByteBufferOutputStream.setDebug(false);
		assertFalse(ByteBufferOutputStream.isLoggable(Level.FINE));
	}
	
	@Test
	void testIsLoggable_8() {
		ByteBufferOutputStream.setDebug(true);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.SEVERE));
	}
	
	@Test
	void testIsLoggable_9() {
		ByteBufferOutputStream.setDebug(false);
		assertTrue(ByteBufferOutputStream.isLoggable(Level.SEVERE));
	}
	
}

// ByteBufferOutputStream_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.util.*;
import org.apache.commons.pool.ObjectPool;
import org.quickserver.net.server.ClientHandler;
import org.quickserver.net.server.impl.NonBlockingClientHandler;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferOutputStream}.
* It contains ten unit test cases for the {@link ByteBufferOutputStream#close()} method.
*/
class ByteBufferOutputStream_1Test {
		
	@Test
	void testClose_0() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_1() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_2() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_3() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_4() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_5() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_6() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_7() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_8() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
	@Test
	void testClose_9() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		byteBufferOutputStream.close();
	}
	
}

// ByteBufferOutputStream_2Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.util.*;
import org.apache.commons.pool.ObjectPool;
import org.quickserver.net.server.ClientHandler;
import org.quickserver.net.server.impl.NonBlockingClientHandler;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferOutputStream}.
* It contains ten unit test cases for the {@link ByteBufferOutputStream#flush()} method.
*/
class ByteBufferOutputStream_2Test {
		
	@Test
	void testFlush_0() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		try {
			byteBufferOutputStream.flush();
		} catch (IOException e) {
			fail(""Unexpected exception: "" + e);
		}
	}
	
	@Test
	void testFlush_1() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		try {
			byteBufferOutputStream.flush();
		} catch (IOException e) {
			fail(""Unexpected exception: "" + e);
		}
	}
	
	@Test
	void testFlush_2() {
		ArrayList bufferList = new ArrayList();
		ClientHandler handler = new NonBlockingClientHandler();
		ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream(bufferList, handler);
		try {
			"
cmpl-6tzN52Ps8Ke1O6IO3u1E2bIqmjhnX,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_0Test.java,37.778420209884644,length,"// PasswordField.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException {
        return getPassword(System.in, prompt);
    }

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException {
        MaskingThread maskingthread = new MaskingThread(prompt);
        Thread thread = new Thread(maskingthread);
        thread.start();
        char[] lineBuffer;
        char[] buf;
        int i;
        buf = lineBuffer = new char[128];
        int room = buf.length;
        int offset = 0;
        int c;
        loop: while (true) {
            c = in.read();
            switch(c) {
                case -1:
                case '\n':
                    break loop;
                case '\r':
                    int c2 = in.read();
                    if ((c2 != '\n') && (c2 != -1)) {
                        if (!(in instanceof PushbackInputStream)) {
                            in = new PushbackInputStream(in);
                        }
                        ((PushbackInputStream) in).unread(c2);
                    } else {
                        break loop;
                    }
                default:
                    if (--room < 0) {
                        buf = new char[offset + 128];
                        room = buf.length - offset - 1;
                        System.arraycopy(lineBuffer, 0, buf, 0, offset);
                        Arrays.fill(lineBuffer, ' ');
                        lineBuffer = buf;
                    }
                    buf[offset++] = (char) c;
                    break;
            }
        }
        maskingthread.stopMasking();
        System.out.print(""\010"");
        //Code to clear doskey on win nt/2000 - Alt+F7
        String os = System.getProperty(""os.name"");
        if (os != null && os.toLowerCase().startsWith(""windows"")) {
            try {
                java.awt.Robot robot = new java.awt.Robot();
                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);
                robot.keyPress(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);
            } catch (Exception ignore) {
                logger.warning(""Could not clears command history: "" + ignore);
            }
        }
        if (offset == 0) {
            return null;
        }
        char[] ret = new char[offset];
        System.arraycopy(buf, 0, ret, 0, offset);
        Arrays.fill(buf, ' ');
        return ret;
    }
}
","// PasswordField_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_0Test {","// PasswordField_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_0Test {

	@Test
	void testGetPassword_0() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_1() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_2() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_3() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_4() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_5() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_6() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_7() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_8() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_9() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
}

// MaskingThread.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class attempts to erase characters echoed to the console.
 * @since 1.4
 */
class MaskingThread extends Thread {
    private volatile boolean stop;
    private char echochar = '*';

    /**
     *@param prompt The prompt displayed to the user
     */
    public MaskingThread(String prompt) {
        System.out.print(prompt);
    }

    /**
     * Begin masking until asked to stop.
     */
    public void run() {
        int priority = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
        try {
            stop = true;
            while (stop) {
                System.out.print(""\010"" + echochar);
                try {
                    // attempt masking at this rate
                    Thread.sleep(1);
                } catch (InterruptedException iex) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        } finally { // restore the original priority
            Thread.currentThread().setPriority(priority);
        }
    }

    /**
     * Instruct the thread to stop masking.
     */
    public void stopMasking() {
        this.stop = false;
    }
}

// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_1Test {
		
	@Test
	void testGetPassword_0() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_1() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_2() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result"
cmpl-6tzO8xM4fs0yddz24cRi1C2A7zYpM,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_1Test.java,47.311079025268555,length,"// PasswordField.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException {
        return getPassword(System.in, prompt);
    }

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException {
        MaskingThread maskingthread = new MaskingThread(prompt);
        Thread thread = new Thread(maskingthread);
        thread.start();
        char[] lineBuffer;
        char[] buf;
        int i;
        buf = lineBuffer = new char[128];
        int room = buf.length;
        int offset = 0;
        int c;
        loop: while (true) {
            c = in.read();
            switch(c) {
                case -1:
                case '\n':
                    break loop;
                case '\r':
                    int c2 = in.read();
                    if ((c2 != '\n') && (c2 != -1)) {
                        if (!(in instanceof PushbackInputStream)) {
                            in = new PushbackInputStream(in);
                        }
                        ((PushbackInputStream) in).unread(c2);
                    } else {
                        break loop;
                    }
                default:
                    if (--room < 0) {
                        buf = new char[offset + 128];
                        room = buf.length - offset - 1;
                        System.arraycopy(lineBuffer, 0, buf, 0, offset);
                        Arrays.fill(lineBuffer, ' ');
                        lineBuffer = buf;
                    }
                    buf[offset++] = (char) c;
                    break;
            }
        }
        maskingthread.stopMasking();
        System.out.print(""\010"");
        //Code to clear doskey on win nt/2000 - Alt+F7
        String os = System.getProperty(""os.name"");
        if (os != null && os.toLowerCase().startsWith(""windows"")) {
            try {
                java.awt.Robot robot = new java.awt.Robot();
                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);
                robot.keyPress(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);
            } catch (Exception ignore) {
                logger.warning(""Could not clears command history: "" + ignore);
            }
        }
        if (offset == 0) {
            return null;
        }
        char[] ret = new char[offset];
        System.arraycopy(buf, 0, ret, 0, offset);
        Arrays.fill(buf, ' ');
        return ret;
    }
}
","// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.
*/
class PasswordField_1Test {","// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.
*/
class PasswordField_1Test {

	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: null.
	* Expected result: NullPointerException.
	*/
	@Test
	public void testGetPassword_1() throws Exception {
		try {
			PasswordField.getPassword(null, ""test"");
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_2() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_3() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_4() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_5() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_6() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_7() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_8() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_9() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_10() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
}

// MaskingThread.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class attempts to erase characters echoed to the console.
 * @since 1.4
 */
class MaskingThread extends Thread {
    private volatile boolean stop;
    private char echochar = '*';

    /**
     *@param prompt The prompt displayed to the user
     */
    public MaskingThread(String prompt) {
        System.out.print(prompt);
    }

    /**
     * Begin masking until asked to stop.
     */
    public void run() {
        int priority = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
        try {
            stop = true;
            while (stop) {
                System.out.print(""\010"" + echochar);
                try {
                    // attempt masking at this rate
                    Thread.sleep(1);
                } catch (InterruptedException iex) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        } finally { // restore the original priority
            Thread.currentThread().setPriority(priority);
        }
    }

    /**
     * Instruct the thread to stop masking.
     */
    public void stopMasking() {
        this.stop = false;
    }
}

// PasswordField_2Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_2Test {
		
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test"
cmpl-6tzPB2azQGQNCY0imUv0Y1XiovaRs,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/pool/PoolHelper.java,36.09478211402893,length,"// PoolHelper.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool;

import org.apache.commons.pool.*;

/**
 * Pool Helper class.
 * @since 1.4.7
 */
public class PoolHelper {

    /**
     * Check if Pool is open.
     */
    public static boolean isPoolOpen(ObjectPool pool) {
        try {
            pool.getNumIdle();
        } catch (Exception e) {
            return false;
        }
        return true;
    }
}
","// PoolHelperTest.java
package org.quickserver.util.pool;

import org.apache.commons.pool.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PoolHelper}.
* It contains ten unit test cases for the {@link PoolHelper#isPoolOpen(ObjectPool)} method.
*/
class PoolHelperTest {","// PoolHelperTest.java
package org.quickserver.util.pool;

import org.apache.commons.pool.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PoolHelper}.
* It contains ten unit test cases for the {@link PoolHelper#isPoolOpen(ObjectPool)} method.
*/
class PoolHelperTest {

	@Test
	void testIsPoolOpen() {
		ObjectPool pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				return 0;
			}
			public int getNumActive() throws UnsupportedOperationException {
				return 0;
			}
			public void clear() throws Exception, UnsupportedOperationException {
			}
			public void close() {
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				return 0;
			}
			public void clear() throws Exception, UnsupportedOperationException {
			}
			public void close() {
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
			}
			public void close() {
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void close() {
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void close() {
				throw new UnsupportedOperationException();
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void close() {
				throw new UnsupportedOperationException();
			}
			public void setFactory(PoolableObjectFactory factory) throws IllegalStateException, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void close() {
				throw new UnsupportedOperationException();
			}
			public void setFactory(PoolableObjectFactory factory) throws IllegalStateException, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public PoolableObjectFactory getFactory() {
				throw new UnsupportedOperationException();
			}
		};
		assertTrue(PoolHelper.isPoolOpen(pool));
		
		pool = new BaseObjectPool() {
			public Object borrowObject() throws Exception {
				return null;
			}
			public void returnObject(Object obj) throws Exception {
			}
			public void invalidateObject(Object obj) throws Exception {
			}
			public void addObject() throws Exception {
			}
			public int getNumIdle() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public int getNumActive() throws UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void clear() throws Exception, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public void close() {
				throw new UnsupportedOperationException();
			}
			public void setFactory(PoolableObjectFactory factory) throws IllegalStateException, UnsupportedOperationException {
				throw new UnsupportedOperationException();
			}
			public PoolableObjectFactory getFactory"
cmpl-6tzQEU4lV6prcF1UkuQcZvNRZdjwc,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/pool/thread/ClientPool.java,44.41292691230774,length,"// ClientPool.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for managing the pool of threads for
 * handling clients.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ClientPool {

    private static final Logger logger = Logger.getLogger(ClientPool.class.getName());

    protected List clients = new ArrayList(3);

    protected ObjectPool pool;

    protected PoolConfig poolConfig;

    //v1.4.6
    private int countNioWriteThreads;

    private int maxThreadsForNioWrite = 10;

    public ClientPool(QSObjectPool objectPool, PoolConfig poolConfig) {
        this.poolConfig = poolConfig;
        pool = objectPool;
    }

    public ObjectPool getObjectPool() {
        return pool;
    }

    public void addClient(Runnable r) throws NoSuchElementException {
        addClient(r, false);
    }

    public synchronized void addClient(Runnable r, boolean keepObjOnFail) throws NoSuchElementException {
        //logger.finest(""Adding Runnable: ""+r);
        clients.add(r);
        ClientThread ct = null;
        try {
            ct = (ClientThread) pool.borrowObject();
            if (ct.isReady() == false) {
                //ct.start();
                //timeout was just in case :-)
                wait(500);
                //Thread.yield();
            } else {
                synchronized (ct) {
                    ct.notify();
                }
            }
        } catch (NoSuchElementException e) {
            logger.info(""No free threads: "" + e);
            if (keepObjOnFail == false)
                clients.remove(r);
            throw e;
        } catch (Exception e) {
            logger.warning(""Error in addClient: "" + e + "", Closing client: "" + (ClientHandler) r);
            try {
                ((ClientHandler) r).forceClose();
            } catch (Exception er) {
                logger.warning(""Error closing client: "" + er);
            }
            try {
                if (ct != null)
                    pool.returnObject(ct);
            } catch (Exception er) {
                logger.warning(""Error in returning thread: "" + er);
            }
        }
    }

    public synchronized void returnObject(Object object) {
        try {
            pool.returnObject(object);
        } catch (Exception e) {
            logger.warning(""IGONRED: Error while returning object : "" + e);
            ((Thread) object).interrupt();
        }
    }

    public synchronized Runnable getClient() {
        if (clients.isEmpty()) {
            return null;
        }
        return (Runnable) clients.remove(0);
    }

    /**
     * @since 1.4.5
     */
    public boolean isClientAvailable() {
        if (clients.isEmpty()) {
            return false;
        } else {
            return true;
        }
    }

    protected void finalize() throws Throwable {
        try {
            close();
        } catch (Exception e) {
            logger.warning(""IGONRED:finalize in pool close : "" + e);
        }
        super.finalize();
    }

    public void close() throws Exception {
        pool.close();
    }

    public void clear() throws Exception {
        pool.clear();
    }

    /**
     * Return the number of instances currently borrowed from my pool.
     * @since 1.4.1
     */
    public int getNumActive() {
        return pool.getNumActive();
    }

    /**
     * Return the number of instances currently idle in my pool.
     * @since 1.4.1
     */
    public int getNumIdle() {
        return pool.getNumIdle();
    }

    /**
     * Returns iterator containing all the active
     * threads i.e ClientHandler handling connected clients.
     * @since 1.3.1
     */
    public final Iterator getAllClientThread() {
        return ((QSObjectPool) pool).getAllActiveObjects();
    }

    public Object getObjectToSynchronize() {
        return ((QSObjectPool) pool).getObjectToSynchronize();
    }

    /**
     * Returns PoolConfig object that configured this pool
     * @since 1.4.5
     */
    public PoolConfig getPoolConfig() {
        return poolConfig;
    }

    /**
     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is
     * imposed.
     * @since 1.4.6
     */
    public void setMaxThreadsForNioWrite(int count) {
        this.maxThreadsForNioWrite = count;
    }

    /**
     * Returns the maximum threads allowed for nio write
     * @since 1.4.6
     */
    public int getMaxThreadsForNioWrite() {
        return maxThreadsForNioWrite;
    }

    /**
     * Notifies when NIO write is complete.
     * @since 1.4.6
     */
    protected void nioWriteEnd() {
        countNioWriteThreads--;
        if (countNioWriteThreads < 0) {
            logger.warning(""countNioWriteThreads should not go less than 0"");
            countNioWriteThreads = 0;
        }
    }

    /**
     * Notifies when NIO write is about to start.
     * @since 1.4.6
     */
    protected void nioWriteStart() {
        countNioWriteThreads++;
    }

    /**
     * Method to suggest if nio write should be sent for processing.
     * @since 1.4.6
     */
    public boolean shouldNioWriteHappen() {
        if (maxThreadsForNioWrite <= 0 || countNioWriteThreads < maxThreadsForNioWrite) {
            return true;
        } else {
            return false;
        }
    }
}
","// ClientPoolTest.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPool}.
* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.
*/
class ClientPoolTest {","// ClientPoolTest.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPool}.
* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.
*/
class ClientPoolTest {

		private static final Logger logger = Logger.getLogger(ClientPoolTest.class.getName());
		
		private ClientPool clientPool;
		
		private PoolConfig poolConfig;
		
		private QSObjectPool objectPool;
		
		private ClientThread clientThread;
		
		private Runnable runnable;
		
		private int maxThreadsForNioWrite;
		
		private int countNioWriteThreads;
		
		private boolean shouldNioWriteHappen;
		
		private void setUp() {
			poolConfig = new PoolConfig();
			objectPool = new QSObjectPool(poolConfig);
			clientPool = new ClientPool(objectPool, poolConfig);
			clientThread = new ClientThread(clientPool);
			runnable = new Runnable() {
				public void run() {
				}
			};
		}
		
		@Test
		void testShouldNioWriteHappen_1() {
			setUp();
			maxThreadsForNioWrite = 0;
			countNioWriteThreads = 0;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_2() {
			setUp();
			maxThreadsForNioWrite = 0;
			countNioWriteThreads = 1;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_3() {
			setUp();
			maxThreadsForNioWrite = 1;
			countNioWriteThreads = 0;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_4() {
			setUp();
			maxThreadsForNioWrite = 1;
			countNioWriteThreads = 1;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertFalse(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_5() {
			setUp();
			maxThreadsForNioWrite = 2;
			countNioWriteThreads = 0;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_6() {
			setUp();
			maxThreadsForNioWrite = 2;
			countNioWriteThreads = 1;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_7() {
			setUp();
			maxThreadsForNioWrite = 2;
			countNioWriteThreads = 2;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertFalse(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_8() {
			setUp();
			maxThreadsForNioWrite = 3;
			countNioWriteThreads = 0;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_9() {
			setUp();
			maxThreadsForNioWrite = 3;
			countNioWriteThreads = 1;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_10() {
			setUp();
			maxThreadsForNioWrite = 3;
			countNioWriteThreads = 2;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_11() {
			setUp();
			maxThreadsForNioWrite = 3;
			countNioWriteThreads = 3;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertFalse(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_12() {
			setUp();
			maxThreadsForNioWrite = 4;
			countNioWriteThreads = 0;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assertTrue(shouldNioWriteHappen);
		}
		
		@Test
		void testShouldNioWriteHappen_13() {
			setUp();
			maxThreadsForNioWrite = 4;
			countNioWriteThreads = 1;
			clientPool.setMaxThreadsForNioWrite(maxThreadsForNioWrite);
			clientPool.nioWriteStart();
			shouldNioWriteHappen = clientPool.shouldNioWriteHappen();
			assert"
cmpl-6tzROnjtR5wIXfUzGCqJz37qVw1aX,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/AccessConstraintConfig.java,44.69576859474182,length,"// AccessConstraintConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;

/**
 * This class encapsulate the access constraints on servers running.
 * The xml is &lt;access-constraint&gt;...&lt;/access-constraint&gt;.
 * @author Akshathkumar Shetty
 * @since 1.3.3
 */
public class AccessConstraintConfig implements Serializable {

    private static final Logger logger = Logger.getLogger(AccessConstraintConfig.class.getName());

    private IpFilterConfig ipFilterConfig;

    /**
     * Returns the IpFilterConfig.
     * @return IpFilterConfig
     */
    public IpFilterConfig getIpFilterConfig() {
        return ipFilterConfig;
    }

    /**
     * Sets the IpFilterConfig
     * XML Tag: &lt;ip-filter&gt;&lt;/ip-filter&gt;
     * @param ipFilterConfig
     */
    public void setIpFilterConfig(IpFilterConfig ipFilterConfig) {
        this.ipFilterConfig = ipFilterConfig;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad + ""<access-constraint>\n"");
        if (getIpFilterConfig() != null)
            sb.append(getIpFilterConfig().toXML(pad + ""\t""));
        sb.append(pad + ""</access-constraint>\n"");
        return sb.toString();
    }

    /**
     * Finds if the socket has access to connect to server.
     * Based on the access constrains set.
     * @exception SecurityException if access not allowed.
     */
    public void checkAccept(Socket socket) {
        if (socket == null || ipFilterConfig == null || ipFilterConfig.getEnable() == false)
            return;
        String remoteIp = socket.getInetAddress().getHostAddress();
        boolean accessFlag = ipFilterConfig.getAllowAccess() == true;
        if (ipFilterConfig.getIpCollection().contains(remoteIp) != accessFlag) {
            try {
                socket.close();
            } catch (IOException e) {
                logger.warning(""IOException : "" + e.getMessage());
            }
            socket = null;
            throw new SecurityException(""Accept denied from "" + remoteIp);
        }
    }
}
","// AccessConstraintConfigTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AccessConstraintConfig}.
* It contains ten unit test cases for the {@link AccessConstraintConfig#toXML(String)} method.
*/
class AccessConstraintConfigTest {","// AccessConstraintConfigTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AccessConstraintConfig}.
* It contains ten unit test cases for the {@link AccessConstraintConfig#toXML(String)} method.
*/
class AccessConstraintConfigTest {

	@Test
	public void testToXML() {
		AccessConstraintConfig accessConstraintConfig = new AccessConstraintConfig();
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.getIpCollection().add(""127.0.0.1"");
		accessConstraintConfig.setIpFilterConfig(ipFilterConfig);
		String xml = accessConstraintConfig.toXML("""");
		assertEquals(""<access-constraint>\n"" +
			""\t<ip-filter enable=\""true\"" allow-access=\""true\"">\n"" +
			""\t\t<ip>127.0.0.1</ip>\n"" +
			""\t</ip-filter>\n"" +
			""</access-constraint>\n"", xml);
	}
}

// IpFilterConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;

/**
 * This class encapsulate the ip filter on servers running.
 * The xml is &lt;ip-filter&gt;...&lt;/ip-filter&gt;.
 * @author Akshathkumar Shetty
 * @since 1.3.3
 */
public class IpFilterConfig implements Serializable {

    private static final Logger logger = Logger.getLogger(IpFilterConfig.class.getName());

    private boolean enable = false;

    /**
     * Returns if the ip filter is enabled.
     * @return boolean
     */
    public boolean getEnable() {
        return enable;
    }

    /**
     * Sets if the ip filter is enabled.
     * XML Tag: &lt;ip-filter enable=""true|false""&gt;&lt;/ip-filter&gt;
     * @param enable
     */
    public void setEnable(boolean enable) {
        this.enable = enable;
    }

    private boolean allowAccess = true;

    /**
     * Returns if the ip filter allows access.
     * @return boolean
     */
    public boolean getAllowAccess() {
        return allowAccess;
    }

    /**
     * Sets if the ip filter allows access.
     * XML Tag: &lt;ip-filter allow-access=""true|false""&gt;&lt;/ip-filter&gt;
     * @param allowAccess
     */
    public void setAllowAccess(boolean allowAccess) {
        this.allowAccess = allowAccess;
    }

    private Set ipCollection = new HashSet();

    /**
     * Returns the ip collection.
     * @return Set
     */
    public Set getIpCollection() {
        return ipCollection;
    }

    /**
     * Sets the ip collection.
     * XML Tag: &lt;ip&gt;127.0.0.1&lt;/ip&gt;
     * @param ipCollection
     */
    public void setIpCollection(Set ipCollection) {
        this.ipCollection = ipCollection;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad + ""<ip-filter enable=\"""" + getEnable() + ""\"" allow-access=\"""" + getAllowAccess() + ""\"">\n"");
        Iterator it = getIpCollection().iterator();
        while (it.hasNext()) {
            sb.append(pad + ""\t<ip>"" + it.next() + ""</ip>\n"");
        }
        sb.append(pad + ""</ip-filter>\n"");
        return sb.toString();
    }
}

// IpFilterConfigTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IpFilterConfig}.
* It contains ten unit test cases for the {@link IpFilterConfig#toXML(String)} method.
*/
class IpFilterConfigTest {
		
	@Test
	public void testToXML() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.getIpCollection().add(""127.0.0.1"");
		String xml = ipFilterConfig.toXML("""");
		assertEquals(""<ip-filter enable=\""true\"" allow-access=\""true\"">\n"" +
			""\t<ip>127.0.0.1</ip>\n"" +
			""</ip-filter>\n"", xml);
	}
}

// ServerConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;
import java.net.*;
import java.io.*;
import java.util.logging.*;

/**
 * This class encapsulate the server configuration.
 * The xml is &lt;server&gt;...&lt;/server&gt;.
 * @author Akshathkumar Shetty
 * @since 1.3.3
 */
public class ServerConfig implements Serializable {

    private static final Logger logger = Logger.getLogger(ServerConfig.class.getName());

    private String name;

    /**
     * Returns the name of the server.
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the name of the server.
     * XML Tag: &lt;server name=""server1""&gt;&lt;/server&gt;
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    private String className;

    /**
     * Returns the class name of the server.
     * @return String
     */
    public String getClassName() {
        return className;
    }

    /**
     * Sets the class name of the server.
     * XML Tag: &lt;server class-name=""org.quickserver.net.server.QuickServer""&gt;&lt;/server&gt;
     * @param className
     */
    public void setClassName(String className) {
        this.className = className;
    }

    private String host;

    /**
     * Returns the host of the server.
     * @return String
     */
    public String getHost() {
        return host;
    }

    /**
     * Sets the host of the server.
     * XML Tag: &lt;server host=""127.0.0.1"
cmpl-6tzSLjgsGIC4nKX1lOuJFPuS08SEr,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/AdvancedSettings.java,78.9476146697998,length,"// AdvancedSettings.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.nio.charset.UnsupportedCharsetException;
import java.nio.charset.Charset;

/**
 *  This class encapsulate Advanced Settings.
 *  The example xml is <pre>
 * 	....
 * 	&lt;advanced-settings&gt;
 * 		&lt;charset&gt;ISO-8859-1&lt;charset&gt;
 * 		&lt;byte-buffer-size&gt;61440&lt;byte-buffer-size&gt;
 * 		&lt;use-direct-byte-buffer&gt;true&lt;/use-direct-byte-buffer&gt;
 * 		&lt;backlog&gt;1024&lt;/backlog&gt;
 * 		&lt;socket-linger&gt;-1&lt;/socket-linger&gt;
 * 		&lt;debug-non-blocking-mode&gt;false&lt;/debug-non-blocking-mode&gt;
 *
 *         &lt;performance-preferences-connection-time&gt;2&lt;performance-preferences-connection-time&gt;
 *         &lt;performance-preferences-latency&gt;4&lt;performance-preferences-latency&gt;
 *         &lt;performance-preferences-bandwidth&gt;2&lt;performance-preferences-bandwidth&gt;
 *
 *         &lt;client-socket-tcp-no-delay&gt;false&lt;client-socket-tcp-no-delay&gt;
 *         &lt;client-socket-tcp-traffic-class&gt;10&lt;client-socket-tcp-traffic-class&gt;
 *
 *         &lt;client-socket-receive-buffer-size&gt;0&lt;client-socket-receive-buffer-size&gt;
 *         &lt;client-socket-send-buffer-size&gt;0&lt;client-socket-send-buffer-size&gt;
 *  	&lt;/advanced-settings&gt;
 * 	....
 *  </pre>
 *  @author Akshathkumar Shetty
 *  @since 1.4.5
 */
public class AdvancedSettings implements java.io.Serializable {

    private String charset = ""ISO-8859-1"";

    private int byteBufferSize = 1024 * 64;

    private int backlog = 0;

    private boolean useDirectByteBuffer = true;

    private int socketLinger = -1;

    private boolean debugNonBlockingMode;

    private String clientIdentifierClass = ""org.quickserver.net.server.impl.OptimisticClientIdentifier"";

    private String qSObjectPoolMakerClass = null;

    private int maxThreadsForNioWrite = 10;

    //2
    private int performancePreferencesConnectionTime = 0;

    //4
    private int performancePreferencesLatency = 0;

    private int performancePreferencesBandwidth = 0;

    private boolean clientSocketTcpNoDelay = false;

    private String clientSocketTrafficClass;

    private int clientSocketReceiveBufferSize;

    private int clientSocketSendBufferSize;

    /**
     * Sets the Charset to be used for String decoding and encoding.
     * XML Tag: &lt;charset&gt;ISO-8859-1&lt;/charset&gt;
     * @param charset to be used for String decoding and encoding
     * @see #getCharset
     */
    public void setCharset(String charset) {
        if (charset == null || charset.trim().length() == 0)
            return;
        if (Charset.isSupported(charset) == false) {
            throw new UnsupportedCharsetException(charset);
        }
        this.charset = charset;
    }

    /**
     * Returns Charset to be used for String decoding and encoding..
     * @see #setCharset
     */
    public String getCharset() {
        return charset;
    }

    /**
     * Sets the ByteBuffer size to be used in ByteBuffer pool.
     * XML Tag: &lt;byte-buffer-size&gt;65536&lt;/byte-buffer-size&gt;
     * @param byteBufferSize size to be used in ByteBuffer pool.
     * @see #getByteBufferSize
     */
    public void setByteBufferSize(int byteBufferSize) {
        if (byteBufferSize > 0)
            this.byteBufferSize = byteBufferSize;
    }

    /**
     * Returns ByteBuffer size to be used in ByteBuffer pool.
     * @see #setByteBufferSize
     */
    public int getByteBufferSize() {
        return byteBufferSize;
    }

    /**
     * Sets the listen backlog length for the QuickServer to listen on.
     * If not set or set a value equal or less than 0, then the default
     * value will be assumed.<br/>
     * XML Tag: &lt;backlog&gt;0&lt;/backlog&gt;
     * @param backlog The listen backlog length.
     * @see #getBacklog
     */
    public void setBacklog(int backlog) {
        if (backlog >= 0)
            this.backlog = backlog;
    }

    /**
     * Returns the listen backlog length for the QuickServer.
     * @see #setBacklog
     */
    public int getBacklog() {
        return backlog;
    }

    /**
     * Sets the UseDirectByteBuffer flag.
     * If not set, it will use <code>true</code><br/>
     * XML Tag: &lt;use-direct-byte-buffer&gt;true&lt;/use-direct-byte-buffer&gt;
     * @param flag UseDirectByteBuffer flag.
     * @see #getUseDirectByteBuffer
     */
    public void setUseDirectByteBuffer(boolean flag) {
        this.useDirectByteBuffer = flag;
    }

    /**
     * Returns UseDirectByteBuffer flag.
     * @see #setUseDirectByteBuffer
     */
    public boolean getUseDirectByteBuffer() {
        return useDirectByteBuffer;
    }

    /**
     * Enable SO_LINGER with the specified linger time in seconds. If linger time is less than
     * <code>0</code> SO_LINGER will be disable.
     * XML Tag: &lt;socket-linger&gt;-1&lt;/socket-linger&gt;
     * @param socketLinger if the linger value is negative SO_LINGER will be disable.
     * @see #getSocketLinger
     */
    public void setSocketLinger(int socketLinger) {
        this.socketLinger = socketLinger;
    }

    /**
     * Returns linger time in seconds. If SO_LINGER is disabled time will be negative;
     * @see #setSocketLinger
     */
    public int getSocketLinger() {
        return socketLinger;
    }

    /**
     * Sets the DebugNonBlockingMode flag.
     * If not set, it will use <code>false</code><br/>
     * XML Tag: &lt;debug-non-blocking-mode&gt;false&lt;/debug-non-blocking-mode&gt;
     * @param debugNonBlockingMode DebugNonBlockingMode flag.
     * @see #getDebugNonBlockingMode
     */
    public void setDebugNonBlockingMode(boolean debugNonBlockingMode) {
        this.debugNonBlockingMode = debugNonBlockingMode;
    }

    /**
     * Returns DebugNonBlockingMode flag.
     * @see #setDebugNonBlockingMode
     */
    public boolean getDebugNonBlockingMode() {
        return debugNonBlockingMode;
    }

    /**
     * Sets the ClientIdentifier class that implements
     * {@link org.quickserver.net.server.ClientIdentifier}.
     * XML Tag: &lt;client-identifier&gt;org.quickserver.net.server.impl.TryClientIdentifier&lt;/client-identifier&gt;
     * @param clientIdentifierClass the fully qualified name of the class that
     * implements {@link org.quickserver.net.server.ClientIdentifier}.
     * @see #getClientIdentifier
     */
    public void setClientIdentifier(String clientIdentifierClass) {
        if (clientIdentifierClass == null || clientIdentifierClass.trim().length() == 0)
            return;
        this.clientIdentifierClass = clientIdentifierClass;
    }

    /**
     * Returns the ClientIdentifier class that that implements
     * {@link org.quickserver.net.server.ClientIdentifier}.
     * @see #setClientIdentifier
     */
    public String getClientIdentifier() {
        return clientIdentifierClass;
    }

    /**
     * Sets the QSObjectPoolMaker class that implements
     * {@link org.quickserver.util.pool.QSObjectPoolMaker}.
     * XML Tag: &lt;qsobject-pool-maker&gt;org.quickserver.util.pool.MakeQSObjectPool&lt;/qsobject-pool-maker&gt;
     * @param qSObjectPoolMakerClass the fully qualified name of the class that
     * implements {@link org.quickserver.util.pool.QSObjectPoolMaker}.
     * @see #getQSObjectPoolMaker
     */
    public void setQSObjectPoolMaker(String qSObjectPoolMakerClass) {
        this.qSObjectPoolMakerClass = qSObjectPoolMakerClass;
    }

    /**
     * Returns the QSObjectPoolMaker class that implements
     * {@link org.quickserver.util.pool.QSObjectPoolMaker}.
     * @see #setQSObjectPoolMaker
     */
    public String getQSObjectPoolMaker() {
        if (qSObjectPoolMakerClass == null)
            qSObjectPoolMakerClass = ""org.quickserver.util.pool.MakeQSObjectPool"";
        return qSObjectPoolMakerClass;
    }

    /**
     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is
     * imposed.
     * XML Tag: &lt;max-threads-for-nio-write&gt;10&lt;/max-threads-for-nio-write&gt;
     * @param maxThreadsForNioWrite maximum threads allowed for nio write
     * @see #getMaxThreadsForNioWrite
     * @since 1.4.6
     */
    public void setMaxThreadsForNioWrite(int maxThreadsForNioWrite) {
        this.maxThreadsForNioWrite = maxThreadsForNioWrite;
    }

    /**
     * Returns the maximum threads allowed for nio write.
     * @see #setMaxThreadsForNioWrite
     * @since 1.4.6
     */
    public int getMaxThreadsForNioWrite() {
        return maxThreadsForNioWrite;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<advanced-settings>\n"");
        sb.append(pad + ""\t<charset>"").append(getCharset()).append(""</charset>\n"");
        sb.append(pad).append(""\t<use-direct-byte-buffer>"").append(getUseDirectByteBuffer()).append(""</use-direct-byte-buffer>\n"");
        sb.append(pad).append(""\t<byte-buffer-size>"").append(getByteBufferSize()).append(""</byte-buffer-size>\n"");
        sb.append(pad).append(""\t<backlog>"").append(getBacklog()).append(""</backlog>\n"");
        sb.append(pad).append(""\t<socket-linger>"").append(getSocketLinger()).append(""</socket-linger>\n"");
        sb.append(pad).append(""\t<debug-non-blocking-mode>"").append(getDebugNonBlockingMode()).append(""</debug-non-blocking-mode>\n"");
        sb.append(pad).append(""\t<client-identifier>"").append(getClientIdentifier()).append(""</client-identifier>\n"");
        sb.append(pad).append(""\t<qsobject-pool-maker>"").append(getQSObjectPoolMaker()).append(""</qsobject-pool-maker>\n"");
        sb.append(pad).append(""\t<max-threads-for-nio-write>"").append(getMaxThreadsForNioWrite()).append(""</max-threads-for-nio-write>\n"");
        sb.append(pad).append(""\t<performance-preferences-connection-time>"").append(getPerformancePreferencesConnectionTime()).append(""</performance-preferences-connection-time>\n"");
        sb.append(pad).append(""\t<performance-preferences-latency>"").append(getPerformancePreferencesLatency()).append(""</performance-preferences-latency>\n"");
        sb.append(pad).append(""\t<performance-preferences-bandwidth>"").append(getPerformancePreferencesBandwidth()).append(""</performance-preferences-bandwidth>\n"");
        sb.append(pad).append(""\t<client-socket-tcp-no-delay>"").append(getClientSocketTcpNoDelay()).append(""</client-socket-tcp-no-delay>\n"");
        if (getClientSocketTrafficClass() != null) {
            sb.append(pad).append(""\t<client-socket-traffic-class>"").append(getClientSocketTrafficClass()).append(""</client-socket-traffic-class>\n"");
        }
        if (getClientSocketReceiveBufferSize() != 0) {
            sb.append(pad).append(""\t<client-socket-receive-buffer-size>"").append(getClientSocketReceiveBufferSize()).append(""</client-socket-receive-buffer-size>\n"");
        }
        if (getClientSocketSendBufferSize() != 0) {
            sb.append(pad).append(""\t<client-socket-send-buffer-size>"").append(getClientSocketSendBufferSize()).append(""</client-socket-send-buffer-size>\n"");
        }
        sb.append(pad).append(""</advanced-settings>\n"");
        return sb.toString();
    }

    public int getPerformancePreferencesConnectionTime() {
        return performancePreferencesConnectionTime;
    }

    public void setPerformancePreferencesConnectionTime(int performancePreferencesConnectionTime) {
        this.performancePreferencesConnectionTime = performancePreferencesConnectionTime;
    }

    public int getPerformancePreferencesLatency() {
        return performancePreferencesLatency;
    }

    public void setPerformancePreferencesLatency(int performancePreferencesLatency) {
        this.performancePreferencesLatency = performancePreferencesLatency;
    }

    public int getPerformancePreferencesBandwidth() {
        return performancePreferencesBandwidth;
    }

    public void setPerformancePreferencesBandwidth(int performancePreferencesBandwidth) {
        this.performancePreferencesBandwidth = performancePreferencesBandwidth;
    }

    public boolean getClientSocketTcpNoDelay() {
        return clientSocketTcpNoDelay;
    }

    public void setClientSocketTcpNoDelay(boolean clientSocketTcpNoDelay) {
        this.clientSocketTcpNoDelay = clientSocketTcpNoDelay;
    }

    public String getClientSocketTrafficClass() {
        return clientSocketTrafficClass;
    }

    public void setClientSocketTrafficClass(String clientSocketTrafficClass) {
        this.clientSocketTrafficClass = clientSocketTrafficClass;
    }

    public int getClientSocketReceiveBufferSize() {
        return clientSocketReceiveBufferSize;
    }

    public void setClientSocketReceiveBufferSize(int clientSocketReceiveBufferSize) {
        this.clientSocketReceiveBufferSize = clientSocketReceiveBufferSize;
    }

    public int getClientSocketSendBufferSize() {
        return clientSocketSendBufferSize;
    }

    public void setClientSocketSendBufferSize(int clientSocketSendBufferSize) {
        this.clientSocketSendBufferSize = clientSocketSendBufferSize;
    }
}
","// AdvancedSettingsTest.java
package org.quickserver.util.xmlreader;

import java.nio.charset.UnsupportedCharsetException;
import java.nio.charset.Charset;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AdvancedSettings}.
* It contains ten unit test cases for the {@link AdvancedSettings#toXML(String)} method.
*/
class AdvancedSettingsTest {","// AdvancedSettingsTest.java
package org.quickserver.util.xmlreader;

import java.nio.charset.UnsupportedCharsetException;
import java.nio.charset.Charset;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AdvancedSettings}.
* It contains ten unit test cases for the {@link AdvancedSettings#toXML(String)} method.
*/
class AdvancedSettingsTest {

	@Test
	void testToXML() {
		AdvancedSettings advancedSettings = new AdvancedSettings();
		assertEquals(""<advanced-settings>\n"" +
				""\t<charset>ISO-8859-1</charset>\n"" +
				""\t<use-direct-byte-buffer>true</use-direct-byte-buffer>\n"" +
				""\t<byte-buffer-size>65536</byte-buffer-size>\n"" +
				""\t<backlog>0</backlog>\n"" +
				""\t<socket-linger>-1</socket-linger>\n"" +
				""\t<debug-non-blocking-mode>false</debug-non-blocking-mode>\n"" +
				""\t<client-identifier>org.quickserver.net.server.impl.OptimisticClientIdentifier</client-identifier>\n"" +
				""\t<qsobject-pool-maker>org.quickserver.util.pool.MakeQSObjectPool</qsobject-pool-maker>\n"" +
				""\t<max-threads-for-nio-write>10</max-threads-for-nio-write>\n"" +
				""\t<performance-preferences-connection-time>0</performance-preferences-connection-time>\n"" +
				""\t<performance-preferences-latency>0</performance-preferences-latency>\n"" +
				""\t<performance-preferences-bandwidth>0</performance-preferences-bandwidth>\n"" +
				""\t<client-socket-tcp-no-delay>false</client-socket-tcp-no-delay>\n"" +
				""</advanced-settings>\n"", advancedSettings.toXML(null));
	}
	
	@Test
	void testToXML_charset() {
		AdvancedSettings advancedSettings = new AdvancedSettings();
		advancedSettings.setCharset(""UTF-8"");
		assertEquals(""<advanced-settings>\n"" +
				""\t<charset>UTF-8</charset>\n"" +
				""\t<use-direct-byte-buffer>true</use-direct-byte-buffer>\n"" +
				""\t<byte-buffer-size>65536</byte-buffer-size>\n"" +
				""\t<backlog>0</backlog>\n"" +
				""\t<socket-linger>-1</socket-linger>\n"" +
				""\t<debug-non-blocking-mode>false</debug-non-blocking-mode>\n"" +
				""\t<client-identifier>org.quickserver.net.server.impl.OptimisticClientIdentifier</client-identifier>\n"" +
				""\t<qsobject-pool-maker>org.quickserver.util.pool.MakeQSObjectPool</qsobject-pool-maker>\n"" +
				""\t<max-threads-for-nio-write>10</max-threads-for-nio-write>\n"" +
				""\t<performance-preferences-connection-time>0</performance-preferences-connection-time>\n"" +
				""\t<performance-preferences-latency>0</performance-preferences-latency>\n"" +
				""\t<performance-preferences-bandwidth>0</performance-preferences-bandwidth>\n"" +
				""\t<client-socket-tcp-no-delay>false</client-socket-tcp-no-delay>\n"" +
				""</advanced-settings>\n"", advancedSettings.toXML(null));
	}
	
	@Test
	void testToXML_charset_exception() {
		AdvancedSettings advancedSettings = new AdvancedSettings();
		assertThrows(UnsupportedCharsetException.class, () -> {
			advancedSettings.setCharset(""UTF-9"");
		});
	}
	
	@Test
	void testToXML_byteBufferSize() {
		AdvancedSettings advancedSettings = new AdvancedSettings();
		advancedSettings.setByteBufferSize(1024);
		assertEquals(""<advanced-settings>\n"" +
				""\t<charset>ISO-8859-1</charset>\n"" +
				""\t<use-direct-byte-buffer>true</use-direct-byte-buffer>\n"" +
				""\t<byte-buffer-size>1024</byte-buffer-size>\n"" +
				""\t<backlog>0</backlog>\n"" +
				""\t<socket-linger>-1</socket-linger>\n"" +
				""\t<debug-non-blocking-mode>false</debug-non-blocking-mode>\n"" +
				""\t<client-identifier>org.quickserver.net.server.impl.OptimisticClientIdentifier</client-identifier>\n"" +
				""\t<qsobject-pool-maker>org.quickserver.util.pool.MakeQSObjectPool</qsobject-pool-maker>\n"" +
				""\t<max-threads-for-nio-write>10</max-threads-for-nio-write>\n"" +
				""\t<performance-preferences-connection-time>0</performance-preferences-connection-time>\n"" +
				""\t<performance-preferences-latency>0</performance-preferences-latency>\n"" +
				""\t<performance-preferences-bandwidth>0</performance-preferences-bandwidth>\n"" +
				""\t<client-socket-tcp-no-delay>false</client-socket-tcp-no-delay>\n"" +
				""</advanced-settings>\n"", advancedSettings.toXML(null));
	}
	
	@Test
	void testToXML_byteBufferSize_negative() {
		AdvancedSettings advancedSettings = new AdvancedSettings();
		advancedSettings.setByteBufferSize(-1);
		assertEquals(""<advanced-settings>\n"" +
				""\t<charset>ISO-8859-1</charset>\n"" +
				""\t<use-direct-byte-buffer>true</use-direct-byte-buffer>\n"" +
				""\t<byte-buffer-size>65536</byte-buffer-size>\n"" +
				""\t<backlog>0</backlog>\n"" +
				""\t<socket-linger>-1</socket-linger>\n"" +
				""\t<debug-non-blocking-mode>false</debug-non-blocking-mode>\n"" +
				""\t<client-identifier>org.quickserver.net.server.impl.OptimisticClientIdentifier</client-identifier>\n"" +
				""\t<qsobject-pool-maker>org.quickserver.util.pool.MakeQSObjectPool</qsobject-pool-maker>\n"" +
				""\t<max-threads-for-nio-write>10</max-threads-for-nio-write>\n"" +
				""\t<performance-preferences-connection-time>0</performance-preferences-connection-time>\n"" +
"
cmpl-6tzTboTTXiDf7jtyjLMn0IihvFrEC,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ApplicationConfiguration_0Test.java,73.97601580619812,length,"// ApplicationConfiguration.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the Application Configuration.
 *  The example xml is <pre>
 *  &lt;quickserver&gt;
 * 	....
 * 	&lt;application-configuration&gt;
 * 		&lt;property&gt;
 * 			&lt;property-name&gt;FTP_ROOT&lt;/property-name&gt;
 * 			&lt;property-value&gt;c:\&lt;/property-value&gt;
 * 		&lt;/property&gt;
 * 		&lt;property&gt;
 * 			&lt;property-name&gt;Server Name&lt;/property-name&gt;
 * 			&lt;property-value&gt;My Server&lt;/property-value&gt;
 * 		&lt;/property&gt;
 * 	&lt;/application-configuration&gt;
 * 	....
 * &lt;/quickserver&gt;
 * </pre>
 *  @author Akshathkumar Shetty
 *  @since 1.3.2
 */
public class ApplicationConfiguration extends HashMap {

    //OR console
    private String promptType = ""gui"";

    /**
     * Sets the PromptType.
     * XML Tag: &lt;prompt-type&gt;true&lt;/prompt-typ&gt;
     * Allowed values = <code>gui</code> | <code>console</code>
     * @see #getPromptType
     * @since 1.4.5
     */
    public void setPromptType(String promptType) {
        if (promptType != null && promptType.equals("""") == false)
            if (promptType.equals(""gui"") || promptType.equals(""console""))
                this.promptType = promptType;
    }

    /**
     * Returns the PromptType
     * @see #setPromptType
     * @since 1.4.5
     */
    public String getPromptType() {
        return promptType;
    }

    /**
     * Addes the {@link Property} passed to the HashMap
     */
    public void addProperty(Property property) {
        put(property.getName(), property.getValue());
    }

    /**
     * Finds if any {@link Property} is present.
     * @return <code>null</code> if no Property was found.
     */
    public Property findProperty(String name) {
        String temp = (String) get(name);
        if (temp != null) {
            return new Property(name, temp);
        } else {
            return null;
        }
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<application-configuration>\n"");
        sb.append(pad).append(""\t<prompt-type>"").append(getPromptType()).append(""</prompt-type>"");
        Iterator iterator = keySet().iterator();
        while (iterator.hasNext()) {
            String key = (String) iterator.next();
            String value = (String) get(key);
            sb.append(pad).append(""\t<property>"");
            sb.append(pad).append(""\t\t<property-name>"").append(key).append(""</property-name>\n"");
            sb.append(pad).append(""\t\t<property-value>"").append(value).append(""</property-value>\n"");
            sb.append(pad).append(""\t</property>\n"");
        }
        sb.append(pad).append(""</application-configuration>\n"");
        return sb.toString();
    }
}
","// ApplicationConfiguration_0Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationConfiguration}.
* It contains ten unit test cases for the {@link ApplicationConfiguration#findProperty(String)} method.
*/
class ApplicationConfiguration_0Test {","// ApplicationConfiguration_0Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationConfiguration}.
* It contains ten unit test cases for the {@link ApplicationConfiguration#findProperty(String)} method.
*/
class ApplicationConfiguration_0Test {

	@Test
	void testFindProperty_0() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""FTP_ROOT"");
		assertNotNull(property);
		assertEquals(""FTP_ROOT"", property.getName());
		assertEquals(""c:\\"", property.getValue());
	}
	
	@Test
	void testFindProperty_1() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""Server Name"");
		assertNotNull(property);
		assertEquals(""Server Name"", property.getName());
		assertEquals(""My Server"", property.getValue());
	}
	
	@Test
	void testFindProperty_2() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""FTP_ROOT"");
		assertNotNull(property);
		assertEquals(""FTP_ROOT"", property.getName());
		assertEquals(""c:\\"", property.getValue());
	}
	
	@Test
	void testFindProperty_3() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""Server Name"");
		assertNotNull(property);
		assertEquals(""Server Name"", property.getName());
		assertEquals(""My Server"", property.getValue());
	}
	
	@Test
	void testFindProperty_4() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""FTP_ROOT"");
		assertNotNull(property);
		assertEquals(""FTP_ROOT"", property.getName());
		assertEquals(""c:\\"", property.getValue());
	}
	
	@Test
	void testFindProperty_5() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""Server Name"");
		assertNotNull(property);
		assertEquals(""Server Name"", property.getName());
		assertEquals(""My Server"", property.getValue());
	}
	
	@Test
	void testFindProperty_6() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""FTP_ROOT"");
		assertNotNull(property);
		assertEquals(""FTP_ROOT"", property.getName());
		assertEquals(""c:\\"", property.getValue());
	}
	
	@Test
	void testFindProperty_7() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""Server Name"");
		assertNotNull(property);
		assertEquals(""Server Name"", property.getName());
		assertEquals(""My Server"", property.getValue());
	}
	
	@Test
	void testFindProperty_8() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""FTP_ROOT"");
		assertNotNull(property);
		assertEquals(""FTP_ROOT"", property.getName());
		assertEquals(""c:\\"", property.getValue());
	}
	
	@Test
	void testFindProperty_9() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		Property property = applicationConfiguration.findProperty(""Server Name"");
		assertNotNull(property);
		assertEquals(""Server Name"", property.getName());
		assertEquals(""My Server"", property.getValue());
	}
	
}

// ApplicationConfiguration_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationConfiguration}.
* It contains ten unit test cases for the {@link ApplicationConfiguration#toXML(String)} method.
*/
class ApplicationConfiguration_1Test {
		
	@Test
	void testToXML_0() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String xml = applicationConfiguration.toXML(null);
		assertNotNull(xml);
		assertEquals(""<application-configuration>\n\t<prompt-type>gui</prompt-type><property>\n\t\t<property-name>FTP_ROOT</property-name>\n\t\t<property-value>c:\\</property-value>\n\t</property>\n<property>\n\t\t<property-name>Server Name</property-name>\n\t\t<property-value>My Server</property-value>\n\t</property>\n</application-configuration>\n"", xml);
	}
	
	@Test
	void testToXML_1() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String xml = applicationConfiguration.toXML(""\t"");
		assertNotNull(xml);
		assertEquals(""\t<application-configuration>\n\t\t<prompt-type>gui</prompt-type><property>\n\t\t\t<property-name>FTP_ROOT</property-name>\n\t\t\t<property-value>c:\\</property-value>\n\t\t</property>\n\t<property>\n\t\t\t<property-name>Server Name</property-name>\n\t\t\t<property-value>My Server</property-value>\n\t\t</property>\n\t</application-configuration>\n"", xml);
	}
	
	@Test
	void testToXML_2() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.add"
cmpl-6tzUnzaI78qaqlFqOw6LD7tJBIegM,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ApplicationConfiguration_1Test.java,58.69560098648071,length,"// ApplicationConfiguration.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the Application Configuration.
 *  The example xml is <pre>
 *  &lt;quickserver&gt;
 * 	....
 * 	&lt;application-configuration&gt;
 * 		&lt;property&gt;
 * 			&lt;property-name&gt;FTP_ROOT&lt;/property-name&gt;
 * 			&lt;property-value&gt;c:\&lt;/property-value&gt;
 * 		&lt;/property&gt;
 * 		&lt;property&gt;
 * 			&lt;property-name&gt;Server Name&lt;/property-name&gt;
 * 			&lt;property-value&gt;My Server&lt;/property-value&gt;
 * 		&lt;/property&gt;
 * 	&lt;/application-configuration&gt;
 * 	....
 * &lt;/quickserver&gt;
 * </pre>
 *  @author Akshathkumar Shetty
 *  @since 1.3.2
 */
public class ApplicationConfiguration extends HashMap {

    //OR console
    private String promptType = ""gui"";

    /**
     * Sets the PromptType.
     * XML Tag: &lt;prompt-type&gt;true&lt;/prompt-typ&gt;
     * Allowed values = <code>gui</code> | <code>console</code>
     * @see #getPromptType
     * @since 1.4.5
     */
    public void setPromptType(String promptType) {
        if (promptType != null && promptType.equals("""") == false)
            if (promptType.equals(""gui"") || promptType.equals(""console""))
                this.promptType = promptType;
    }

    /**
     * Returns the PromptType
     * @see #setPromptType
     * @since 1.4.5
     */
    public String getPromptType() {
        return promptType;
    }

    /**
     * Addes the {@link Property} passed to the HashMap
     */
    public void addProperty(Property property) {
        put(property.getName(), property.getValue());
    }

    /**
     * Finds if any {@link Property} is present.
     * @return <code>null</code> if no Property was found.
     */
    public Property findProperty(String name) {
        String temp = (String) get(name);
        if (temp != null) {
            return new Property(name, temp);
        } else {
            return null;
        }
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<application-configuration>\n"");
        sb.append(pad).append(""\t<prompt-type>"").append(getPromptType()).append(""</prompt-type>"");
        Iterator iterator = keySet().iterator();
        while (iterator.hasNext()) {
            String key = (String) iterator.next();
            String value = (String) get(key);
            sb.append(pad).append(""\t<property>"");
            sb.append(pad).append(""\t\t<property-name>"").append(key).append(""</property-name>\n"");
            sb.append(pad).append(""\t\t<property-value>"").append(value).append(""</property-value>\n"");
            sb.append(pad).append(""\t</property>\n"");
        }
        sb.append(pad).append(""</application-configuration>\n"");
        return sb.toString();
    }
}
","// ApplicationConfiguration_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationConfiguration}.
* It contains ten unit test cases for the {@link ApplicationConfiguration#toXML(String)} method.
*/
class ApplicationConfiguration_1Test {","// ApplicationConfiguration_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ApplicationConfiguration}.
* It contains ten unit test cases for the {@link ApplicationConfiguration#toXML(String)} method.
*/
class ApplicationConfiguration_1Test {

	@Test
	public void testToXML_1() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""gui"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>gui</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(null));
	}
	
	@Test
	public void testToXML_2() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""console"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>console</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(null));
	}
	
	@Test
	public void testToXML_3() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""gui"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>gui</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(""""));
	}
	
	@Test
	public void testToXML_4() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""console"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>console</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(""""));
	}
	
	@Test
	public void testToXML_5() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""gui"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>gui</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(""\t""));
	}
	
	@Test
	public void testToXML_6() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""console"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My Server""));
		String expected = ""<application-configuration>\n"" +
			""\t<prompt-type>console</prompt-type>"" +
			""\t<property>\n"" +
			""\t\t<property-name>FTP_ROOT</property-name>\n"" +
			""\t\t<property-value>c:\\</property-value>\n"" +
			""\t</property>\n"" +
			""\t<property>\n"" +
			""\t\t<property-name>Server Name</property-name>\n"" +
			""\t\t<property-value>My Server</property-value>\n"" +
			""\t</property>\n"" +
			""</application-configuration>\n"";
		assertEquals(expected, applicationConfiguration.toXML(""\t""));
	}
	
	@Test
	public void testToXML_7() {
		ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
		applicationConfiguration.setPromptType(""gui"");
		applicationConfiguration.addProperty(new Property(""FTP_ROOT"", ""c:\\""));
		applicationConfiguration.addProperty(new Property(""Server Name"", ""My"
cmpl-6tzVq3RizmHlR9JPGgeBAqsVW4dbP,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ByteBufferObjectPoolConfig.java,49.83611869812012,length,"// ByteBufferObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the ByteBuffer Object pool configuration.
 * The xml is &lt;byte-buffer-object-pool&gt;...&lt;/byte-buffer-object-pool&gt;
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ByteBufferObjectPoolConfig extends PoolConfig {

    public ByteBufferObjectPoolConfig() {
        super();
    }

    public ByteBufferObjectPoolConfig(PoolConfig poolConfig) {
        setMaxActive(poolConfig.getMaxActive());
        setMaxIdle(poolConfig.getMaxIdle());
        setInitSize(poolConfig.getInitSize());
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<byte-buffer-object-pool>\n"");
        sb.append(pad).append(""\t<max-active>"").append(getMaxActive()).append(""</max-active>\n"");
        sb.append(pad).append(""\t<max-idle>"").append(getMaxIdle()).append(""</max-idle>\n"");
        sb.append(pad).append(""\t<init-size>"").append(getInitSize()).append(""</init-size>\n"");
        sb.append(pad).append(""</byte-buffer-object-pool>\n"");
        return sb.toString();
    }
}
","// ByteBufferObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferObjectPoolConfig}.
* It contains ten unit test cases for the {@link ByteBufferObjectPoolConfig#toXML(String)} method.
*/
class ByteBufferObjectPoolConfigTest {","// ByteBufferObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferObjectPoolConfig}.
* It contains ten unit test cases for the {@link ByteBufferObjectPoolConfig#toXML(String)} method.
*/
class ByteBufferObjectPoolConfigTest {

	@Test
	void testToXML() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPad() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<byte-buffer-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithNullPad() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(null);
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithEmptyPad() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActive() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxIdle() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxIdle(5);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithInitSize() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActiveAndMaxIdle() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActiveAndInitSize() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxIdleAndInitSize() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActiveAndMaxIdleAndInitSize() {
		ByteBufferObjectPoolConfig config = new ByteBufferObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<byte-buffer-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</byte-buffer-object-pool>\n"", xml);
	}
	
}

// ByteBufferObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferObjectPoolConfig}.
* It contains ten unit test cases for the {@link ByteBufferObjectPoolConfig#toXML(String)} method.
*/
class ByteBufferObjectPoolConfigTest {
		
	@Test
	void testToXML() {
"
cmpl-6tzWuHfUOYp7jCGiTYCP6yLbb8QWn,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ClientDataObjectPoolConfig.java,75.90103721618652,length,"// ClientDataObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the Thread Object pool configuration.
 * The xml is &lt;client-data-object-pool&gt;...&lt;/client-data-object-pool&gt;
 * @author Akshathkumar Shetty
 */
public class ClientDataObjectPoolConfig extends PoolConfig {

    public ClientDataObjectPoolConfig() {
        super();
    }

    public ClientDataObjectPoolConfig(PoolConfig poolConfig) {
        setMaxActive(poolConfig.getMaxActive());
        setMaxIdle(poolConfig.getMaxIdle());
        setInitSize(poolConfig.getInitSize());
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<client-data-object-pool>\n"");
        sb.append(pad).append(""\t<max-active>"").append(getMaxActive()).append(""</max-active>\n"");
        sb.append(pad).append(""\t<max-idle>"").append(getMaxIdle()).append(""</max-idle>\n"");
        sb.append(pad).append(""\t<init-size>"").append(getInitSize()).append(""</init-size>\n"");
        sb.append(pad).append(""</client-data-object-pool>\n"");
        return sb.toString();
    }
}
","// ClientDataObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientDataObjectPoolConfig}.
* It contains ten unit test cases for the {@link ClientDataObjectPoolConfig#toXML(String)} method.
*/
class ClientDataObjectPoolConfigTest {","// ClientDataObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientDataObjectPoolConfig}.
* It contains ten unit test cases for the {@link ClientDataObjectPoolConfig#toXML(String)} method.
*/
class ClientDataObjectPoolConfigTest {

	@Test
	void testToXML() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""<client-data-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(null));
	}
	
	@Test
	void testToXMLWithPad() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActive() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxIdle() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxIdle(5);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndInitSize() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdle() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndInitSize() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxIdleAndInitSize() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdleAndInitSize() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdleAndInitSizeAndNull() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""        <init-size>2</init-size>\n"" +
				""    </client-data-object-pool>\n"";
		assertEquals(expected, clientDataObjectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdleAndInitSizeAndEmpty() {
		ClientDataObjectPoolConfig clientDataObjectPoolConfig = new ClientDataObjectPoolConfig();
		clientDataObjectPoolConfig.setMaxActive(10);
		clientDataObjectPoolConfig.setMaxIdle(5);
		clientDataObjectPoolConfig.setInitSize(2);
		String expected = ""    <client-data-object-pool>\n"" +
				""        <"
cmpl-6tzY7BuuwBFh6DCNxslN4Ahl0KirE,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ClientHandlerObjectPoolConfig.java,66.8929922580719,length,"// ClientHandlerObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the ClientHandler Object pool configuration.
 * The xml is &lt;client-handler-object-pool&gt;...&lt;/client-handler-object-pool&gt;
 * @author Akshathkumar Shetty
 */
public class ClientHandlerObjectPoolConfig extends PoolConfig {

    public ClientHandlerObjectPoolConfig() {
        super();
    }

    public ClientHandlerObjectPoolConfig(PoolConfig poolConfig) {
        setMaxActive(poolConfig.getMaxActive());
        setMaxIdle(poolConfig.getMaxIdle());
        setInitSize(poolConfig.getInitSize());
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<client-handler-object-pool>\n"");
        sb.append(pad).append(""\t<max-active>"").append(getMaxActive()).append(""</max-active>\n"");
        sb.append(pad).append(""\t<max-idle>"").append(getMaxIdle()).append(""</max-idle>\n"");
        sb.append(pad).append(""\t<init-size>"").append(getInitSize()).append(""</init-size>\n"");
        sb.append(pad).append(""</client-handler-object-pool>\n"");
        return sb.toString();
    }
}
","// ClientHandlerObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientHandlerObjectPoolConfig}.
* It contains ten unit test cases for the {@link ClientHandlerObjectPoolConfig#toXML(String)} method.
*/
class ClientHandlerObjectPoolConfigTest {","// ClientHandlerObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientHandlerObjectPoolConfig}.
* It contains ten unit test cases for the {@link ClientHandlerObjectPoolConfig#toXML(String)} method.
*/
class ClientHandlerObjectPoolConfigTest {

	@Test
	void testToXML() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPad() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<client-handler-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithNullPad() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(null);
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithEmptyPad() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActiveZero() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(0);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>0</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxActiveNegative() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(-1);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>-1</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxIdleZero() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(0);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>0</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithMaxIdleNegative() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(-1);
		config.setInitSize(2);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>-1</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithInitSizeZero() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(0);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>0</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithInitSizeNegative() {
		ClientHandlerObjectPoolConfig config = new ClientHandlerObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(-1);
		String xml = config.toXML("""");
		assertEquals(""<client-handler-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>-1</init-size>\n"" +
				""</client-handler-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithAllZero() {
"
cbefdf75-f1db-4211-8770-5e084d7b4f04,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ConfigReader_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11575 tokens (9575 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// ConfigReader.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;

/**
 * This class reads the xml configuration and gives
 * QuickServerConfig object.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ConfigReader {

    private static Logger logger = Logger.getLogger(ConfigReader.class.getName());

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.3
     */
    public static QuickServerConfig read(String fileName) throws Exception {
        File configFile = new File(fileName);
        FileInputStream fis = new FileInputStream(configFile);
        logger.fine(""Loading config from xml file : "" + configFile.getAbsolutePath());
        return read(fis, configFile.getAbsolutePath());
    }

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.4
     */
    public static QuickServerConfig read(InputStream input, String config_file_location) throws Exception {
        Digester digester = new Digester();
        digester.setValidating(false);
        //digester.setNamespaceAware(true);
        //String xsd = """" + new File(""quickserver_config.xsd"").toURI();
        //digester.setSchema(xsd);
        String mainTag = ""quickserver"";
        String subTag = """";
        digester.addObjectCreate(mainTag, QuickServerConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(mainTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(mainTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(mainTag + ""/bind-address"", ""bindAddr"");
        //<server-mode>
        String curTag = mainTag + ""/server-mode"";
        digester.addObjectCreate(curTag, ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/blocking"", ""blocking"");
        digester.addSetNext(curTag, ""setServerMode"");
        //</server-mode>
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(mainTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(mainTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(mainTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(mainTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        curTag = mainTag + ""/default-data-mode"";
        digester.addObjectCreate(curTag, DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag, ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        curTag = mainTag + ""/object-pool"";
        digester.addObjectCreate(curTag, ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag, ""setObjectPoolConfig"");
        //</object-pool>
        //<communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/communication-logging/enable"", ""communicationLogging"");
        //</communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/security-manager-class"", ""securityManagerClass"");
        //<access-constraint>
        digester.addObjectCreate(mainTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(mainTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(mainTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(mainTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(mainTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<application-jar-path>
        digester.addBeanPropertySetter(mainTag + ""/application-jar-path"", ""applicationJarPath"");
        //<server-hooks>
        digester.addObjectCreate(mainTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(mainTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        curTag = mainTag + ""/secure"";
        digester.addObjectCreate(curTag, Secure.class);
        digester.addBeanPropertySetter(curTag + ""/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag, ""setSecure"");
        //</secure>
        //<advanced-settings>
        curTag = mainTag + ""/advanced-settings"";
        digester.addObjectCreate(curTag, AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-connection-time"", ""performancePreferencesConnectionTime"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-latency"", ""performancePreferencesLatency"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-bandwidth"", ""performancePreferencesBandwidth"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-tcp-no-delay"", ""clientSocketTcpNoDelay"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-traffic-class"", ""clientSocketTrafficClass"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-receive-buffer-size"", ""clientSocketReceiveBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-send-buffer-size"", ""clientSocketSendBufferSize"");
        digester.addSetNext(curTag, ""setAdvancedSettings"");
        //</advanced-settings>
        //<qsadmin-server>
        subTag = ""qsadmin-server"";
        curTag = mainTag + ""/"" + subTag;
        digester.addObjectCreate(curTag, QSAdminServerConfig.class);
        digester.addBeanPropertySetter(curTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        //<server-mode>
        digester.addObjectCreate(curTag + ""/server-mode"", ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/server-mode/blocking"", ""blocking"");
        digester.addSetNext(curTag + ""/server-mode"", ""setServerMode"");
        //</server-mode>
        digester.addBeanPropertySetter(curTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(curTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(curTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(curTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(curTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(curTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(curTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(curTag + ""/bind-address"", ""bindAddr"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        digester.addObjectCreate(curTag + ""/default-data-mode"", DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag + ""/default-data-mode"", ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        digester.addObjectCreate(curTag + ""/object-pool"", ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag + ""/object-pool"", ""setObjectPoolConfig"");
        //</object-pool>
        //<command-shell>
        digester.addBeanPropertySetter(curTag + ""/command-shell/enable"", ""commandShellEnable"");
        digester.addBeanPropertySetter(curTag + ""/command-shell/prompt-name"", ""commandShellPromptName"");
        //</command-shell>
        //<communication-logging><enable>
        digester.addBeanPropertySetter(curTag + ""/communication-logging/enable"", ""communicationLogging"");
        //<access-constraint>
        digester.addObjectCreate(curTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(curTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(curTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(curTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(curTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<server-hooks>
        digester.addObjectCreate(curTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(curTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(curTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        digester.addObjectCreate(curTag + ""/secure"", Secure.class);
        digester.addBeanPropertySetter(curTag + ""/secure/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/secure/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/secure/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/secure/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/secure/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag + ""/secure"", ""setSecure"");
        //</secure>
        digester.addBeanPropertySetter(curTag + ""/command-plugin"", ""commandPlugin"");
        //<advanced-settings>
        digester.addObjectCreate(curTag + ""/advanced-settings"", AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addSetNext(curTag + ""/advanced-settings"", ""setAdvancedSettings"");
        //</advanced-settings>
        digester.addSetNext(curTag, ""setQSAdminServerConfig"");
        //</qsadmin-server>
        //<db-object-pool>
        subTag = ""db-object-pool"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, DBObjectPoolConfig.class);
        //<database-connection-set>
        digester.addObjectCreate(mainTag + ""/"" + subTag + ""/database-connection-set"", DatabaseConnectionSet.class);
        //<database-connection>
        curTag = mainTag + ""/"" + subTag + ""/database-connection-set/database-connection"";
        digester.addObjectCreate(curTag, DatabaseConnectionConfig.class);
        digester.addBeanPropertySetter(curTag + ""/id"", ""id"");
        digester.addBeanPropertySetter(curTag + ""/driver"", ""driver"");
        digester.addBeanPropertySetter(curTag + ""/url"", ""url"");
        digester.addBeanPropertySetter(curTag + ""/username"", ""username"");
        digester.addBeanPropertySetter(curTag + ""/password"", ""password"");
        digester.addSetNext(curTag, ""addDatabaseConnection"");
        //</database-connection>
        digester.addSetNext(mainTag + ""/"" + subTag + ""/database-connection-set"", ""setDatabaseConnectionSet"");
        //</database-connection-set>
        //<db-pool-util>
        curTag = mainTag + ""/"" + subTag + ""/db-pool-util"";
        digester.addBeanPropertySetter(curTag, ""dbPoolUtil"");
        //</db-pool-util>
        digester.addSetNext(mainTag + ""/"" + subTag, ""setDBObjectPoolConfig"");
        //</db-object-pool>
        //<application-configuration>
        subTag = ""application-configuration"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, ApplicationConfiguration.class);
        digester.addBeanPropertySetter(mainTag + ""/"" + subTag + ""/prompt-type"", ""promptType"");
        curTag = mainTag + ""/"" + subTag + ""/"" + ""property"";
        digester.addObjectCreate(curTag, Property.class);
        digester.addBeanPropertySetter(curTag + ""/property-name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/property-value"", ""value"");
        digester.addSetNext(curTag, ""addProperty"");
        digester.addSetNext(mainTag + ""/"" + subTag, ""setApplicationConfiguration"");
        //</application-configuration>
        //<init-server-hooks>
        subTag = ""init-server-hooks"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, InitServerHooks.class);
        digester.addCallMethod(mainTag + ""/"" + subTag + ""/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/"" + subTag, ""setInitServerHooks"");
        //</init-server-hooks>
        QuickServerConfig qsc = (QuickServerConfig) digester.parse(input);
        qsc.setConfigFile(config_file_location);
        loadMissingApplicationConfiguration(qsc);
        QuickServer.setDebugNonBlockingMode(qsc.getAdvancedSettings().getDebugNonBlockingMode());
        return qsc;
    }

    private static void loadMissingApplicationConfiguration(QuickServerConfig qsc) throws IOException {
        ApplicationConfiguration ac = qsc.getApplicationConfiguration();
        if (ac == null)
            return;
        //check if any application-configuration had missing property-value
        Set propertyNames = ac.keySet();
        Iterator iterator = propertyNames.iterator();
        String key = null;
        Object value = null;
        char[] sv = null;
        SensitiveInput sensitiveInput = null;
        boolean guiPrompt = ac.getPromptType().equals(""console"") == false ? true : false;
        while (iterator.hasNext()) {
            key = (String) iterator.next();
            value = ac.get(key);
            if (value == null) {
                if (guiPrompt && sensitiveInput == null) {
                    sensitiveInput = new SensitiveInput(qsc.getName() + "" - Input Prompt"");
                }
                if (guiPrompt)
                    sv = sensitiveInput.getInput(key);
                else
                    sv = PasswordField.getPassword(""Input property value for "" + key + "" : "");
                if (sv != null) {
                    value = new String(sv);
                    ac.put(key, value);
                }
                value = null;
            }
        }
    }

    /**
     * Make the file passed absolute, relative to the location of
     * configuration file that loaded QuickServerConfig object passed.
     * @since 1.4
     */
    public static File makeAbsoluteToConfig(String fileName, QuickServerConfig config) {
        File file = new File(fileName);
        if (config == null)
            return file;
        if (file.isAbsolute() == false) {
            String temp = config.getConfigFile();
            if (temp == null)
                return file;
            file = new File(temp);
            temp = file.getParent() + File.separatorChar + fileName;
            file = new File(temp);
        }
        return file;
    }
}
","// ConfigReader_0Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#read(String)} method.
*/
class ConfigReader_0Test {","// ConfigReader_0Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#read(String)} method.
*/
class ConfigReader_0Test {
"
06006746-3c0c-41d1-80d6-b0b19bdb85eb,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ConfigReader_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11578 tokens (9578 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// ConfigReader.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;

/**
 * This class reads the xml configuration and gives
 * QuickServerConfig object.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ConfigReader {

    private static Logger logger = Logger.getLogger(ConfigReader.class.getName());

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.3
     */
    public static QuickServerConfig read(String fileName) throws Exception {
        File configFile = new File(fileName);
        FileInputStream fis = new FileInputStream(configFile);
        logger.fine(""Loading config from xml file : "" + configFile.getAbsolutePath());
        return read(fis, configFile.getAbsolutePath());
    }

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.4
     */
    public static QuickServerConfig read(InputStream input, String config_file_location) throws Exception {
        Digester digester = new Digester();
        digester.setValidating(false);
        //digester.setNamespaceAware(true);
        //String xsd = """" + new File(""quickserver_config.xsd"").toURI();
        //digester.setSchema(xsd);
        String mainTag = ""quickserver"";
        String subTag = """";
        digester.addObjectCreate(mainTag, QuickServerConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(mainTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(mainTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(mainTag + ""/bind-address"", ""bindAddr"");
        //<server-mode>
        String curTag = mainTag + ""/server-mode"";
        digester.addObjectCreate(curTag, ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/blocking"", ""blocking"");
        digester.addSetNext(curTag, ""setServerMode"");
        //</server-mode>
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(mainTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(mainTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(mainTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(mainTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        curTag = mainTag + ""/default-data-mode"";
        digester.addObjectCreate(curTag, DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag, ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        curTag = mainTag + ""/object-pool"";
        digester.addObjectCreate(curTag, ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag, ""setObjectPoolConfig"");
        //</object-pool>
        //<communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/communication-logging/enable"", ""communicationLogging"");
        //</communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/security-manager-class"", ""securityManagerClass"");
        //<access-constraint>
        digester.addObjectCreate(mainTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(mainTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(mainTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(mainTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(mainTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<application-jar-path>
        digester.addBeanPropertySetter(mainTag + ""/application-jar-path"", ""applicationJarPath"");
        //<server-hooks>
        digester.addObjectCreate(mainTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(mainTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        curTag = mainTag + ""/secure"";
        digester.addObjectCreate(curTag, Secure.class);
        digester.addBeanPropertySetter(curTag + ""/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag, ""setSecure"");
        //</secure>
        //<advanced-settings>
        curTag = mainTag + ""/advanced-settings"";
        digester.addObjectCreate(curTag, AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-connection-time"", ""performancePreferencesConnectionTime"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-latency"", ""performancePreferencesLatency"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-bandwidth"", ""performancePreferencesBandwidth"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-tcp-no-delay"", ""clientSocketTcpNoDelay"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-traffic-class"", ""clientSocketTrafficClass"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-receive-buffer-size"", ""clientSocketReceiveBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-send-buffer-size"", ""clientSocketSendBufferSize"");
        digester.addSetNext(curTag, ""setAdvancedSettings"");
        //</advanced-settings>
        //<qsadmin-server>
        subTag = ""qsadmin-server"";
        curTag = mainTag + ""/"" + subTag;
        digester.addObjectCreate(curTag, QSAdminServerConfig.class);
        digester.addBeanPropertySetter(curTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        //<server-mode>
        digester.addObjectCreate(curTag + ""/server-mode"", ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/server-mode/blocking"", ""blocking"");
        digester.addSetNext(curTag + ""/server-mode"", ""setServerMode"");
        //</server-mode>
        digester.addBeanPropertySetter(curTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(curTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(curTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(curTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(curTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(curTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(curTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(curTag + ""/bind-address"", ""bindAddr"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        digester.addObjectCreate(curTag + ""/default-data-mode"", DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag + ""/default-data-mode"", ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        digester.addObjectCreate(curTag + ""/object-pool"", ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag + ""/object-pool"", ""setObjectPoolConfig"");
        //</object-pool>
        //<command-shell>
        digester.addBeanPropertySetter(curTag + ""/command-shell/enable"", ""commandShellEnable"");
        digester.addBeanPropertySetter(curTag + ""/command-shell/prompt-name"", ""commandShellPromptName"");
        //</command-shell>
        //<communication-logging><enable>
        digester.addBeanPropertySetter(curTag + ""/communication-logging/enable"", ""communicationLogging"");
        //<access-constraint>
        digester.addObjectCreate(curTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(curTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(curTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(curTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(curTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<server-hooks>
        digester.addObjectCreate(curTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(curTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(curTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        digester.addObjectCreate(curTag + ""/secure"", Secure.class);
        digester.addBeanPropertySetter(curTag + ""/secure/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/secure/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/secure/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/secure/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/secure/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag + ""/secure"", ""setSecure"");
        //</secure>
        digester.addBeanPropertySetter(curTag + ""/command-plugin"", ""commandPlugin"");
        //<advanced-settings>
        digester.addObjectCreate(curTag + ""/advanced-settings"", AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addSetNext(curTag + ""/advanced-settings"", ""setAdvancedSettings"");
        //</advanced-settings>
        digester.addSetNext(curTag, ""setQSAdminServerConfig"");
        //</qsadmin-server>
        //<db-object-pool>
        subTag = ""db-object-pool"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, DBObjectPoolConfig.class);
        //<database-connection-set>
        digester.addObjectCreate(mainTag + ""/"" + subTag + ""/database-connection-set"", DatabaseConnectionSet.class);
        //<database-connection>
        curTag = mainTag + ""/"" + subTag + ""/database-connection-set/database-connection"";
        digester.addObjectCreate(curTag, DatabaseConnectionConfig.class);
        digester.addBeanPropertySetter(curTag + ""/id"", ""id"");
        digester.addBeanPropertySetter(curTag + ""/driver"", ""driver"");
        digester.addBeanPropertySetter(curTag + ""/url"", ""url"");
        digester.addBeanPropertySetter(curTag + ""/username"", ""username"");
        digester.addBeanPropertySetter(curTag + ""/password"", ""password"");
        digester.addSetNext(curTag, ""addDatabaseConnection"");
        //</database-connection>
        digester.addSetNext(mainTag + ""/"" + subTag + ""/database-connection-set"", ""setDatabaseConnectionSet"");
        //</database-connection-set>
        //<db-pool-util>
        curTag = mainTag + ""/"" + subTag + ""/db-pool-util"";
        digester.addBeanPropertySetter(curTag, ""dbPoolUtil"");
        //</db-pool-util>
        digester.addSetNext(mainTag + ""/"" + subTag, ""setDBObjectPoolConfig"");
        //</db-object-pool>
        //<application-configuration>
        subTag = ""application-configuration"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, ApplicationConfiguration.class);
        digester.addBeanPropertySetter(mainTag + ""/"" + subTag + ""/prompt-type"", ""promptType"");
        curTag = mainTag + ""/"" + subTag + ""/"" + ""property"";
        digester.addObjectCreate(curTag, Property.class);
        digester.addBeanPropertySetter(curTag + ""/property-name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/property-value"", ""value"");
        digester.addSetNext(curTag, ""addProperty"");
        digester.addSetNext(mainTag + ""/"" + subTag, ""setApplicationConfiguration"");
        //</application-configuration>
        //<init-server-hooks>
        subTag = ""init-server-hooks"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, InitServerHooks.class);
        digester.addCallMethod(mainTag + ""/"" + subTag + ""/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/"" + subTag, ""setInitServerHooks"");
        //</init-server-hooks>
        QuickServerConfig qsc = (QuickServerConfig) digester.parse(input);
        qsc.setConfigFile(config_file_location);
        loadMissingApplicationConfiguration(qsc);
        QuickServer.setDebugNonBlockingMode(qsc.getAdvancedSettings().getDebugNonBlockingMode());
        return qsc;
    }

    private static void loadMissingApplicationConfiguration(QuickServerConfig qsc) throws IOException {
        ApplicationConfiguration ac = qsc.getApplicationConfiguration();
        if (ac == null)
            return;
        //check if any application-configuration had missing property-value
        Set propertyNames = ac.keySet();
        Iterator iterator = propertyNames.iterator();
        String key = null;
        Object value = null;
        char[] sv = null;
        SensitiveInput sensitiveInput = null;
        boolean guiPrompt = ac.getPromptType().equals(""console"") == false ? true : false;
        while (iterator.hasNext()) {
            key = (String) iterator.next();
            value = ac.get(key);
            if (value == null) {
                if (guiPrompt && sensitiveInput == null) {
                    sensitiveInput = new SensitiveInput(qsc.getName() + "" - Input Prompt"");
                }
                if (guiPrompt)
                    sv = sensitiveInput.getInput(key);
                else
                    sv = PasswordField.getPassword(""Input property value for "" + key + "" : "");
                if (sv != null) {
                    value = new String(sv);
                    ac.put(key, value);
                }
                value = null;
            }
        }
    }

    /**
     * Make the file passed absolute, relative to the location of
     * configuration file that loaded QuickServerConfig object passed.
     * @since 1.4
     */
    public static File makeAbsoluteToConfig(String fileName, QuickServerConfig config) {
        File file = new File(fileName);
        if (config == null)
            return file;
        if (file.isAbsolute() == false) {
            String temp = config.getConfigFile();
            if (temp == null)
                return file;
            file = new File(temp);
            temp = file.getParent() + File.separatorChar + fileName;
            file = new File(temp);
        }
        return file;
    }
}
","// ConfigReader_1Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#read(InputStream, String)} method.
*/
class ConfigReader_1Test {","// ConfigReader_1Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#read(InputStream, String)} method.
*/
class ConfigReader_1Test {
"
3996fe8c-c85f-4155-b716-bb81c78aad21,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ConfigReader_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11583 tokens (9583 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// ConfigReader.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;

/**
 * This class reads the xml configuration and gives
 * QuickServerConfig object.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ConfigReader {

    private static Logger logger = Logger.getLogger(ConfigReader.class.getName());

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.3
     */
    public static QuickServerConfig read(String fileName) throws Exception {
        File configFile = new File(fileName);
        FileInputStream fis = new FileInputStream(configFile);
        logger.fine(""Loading config from xml file : "" + configFile.getAbsolutePath());
        return read(fis, configFile.getAbsolutePath());
    }

    /**
     * Parses XML config of QuickServer of version 1.3 and above
     * @since 1.4
     */
    public static QuickServerConfig read(InputStream input, String config_file_location) throws Exception {
        Digester digester = new Digester();
        digester.setValidating(false);
        //digester.setNamespaceAware(true);
        //String xsd = """" + new File(""quickserver_config.xsd"").toURI();
        //digester.setSchema(xsd);
        String mainTag = ""quickserver"";
        String subTag = """";
        digester.addObjectCreate(mainTag, QuickServerConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(mainTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(mainTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(mainTag + ""/bind-address"", ""bindAddr"");
        //<server-mode>
        String curTag = mainTag + ""/server-mode"";
        digester.addObjectCreate(curTag, ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/blocking"", ""blocking"");
        digester.addSetNext(curTag, ""setServerMode"");
        //</server-mode>
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(mainTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(mainTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(mainTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(mainTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(mainTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(mainTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(mainTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(mainTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(mainTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(mainTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        curTag = mainTag + ""/default-data-mode"";
        digester.addObjectCreate(curTag, DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag, ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        curTag = mainTag + ""/object-pool"";
        digester.addObjectCreate(curTag, ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag, ""setObjectPoolConfig"");
        //</object-pool>
        //<communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/communication-logging/enable"", ""communicationLogging"");
        //</communication-logging>
        digester.addBeanPropertySetter(mainTag + ""/security-manager-class"", ""securityManagerClass"");
        //<access-constraint>
        digester.addObjectCreate(mainTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(mainTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(mainTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(mainTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(mainTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(mainTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<application-jar-path>
        digester.addBeanPropertySetter(mainTag + ""/application-jar-path"", ""applicationJarPath"");
        //<server-hooks>
        digester.addObjectCreate(mainTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(mainTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        curTag = mainTag + ""/secure"";
        digester.addObjectCreate(curTag, Secure.class);
        digester.addBeanPropertySetter(curTag + ""/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag, ""setSecure"");
        //</secure>
        //<advanced-settings>
        curTag = mainTag + ""/advanced-settings"";
        digester.addObjectCreate(curTag, AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-connection-time"", ""performancePreferencesConnectionTime"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-latency"", ""performancePreferencesLatency"");
        digester.addBeanPropertySetter(curTag + ""/performance-preferences-bandwidth"", ""performancePreferencesBandwidth"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-tcp-no-delay"", ""clientSocketTcpNoDelay"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-traffic-class"", ""clientSocketTrafficClass"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-receive-buffer-size"", ""clientSocketReceiveBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/client-socket-send-buffer-size"", ""clientSocketSendBufferSize"");
        digester.addSetNext(curTag, ""setAdvancedSettings"");
        //</advanced-settings>
        //<qsadmin-server>
        subTag = ""qsadmin-server"";
        curTag = mainTag + ""/"" + subTag;
        digester.addObjectCreate(curTag, QSAdminServerConfig.class);
        digester.addBeanPropertySetter(curTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/server-banner"", ""serverBanner"");
        digester.addBeanPropertySetter(curTag + ""/port"", ""port"");
        //<server-mode>
        digester.addObjectCreate(curTag + ""/server-mode"", ServerMode.class);
        digester.addBeanPropertySetter(curTag + ""/server-mode/blocking"", ""blocking"");
        digester.addSetNext(curTag + ""/server-mode"", ""setServerMode"");
        //</server-mode>
        digester.addBeanPropertySetter(curTag + ""/client-event-handler"", ""clientEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-command-handler"", ""clientCommandHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        //v1.4
        digester.addBeanPropertySetter(curTag + ""/client-binary-handler"", ""clientBinaryHandler"");
        //v1.4.5
        digester.addBeanPropertySetter(curTag + ""/client-write-handler"", ""clientWriteHandler"");
        //v1.3
        digester.addBeanPropertySetter(curTag + ""/authenticator"", ""authenticator"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-authentication-handler"", ""clientAuthenticationHandler"");
        digester.addBeanPropertySetter(curTag + ""/client-data"", ""clientData"");
        //v1.4.6
        digester.addBeanPropertySetter(curTag + ""/client-extended-event-handler"", ""clientExtendedEventHandler"");
        digester.addBeanPropertySetter(curTag + ""/timeout"", ""timeout"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try"", ""maxAuthTry"");
        digester.addBeanPropertySetter(curTag + ""/max-auth-try-msg"", ""maxAuthTryMsg"");
        digester.addBeanPropertySetter(curTag + ""/timeout-msg"", ""timeoutMsg"");
        digester.addBeanPropertySetter(curTag + ""/max-connection"", ""maxConnection"");
        digester.addBeanPropertySetter(curTag + ""/max-connection-msg"", ""maxConnectionMsg"");
        digester.addBeanPropertySetter(curTag + ""/bind-address"", ""bindAddr"");
        digester.addBeanPropertySetter(curTag + ""/client-object-handler"", ""clientObjectHandler"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-level"", ""consoleLoggingLevel"");
        digester.addBeanPropertySetter(curTag + ""/console-logging-formatter"", ""consoleLoggingFormatter"");
        //<default-data-mode>
        digester.addObjectCreate(curTag + ""/default-data-mode"", DefaultDataMode.class);
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-in"", ""dataModeIn"");
        digester.addBeanPropertySetter(curTag + ""/default-data-mode/data-type-out"", ""dataModeOut"");
        digester.addSetNext(curTag + ""/default-data-mode"", ""setDefaultDataMode"");
        //</default-data-mode>
        //<object-pool>
        digester.addObjectCreate(curTag + ""/object-pool"", ObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/init-size"", ""initSize"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/pool-manager"", ""poolManager"");
        //<thread-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/thread-object-pool"", ThreadObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/thread-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/thread-object-pool"", ""setThreadObjectPoolConfig"");
        //</thread-object-pool>
        //<client-handler-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-handler-object-pool"", ClientHandlerObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-handler-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-handler-object-pool"", ""setClientHandlerObjectPoolConfig"");
        //</client-handler-object-pool>
        //<byte-buffer-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/byte-buffer-object-pool"", ByteBufferObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/byte-buffer-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/byte-buffer-object-pool"", ""setByteBufferObjectPoolConfig"");
        //</byte-buffer-object-pool>
        //<client-data-object-pool>
        digester.addObjectCreate(curTag + ""/object-pool/client-data-object-pool"", ClientDataObjectPoolConfig.class);
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-active"", ""maxActive"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/max-idle"", ""maxIdle"");
        digester.addBeanPropertySetter(curTag + ""/object-pool/client-data-object-pool/init-size"", ""initSize"");
        digester.addSetNext(curTag + ""/object-pool/client-data-object-pool"", ""setClientDataObjectPoolConfig"");
        //</client-data-object-pool>
        digester.addSetNext(curTag + ""/object-pool"", ""setObjectPoolConfig"");
        //</object-pool>
        //<command-shell>
        digester.addBeanPropertySetter(curTag + ""/command-shell/enable"", ""commandShellEnable"");
        digester.addBeanPropertySetter(curTag + ""/command-shell/prompt-name"", ""commandShellPromptName"");
        //</command-shell>
        //<communication-logging><enable>
        digester.addBeanPropertySetter(curTag + ""/communication-logging/enable"", ""communicationLogging"");
        //<access-constraint>
        digester.addObjectCreate(curTag + ""/access-constraint"", AccessConstraintConfig.class);
        //<ip-filter>
        digester.addObjectCreate(curTag + ""/access-constraint/ip-filter"", IpFilterConfig.class);
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/access-constraint/ip-filter/allow-access"", ""allowAccess"");
        //<ip-collection>
        digester.addCallMethod(curTag + ""/access-constraint/ip-filter/ip-collection/client-ip-address"", ""addClientIpAddress"", 0);
        //<ip-collection>
        digester.addSetNext(curTag + ""/access-constraint/ip-filter"", ""setIpFilterConfig"");
        //<ip-filter>
        digester.addSetNext(curTag + ""/access-constraint"", ""setAccessConstraintConfig"");
        //</access-constraint>
        //<server-hooks>
        digester.addObjectCreate(curTag + ""/server-hooks"", ServerHooks.class);
        digester.addCallMethod(curTag + ""/server-hooks/class-name"", ""addClassName"", 0);
        digester.addSetNext(curTag + ""/server-hooks"", ""setServerHooks"");
        //</server-hooks>
        //<secure>
        digester.addObjectCreate(curTag + ""/secure"", Secure.class);
        digester.addBeanPropertySetter(curTag + ""/secure/enable"", ""enable"");
        digester.addBeanPropertySetter(curTag + ""/secure/load"", ""load"");
        digester.addBeanPropertySetter(curTag + ""/secure/port"", ""port"");
        digester.addBeanPropertySetter(curTag + ""/secure/protocol"", ""protocol"");
        digester.addBeanPropertySetter(curTag + ""/secure/client-auth-enable"", ""clientAuthEnable"");
        //<secure-store>
        digester.addObjectCreate(curTag + ""/secure/secure-store"", SecureStore.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/algorithm"", ""algorithm"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/provider"", ""provider"");
        //<key-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/key-store-info"", KeyStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/key-store-info/key-password"", ""keyPassword"");
        digester.addSetNext(curTag + ""/secure/secure-store/key-store-info"", ""setKeyStoreInfo"");
        //</key-store-info>
        //<trust-store-info>
        digester.addObjectCreate(curTag + ""/secure/secure-store/trust-store-info"", TrustStoreInfo.class);
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-file"", ""storeFile"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/store-password"", ""storePassword"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/type"", ""type"");
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/trust-store-info/provider"", ""provider"");
        digester.addSetNext(curTag + ""/secure/secure-store/trust-store-info"", ""setTrustStoreInfo"");
        //</trust-store-info>
        digester.addBeanPropertySetter(curTag + ""/secure/secure-store/secure-store-manager"", ""secureStoreManager"");
        digester.addSetNext(curTag + ""/secure/secure-store"", ""setSecureStore"");
        //</secure-store>
        digester.addSetNext(curTag + ""/secure"", ""setSecure"");
        //</secure>
        digester.addBeanPropertySetter(curTag + ""/command-plugin"", ""commandPlugin"");
        //<advanced-settings>
        digester.addObjectCreate(curTag + ""/advanced-settings"", AdvancedSettings.class);
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/charset"", ""charset"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/byte-buffer-size"", ""byteBufferSize"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/backlog"", ""backlog"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/use-direct-byte-buffer"", ""useDirectByteBuffer"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/socket-linger"", ""socketLinger"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/debug-non-blocking-mode"", ""debugNonBlockingMode"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/client-identifier"", ""clientIdentifier"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/qsobject-pool-maker"", ""qSObjectPoolMaker"");
        digester.addBeanPropertySetter(curTag + ""/advanced-settings/max-threads-for-nio-write"", ""maxThreadsForNioWrite"");
        digester.addSetNext(curTag + ""/advanced-settings"", ""setAdvancedSettings"");
        //</advanced-settings>
        digester.addSetNext(curTag, ""setQSAdminServerConfig"");
        //</qsadmin-server>
        //<db-object-pool>
        subTag = ""db-object-pool"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, DBObjectPoolConfig.class);
        //<database-connection-set>
        digester.addObjectCreate(mainTag + ""/"" + subTag + ""/database-connection-set"", DatabaseConnectionSet.class);
        //<database-connection>
        curTag = mainTag + ""/"" + subTag + ""/database-connection-set/database-connection"";
        digester.addObjectCreate(curTag, DatabaseConnectionConfig.class);
        digester.addBeanPropertySetter(curTag + ""/id"", ""id"");
        digester.addBeanPropertySetter(curTag + ""/driver"", ""driver"");
        digester.addBeanPropertySetter(curTag + ""/url"", ""url"");
        digester.addBeanPropertySetter(curTag + ""/username"", ""username"");
        digester.addBeanPropertySetter(curTag + ""/password"", ""password"");
        digester.addSetNext(curTag, ""addDatabaseConnection"");
        //</database-connection>
        digester.addSetNext(mainTag + ""/"" + subTag + ""/database-connection-set"", ""setDatabaseConnectionSet"");
        //</database-connection-set>
        //<db-pool-util>
        curTag = mainTag + ""/"" + subTag + ""/db-pool-util"";
        digester.addBeanPropertySetter(curTag, ""dbPoolUtil"");
        //</db-pool-util>
        digester.addSetNext(mainTag + ""/"" + subTag, ""setDBObjectPoolConfig"");
        //</db-object-pool>
        //<application-configuration>
        subTag = ""application-configuration"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, ApplicationConfiguration.class);
        digester.addBeanPropertySetter(mainTag + ""/"" + subTag + ""/prompt-type"", ""promptType"");
        curTag = mainTag + ""/"" + subTag + ""/"" + ""property"";
        digester.addObjectCreate(curTag, Property.class);
        digester.addBeanPropertySetter(curTag + ""/property-name"", ""name"");
        digester.addBeanPropertySetter(curTag + ""/property-value"", ""value"");
        digester.addSetNext(curTag, ""addProperty"");
        digester.addSetNext(mainTag + ""/"" + subTag, ""setApplicationConfiguration"");
        //</application-configuration>
        //<init-server-hooks>
        subTag = ""init-server-hooks"";
        digester.addObjectCreate(mainTag + ""/"" + subTag, InitServerHooks.class);
        digester.addCallMethod(mainTag + ""/"" + subTag + ""/class-name"", ""addClassName"", 0);
        digester.addSetNext(mainTag + ""/"" + subTag, ""setInitServerHooks"");
        //</init-server-hooks>
        QuickServerConfig qsc = (QuickServerConfig) digester.parse(input);
        qsc.setConfigFile(config_file_location);
        loadMissingApplicationConfiguration(qsc);
        QuickServer.setDebugNonBlockingMode(qsc.getAdvancedSettings().getDebugNonBlockingMode());
        return qsc;
    }

    private static void loadMissingApplicationConfiguration(QuickServerConfig qsc) throws IOException {
        ApplicationConfiguration ac = qsc.getApplicationConfiguration();
        if (ac == null)
            return;
        //check if any application-configuration had missing property-value
        Set propertyNames = ac.keySet();
        Iterator iterator = propertyNames.iterator();
        String key = null;
        Object value = null;
        char[] sv = null;
        SensitiveInput sensitiveInput = null;
        boolean guiPrompt = ac.getPromptType().equals(""console"") == false ? true : false;
        while (iterator.hasNext()) {
            key = (String) iterator.next();
            value = ac.get(key);
            if (value == null) {
                if (guiPrompt && sensitiveInput == null) {
                    sensitiveInput = new SensitiveInput(qsc.getName() + "" - Input Prompt"");
                }
                if (guiPrompt)
                    sv = sensitiveInput.getInput(key);
                else
                    sv = PasswordField.getPassword(""Input property value for "" + key + "" : "");
                if (sv != null) {
                    value = new String(sv);
                    ac.put(key, value);
                }
                value = null;
            }
        }
    }

    /**
     * Make the file passed absolute, relative to the location of
     * configuration file that loaded QuickServerConfig object passed.
     * @since 1.4
     */
    public static File makeAbsoluteToConfig(String fileName, QuickServerConfig config) {
        File file = new File(fileName);
        if (config == null)
            return file;
        if (file.isAbsolute() == false) {
            String temp = config.getConfigFile();
            if (temp == null)
                return file;
            file = new File(temp);
            temp = file.getParent() + File.separatorChar + fileName;
            file = new File(temp);
        }
        return file;
    }
}
","// ConfigReader_2Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#makeAbsoluteToConfig(String, QuickServerConfig)} method.
*/
class ConfigReader_2Test {","// ConfigReader_2Test.java
package org.quickserver.util.xmlreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.commons.digester3.Digester;
import org.quickserver.net.server.QuickServer;
import org.quickserver.swing.SensitiveInput;
import org.quickserver.util.io.PasswordField;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigReader}.
* It contains ten unit test cases for the {@link ConfigReader#makeAbsoluteToConfig(String, QuickServerConfig)} method.
*/
class ConfigReader_2Test {
"
cmpl-6tzc7Hrr0I9kJwC2j7pnRSg2DUivm,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/DBObjectPoolConfig.java,53.52558612823486,length,"// DBObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the database object pool.
 * The xml is &lt;db-object-pool&gt;...&lt;/db-object-pool&gt;.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class DBObjectPoolConfig implements java.io.Serializable {

    private DatabaseConnectionSet databaseConnectionSet;

    private String dbPoolUtil;

    /**
     * Returns the DatabaseConnectionSet.
     * @return DatabaseConnectionSet
     */
    public DatabaseConnectionSet getDatabaseConnectionSet() {
        return databaseConnectionSet;
    }

    /**
     * Sets the DatabaseConnectionSet.
     * XML Tag: &lt;database-connection-set&gt;&lt;/database-connection-set&gt;
     * @param databaseConnectionSet
     */
    public void setDatabaseConnectionSet(DatabaseConnectionSet databaseConnectionSet) {
        this.databaseConnectionSet = databaseConnectionSet;
    }

    /**
     * Sets the {@link org.quickserver.sql.DBPoolUtil} class that handles the
     * database connection pools.
     * XML Tag: &lt;db-pool-util&gt;&lt;/db-pool-util&gt;
     * @param className the fully qualified name of the class
     * that implements {@link org.quickserver.sql.DBPoolUtil}.
     * @see #getDbPoolUtil
     */
    public void setDbPoolUtil(String className) {
        dbPoolUtil = className;
    }

    /**
     * Returns the {@link org.quickserver.sql.DBPoolUtil} class that handles the
     * database connection pools.
     * @see #setDbPoolUtil
     */
    public String getDbPoolUtil() {
        return dbPoolUtil;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<db-object-pool>\n"");
        if (getDatabaseConnectionSet() != null)
            sb.append(getDatabaseConnectionSet().toXML(pad + ""\t""));
        sb.append(pad).append(""\t<db-pool-util>"").append(getDbPoolUtil()).append(""</db-pool-util>\n"");
        sb.append(pad).append(""</db-object-pool>\n"");
        return sb.toString();
    }
}
","// DBObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DBObjectPoolConfig}.
* It contains ten unit test cases for the {@link DBObjectPoolConfig#toXML(String)} method.
*/
class DBObjectPoolConfigTest {","// DBObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DBObjectPoolConfig}.
* It contains ten unit test cases for the {@link DBObjectPoolConfig#toXML(String)} method.
*/
class DBObjectPoolConfigTest {

	@Test
	void testToXML() {
		DBObjectPoolConfig dbObjectPoolConfig = new DBObjectPoolConfig();
		dbObjectPoolConfig.setDbPoolUtil(""org.quickserver.sql.DBPoolUtil"");
		DatabaseConnectionSet databaseConnectionSet = new DatabaseConnectionSet();
		databaseConnectionSet.setName(""test"");
		databaseConnectionSet.setDriver(""org.hsqldb.jdbcDriver"");
		databaseConnectionSet.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		databaseConnectionSet.setUser(""sa"");
		databaseConnectionSet.setPassword("""");
		databaseConnectionSet.setMaxConn(10);
		databaseConnectionSet.setMinConn(5);
		databaseConnectionSet.setMaxWait(1000);
		databaseConnectionSet.setMaxIdleTime(1000);
		databaseConnectionSet.setMaxUseCount(1000);
		databaseConnectionSet.setMaxUseTime(1000);
		databaseConnectionSet.setTestQuery(""SELECT 1"");
		databaseConnectionSet.setTestQueryWait(1000);
		databaseConnectionSet.setTestQueryOnBorrow(true);
		databaseConnectionSet.setTestQueryOnReturn(true);
		databaseConnectionSet.setTestQueryOnIdle(true);
		databaseConnectionSet.setTestQueryOnCreate(true);
		databaseConnectionSet.setTestQueryOnDestroy(true);
		databaseConnectionSet.setTestQueryOnCheckout(true);
		databaseConnectionSet.setTestQueryOnCheckin(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnExhausted(true);
		databaseConnectionSet.setTestQueryOnError(true);
		databaseConnectionSet.setTestQueryOnTimeout(true);
		databaseConnectionSet.setTestQueryOnConnect(true);
		databaseConnectionSet.setTestQueryOnDisconnect(true);
		databaseConnectionSet.setTestQueryOnReconnect(true);
		databaseConnectionSet.setTestQueryOnShutdown(true);
		databaseConnectionSet.setTestQueryOnStartup(true);
		databaseConnectionSet.setTestQueryOnValidate(true);
		databaseConnectionSet.setTestQueryOnInvalidate(true);
		databaseConnectionSet.setTestQueryOnEvict(true);
		databaseConnectionSet.setTestQueryOnExpire(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTestQueryOnRelease(true);
		databaseConnectionSet.setTest"
cmpl-6tzdAlKuEwaAhFFwnJcObDPt1og6B,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/DatabaseConnectionConfig.java,33.799917697906494,length,"// DatabaseConnectionConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;

/**
 * This class encapsulate the database connection configuration.
 * The xml is &lt;database-connection&gt;...&lt;/database-connection&gt;
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class DatabaseConnectionConfig implements java.io.Serializable {

    private String id = """";

    private String driver = """";

    private String url = """";

    private String username = """";

    private String password = """";

    /**
     * Returns the id.
     * @return id that identifies the connection.
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the id.
     * XML Tag: &lt;id&gt;&lt;/id&gt;
     * @param id for this connection.
     */
    public void setId(String id) {
        if (id != null)
            this.id = id;
    }

    /**
     * Returns the database driver.
     * @return driver that driver class
     */
    public String getDriver() {
        return driver;
    }

    /**
     * Sets the database driver.
     * XML Tag: &lt;driver&gt;&lt;/driver&gt;
     * @param driver that driver class
     */
    public void setDriver(String driver) {
        if (driver != null)
            this.driver = driver;
    }

    /**
     * Returns the url.
     * @return URl for this connection.
     */
    public String getUrl() {
        return url;
    }

    /**
     * Sets the url.
     * XML Tag: &lt;url&gt;&lt;/url&gt;
     * @param url for this connection.
     */
    public void setUrl(String url) {
        if (url != null)
            this.url = url;
    }

    /**
     * Returns the username
     * @return username for this connection.
     */
    public String getUsername() {
        return username;
    }

    /**
     * Sets the username.
     * XML Tag: &lt;username&gt;&lt;/username&gt;
     * @param username for this connection.
     */
    public void setUsername(String username) {
        if (username != null)
            this.username = username;
    }

    /**
     * Returns the password.
     * @return password for this connection.
     */
    public String getPassword() {
        return password;
    }

    /**
     * Sets the password.
     * XML Tag: &lt;password&gt;&lt;/password&gt;
     * @param password for this connection.
     */
    public void setPassword(String password) {
        if (password != null)
            this.password = password;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<database-connection>\n"");
        sb.append(pad).append(""\t<id>"").append(getId()).append(""</id>\n"");
        sb.append(pad).append(""\t<driver>"").append(getDriver()).append(""</driver>\n"");
        sb.append(pad).append(""\t<url>"").append(getUrl()).append(""</url>\n"");
        sb.append(pad).append(""\t<username>"").append(getUsername()).append(""</username>\n"");
        sb.append(pad).append(""\t<password>"").append(getPassword()).append(""</password>\n"");
        sb.append(pad).append(""</database-connection>\n"");
        return sb.toString();
    }
}
","// DatabaseConnectionConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DatabaseConnectionConfig}.
* It contains ten unit test cases for the {@link DatabaseConnectionConfig#toXML(String)} method.
*/
class DatabaseConnectionConfigTest {","// DatabaseConnectionConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DatabaseConnectionConfig}.
* It contains ten unit test cases for the {@link DatabaseConnectionConfig#toXML(String)} method.
*/
class DatabaseConnectionConfigTest {

	@Test
	void testToXML() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(""id"");
		databaseConnectionConfig.setDriver(""driver"");
		databaseConnectionConfig.setUrl(""url"");
		databaseConnectionConfig.setUsername(""username"");
		databaseConnectionConfig.setPassword(""password"");
		String xml = databaseConnectionConfig.toXML("""");
		assertEquals(""<database-connection>\n"" + 
			""\t<id>id</id>\n"" + 
			""\t<driver>driver</driver>\n"" + 
			""\t<url>url</url>\n"" + 
			""\t<username>username</username>\n"" + 
			""\t<password>password</password>\n"" + 
			""</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_null() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(null);
		databaseConnectionConfig.setDriver(null);
		databaseConnectionConfig.setUrl(null);
		databaseConnectionConfig.setUsername(null);
		databaseConnectionConfig.setPassword(null);
		String xml = databaseConnectionConfig.toXML("""");
		assertEquals(""<database-connection>\n"" + 
			""\t<id></id>\n"" + 
			""\t<driver></driver>\n"" + 
			""\t<url></url>\n"" + 
			""\t<username></username>\n"" + 
			""\t<password></password>\n"" + 
			""</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_empty() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId("""");
		databaseConnectionConfig.setDriver("""");
		databaseConnectionConfig.setUrl("""");
		databaseConnectionConfig.setUsername("""");
		databaseConnectionConfig.setPassword("""");
		String xml = databaseConnectionConfig.toXML("""");
		assertEquals(""<database-connection>\n"" + 
			""\t<id></id>\n"" + 
			""\t<driver></driver>\n"" + 
			""\t<url></url>\n"" + 
			""\t<username></username>\n"" + 
			""\t<password></password>\n"" + 
			""</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(""id"");
		databaseConnectionConfig.setDriver(""driver"");
		databaseConnectionConfig.setUrl(""url"");
		databaseConnectionConfig.setUsername(""username"");
		databaseConnectionConfig.setPassword(""password"");
		String xml = databaseConnectionConfig.toXML(""\t"");
		assertEquals(""<database-connection>\n"" + 
			""\t\t<id>id</id>\n"" + 
			""\t\t<driver>driver</driver>\n"" + 
			""\t\t<url>url</url>\n"" + 
			""\t\t<username>username</username>\n"" + 
			""\t\t<password>password</password>\n"" + 
			""\t</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad_null() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(null);
		databaseConnectionConfig.setDriver(null);
		databaseConnectionConfig.setUrl(null);
		databaseConnectionConfig.setUsername(null);
		databaseConnectionConfig.setPassword(null);
		String xml = databaseConnectionConfig.toXML(""\t"");
		assertEquals(""<database-connection>\n"" + 
			""\t\t<id></id>\n"" + 
			""\t\t<driver></driver>\n"" + 
			""\t\t<url></url>\n"" + 
			""\t\t<username></username>\n"" + 
			""\t\t<password></password>\n"" + 
			""\t</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad_empty() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId("""");
		databaseConnectionConfig.setDriver("""");
		databaseConnectionConfig.setUrl("""");
		databaseConnectionConfig.setUsername("""");
		databaseConnectionConfig.setPassword("""");
		String xml = databaseConnectionConfig.toXML(""\t"");
		assertEquals(""<database-connection>\n"" + 
			""\t\t<id></id>\n"" + 
			""\t\t<driver></driver>\n"" + 
			""\t\t<url></url>\n"" + 
			""\t\t<username></username>\n"" + 
			""\t\t<password></password>\n"" + 
			""\t</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad_null_pad() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(""id"");
		databaseConnectionConfig.setDriver(""driver"");
		databaseConnectionConfig.setUrl(""url"");
		databaseConnectionConfig.setUsername(""username"");
		databaseConnectionConfig.setPassword(""password"");
		String xml = databaseConnectionConfig.toXML(null);
		assertEquals(""<database-connection>\n"" + 
			""\t<id>id</id>\n"" + 
			""\t<driver>driver</driver>\n"" + 
			""\t<url>url</url>\n"" + 
			""\t<username>username</username>\n"" + 
			""\t<password>password</password>\n"" + 
			""</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad_empty_pad() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(""id"");
		databaseConnectionConfig.setDriver(""driver"");
		databaseConnectionConfig.setUrl(""url"");
		databaseConnectionConfig.setUsername(""username"");
		databaseConnectionConfig.setPassword(""password"");
		String xml = databaseConnectionConfig.toXML("""");
		assertEquals(""<database-connection>\n"" + 
			""\t<id>id</id>\n"" + 
			""\t<driver>driver</driver>\n"" + 
			""\t<url>url</url>\n"" + 
			""\t<username>username</username>\n"" + 
			""\t<password>password</password>\n"" + 
			""</database-connection>\n"", xml);
	}
	
	@Test
	void testToXML_pad_null_pad_null() {
		DatabaseConnectionConfig databaseConnectionConfig = new DatabaseConnectionConfig();
		databaseConnectionConfig.setId(null);
		databaseConnectionConfig.setDriver(null);
		databaseConnectionConfig.setUrl(null);
		databaseConnectionConfig.setUsername(null);
		databaseConnectionConfig.set"
cmpl-6tzeDwKbPBrkXKwHWryDqR0IOHFwD,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/DatabaseConnectionSet_1Test.java,47.39689302444458,length,"// DatabaseConnectionSet.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 * This class encapsulate the database connection set.
 * The xml is &lt;database-connection-set&gt;...&lt;/database-connection-set&gt;
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class DatabaseConnectionSet implements java.io.Serializable {

    private ArrayList databaseConnectionSet = null;

    public DatabaseConnectionSet() {
        databaseConnectionSet = new ArrayList();
    }

    /**
     * Adds a DatabaseConnectionConfig object to the set.
     */
    public void addDatabaseConnection(DatabaseConnectionConfig dbcConfig) {
        if (dbcConfig != null) {
            databaseConnectionSet.add(dbcConfig);
        }
    }

    public Iterator iterator() {
        return databaseConnectionSet.iterator();
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<database-connection-set>\n"");
        Iterator iterator = iterator();
        while (iterator.hasNext()) {
            DatabaseConnectionConfig dcc = (DatabaseConnectionConfig) iterator.next();
            sb.append(dcc.toXML(pad + ""\t""));
        }
        sb.append(pad).append(""</database-connection-set>\n"");
        return sb.toString();
    }
}
","// DatabaseConnectionSet_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DatabaseConnectionSet}.
* It contains ten unit test cases for the {@link DatabaseConnectionSet#toXML(String)} method.
*/
class DatabaseConnectionSet_1Test {","// DatabaseConnectionSet_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DatabaseConnectionSet}.
* It contains ten unit test cases for the {@link DatabaseConnectionSet#toXML(String)} method.
*/
class DatabaseConnectionSet_1Test {

	@Test
	public void testToXML_1() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(null);
		assertEquals(""<database-connection-set>\n\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_2() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t"");
		assertEquals(""\t<database-connection-set>\n\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n\t</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_3() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML("""");
		assertEquals(""<database-connection-set>\n\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_4() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t\t"");
		assertEquals(""\t\t<database-connection-set>\n\t\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n\t\t</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_5() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t\t\t"");
		assertEquals(""\t\t\t<database-connection-set>\n\t\t\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n\t\t\t</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_6() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t\t\t\t"");
		assertEquals(""\t\t\t\t<database-connection-set>\n\t\t\t\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n\t\t\t\t</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_7() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t\t\t\t\t"");
		assertEquals(""\t\t\t\t\t<database-connection-set>\n\t\t\t\t\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/test\"" user=\""sa\"" password=\""\"" />\n\t\t\t\t\t</database-connection-set>\n"", xml);
	}
	
	@Test
	public void testToXML_8() {
		DatabaseConnectionSet dcs = new DatabaseConnectionSet();
		DatabaseConnectionConfig dcc = new DatabaseConnectionConfig();
		dcc.setId(""test"");
		dcc.setDriver(""org.hsqldb.jdbcDriver"");
		dcc.setUrl(""jdbc:hsqldb:hsql://localhost/test"");
		dcc.setUser(""sa"");
		dcc.setPassword("""");
		dcs.addDatabaseConnection(dcc);
		String xml = dcs.toXML(""\t\t\t\t\t\t"");
		assertEquals(""\t\t\t\t\t\t<database-connection-set>\n\t\t\t\t\t\t\t<database-connection id=\""test\"" driver=\""org.hsqldb.jdbcDriver\"" url=\""jdbc:hsqldb:hsql://localhost/"
cmpl-6tzfGPOcuTqRAMBYk2WQEMeLeBITK,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/DefaultDataMode_0Test.java,46.28309679031372,length,"// DefaultDataMode.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;

/**
 * This class encapsulate default DataMode for ClientHandler.
 * The xml is &lt;default-data-mode&gt;...&lt;/default-data-mode&gt;
 * @author Akshathkumar Shetty
 * @since 1.4.6
 */
public class DefaultDataMode implements java.io.Serializable {

    private DataMode defaultDataModeIN;

    private DataMode defaultDataModeOUT;

    public DefaultDataMode() {
        defaultDataModeIN = DataMode.STRING;
        defaultDataModeOUT = DataMode.STRING;
    }

    /**
     * Sets DataMode for DataType.IN
     * Valid values are <code>STRING|BYTE|OBJECT|BINARY</code>
     */
    public void setDataModeIn(String dataMode) {
        if (dataMode.toUpperCase().equals(""STRING""))
            defaultDataModeIN = DataMode.STRING;
        else if (dataMode.toUpperCase().equals(""BYTE""))
            defaultDataModeIN = DataMode.BYTE;
        else if (dataMode.toUpperCase().equals(""OBJECT""))
            defaultDataModeIN = DataMode.OBJECT;
        else if (dataMode.toUpperCase().equals(""BINARY""))
            defaultDataModeIN = DataMode.BINARY;
    }

    public String getDataModeIn() {
        return defaultDataModeIN.toString();
    }

    /**
     * Sets DataMode for DataType.OUT
     * Valid values are <code>STRING|BYTE|OBJECT|BINARY</code>
     */
    public void setDataModeOut(String dataMode) {
        if (dataMode.toUpperCase().equals(""STRING""))
            defaultDataModeOUT = DataMode.STRING;
        else if (dataMode.toUpperCase().equals(""BYTE""))
            defaultDataModeOUT = DataMode.BYTE;
        else if (dataMode.toUpperCase().equals(""OBJECT""))
            defaultDataModeOUT = DataMode.OBJECT;
        else if (dataMode.toUpperCase().equals(""BINARY""))
            defaultDataModeOUT = DataMode.BINARY;
    }

    public String getDataModeOut() {
        return defaultDataModeOUT.toString();
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     */
    public void setDataMode(DataMode dataMode, DataType dataType) {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     */
    public DataMode getDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<default-data-mode>\n"");
        sb.append(pad).append(""\t<data-type-in>"").append(getDataModeIn()).append(""</data-type-in>\n"");
        sb.append(pad).append(""\t<data-type-out>"").append(getDataModeOut()).append(""</data-type-out>\n"");
        sb.append(pad).append(""</default-data-mode>\n"");
        return sb.toString();
    }
}
","// DefaultDataMode_0Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#getDataMode(DataType)} method.
*/
class DefaultDataMode_0Test {","// DefaultDataMode_0Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#getDataMode(DataType)} method.
*/
class DefaultDataMode_0Test {

	@Test
	void testGetDataMode_0() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.STRING, DataType.OUT);
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_1() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.OUT);
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_2() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_3() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_4() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.OUT);
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_5() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_6() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_7() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.STRING, DataType.OUT);
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_8() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testGetDataMode_9() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.OUT));
	}
	
}

// DefaultDataMode_1Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#setDataMode(DataMode, DataType)} method.
*/
class DefaultDataMode_1Test {
		
	@Test
	void testSetDataMode_0() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.STRING, DataType.OUT);
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.STRING, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testSetDataMode_1() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.OUT);
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BYTE, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testSetDataMode_2() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.OBJECT, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void testSetDataMode_3() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.IN));
		assertEquals(DataMode.BINARY, defaultDataMode.getDataMode(DataType.OUT));
	}
	
	@Test
	void"
cmpl-6tzgJ2EHks5Lgf6AfGscWIKH6l8Kb,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/DefaultDataMode_1Test.java,53.39964580535889,length,"// DefaultDataMode.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;

/**
 * This class encapsulate default DataMode for ClientHandler.
 * The xml is &lt;default-data-mode&gt;...&lt;/default-data-mode&gt;
 * @author Akshathkumar Shetty
 * @since 1.4.6
 */
public class DefaultDataMode implements java.io.Serializable {

    private DataMode defaultDataModeIN;

    private DataMode defaultDataModeOUT;

    public DefaultDataMode() {
        defaultDataModeIN = DataMode.STRING;
        defaultDataModeOUT = DataMode.STRING;
    }

    /**
     * Sets DataMode for DataType.IN
     * Valid values are <code>STRING|BYTE|OBJECT|BINARY</code>
     */
    public void setDataModeIn(String dataMode) {
        if (dataMode.toUpperCase().equals(""STRING""))
            defaultDataModeIN = DataMode.STRING;
        else if (dataMode.toUpperCase().equals(""BYTE""))
            defaultDataModeIN = DataMode.BYTE;
        else if (dataMode.toUpperCase().equals(""OBJECT""))
            defaultDataModeIN = DataMode.OBJECT;
        else if (dataMode.toUpperCase().equals(""BINARY""))
            defaultDataModeIN = DataMode.BINARY;
    }

    public String getDataModeIn() {
        return defaultDataModeIN.toString();
    }

    /**
     * Sets DataMode for DataType.OUT
     * Valid values are <code>STRING|BYTE|OBJECT|BINARY</code>
     */
    public void setDataModeOut(String dataMode) {
        if (dataMode.toUpperCase().equals(""STRING""))
            defaultDataModeOUT = DataMode.STRING;
        else if (dataMode.toUpperCase().equals(""BYTE""))
            defaultDataModeOUT = DataMode.BYTE;
        else if (dataMode.toUpperCase().equals(""OBJECT""))
            defaultDataModeOUT = DataMode.OBJECT;
        else if (dataMode.toUpperCase().equals(""BINARY""))
            defaultDataModeOUT = DataMode.BINARY;
    }

    public String getDataModeOut() {
        return defaultDataModeOUT.toString();
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     */
    public void setDataMode(DataMode dataMode, DataType dataType) {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     */
    public DataMode getDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<default-data-mode>\n"");
        sb.append(pad).append(""\t<data-type-in>"").append(getDataModeIn()).append(""</data-type-in>\n"");
        sb.append(pad).append(""\t<data-type-out>"").append(getDataModeOut()).append(""</data-type-out>\n"");
        sb.append(pad).append(""</default-data-mode>\n"");
        return sb.toString();
    }
}
","// DefaultDataMode_1Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#toXML(String)} method.
*/
class DefaultDataMode_1Test {","// DefaultDataMode_1Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#toXML(String)} method.
*/
class DefaultDataMode_1Test {

	@Test
	void testToXML_1() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.STRING, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>STRING</data-type-in>\n"" +
				""\t<data-type-out>STRING</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_2() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>BYTE</data-type-in>\n"" +
				""\t<data-type-out>BYTE</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_3() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>OBJECT</data-type-in>\n"" +
				""\t<data-type-out>OBJECT</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_4() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>BINARY</data-type-in>\n"" +
				""\t<data-type-out>BINARY</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_5() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>STRING</data-type-in>\n"" +
				""\t<data-type-out>BYTE</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_6() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>STRING</data-type-in>\n"" +
				""\t<data-type-out>OBJECT</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_7() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.STRING, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>STRING</data-type-in>\n"" +
				""\t<data-type-out>BINARY</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_8() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.STRING, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>BYTE</data-type-in>\n"" +
				""\t<data-type-out>STRING</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_9() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.OBJECT, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>BYTE</data-type-in>\n"" +
				""\t<data-type-out>OBJECT</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
	@Test
	void testToXML_10() {
		DefaultDataMode defaultDataMode = new DefaultDataMode();
		defaultDataMode.setDataMode(DataMode.BYTE, DataType.IN);
		defaultDataMode.setDataMode(DataMode.BINARY, DataType.OUT);
		String expected = ""<default-data-mode>\n"" +
				""\t<data-type-in>BYTE</data-type-in>\n"" +
				""\t<data-type-out>BINARY</data-type-out>\n"" +
				""</default-data-mode>\n"";
		assertEquals(expected, defaultDataMode.toXML(null));
	}
	
}

// DefaultDataMode_2Test.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataMode}.
* It contains ten unit test cases for the {@link DefaultDataMode#to"
cmpl-6tzhMIHIjurtWVQuPwzhdFrIBoECW,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/InitServerHooks.java,38.762223958969116,length,"// InitServerHooks.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the init Server Hooks. Called just after server
 *  loads the xml configuration file. Can be using to set up loggers.
 *  The example xml is <pre>
 * 	....
 * 	&lt;init-server-hooks&gt;
 * 		&lt;class-name&gt;package1.Class1&lt;/class-name&gt;
 * 		&lt;class-name&gt;package1.Class2&lt;/class-name&gt;
 * 	&lt;/init-server-hooks&gt;
 * 	....
 *  </pre>
 *  @see org.quickserver.net.InitServerHook
 *  @see org.quickserver.util.xmlreader.ServerHooks
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class InitServerHooks extends ArrayList {

    /**
     * Addes the class to init server hooks.
     */
    public void addClassName(String className) {
        if (className != null && className.trim().length() != 0) {
            add(className.trim());
        }
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<init-server-hooks>\n"");
        Iterator iterator = iterator();
        while (iterator.hasNext()) {
            String classname = (String) iterator.next();
            sb.append(pad).append(""\t<class-name>"").append(classname).append(""</class-name>\n"");
        }
        sb.append(pad).append(""</init-server-hooks>\n"");
        return sb.toString();
    }
}
","// InitServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link InitServerHooks}.
* It contains ten unit test cases for the {@link InitServerHooks#toXML(String)} method.
*/
class InitServerHooksTest {","// InitServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link InitServerHooks}.
* It contains ten unit test cases for the {@link InitServerHooks#toXML(String)} method.
*/
class InitServerHooksTest {

	@Test
	public void testToXML() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName(""package1.Class1"");
		initServerHooks.addClassName(""package1.Class2"");
		String xml = initServerHooks.toXML(null);
		assertEquals(""<init-server-hooks>\n\t<class-name>package1.Class1</class-name>\n\t<class-name>package1.Class2</class-name>\n</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName(""package1.Class1"");
		initServerHooks.addClassName(""package1.Class2"");
		String xml = initServerHooks.toXML(""\t"");
		assertEquals(""\t<init-server-hooks>\n\t\t<class-name>package1.Class1</class-name>\n\t\t<class-name>package1.Class2</class-name>\n\t</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyList() {
		InitServerHooks initServerHooks = new InitServerHooks();
		String xml = initServerHooks.toXML(null);
		assertEquals(""<init-server-hooks>\n</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyListAndPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		String xml = initServerHooks.toXML(""\t"");
		assertEquals(""\t<init-server-hooks>\n\t</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNull() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName(null);
		String xml = initServerHooks.toXML(null);
		assertEquals(""<init-server-hooks>\n</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullAndPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName(null);
		String xml = initServerHooks.toXML(""\t"");
		assertEquals(""\t<init-server-hooks>\n\t</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyString() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName("""");
		String xml = initServerHooks.toXML(null);
		assertEquals(""<init-server-hooks>\n</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyStringAndPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName("""");
		String xml = initServerHooks.toXML(""\t"");
		assertEquals(""\t<init-server-hooks>\n\t</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithBlankString() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName("" "");
		String xml = initServerHooks.toXML(null);
		assertEquals(""<init-server-hooks>\n</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithBlankStringAndPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName("" "");
		String xml = initServerHooks.toXML(""\t"");
		assertEquals(""\t<init-server-hooks>\n\t</init-server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithBlankStringAndTabPad() {
		InitServerHooks initServerHooks = new InitServerHooks();
		initServerHooks.addClassName("" "");
		String xml = initServerHooks.toXML(""\t\t"");
		assertEquals(""\t\t<init-server-hooks>\n\t\t</init-server-hooks>\n"", xml);
	}
	
}

// ServerHooks.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the server hooks.
 *  The example xml is <pre>
 * 	....
 * 	&lt;server-hooks&gt;
 * 		&lt;class-name&gt;package1.Class1&lt;/class-name&gt;
 * 		&lt;class-name&gt;package1.Class2&lt;/class-name&gt;
 * 	&lt;/server-hooks&gt;
 * 	....
 *  </pre>
 *  @see org.quickserver.net.ServerHook
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class ServerHooks extends ArrayList {

    /**
     * Addes the class to server hooks.
     */
    public void addClassName(String className) {
        if (className != null && className.trim().length() != 0) {
            add(className.trim());
        }
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<server-hooks>\n"");
        Iterator iterator = iterator();
        while (iterator.hasNext()) {
            String classname = (String) iterator.next();
            sb.append(pad).append(""\t<class-name>"").append(classname).append(""</class-name>\n"");
        }
        sb.append(pad).append(""</server-hooks>\n"");
        return sb.toString();
    }
}

// ServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerHooks}.
* It contains ten unit test cases for the {@link ServerHooks#toXML(String)} method.
*/
class ServerHooksTest {
		
	@Test
	public void testToXML() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(""package1.Class1"");
		serverHooks.add"
cmpl-6tziPkpWE3Wo8ADLe6nNqil0sLXWk,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/IpFilterConfig_1Test.java,43.0617516040802,length,"// IpFilterConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 * This class encapsulate the IP based Filter config.
 * The xml is &lt;ip-filter&gt;...&lt;/ip-filter&gt;<br>
 * <b>Note:</b> Make sure that access from 127.0.0.1 is allowed at
 * all times, else some of the QsAdmin command will fail.
 * @author Akshathkumar Shetty
 * @since 1.3.3
 */
public class IpFilterConfig implements java.io.Serializable {

    private ArrayList ipCollection = null;

    private boolean enable = false;

    private boolean allowAccess = false;

    public IpFilterConfig() {
        ipCollection = new ArrayList();
    }

    /**
     * Adds a Client Ip Address to the list
     */
    public void addClientIpAddress(String clientIpAddress) {
        if (clientIpAddress != null) {
            ipCollection.add(clientIpAddress);
        }
    }

    /**
     * Returns ClientIpAddress collection
     */
    public ArrayList getIpCollection() {
        return ipCollection;
    }

    public Iterator iterator() {
        return ipCollection.iterator();
    }

    /**
     * Sets the IP filter enable flag.
     * XML Tag: &lt;ip-filter&gt;&lt;enable&gt;true&lt;/enable&gt;&lt;/ip-filter&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * @see #getEnable
     */
    public void setEnable(boolean enable) {
        this.enable = enable;
    }

    /**
     * Returns the IP filter enable flag.
     * @see #setEnable
     */
    public boolean getEnable() {
        return enable;
    }

    /**
     * Sets the allow access flag.
     * XML Tag: &lt;ip-filter&gt;&lt;allow-access&gt;true&lt;/allow-access&gt;&lt;/ip-filter&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * @see #getAllowAccess
     */
    public void setAllowAccess(boolean enable) {
        this.allowAccess = enable;
    }

    /**
     * Returns the allow access flag.
     * @see #setAllowAccess
     */
    public boolean getAllowAccess() {
        return allowAccess;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<ip-filter>\n"");
        sb.append(pad).append(""\t<enable>"").append(getEnable()).append(""</enable>\n"");
        sb.append(pad).append(""\t<allow-access>"").append(getAllowAccess()).append(""</allow-access>\n"");
        sb.append(pad).append(""\t<ip-collection>\n"");
        Iterator iterator = iterator();
        while (iterator.hasNext()) {
            String cip = (String) iterator.next();
            sb.append(pad).append(""\t\t<client-ip-address>"").append(cip).append(""</client-ip-address>\n"");
        }
        sb.append(pad).append(""\t</ip-collection>\n"");
        sb.append(pad).append(""</ip-filter>\n"");
        return sb.toString();
    }
}
","// IpFilterConfig_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IpFilterConfig}.
* It contains ten unit test cases for the {@link IpFilterConfig#toXML(String)} method.
*/
class IpFilterConfig_1Test {","// IpFilterConfig_1Test.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IpFilterConfig}.
* It contains ten unit test cases for the {@link IpFilterConfig#toXML(String)} method.
*/
class IpFilterConfig_1Test {

	@Test
	void testToXML_1() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		ipFilterConfig.addClientIpAddress(""192.168.1.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>true</enable>\n"" +
			""\t<allow-access>true</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t\t<client-ip-address>192.168.1.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_2() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(false);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		ipFilterConfig.addClientIpAddress(""192.168.1.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>true</enable>\n"" +
			""\t<allow-access>false</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t\t<client-ip-address>192.168.1.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_3() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(false);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		ipFilterConfig.addClientIpAddress(""192.168.1.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>false</enable>\n"" +
			""\t<allow-access>true</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t\t<client-ip-address>192.168.1.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_4() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(false);
		ipFilterConfig.setAllowAccess(false);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		ipFilterConfig.addClientIpAddress(""192.168.1.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>false</enable>\n"" +
			""\t<allow-access>false</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t\t<client-ip-address>192.168.1.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_5() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>true</enable>\n"" +
			""\t<allow-access>true</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_6() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(true);
		ipFilterConfig.setAllowAccess(false);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>true</enable>\n"" +
			""\t<allow-access>false</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_7() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(false);
		ipFilterConfig.setAllowAccess(true);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>false</enable>\n"" +
			""\t<allow-access>true</allow-access>\n"" +
			""\t<ip-collection>\n"" +
			""\t\t<client-ip-address>127.0.0.1</client-ip-address>\n"" +
			""\t</ip-collection>\n"" +
			""</ip-filter>\n"";
		assertEquals(expected, ipFilterConfig.toXML(null));
	}
	
	@Test
	void testToXML_8() {
		IpFilterConfig ipFilterConfig = new IpFilterConfig();
		ipFilterConfig.setEnable(false);
		ipFilterConfig.setAllowAccess(false);
		ipFilterConfig.addClientIpAddress(""127.0.0.1"");
		String expected = ""<ip-filter>\n"" +
			""\t<enable>false</enable>\n"" +
			""\t<allow-access>false</allow-access"
cmpl-6tzjSBL8uMioWhXkHKBsjTaCDG5qh,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/KeyStoreInfo.java,40.14052891731262,length,"// KeyStoreInfo.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 *  This class encapsulate Key Store.
 *  The example xml is <pre>
 * 	....
 * 	&lt;key-store-info&gt;
 * 		&lt;store-file&gt;NONE&lt;/store-file&gt;
 * 		&lt;store-password&gt;&lt;/store-password&gt;
 * 		&lt;key-password&gt;&lt;/key-password&gt;
 * 	&lt;/key-store-info&gt;
 * 	....
 *  </pre>
 *  @see TrustStoreInfo
 *  @see SecureStore
 *  @see Secure
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class KeyStoreInfo implements java.io.Serializable {

    private String storeFile = ""NONE"";

    private String storePassword = null;

    private String keyPassword = null;

    /**
     * Sets the store file path. This can be either absolute or
     * relative(to config file) path to the store file.
     * XML Tag: &lt;store-file&gt;NONE&lt;/store-file&gt;
     * @param storeFile store file.
     * @see #getStoreFile
     */
    public void setStoreFile(String storeFile) {
        if (storeFile != null && storeFile.trim().length() != 0)
            this.storeFile = storeFile;
    }

    /**
     * Returns the store file path. This can be either absolute or
     * relative(to config file) path to the store file.
     * @see #setStoreFile
     */
    public String getStoreFile() {
        return storeFile;
    }

    /**
     * Sets the store password.
     * XML Tag: &lt;store-password&gt;&lt;/store-password&gt;
     * @param storePassword store password
     * @see #getStorePassword
     */
    public void setStorePassword(String storePassword) {
        if (storePassword != null)
            this.storePassword = storePassword;
    }

    /**
     * Returns store password.
     * @see #setStorePassword
     */
    public String getStorePassword() {
        return storePassword;
    }

    /**
     * Sets the key password.
     * XML Tag: &lt;key-password&gt;&lt;/key-password&gt;
     * @param keyPassword key password
     * @see #getKeyPassword
     */
    public void setKeyPassword(String keyPassword) {
        if (keyPassword != null)
            this.keyPassword = keyPassword;
    }

    /**
     * Returns key password.
     * @see #setKeyPassword
     */
    public String getKeyPassword() {
        return keyPassword;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<key-store-info>\n"");
        sb.append(pad).append(""\t<store-file>"").append(getStoreFile()).append(""</store-file>\n"");
        if (getStorePassword() != null)
            sb.append(pad).append(""\t<store-password>"").append(getStorePassword()).append(""</store-password>\n"");
        else
            sb.append(pad).append(""\t</store-password>\n"");
        if (getKeyPassword() != null)
            sb.append(pad).append(""\t<key-password>"").append(getKeyPassword()).append(""</key-password>\n"");
        else
            sb.append(pad).append(""\t</key-password>\n"");
        sb.append(pad).append(""</key-store-info>\n"");
        return sb.toString();
    }
}
","// KeyStoreInfoTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link KeyStoreInfo}.
* It contains ten unit test cases for the {@link KeyStoreInfo#toXML(String)} method.
*/
class KeyStoreInfoTest {","// KeyStoreInfoTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link KeyStoreInfo}.
* It contains ten unit test cases for the {@link KeyStoreInfo#toXML(String)} method.
*/
class KeyStoreInfoTest {

	@Test
	void testToXML() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""<key-store-info>\n"" +
				""\t<store-file>NONE</store-file>\n"" +
				""\t<store-password></store-password>\n"" +
				""\t<key-password></key-password>\n"" +
				""</key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""""));
	}
	
	@Test
	void testToXML2() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""    <key-store-info>\n"" +
				""        <store-file>NONE</store-file>\n"" +
				""        <store-password></store-password>\n"" +
				""        <key-password></key-password>\n"" +
				""    </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""    ""));
	}
	
	@Test
	void testToXML3() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""        <key-store-info>\n"" +
				""                <store-file>NONE</store-file>\n"" +
				""                <store-password></store-password>\n"" +
				""                <key-password></key-password>\n"" +
				""        </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""        ""));
	}
	
	@Test
	void testToXML4() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                <key-store-info>\n"" +
				""                        <store-file>NONE</store-file>\n"" +
				""                        <store-password></store-password>\n"" +
				""                        <key-password></key-password>\n"" +
				""                </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                ""));
	}
	
	@Test
	void testToXML5() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                        <key-store-info>\n"" +
				""                                <store-file>NONE</store-file>\n"" +
				""                                <store-password></store-password>\n"" +
				""                                <key-password></key-password>\n"" +
				""                        </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                        ""));
	}
	
	@Test
	void testToXML6() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                                <key-store-info>\n"" +
				""                                        <store-file>NONE</store-file>\n"" +
				""                                        <store-password></store-password>\n"" +
				""                                        <key-password></key-password>\n"" +
				""                                </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                                ""));
	}
	
	@Test
	void testToXML7() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                                        <key-store-info>\n"" +
				""                                                <store-file>NONE</store-file>\n"" +
				""                                                <store-password></store-password>\n"" +
				""                                                <key-password></key-password>\n"" +
				""                                        </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                                        ""));
	}
	
	@Test
	void testToXML8() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                                                <key-store-info>\n"" +
				""                                                        <store-file>NONE</store-file>\n"" +
				""                                                        <store-password></store-password>\n"" +
				""                                                        <key-password></key-password>\n"" +
				""                                                </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                                                ""));
	}
	
	@Test
	void testToXML9() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                                                        <key-store-info>\n"" +
				""                                                                <store-file>NONE</store-file>\n"" +
				""                                                                <store-password></store-password>\n"" +
				""                                                                <key-password></key-password>\n"" +
				""                                                        </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                                                        ""));
	}
	
	@Test
	void testToXML10() {
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""NONE"");
		keyStoreInfo.setStorePassword("""");
		keyStoreInfo.setKeyPassword("""");
		String expected = ""                                                                <key-store-info>\n"" +
				""                                                                        <store-file>NONE</store-file>\n"" +
				""                                                                        <store-password></store-password>\n"" +
				""                                                                        <key-password></key-password>\n"" +
				""                                                                </key-store-info>\n"";
		assertEquals(expected, keyStoreInfo.toXML(""                                                                ""));
	}
}

// SecureStore.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer"
cmpl-6tzkW37NFFm360FSqvSI9jZbBJkzp,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ObjectPoolConfig.java,44.817256450653076,length,"// ObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the Object pool configuration.
 * The xml is &lt;object-pool&gt;...&lt;/object-pool&gt;
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ObjectPoolConfig extends PoolConfig {

    private ThreadObjectPoolConfig threadObjectPoolConfig;

    private ClientHandlerObjectPoolConfig clientHandlerObjectPoolConfig;

    private ByteBufferObjectPoolConfig byteBufferObjectPoolConfig;

    private ClientDataObjectPoolConfig clientDataObjectPoolConfig;

    private String poolManager = null;

    /**
     * Returns PoolManager object
     * @return poolManager
     */
    public String getPoolManager() {
        if (poolManager == null)
            poolManager = ""org.quickserver.net.server.impl.BasicPoolManager"";
        return poolManager;
    }

    /**
     * @param poolManager
     */
    public void setPoolManager(String poolManager) {
        this.poolManager = poolManager;
    }

    /**
     * Returns ByteBufferObjectPoolConfig object
     * @return byteBufferObjectPoolConfig
     */
    public ByteBufferObjectPoolConfig getByteBufferObjectPoolConfig() {
        if (byteBufferObjectPoolConfig == null)
            byteBufferObjectPoolConfig = new ByteBufferObjectPoolConfig(this);
        return byteBufferObjectPoolConfig;
    }

    /**
     * @param byteBufferObjectPoolConfig
     */
    public void setByteBufferObjectPoolConfig(ByteBufferObjectPoolConfig byteBufferObjectPoolConfig) {
        this.byteBufferObjectPoolConfig = byteBufferObjectPoolConfig;
    }

    /**
     * Returns ClientHandlerObjectPoolConfig object
     * @return clientHandlerObjectPoolConfig
     */
    public ClientHandlerObjectPoolConfig getClientHandlerObjectPoolConfig() {
        if (clientHandlerObjectPoolConfig == null)
            clientHandlerObjectPoolConfig = new ClientHandlerObjectPoolConfig(this);
        return clientHandlerObjectPoolConfig;
    }

    /**
     * @param clientHandlerObjectPoolConfig
     */
    public void setClientHandlerObjectPoolConfig(ClientHandlerObjectPoolConfig clientHandlerObjectPoolConfig) {
        this.clientHandlerObjectPoolConfig = clientHandlerObjectPoolConfig;
    }

    /**
     * Returns ThreadObjectPoolConfig object
     * @return threadObjectPoolConfig
     */
    public ThreadObjectPoolConfig getThreadObjectPoolConfig() {
        if (threadObjectPoolConfig == null)
            threadObjectPoolConfig = new ThreadObjectPoolConfig(this);
        return threadObjectPoolConfig;
    }

    /**
     * @param threadObjectPoolConfig
     */
    public void setThreadObjectPoolConfig(ThreadObjectPoolConfig threadObjectPoolConfig) {
        this.threadObjectPoolConfig = threadObjectPoolConfig;
    }

    /**
     * Returns ClientDataObjectPoolConfig object
     * @return clientDataObjectPoolConfig
     */
    public ClientDataObjectPoolConfig getClientDataObjectPoolConfig() {
        if (clientDataObjectPoolConfig == null)
            clientDataObjectPoolConfig = new ClientDataObjectPoolConfig(this);
        return clientDataObjectPoolConfig;
    }

    /**
     * @param clientDataObjectPoolConfig
     */
    public void setClientDataObjectPoolConfig(ClientDataObjectPoolConfig clientDataObjectPoolConfig) {
        this.clientDataObjectPoolConfig = clientDataObjectPoolConfig;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<object-pool>\n"");
        sb.append(pad).append(""\t<max-active>"").append(getMaxActive()).append(""</max-active>\n"");
        sb.append(pad).append(""\t<max-idle>"").append(getMaxIdle()).append(""</max-idle>\n"");
        sb.append(pad).append(""\t<init-size>"").append(getInitSize()).append(""</init-size>\n"");
        sb.append(getThreadObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(getClientHandlerObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(getByteBufferObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(getClientDataObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(pad).append(""\t<pool-manager>"").append(getPoolManager()).append(""</pool-manager>\n"");
        sb.append(pad).append(""</object-pool>\n"");
        return sb.toString();
    }
}
","// ObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectPoolConfig}.
* It contains ten unit test cases for the {@link ObjectPoolConfig#toXML(String)} method.
*/
class ObjectPoolConfigTest {","// ObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectPoolConfig}.
* It contains ten unit test cases for the {@link ObjectPoolConfig#toXML(String)} method.
*/
class ObjectPoolConfigTest {

	@Test
	void testToXML() {
		ObjectPoolConfig objectPoolConfig = new ObjectPoolConfig();
		objectPoolConfig.setMaxActive(10);
		objectPoolConfig.setMaxIdle(5);
		objectPoolConfig.setInitSize(2);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getThreadObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getByteBufferObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getByteBufferObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getByteBufferObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getClientDataObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getClientDataObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getClientDataObjectPoolConfig().setInitSize(2);
		objectPoolConfig.setPoolManager(""org.quickserver.net.server.impl.BasicPoolManager"");
		String expected = ""<object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""\t<thread-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-pool>\n"" +
				""\t<client-handler-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</client-handler-pool>\n"" +
				""\t<byte-buffer-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</byte-buffer-pool>\n"" +
				""\t<client-data-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</client-data-pool>\n"" +
				""\t<pool-manager>org.quickserver.net.server.impl.BasicPoolManager</pool-manager>\n"" +
				""</object-pool>\n"";
		assertEquals(expected, objectPoolConfig.toXML(null));
	}
	
	@Test
	void testToXML2() {
		ObjectPoolConfig objectPoolConfig = new ObjectPoolConfig();
		objectPoolConfig.setMaxActive(10);
		objectPoolConfig.setMaxIdle(5);
		objectPoolConfig.setInitSize(2);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getThreadObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getClientHandlerObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getByteBufferObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getByteBufferObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getByteBufferObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getClientDataObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getClientDataObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getClientDataObjectPoolConfig().setInitSize(2);
		objectPoolConfig.setPoolManager(""org.quickserver.net.server.impl.BasicPoolManager"");
		String expected = ""    <object-pool>\n"" +
				""        <max-active>10</max-active>\n"" +
				""        <max-idle>5</max-idle>\n"" +
				""        <init-size>2</init-size>\n"" +
				""        <thread-pool>\n"" +
				""            <max-active>10</max-active>\n"" +
				""            <max-idle>5</max-idle>\n"" +
				""            <init-size>2</init-size>\n"" +
				""        </thread-pool>\n"" +
				""        <client-handler-pool>\n"" +
				""            <max-active>10</max-active>\n"" +
				""            <max-idle>5</max-idle>\n"" +
				""            <init-size>2</init-size>\n"" +
				""        </client-handler-pool>\n"" +
				""        <byte-buffer-pool>\n"" +
				""            <max-active>10</max-active>\n"" +
				""            <max-idle>5</max-idle>\n"" +
				""            <init-size>2</init-size>\n"" +
				""        </byte-buffer-pool>\n"" +
				""        <client-data-pool>\n"" +
				""            <max-active>10</max-active>\n"" +
				""            <max-idle>5</max-idle>\n"" +
				""            <init-size>2</init-size>\n"" +
				""        </client-data-pool>\n"" +
				""        <pool-manager>org.quickserver.net.server.impl.BasicPoolManager</pool-manager>\n"" +
				""    </object-pool>\n"";
		assertEquals(expected, objectPoolConfig.toXML(""    ""));
	}
	
	@Test
	void testToXML3() {
		ObjectPoolConfig objectPoolConfig = new ObjectPoolConfig();
		objectPoolConfig.setMaxActive(10);
		objectPoolConfig.setMaxIdle(5);
		objectPoolConfig.setInitSize(2);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxActive(10);
		objectPoolConfig.getThreadObjectPoolConfig().setMaxIdle(5);
		objectPoolConfig.getThreadObjectPoolConfig().setInitSize(2);
		objectPoolConfig.getClientHandler"
cmpl-6tzlY29hUoLCIZjEONhiNRyl9GzWV,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/PluginConfigReader_1Test.java,48.11760950088501,length,"// PluginConfigReader.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.io.*;
import java.util.logging.*;
import org.apache.commons.digester3.Digester;

/**
 * This class reads the xml configuration and gives
 * QSAdminPluginConfig object.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class PluginConfigReader {

    private static Logger logger = Logger.getLogger(PluginConfigReader.class.getName());

    public static QSAdminPluginConfig read(String fileName) throws Exception {
        File input = new File(fileName);
        return read(input);
    }

    /**
     * Parses XML config of QSAdmin Plugin
     */
    public static QSAdminPluginConfig read(File input) throws Exception {
        Digester digester = new Digester();
        digester.setValidating(false);
        String mainTag = ""qsadmin-plugin"";
        digester.addObjectCreate(mainTag, QSAdminPluginConfig.class);
        digester.addBeanPropertySetter(mainTag + ""/name"", ""name"");
        digester.addBeanPropertySetter(mainTag + ""/desc"", ""desc"");
        digester.addBeanPropertySetter(mainTag + ""/type"", ""type"");
        digester.addBeanPropertySetter(mainTag + ""/main-class"", ""mainClass"");
        digester.addBeanPropertySetter(mainTag + ""/active"", ""active"");
        logger.fine(""Loading Plugin config from xml file : "" + input.getAbsolutePath());
        QSAdminPluginConfig psc = (QSAdminPluginConfig) digester.parse(input);
        return psc;
    }
}
","// PluginConfigReader_1Test.java
package org.quickserver.util.xmlreader;

import java.io.*;
import java.util.logging.*;
import org.apache.commons.digester3.Digester;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PluginConfigReader}.
* It contains ten unit test cases for the {@link PluginConfigReader#read(File)} method.
*/
class PluginConfigReader_1Test {","// PluginConfigReader_1Test.java
package org.quickserver.util.xmlreader;

import java.io.*;
import java.util.logging.*;
import org.apache.commons.digester3.Digester;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PluginConfigReader}.
* It contains ten unit test cases for the {@link PluginConfigReader#read(File)} method.
*/
class PluginConfigReader_1Test {

	@Test
	void testRead_1() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_1.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_2() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_2.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_3() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_3.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_4() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_4.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_5() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_5.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_6() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_6.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_7() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_7.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_8() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_8.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_9() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_9.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
	@Test
	void testRead_10() throws Exception {
		File input = new File(""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_1Test_10.xml"");
		QSAdminPluginConfig psc = PluginConfigReader.read(input);
		assertEquals(""TestPlugin"", psc.getName());
		assertEquals(""Test Plugin"", psc.getDesc());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getMainClass());
		assertEquals(""org.quickserver.net.qsadmin.TestPlugin"", psc.getType());
		assertEquals(""true"", psc.getActive());
	}
	
}

// PluginConfigReader_2Test.java
package org.quickserver.util.xmlreader;

import java.io.*;
import java.util.logging.*;
import org.apache.commons.digester3.Digester;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PluginConfigReader}.
* It contains ten unit test cases for the {@link PluginConfigReader#read(String)} method.
*/
class PluginConfigReader_2Test {
		
	@Test
	void testRead_1() throws Exception {
		String fileName = ""src/test/resources/org/quickserver/util/xmlreader/PluginConfigReader_2Test_1.xml"";
		QSAdminPluginConfig psc = PluginConfigReader.read(fileName);
		assertEqu"
cmpl-6tzmb7zFfUEKi0ZTnKnnaqeOFL7uv,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/QSAdminPluginConfig.java,39.96082854270935,length,"// QSAdminPluginConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the QSAdmin Plugin configuration.
 * The xml is &lt;qsadmin-plugin&gt;...&lt;/qsadmin-plugin&gt;
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class QSAdminPluginConfig implements java.io.Serializable {

    private String name = """";

    private String desc = """";

    private String type = """";

    private String mainClass = """";

    private String active = ""no"";

    /**
     * @return description
     */
    public String getDesc() {
        return desc;
    }

    /**
     * @param desc
     */
    public void setDesc(String desc) {
        if (desc != null)
            this.desc = desc;
    }

    /**
     * @param active Valid Values: <code>true</code> or <code>false</code>
     */
    public void setActive(String active) {
        if (active != null)
            this.active = active;
    }

    /**
     * Returns active flag.
     */
    public String getActive() {
        return active;
    }

    /**
     * @return MainClass
     */
    public String getMainClass() {
        return mainClass;
    }

    /**
     * @param mainClass
     */
    public void setMainClass(String mainClass) {
        if (mainClass != null)
            this.mainClass = mainClass;
    }

    /**
     * @return name of the plugin
     */
    public String getName() {
        return name;
    }

    /**
     * @param name
     */
    public void setName(String name) {
        if (name != null)
            this.name = name;
    }

    /**
     * Returns class which plugin extends or implements.
     * @return type of plugin.
     */
    public String getType() {
        return type;
    }

    /**
     * @param type of class which plugin extends or implements.
     */
    public void setType(String type) {
        if (type != null)
            this.type = type;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<qsadmin-plugin>\n"");
        sb.append(pad).append(""\t<name>"").append(getName()).append(""</name>\n"");
        sb.append(pad).append(""\t<desc>"").append(getDesc()).append(""</desc>\n"");
        sb.append(pad).append(""\t<type>"").append(getType()).append(""</type>\n"");
        sb.append(pad).append(""\t<main-class>"").append(getMainClass()).append(""</main-class>\n"");
        sb.append(pad).append(""\t<active>"").append(getActive()).append(""</active>\n"");
        sb.append(pad).append(""</qsadmin-plugin>\n"");
        return sb.toString();
    }
}
","// QSAdminPluginConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminPluginConfig}.
* It contains ten unit test cases for the {@link QSAdminPluginConfig#toXML(String)} method.
*/
class QSAdminPluginConfigTest {","// QSAdminPluginConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminPluginConfig}.
* It contains ten unit test cases for the {@link QSAdminPluginConfig#toXML(String)} method.
*/
class QSAdminPluginConfigTest {

	@Test
	void testToXML() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(""TestPlugin"");
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML("""");
		assertEquals(""<qsadmin-plugin>\n"" + 
				""\t<name>TestPlugin</name>\n"" + 
				""\t<desc>Test Plugin</desc>\n"" + 
				""\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t<active>true</active>\n"" + 
				""</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithPad() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(""TestPlugin"");
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML(""\t"");
		assertEquals(""\t<qsadmin-plugin>\n"" + 
				""\t\t<name>TestPlugin</name>\n"" + 
				""\t\t<desc>Test Plugin</desc>\n"" + 
				""\t\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t\t<active>true</active>\n"" + 
				""\t</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithNullPad() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(""TestPlugin"");
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML(null);
		assertEquals(""<qsadmin-plugin>\n"" + 
				""\t<name>TestPlugin</name>\n"" + 
				""\t<desc>Test Plugin</desc>\n"" + 
				""\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t<active>true</active>\n"" + 
				""</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithEmptyPad() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(""TestPlugin"");
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML("""");
		assertEquals(""<qsadmin-plugin>\n"" + 
				""\t<name>TestPlugin</name>\n"" + 
				""\t<desc>Test Plugin</desc>\n"" + 
				""\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t<active>true</active>\n"" + 
				""</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithNullName() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(null);
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML("""");
		assertEquals(""<qsadmin-plugin>\n"" + 
				""\t<name></name>\n"" + 
				""\t<desc>Test Plugin</desc>\n"" + 
				""\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t<active>true</active>\n"" + 
				""</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithEmptyName() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName("""");
		qsAdminPluginConfig.setDesc(""Test Plugin"");
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass(""org.quickserver.net.qsadmin.TestPlugin"");
		qsAdminPluginConfig.setActive(""true"");
		String xml = qsAdminPluginConfig.toXML("""");
		assertEquals(""<qsadmin-plugin>\n"" + 
				""\t<name></name>\n"" + 
				""\t<desc>Test Plugin</desc>\n"" + 
				""\t<type>org.quickserver.net.qsadmin.PluginInterface</type>\n"" + 
				""\t<main-class>org.quickserver.net.qsadmin.TestPlugin</main-class>\n"" + 
				""\t<active>true</active>\n"" + 
				""</qsadmin-plugin>\n"", xml);
	}
	
	@Test
	void testToXMLWithNullDesc() {
		QSAdminPluginConfig qsAdminPluginConfig = new QSAdminPluginConfig();
		qsAdminPluginConfig.setName(""TestPlugin"");
		qsAdminPluginConfig.setDesc(null);
		qsAdminPluginConfig.setType(""org.quickserver.net.qsadmin.PluginInterface"");
		qsAdminPluginConfig.setMainClass"
cmpl-6tzneewkt63O4P9eQnAe95U3yNFXR,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/QSAdminServerConfig.java,44.61904454231262,length,"// QSAdminServerConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.quickserver.net.qsadmin.QSAdminServer;

/**
 * This class encapsulate the configuration of QSAdminServer.
 * This class is used by
 * {@link org.quickserver.net.server.QuickServer#configQuickServer}
 * and {@link org.quickserver.net.server.QuickServer#initService} method to
 * initialise QSAdminServer.
 * @author Akshathkumar Shetty
 * @since 1.2
 */
public class QSAdminServerConfig extends BasicServerConfig {

    private String commandPlugin;

    private String commandShellEnabled = ""false"";

    private String commandShellPromptName = ""QSAdmin"";

    public QSAdminServerConfig() {
        setName(""QSAdminServer v "" + QSAdminServer.getVersion());
        setPort(9877);
        setBindAddr(""127.0.0.1"");
        setClientCommandHandler(""org.quickserver.net.qsadmin.CommandHandler"");
        setClientEventHandler(""org.quickserver.net.qsadmin.CommandHandler"");
        setClientAuthenticationHandler(""org.quickserver.net.qsadmin.Authenticator"");
        setClientData(""org.quickserver.net.qsadmin.Data"");
        setMaxConnection(1);
        getServerMode().setBlocking(true);
    }

    /**
     * Set the CommandPlugin for QSAdminServer class which plugs in into
     * CommandHandler of QsAdminServer,it will be null if not set.
     * XML Tag: &lt;command-plugin&gt;&lt;/command-plugin&gt;
     */
    public void setCommandPlugin(String plugin) {
        if (plugin != null && plugin.equals("""") == false)
            commandPlugin = plugin;
    }

    /**
     * Gets the CommandPlugin for QSAdminServer class which plugsin into
     * CommandHandler of QsAdminServer,it will be null if not set.
     */
    public String getCommandPlugin() {
        return commandPlugin;
    }

    /**
     * Set the CommandShellEnable flag for QSAdminServer
     * XML Tag: &lt;command-shell&gt;&lt;enable&gt;true&lt;/enable&gt;&lt;/command-shell&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * @since 1.3.2
     */
    public void setCommandShellEnable(String enable) {
        if (enable != null && enable.equals("""") == false)
            commandShellEnabled = enable;
    }

    /**
     * Gets the CommandShellEnable flag for QSAdminServer
     * @since 1.3.2
     */
    public String getCommandShellEnable() {
        return commandShellEnabled;
    }

    /**
     * Set the PromptName for QSAdminShell
     * XML Tag: &lt;command-shell&gt;&lt;prompt-name&gt;true&lt;/prompt-name&gt;&lt;/command-shell&gt;
     * Default values = <code>QSAdmin</code>
     * @since 1.3.2
     */
    public void setCommandShellPromptName(String commandShellPromptName) {
        if (commandShellPromptName != null && commandShellPromptName.equals("""") == false)
            this.commandShellPromptName = commandShellPromptName;
    }

    /**
     * Gets the PromptName for QSAdminShell
     * @since 1.3.2
     */
    public String getCommandShellPromptName() {
        return commandShellPromptName;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad + ""<qsadmin-server>\n"");
        if (getName() != null)
            sb.append(pad + ""\t<name>"" + getName() + ""</name>\n"");
        if (getServerBanner() != null)
            sb.append(pad + ""\t<server-banner>"" + getServerBanner() + ""</server-banner>\n"");
        sb.append(pad + ""\t<port>"" + getPort() + ""</port>\n"");
        sb.append(pad + ""\t<bind-address>"" + getBindAddr() + ""</bind-address>\n"");
        sb.append(getServerMode().toXML(pad + ""\t""));
        if (getClientEventHandler() != null)
            sb.append(pad + ""\t<client-event-handler>"" + getClientEventHandler() + ""</client-event-handler>\n"");
        if (getClientCommandHandler() != null)
            sb.append(pad + ""\t<client-command-handler>"" + getClientCommandHandler() + ""</client-command-handler>\n"");
        if (getClientObjectHandler() != null)
            sb.append(pad + ""\t<client-object-handler>"" + getClientObjectHandler() + ""</client-object-handler>\n"");
        if (getClientBinaryHandler() != null)
            sb.append(pad + ""\t<client-binary-handler>"" + getClientBinaryHandler() + ""</client-binary-handler>\n"");
        if (getClientWriteHandler() != null)
            sb.append(pad + ""\t<client-write-handler>"" + getClientWriteHandler() + ""</client-write-handler>\n"");
        if (getClientAuthenticationHandler() != null)
            sb.append(pad + ""\t<client-authentication-handler>"" + getClientAuthenticationHandler() + ""</client-authentication-handler>\n"");
        else if (getAuthenticator() != null)
            sb.append(pad + ""\t<authenticator>"" + getAuthenticator() + ""</authenticator>\n"");
        if (getClientData() != null)
            sb.append(pad + ""\t<client-data>"" + getClientData() + ""</client-data>\n"");
        if (getClientExtendedEventHandler() != null)
            sb.append(pad + ""\t<client-extended-event-handler>"" + getClientExtendedEventHandler() + ""</client-extended-event-handler>\n"");
        sb.append(pad + ""\t<timeout>"" + getTimeout() + ""</timeout>\n"");
        if (getTimeoutMsg() != null)
            sb.append(pad + ""\t<timeout-msg>"" + getTimeoutMsg() + ""</timeout-msg>\n"");
        sb.append(pad + ""\t<max-auth-try>"" + getMaxAuthTry() + ""</max-auth-try>\n"");
        if (getMaxAuthTryMsg() != null)
            sb.append(pad + ""\t<max-auth-try-msg>"" + getMaxAuthTryMsg() + ""</max-auth-try-msg>\n"");
        sb.append(pad + ""\t<max-connection>"" + getMaxConnection() + ""</max-connection>\n"");
        if (getMaxConnectionMsg() != null)
            sb.append(pad + ""\t<max-connection-msg>"" + getMaxConnectionMsg() + ""</max-connection-msg>\n"");
        /*
		//Not used. Use main QS console logging
		if(getConsoleLoggingLevel()!=null) 
			sb.append(pad+""\t<console-logging-level>""+getConsoleLoggingLevel()+""</console-logging-level>\n"");
		if(getConsoleLoggingFormatter()!=null) 
			sb.append(pad+""\t<console-logging-formatter>""+getConsoleLoggingFormatter()+""</consoleLoggingFormatter>\n"");
		*/
        sb.append(getObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(pad).append(""\t<communication-logging>\n"");
        sb.append(pad).append(""\t\t<enable>"").append(getCommunicationLogging()).append(""</enable>\n"");
        sb.append(pad).append(""\t</communication-logging>\n"");
        if (getCommandPlugin() != null)
            sb.append(pad).append(""\t<command-plugin>"").append(getCommandPlugin()).append(""</command-plugin>\n"");
        sb.append(pad).append(""\t<command-shell>\n"");
        sb.append(pad).append(""\t\t<enable>"").append(getCommandShellEnable()).append(""</enable>\n"");
        sb.append(pad).append(""\t\t<prompt-name>"").append(getCommandShellPromptName()).append(""</prompt-name>\n"");
        sb.append(pad + ""\t</command-shell>\n"");
        if (getAccessConstraintConfig() != null) {
            sb.append(getAccessConstraintConfig().toXML(pad + ""\t""));
        }
        if (getServerHooks() != null) {
            sb.append(getServerHooks().toXML(pad + ""\t""));
        }
        sb.append(getSecure().toXML(pad + ""\t""));
        sb.append(getAdvancedSettings().toXML(pad + ""\t""));
        sb.append(pad).append(""</qsadmin-server>\n"");
        return sb.toString();
    }

    public String toString() {
        return toXML(null);
    }
}
","// QSAdminServerConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.quickserver.net.qsadmin.QSAdminServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminServerConfig}.
* It contains ten unit test cases for the {@link QSAdminServerConfig#toXML(String)} method.
*/
class QSAdminServerConfigTest {","// QSAdminServerConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.quickserver.net.qsadmin.QSAdminServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminServerConfig}.
* It contains ten unit test cases for the {@link QSAdminServerConfig#toXML(String)} method.
*/
class QSAdminServerConfigTest {

	@Test
	void testToXML() {
		QSAdminServerConfig qsadminServerConfig = new QSAdminServerConfig();
		qsadminServerConfig.setName(""QSAdminServer v "" + QSAdminServer.getVersion());
		qsadminServerConfig.setPort(9877);
		qsadminServerConfig.setBindAddr(""127.0.0.1"");
		qsadminServerConfig.setClientCommandHandler(""org.quickserver.net.qsadmin.CommandHandler"");
		qsadminServerConfig.setClientEventHandler(""org.quickserver.net.qsadmin.CommandHandler"");
		qsadminServerConfig.setClientAuthenticationHandler(""org.quickserver.net.qsadmin.Authenticator"");
		qsadminServerConfig.setClientData(""org.quickserver.net.qsadmin.Data"");
		qsadminServerConfig.setMaxConnection(1);
		qsadminServerConfig.getServerMode().setBlocking(true);
		qsadminServerConfig.setCommandPlugin(""org.quickserver.net.qsadmin.Plugin"");
		qsadminServerConfig.setCommandShellEnable(""true"");
		qsadminServerConfig.setCommandShellPromptName(""QSAdmin"");
		
		String expected = ""<qsadmin-server>\n"" + 
				""\t<name>QSAdminServer v 1.4.5</name>\n"" + 
				""\t<port>9877</port>\n"" + 
				""\t<bind-address>127.0.0.1</bind-address>\n"" + 
				""\t<server-mode>\n"" + 
				""\t\t<blocking>true</blocking>\n"" + 
				""\t</server-mode>\n"" + 
				""\t<client-event-handler>org.quickserver.net.qsadmin.CommandHandler</client-event-handler>\n"" + 
				""\t<client-command-handler>org.quickserver.net.qsadmin.CommandHandler</client-command-handler>\n"" + 
				""\t<client-authentication-handler>org.quickserver.net.qsadmin.Authenticator</client-authentication-handler>\n"" + 
				""\t<client-data>org.quickserver.net.qsadmin.Data</client-data>\n"" + 
				""\t<timeout>0</timeout>\n"" + 
				""\t<max-auth-try>3</max-auth-try>\n"" + 
				""\t<max-connection>1</max-connection>\n"" + 
				""\t<object-pool>\n"" + 
				""\t\t<max-active>10</max-active>\n"" + 
				""\t\t<max-idle>5</max-idle>\n"" + 
				""\t\t<max-wait>-1</max-wait>\n"" + 
				""\t\t<min-evictable-idle-time>1800000</min-evictable-idle-time>\n"" + 
				""\t\t<time-between-eviction-runs>-1</time-between-eviction-runs>\n"" + 
				""\t\t<num-tests-per-eviction-run>3</num-tests-per-eviction-run>\n"" + 
				""\t\t<min-idle>0</min-idle>\n"" + 
				""\t\t<test-on-borrow>false</test-on-borrow>\n"" + 
				""\t\t<test-on-return>false</test-on-return>\n"" + 
				""\t\t<test-while-idle>false</test-while-idle>\n"" + 
				""\t\t<lifo>true</lifo>\n"" + 
				""\t\t<fairness>false</fairness>\n"" + 
				""\t\t<block-when-exhausted>true</block-when-exhausted>\n"" + 
				""\t\t<jmx-enabled>false</jmx-enabled>\n"" + 
				""\t\t<jmx-name-base>pool</jmx-name-base>\n"" + 
				""\t\t<jmx-name-prefix>pool</jmx-name-prefix>\n"" + 
				""\t</object-pool>\n"" + 
				""\t<communication-logging>\n"" + 
				""\t\t<enable>false</enable>\n"" + 
				""\t</communication-logging>\n"" + 
				""\t<command-plugin>org.quickserver.net.qsadmin.Plugin</command-plugin>\n"" + 
				""\t<command-shell>\n"" + 
				""\t\t<enable>true</enable>\n"" + 
				""\t\t<prompt-name>QSAdmin</prompt-name>\n"" + 
				""\t</command-shell>\n"" + 
				""\t<access-constraint>\n"" + 
				""\t\t<allow-all>false</allow-all>\n"" + 
				""\t\t<allow-ip>\n"" + 
				""\t\t\t<ip>127.0.0.1</ip>\n"" + 
				""\t\t</allow-ip>\n"" + 
				""\t\t<allow-host>\n"" + 
				""\t\t\t<host>localhost</host>\n"" + 
				""\t\t</allow-host>\n"" + 
				""\t\t<deny-ip>\n"" + 
				""\t\t\t<ip>127.0.0.1</ip>\n"" + 
				""\t\t</deny-ip>\n"" + 
				""\t\t<deny-host>\n"" + 
				""\t\t\t<host>localhost</host>\n"" + 
				""\t\t</deny-host>\n"" + 
				""\t</access-constraint>\n"" + 
				""\t<server-hooks>\n"" + 
				""\t\t<init-service>\n"" + 
				""\t\t\t<class>org.quickserver.net.qsadmin.InitServiceHook</class>\n"" + 
				""\t\t</init-service>\n"" + 
				""\t\t<pre-accept>\n"" + 
				""\t\t\t<class>org.quickserver.net.qsadmin.PreAcceptHook</class>\n"" + 
				""\t\t</pre-accept>\n"" + 
				""\t\t<post-accept>\n"" + 
				""\t\t\t<class>org.quickserver.net.qsadmin.PostAcceptHook</class>\n"" + 
				""\t\t</post-accept>\n"" + 
				""\t\t<pre-close>"
cmpl-6tzohZjgGpTx3RNMOd2QFgdFYWEz6,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/QuickServerConfig.java,42.68683338165283,length,"// QuickServerConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;

/**
 * This class encapsulate the configuration of QuickServer.
 * <p>
 * This is used by {@link QuickServer#configQuickServer} and
 * {@link QuickServer#initService} method to initialise
 * QuickServer.
 * </p>
 * @author Akshathkumar Shetty
 * @since 1.2
 */
public class QuickServerConfig extends BasicServerConfig {

    private QSAdminServerConfig qSAdminServerConfig;

    private DBObjectPoolConfig dDObjectPoolConfig;

    private ApplicationConfiguration applicationConfiguration;

    private InitServerHooks initServerHooks;

    private String securityManagerClass = null;

    private String configFile = null;

    private String applicationJarPath = null;

    public QuickServerConfig() {
        setName(""QuickServer v"" + QuickServer.getVersion());
    }

    /**
     * Sets the QSAdminServer configuration.
     * XML Tag: &lt;qsadmin-server&gt;&lt;/qsadmin-server&gt;
     */
    public void setQSAdminServerConfig(QSAdminServerConfig config) {
        qSAdminServerConfig = config;
    }

    /**
     * Returns QSAdminServer configuration.
     */
    public QSAdminServerConfig getQSAdminServerConfig() {
        return qSAdminServerConfig;
    }

    /**
     * Sets the DBObjectPoolConfig
     * XML Tag: &lt;object-pool&gt;&lt;/object-pool&gt;
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dDObjectPoolConfig) {
        this.dDObjectPoolConfig = dDObjectPoolConfig;
    }

    /**
     * Returns DBObjectPoolConfig
     * @since 1.3
     */
    public DBObjectPoolConfig getDBObjectPoolConfig() {
        return dDObjectPoolConfig;
    }

    /**
     * Sets the Application Configuration. This can be used by application to
     * store its configuration information.
     * XML Tag: &lt;application-configuration&gt;&lt;/application-configuration&gt;
     * @since 1.3.2
     */
    public void setApplicationConfiguration(ApplicationConfiguration applicationConfiguration) {
        this.applicationConfiguration = applicationConfiguration;
    }

    /**
     * Returns ApplicationConfiguration
     * @since 1.3.2
     */
    public ApplicationConfiguration getApplicationConfiguration() {
        return applicationConfiguration;
    }

    /**
     * Sets the SecurityManager class
     * XML Tag: &lt;security-manager-class&gt;&lt;/security-manager-class&gt;
     * @param securityManagerClass className the fully qualified name of the
     * class that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    /**
     * Sets the file path of the file that loaded the config from.
     * @since 1.3.3
     */
    protected void setConfigFile(String fileName) {
        configFile = fileName;
    }

    /**
     * Returns the file path of the file that loaded the configuration file.
     * @since 1.3.3
     */
    public String getConfigFile() {
        return configFile;
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the jars
     * needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    public void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the jars
     * needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the InitServerHooks.
     * @see #getInitServerHooks
     * @since 1.4
     */
    public void setInitServerHooks(InitServerHooks initServerHooks) {
        this.initServerHooks = initServerHooks;
    }

    /**
     * Returns the InitServerHooks.
     * @see #setInitServerHooks
     * @since 1.4
     */
    public InitServerHooks getInitServerHooks() {
        return initServerHooks;
    }

    /**
     * Returns XML config of this class.
     * @since 1.3
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad + ""<quickserver>\n"");
        if (getName() != null)
            sb.append(pad + ""\t<name>"" + getName() + ""</name>\n"");
        if (getServerBanner() != null)
            sb.append(pad + ""\t<server-banner>"" + getServerBanner() + ""</server-banner>\n"");
        sb.append(pad + ""\t<port>"" + getPort() + ""</port>\n"");
        if (getBindAddr() != null)
            sb.append(pad + ""\t<bind-address>"" + getBindAddr() + ""</bind-address>\n"");
        sb.append(getServerMode().toXML(pad + ""\t""));
        if (getClientEventHandler() != null)
            sb.append(pad + ""\t<client-event-handler>"" + getClientEventHandler() + ""</client-event-handler>\n"");
        if (getClientCommandHandler() != null)
            sb.append(pad + ""\t<client-command-handler>"" + getClientCommandHandler() + ""</client-command-handler>\n"");
        if (getClientObjectHandler() != null)
            sb.append(pad + ""\t<client-object-handler>"" + getClientObjectHandler() + ""</client-object-handler>\n"");
        if (getClientBinaryHandler() != null)
            sb.append(pad + ""\t<client-binary-handler>"" + getClientBinaryHandler() + ""</client-binary-handler>\n"");
        if (getClientWriteHandler() != null)
            sb.append(pad + ""\t<client-write-handler>"" + getClientWriteHandler() + ""</client-write-handler>\n"");
        if (getClientAuthenticationHandler() != null)
            sb.append(pad + ""\t<client-authentication-handler>"" + getClientAuthenticationHandler() + ""</client-authentication-handler>\n"");
        else if (getAuthenticator() != null)
            sb.append(pad + ""\t<authenticator>"" + getAuthenticator() + ""</authenticator>\n"");
        if (getClientData() != null)
            sb.append(pad + ""\t<client-data>"" + getClientData() + ""</client-data>\n"");
        if (getClientExtendedEventHandler() != null)
            sb.append(pad + ""\t<client-extended-event-handler>"" + getClientExtendedEventHandler() + ""</client-extended-event-handler>\n"");
        sb.append(getDefaultDataMode().toXML(pad + ""\t""));
        sb.append(pad + ""\t<timeout>"" + getTimeout() + ""</timeout>\n"");
        if (getTimeoutMsg() != null)
            sb.append(pad + ""\t<timeout-msg>"" + getTimeoutMsg() + ""</timeout-msg>\n"");
        sb.append(pad + ""\t<max-auth-try>"" + getMaxAuthTry() + ""</max-auth-try>\n"");
        if (getMaxAuthTryMsg() != null)
            sb.append(pad + ""\t<max-auth-try-msg>"" + getMaxAuthTryMsg() + ""</max-auth-try-msg>\n"");
        sb.append(pad + ""\t<max-connection>"" + getMaxConnection() + ""</max-connection>\n"");
        if (getMaxConnectionMsg() != null)
            sb.append(pad + ""\t<max-connection-msg>"" + getMaxConnectionMsg() + ""</max-connection-msg>\n"");
        if (getConsoleLoggingLevel() != null)
            sb.append(pad + ""\t<console-logging-level>"" + getConsoleLoggingLevel() + ""</console-logging-level>\n"");
        if (getConsoleLoggingFormatter() != null)
            sb.append(pad + ""\t<console-logging-formatter>"" + getConsoleLoggingFormatter() + ""</console-logging-formatter>\n"");
        sb.append(getObjectPoolConfig().toXML(pad + ""\t""));
        sb.append(pad + ""\t<communication-logging>\n"");
        sb.append(pad + ""\t\t<enable>"" + getCommunicationLogging() + ""</enable>\n"");
        sb.append(pad + ""\t</communication-logging>\n"");
        if (getDBObjectPoolConfig() != null) {
            sb.append(getDBObjectPoolConfig().toXML(pad + ""\t""));
        }
        if (getSecurityManagerClass() != null) {
            sb.append(pad + ""\t<security-manager-class>"" + getSecurityManagerClass() + ""</security-manager-class>\n"");
        }
        if (getAccessConstraintConfig() != null) {
            sb.append(getAccessConstraintConfig().toXML(pad + ""\t""));
        }
        if (getQSAdminServerConfig() != null)
            sb.append(getQSAdminServerConfig().toXML(pad + ""\t""));
        if (getApplicationConfiguration() != null) {
            sb.append(getApplicationConfiguration().toXML(pad + ""\t""));
        }
        if (getApplicationJarPath() != null) {
            sb.append(pad + ""\t<application-jar-path>"" + getApplicationJarPath() + ""</application-jar-path>\n"");
        }
        if (getServerHooks() != null) {
            sb.append(getServerHooks().toXML(pad + ""\t""));
        }
        if (getInitServerHooks() != null) {
            sb.append(getInitServerHooks().toXML(pad + ""\t""));
        }
        sb.append(getSecure().toXML(pad + ""\t""));
        sb.append(getAdvancedSettings().toXML(pad + ""\t""));
        sb.append(pad + ""</quickserver>\n"");
        return sb.toString();
    }

    public String toString() {
        return toXML(null);
    }
}
","// QuickServerConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServerConfig}.
* It contains ten unit test cases for the {@link QuickServerConfig#toXML(String)} method.
*/
class QuickServerConfigTest {","// QuickServerConfigTest.java
package org.quickserver.util.xmlreader;

import org.quickserver.net.server.QuickServer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServerConfig}.
* It contains ten unit test cases for the {@link QuickServerConfig#toXML(String)} method.
*/
class QuickServerConfigTest {

	@Test
	void testToXML() {
		QuickServerConfig qsc = new QuickServerConfig();
		qsc.setName(""Test Server"");
		qsc.setServerBanner(""Test Server Banner"");
		qsc.setPort(1234);
		qsc.setBindAddr(""127.0.0.1"");
		qsc.setServerMode(ServerMode.SINGLE_THREADED);
		qsc.setClientEventHandler(""org.quickserver.net.server.impl.ClientEventHandlerImpl"");
		qsc.setClientCommandHandler(""org.quickserver.net.server.impl.ClientCommandHandlerImpl"");
		qsc.setClientObjectHandler(""org.quickserver.net.server.impl.ClientObjectHandlerImpl"");
		qsc.setClientBinaryHandler(""org.quickserver.net.server.impl.ClientBinaryHandlerImpl"");
		qsc.setClientWriteHandler(""org.quickserver.net.server.impl.ClientWriteHandlerImpl"");
		qsc.setClientAuthenticationHandler(""org.quickserver.net.server.impl.ClientAuthenticationHandlerImpl"");
		qsc.setClientData(""org.quickserver.net.server.impl.ClientDataImpl"");
		qsc.setClientExtendedEventHandler(""org.quickserver.net.server.impl.ClientExtendedEventHandlerImpl"");
		qsc.setDefaultDataMode(DataMode.BINARY);
		qsc.setTimeout(1234);
		qsc.setTimeoutMsg(""Timeout Msg"");
		qsc.setMaxAuthTry(1234);
		qsc.setMaxAuthTryMsg(""Max Auth Try Msg"");
		qsc.setMaxConnection(1234);
		qsc.setMaxConnectionMsg(""Max Connection Msg"");
		qsc.setConsoleLoggingLevel(""INFO"");
		qsc.setConsoleLoggingFormatter(""org.quickserver.net.server.impl.ConsoleLoggingFormatterImpl"");
		qsc.setObjectPoolConfig(new ObjectPoolConfig());
		qsc.setCommunicationLogging(true);
		qsc.setDBObjectPoolConfig(new DBObjectPoolConfig());
		qsc.setSecurityManagerClass(""org.quickserver.net.server.impl.SecurityManagerImpl"");
		qsc.setAccessConstraintConfig(new AccessConstraintConfig());
		qsc.setQSAdminServerConfig(new QSAdminServerConfig());
		qsc.setApplicationConfiguration(new ApplicationConfiguration());
		qsc.setApplicationJarPath(""/home/user/app.jar"");
		qsc.setServerHooks(new ServerHooks());
		qsc.setInitServerHooks(new InitServerHooks());
		qsc.setSecure(new Secure());
		qsc.setAdvancedSettings(new AdvancedSettings());
		
		String expected = ""<quickserver>\n"" + 
				""\t<name>Test Server</name>\n"" + 
				""\t<server-banner>Test Server Banner</server-banner>\n"" + 
				""\t<port>1234</port>\n"" + 
				""\t<bind-address>127.0.0.1</bind-address>\n"" + 
				""\t<server-mode>\n"" + 
				""\t\t<type>SINGLE_THREADED</type>\n"" + 
				""\t</server-mode>\n"" + 
				""\t<client-event-handler>org.quickserver.net.server.impl.ClientEventHandlerImpl</client-event-handler>\n"" + 
				""\t<client-command-handler>org.quickserver.net.server.impl.ClientCommandHandlerImpl</client-command-handler>\n"" + 
				""\t<client-object-handler>org.quickserver.net.server.impl.ClientObjectHandlerImpl</client-object-handler>\n"" + 
				""\t<client-binary-handler>org.quickserver.net.server.impl.ClientBinaryHandlerImpl</client-binary-handler>\n"" + 
				""\t<client-write-handler>org.quickserver.net.server.impl.ClientWriteHandlerImpl</client-write-handler>\n"" + 
				""\t<client-authentication-handler>org.quickserver.net.server.impl.ClientAuthenticationHandlerImpl</client-authentication-handler>\n"" + 
				""\t<client-data>org.quickserver.net.server.impl.ClientDataImpl</client-data>\n"" + 
				""\t<client-extended-event-handler>org.quickserver.net.server.impl.ClientExtendedEventHandlerImpl</client-extended-event-handler>\n"" + 
				""\t<default-data-mode>\n"" + 
				""\t\t<type>BINARY</type>\n"" + 
				""\t</default-data-mode>\n"" + 
				""\t<timeout>1234</timeout>\n"" + 
				""\t<timeout-msg>Timeout Msg</timeout-msg>\n"" + 
				""\t<max-auth-try>1234</max-auth-try>\n"" + 
				""\t<max-auth-try-msg>Max Auth Try Msg</max-auth-try-msg>\n"" + 
				""\t<max-connection>1234</max-connection>\n"" + 
				""\t<max-connection-msg>Max Connection Msg</max-connection-msg>\n"" + 
				""\t<console-logging-level>INFO</console-logging-level>\n"" + 
				""\t<console-logging-formatter>org.quickserver.net.server.impl.ConsoleLoggingFormatterImpl</console-logging-formatter>\n"" + 
				""\t<object-pool>\n"" + 
				""\t\t<max-pool-size>10</max-pool-size>\n"" + 
				""\t\t<min-pool-size>1</min-pool-size>\n"" + 
				""\t\t<max-idle-time>3600</max-idle-time>\n"" + 
				""\t\t<max-wait-time>1000</max-wait-time>\n"" + 
				""\t\t<max-life-time>-1</max-life-time>\n"" + 
				""\t\t<pool-size-increment>1</pool-size-increment>\n"" + 
				""\t\t<pool-size-decrement>1</pool-size-decrement>\n"" + 
				""\t\t<pool-size-decrement-on-error>true</pool-size-decrement-on-error>\n"" + 
				""\t\t<pool-size-decrement-on-exception>true</pool-size-decrement-on-exception>\n"" + 
				""\t\t<pool-size-decrement-on-close>true</pool-size-decrement-on-close>\n"" + 
				""\t\t<pool-size-decrement-on-timeout>true</pool-size-decrement-on-timeout>\n"" + 
				""\t\t<pool-size-decrement-on-max-life-time>true</pool-size-decrement-on-max-life-time>\n"" + 
"
cmpl-6tzpks5AWRnOs3uObNReQkD7ZJvRl,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/Secure.java,40.42470026016235,length,"// Secure.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the setting that help in configuring a secure socket
 *  based QuickServer.
 *  The example xml is <pre>
 * 	....
 * 	&lt;secure&gt;
 * 		&lt;enable&gt;true&lt;/enable&gt;
 * 		&lt;load&gt;true&lt;/load&gt;
 * 		&lt;port&gt;&lt;/port&gt;
 * 		&lt;protocol&gt;TLS&lt;/protocol&gt;
 * 		&lt;client-auth-enable&gt;false&lt;/client-auth-enable&gt;
 * 		&lt;secure-store&gt;
 * 			....
 * 		&lt;/secure-store&gt;
 * 	&lt;/secure&gt;
 * 	....
 *  </pre>
 *  @see TrustStoreInfo
 *  @see KeyStoreInfo
 *  @see SecureStore
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class Secure implements java.io.Serializable {

    private boolean enable = false;

    private boolean load = false;

    //will use servers port
    private int port = -1;

    private String protocol = ""TLS"";

    private boolean clientAuthEnable = false;

    private SecureStore secureStore = new SecureStore();

    /**
     * Sets the Secure enable flag.
     * If not set, it will use <code>false</code><br/>
     * XML Tag: &lt;secure&gt;&lt;enable&gt;true&lt;/enable&gt;&lt;/secure&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * If enable is set to <code>true</code> load is also set to <code>true</code>.
     * @see #getEnable
     */
    public void setEnable(boolean enable) {
        this.enable = enable;
        if (enable == true) {
            setLoad(true);
        }
    }

    /**
     * Returns the Secure enable flag.
     * @see #setEnable
     */
    public boolean getEnable() {
        return enable;
    }

    /**
     * Returns the Secure enable flag.
     */
    public boolean isEnable() {
        return enable;
    }

    /**
     * Sets the load flag for SSLContext.
     * If not set, it will use <code>false</code><br/>
     * XML Tag: &lt;Secure&gt;&lt;load&gt;true&lt;/load&gt;&lt;/Secure&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * @see #getLoad
     */
    public void setLoad(boolean load) {
        this.load = load;
    }

    /**
     * Returns the load flag for SSLContext.
     * @see #setLoad
     */
    public boolean getLoad() {
        return load;
    }

    /**
     * Returns the load flag for SSLContext.
     */
    public boolean isLoad() {
        return load;
    }

    /**
     * Sets the port for the QuickServer to listen on in secure mode.
     * If not set, it will run on servers non secure port<br/>
     * XML Tag: &lt;port&gt;&lt;/port&gt;
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port >= 0)
            this.port = port;
    }

    /**
     * Returns the port for the QuickServer to listen on in secure mode.
     * @see #setPort
     */
    public int getPort() {
        return port;
    }

    /**
     * Sets the protocol for the QuickServer to listen on in secure mode.
     * If not set, it will use <code>TLS</code><br/>
     * XML Tag: &lt;protocol&gt;TLS&lt;/protocol&gt;
     * @param protocol to listen on in secure mode.
     * @see #getProtocol
     */
    public void setProtocol(String protocol) {
        if (protocol != null && protocol.trim().length() != 0)
            this.protocol = protocol;
    }

    /**
     * Returns the protocol for the QuickServer to listen on in secure mode.
     * @see #setProtocol
     */
    public String getProtocol() {
        return protocol;
    }

    /**
     * Sets whether the connections which are accepted must include
     * successful client authentication.
     * If not set, it will use <code>false</code><br/>
     * XML Tag: &lt;client-auth-enable&gt;false&lt;/client-auth-enable&gt;
     * @param enable client authentication enable flag
     * @see #getClientAuthEnable
     */
    public void setClientAuthEnable(boolean enable) {
        this.clientAuthEnable = enable;
    }

    /**
     * Returns whether the connections which are accepted must include
     * successful client authentication.
     * @see #setClientAuthEnable
     */
    public boolean getClientAuthEnable() {
        return clientAuthEnable;
    }

    /**
     * Returns whether the connections which are accepted must include
     * successful client authentication.
     */
    public boolean isClientAuthEnable() {
        return clientAuthEnable;
    }

    /**
     * Sets SecureStore information
     * XML Tag: &lt;secure-store&gt;&lt;/secure-store&gt;
     * @param secureStore SecureStore information
     * @see #getSecureStore
     */
    public void setSecureStore(SecureStore secureStore) {
        if (secureStore != null)
            this.secureStore = secureStore;
    }

    /**
     * Returns SecureStore information.
     * @see #setSecureStore
     */
    public SecureStore getSecureStore() {
        return secureStore;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad + ""<secure>\n"");
        sb.append(pad + ""\t<enable>"" + getEnable() + ""</enable>\n"");
        sb.append(pad + ""\t<load>"" + getLoad() + ""</load>\n"");
        if (getPort() != -1)
            sb.append(pad + ""\t<port>"" + getPort() + ""</port>\n"");
        sb.append(pad + ""\t<protocol>"" + getProtocol() + ""</protocol>\n"");
        sb.append(pad + ""\t<client-auth-enable>"" + getClientAuthEnable() + ""</client-auth-enable>\n"");
        if (getSecureStore() != null) {
            sb.append(getSecureStore().toXML(pad + ""\t""));
        }
        sb.append(pad + ""</secure>\n"");
        return sb.toString();
    }
}
","// SecureTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Secure}.
* It contains ten unit test cases for the {@link Secure#toXML(String)} method.
*/
class SecureTest {","// SecureTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Secure}.
* It contains ten unit test cases for the {@link Secure#toXML(String)} method.
*/
class SecureTest {

	@Test
	public void testToXML() {
		Secure secure = new Secure();
		String xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>false</enable>\n""+
			""\t<load>false</load>\n""+
			""\t<protocol>TLS</protocol>\n""+
			""\t<client-auth-enable>false</client-auth-enable>\n""+
			""\t<secure-store>\n""+
			""\t\t<trust-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</trust-store>\n""+
			""\t\t<key-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</key-store>\n""+
			""\t</secure-store>\n""+
			""</secure>\n"", xml);
		
		secure.setEnable(true);
		xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>true</enable>\n""+
			""\t<load>true</load>\n""+
			""\t<protocol>TLS</protocol>\n""+
			""\t<client-auth-enable>false</client-auth-enable>\n""+
			""\t<secure-store>\n""+
			""\t\t<trust-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</trust-store>\n""+
			""\t\t<key-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</key-store>\n""+
			""\t</secure-store>\n""+
			""</secure>\n"", xml);
		
		secure.setLoad(false);
		xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>true</enable>\n""+
			""\t<load>false</load>\n""+
			""\t<protocol>TLS</protocol>\n""+
			""\t<client-auth-enable>false</client-auth-enable>\n""+
			""\t<secure-store>\n""+
			""\t\t<trust-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</trust-store>\n""+
			""\t\t<key-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</key-store>\n""+
			""\t</secure-store>\n""+
			""</secure>\n"", xml);
		
		secure.setPort(1234);
		xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>true</enable>\n""+
			""\t<load>false</load>\n""+
			""\t<port>1234</port>\n""+
			""\t<protocol>TLS</protocol>\n""+
			""\t<client-auth-enable>false</client-auth-enable>\n""+
			""\t<secure-store>\n""+
			""\t\t<trust-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</trust-store>\n""+
			""\t\t<key-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</key-store>\n""+
			""\t</secure-store>\n""+
			""</secure>\n"", xml);
		
		secure.setProtocol(""SSLv3"");
		xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>true</enable>\n""+
			""\t<load>false</load>\n""+
			""\t<port>1234</port>\n""+
			""\t<protocol>SSLv3</protocol>\n""+
			""\t<client-auth-enable>false</client-auth-enable>\n""+
			""\t<secure-store>\n""+
			""\t\t<trust-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</trust-store>\n""+
			""\t\t<key-store>\n""+
			""\t\t\t<file></file>\n""+
			""\t\t\t<password></password>\n""+
			""\t\t\t<type>JKS</type>\n""+
			""\t\t</key-store>\n""+
			""\t</secure-store>\n""+
			""</secure>\n"", xml);
		
		secure.setClientAuthEnable(true);
		xml = secure.toXML("""");
		assertEquals(""<secure>\n""+
			""\t<enable>true</enable>\n""+
			""\t<load>false</load>\n""+
			""\t<port>1234</port>\n""+
			""\t<protocol>SSLv3</protocol>\n""+
		"
cmpl-6tzqnftP1637CUB6tERkN7fwmhE3d,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/SecureStore.java,46.92832612991333,length,"// SecureStore.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 *  This class encapsulate the setting that help in configuring a secure store.
 *  The example xml is <pre>
 * 	....
 * 	&lt;secure-store&gt;
 * 		&lt;type&gt;JKS&lt;/type&gt;
 * 		&lt;algorithm&gt;SunX509&lt;/algorithm&gt;
 * 		&lt;provider&gt;SUN&lt;/provider&gt;
 * 		&lt;key-store-info&gt;
 * 			&lt;store-file&gt;&lt;/store-file&gt;
 * 			&lt;store-password&gt;&lt;/store-password&gt;
 * 			&lt;key-password&gt;&lt;/key-password&gt;
 * 		&lt;/key-store-info&gt;
 * 		&lt;trust-store-info&gt;
 * 			&lt;store-file&gt;&lt;/store-file&gt;
 * 			&lt;store-password&gt;&lt;/store-password&gt;
 * 		&lt;/trust-store-info&gt;
 * 		&lt;secure-store-manager&gt;org.quickserver.security.SecureStoreManager&lt;/secure-store-manager&gt;
 * 	&lt;/secure-store&gt;
 * 	....
 *  </pre>
 *  @see TrustStoreInfo
 *  @see KeyStoreInfo
 *  @see Secure
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class SecureStore implements java.io.Serializable {

    private String type = ""JKS"";

    private String algorithm = ""SunX509"";

    //""SUN"";
    private String provider = null;

    private KeyStoreInfo keyStoreInfo = null;

    private TrustStoreInfo trustStoreInfo = null;

    private String secureStoreManager = ""org.quickserver.security.SecureStoreManager"";

    /**
     * Sets the type of keystore.
     * If not set, it will use <code>JKS</code><br/>
     * XML Tag: &lt;type&gt;JKS&lt;/type&gt;
     * @param type of keystore.
     * @see #getType
     */
    public void setType(String type) {
        if (type != null && type.trim().length() != 0)
            this.type = type;
    }

    /**
     * Returns the type of keystore.
     * @see #setType
     */
    public String getType() {
        return type;
    }

    /**
     * Sets the algorithm for the QuickServer used for key management
     * when run in a secure mode.
     * If not set, it will use <code>SunX509</code><br/>
     * XML Tag: &lt;algorithm&gt;SunX509&lt;/algorithm&gt;
     * @param algorithm for key management.
     * @see #getAlgorithm
     */
    public void setAlgorithm(String algorithm) {
        if (algorithm != null && algorithm.trim().length() != 0)
            this.algorithm = algorithm;
    }

    /**
     * Returns the algorithm for the QuickServer used for key management
     * when run in a secure mode.
     * @see #setAlgorithm
     */
    public String getAlgorithm() {
        return algorithm;
    }

    /**
     * Sets the provider of keystore.
     * Recommended not set, it will auto pick.<br/>
     * XML Tag: &lt;provider&gt;SUN&lt;/provider&gt;
     * @param provider of keystore.
     * @see #getProvider
     */
    public void setProvider(String provider) {
        if (provider != null && provider.trim().length() != 0)
            this.provider = provider;
    }

    /**
     * Returns the provider of keystore.
     * @see #setProvider
     */
    public String getProvider() {
        return provider;
    }

    /**
     * Sets KeyStore information
     * XML Tag: &lt;key-store-info&gt;&lt;/key-store-info&gt;
     * @param keyStoreInfo key store information
     * @see #getKeyStoreInfo
     */
    public void setKeyStoreInfo(KeyStoreInfo keyStoreInfo) {
        if (keyStoreInfo != null)
            this.keyStoreInfo = keyStoreInfo;
    }

    /**
     * Returns KeyStore information.
     * @see #setKeyStoreInfo
     */
    public KeyStoreInfo getKeyStoreInfo() {
        return keyStoreInfo;
    }

    /**
     * Sets TrustStore information
     * XML Tag: &lt;trust-store-info&gt;&lt;/trust-store-info&gt;
     * @param trustStoreInfo trust store information
     * @see #getTrustStoreInfo
     */
    public void setTrustStoreInfo(TrustStoreInfo trustStoreInfo) {
        if (trustStoreInfo != null)
            this.trustStoreInfo = trustStoreInfo;
    }

    /**
     * Returns TrustStore information.
     * @see #setTrustStoreInfo
     */
    public TrustStoreInfo getTrustStoreInfo() {
        return trustStoreInfo;
    }

    /**
     * Sets the SecureStoreManager class name.
     * If not set, it will use <code>org.quickserver.security.SecureStoreManager</code><br/>
     * XML Tag: &lt;secure-store-manager&gt;org.quickserver.security.SecureStoreManager&lt;/secure-store-manager&gt;
     * @param className the fully qualified name of the class that
     * extends {@link org.quickserver.security.SecureStoreManager}
     * @see #getSecureStoreManager
     * @see org.quickserver.security.SecureStoreManager
     * @since 1.4
     */
    public void setSecureStoreManager(String className) {
        if (className != null && className.trim().length() != 0)
            this.secureStoreManager = className;
    }

    /**
     * Returns the SecureStoreManager class.
     * @see #setSecureStoreManager
     * @see org.quickserver.security.SecureStoreManager
     * @since 1.4
     */
    public String getSecureStoreManager() {
        return secureStoreManager;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<secure-store>\n"");
        sb.append(pad).append(""\t<type>"").append(getType()).append(""</type>\n"");
        sb.append(pad).append(""\t<algorithm>"").append(getAlgorithm()).append(""</algorithm>\n"");
        if (getProvider() != null)
            sb.append(pad).append(""\t<provider>"").append(getProvider()).append(""</provider>\n"");
        if (getKeyStoreInfo() != null) {
            sb.append(getKeyStoreInfo().toXML(pad + ""\t""));
        }
        if (getTrustStoreInfo() != null) {
            sb.append(getTrustStoreInfo().toXML(pad + ""\t""));
        }
        sb.append(pad).append(""\t<secure-store-manager>"").append(getSecureStoreManager()).append(""</secure-store-manager>\n"");
        sb.append(pad).append(""</secure-store>\n"");
        return sb.toString();
    }
}
","// SecureStoreTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStore}.
* It contains ten unit test cases for the {@link SecureStore#toXML(String)} method.
*/
class SecureStoreTest {","// SecureStoreTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SecureStore}.
* It contains ten unit test cases for the {@link SecureStore#toXML(String)} method.
*/
class SecureStoreTest {

	@Test
	void testToXML() {
		SecureStore secureStore = new SecureStore();
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithProvider() {
		SecureStore secureStore = new SecureStore();
		secureStore.setProvider(""SUN"");
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<provider>SUN</provider>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithKeyStoreInfo() {
		SecureStore secureStore = new SecureStore();
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""keystore.jks"");
		keyStoreInfo.setStorePassword(""changeit"");
		keyStoreInfo.setKeyPassword(""changeit"");
		secureStore.setKeyStoreInfo(keyStoreInfo);
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<key-store-info>\n"" + 
			""\t\t<store-file>keystore.jks</store-file>\n"" + 
			""\t\t<store-password>changeit</store-password>\n"" + 
			""\t\t<key-password>changeit</key-password>\n"" + 
			""\t</key-store-info>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithTrustStoreInfo() {
		SecureStore secureStore = new SecureStore();
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""truststore.jks"");
		trustStoreInfo.setStorePassword(""changeit"");
		secureStore.setTrustStoreInfo(trustStoreInfo);
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<trust-store-info>\n"" + 
			""\t\t<store-file>truststore.jks</store-file>\n"" + 
			""\t\t<store-password>changeit</store-password>\n"" + 
			""\t</trust-store-info>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithSecureStoreManager() {
		SecureStore secureStore = new SecureStore();
		secureStore.setSecureStoreManager(""org.quickserver.security.SecureStoreManager"");
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithAll() {
		SecureStore secureStore = new SecureStore();
		secureStore.setProvider(""SUN"");
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""keystore.jks"");
		keyStoreInfo.setStorePassword(""changeit"");
		keyStoreInfo.setKeyPassword(""changeit"");
		secureStore.setKeyStoreInfo(keyStoreInfo);
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""truststore.jks"");
		trustStoreInfo.setStorePassword(""changeit"");
		secureStore.setTrustStoreInfo(trustStoreInfo);
		secureStore.setSecureStoreManager(""org.quickserver.security.SecureStoreManager"");
		String xml = secureStore.toXML("""");
		assertEquals(""<secure-store>\n"" + 
			""\t<type>JKS</type>\n"" + 
			""\t<algorithm>SunX509</algorithm>\n"" + 
			""\t<provider>SUN</provider>\n"" + 
			""\t<key-store-info>\n"" + 
			""\t\t<store-file>keystore.jks</store-file>\n"" + 
			""\t\t<store-password>changeit</store-password>\n"" + 
			""\t\t<key-password>changeit</key-password>\n"" + 
			""\t</key-store-info>\n"" + 
			""\t<trust-store-info>\n"" + 
			""\t\t<store-file>truststore.jks</store-file>\n"" + 
			""\t\t<store-password>changeit</store-password>\n"" + 
			""\t</trust-store-info>\n"" + 
			""\t<secure-store-manager>org.quickserver.security.SecureStoreManager</secure-store-manager>\n"" + 
			""</secure-store>\n"", xml);
	}
	
	@Test
	void testToXMLWithAllAndPad() {
		SecureStore secureStore = new SecureStore();
		secureStore.setProvider(""SUN"");
		KeyStoreInfo keyStoreInfo = new KeyStoreInfo();
		keyStoreInfo.setStoreFile(""keystore.jks"");
		keyStoreInfo.setStorePassword(""changeit"");
		keyStoreInfo.setKeyPassword(""changeit"");
		secureStore.setKeyStoreInfo(keyStoreInfo);
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""truststore.jks"");
		trustStoreInfo.setStorePassword(""changeit"");
		secureStore.setTrustStoreInfo(trustStoreInfo);
		secureStore.setSecureStoreManager(""org.quickserver.security.SecureStoreManager"");
		String xml = secureStore.toXML(""\t"");
		assertEquals(""\t<secure-store>\n"" + 
		"
cmpl-6tzrqsU3W06FBgjvfh4f7vKbVwaG4,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ServerHooks.java,36.674540519714355,length,"// ServerHooks.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;

/**
 *  This class encapsulate the Server Hooks. These are event listeners to
 *  the QuickServer.
 *  The example xml is <pre>
 * 	....
 * 	&lt;server-hooks&gt;
 * 		&lt;class-name&gt;package1.Class1&lt;/class-name&gt;
 * 		&lt;class-name&gt;package1.Class2&lt;/class-name&gt;
 * 	&lt;/server-hooks&gt;
 * 	....
 *  </pre>
 *  @see org.quickserver.net.ServerHook
 *  @see org.quickserver.util.xmlreader.InitServerHooks
 *  @author Akshathkumar Shetty
 *  @since 1.3.3
 */
public class ServerHooks extends ArrayList {

    /**
     * Addes the class to server hooks
     */
    public void addClassName(String className) {
        if (className != null && className.trim().length() != 0) {
            add(className.trim());
        }
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<server-hooks>\n"");
        Iterator iterator = iterator();
        while (iterator.hasNext()) {
            String classname = (String) iterator.next();
            sb.append(pad).append(""\t<class-name>"").append(classname).append(""</class-name>\n"");
        }
        sb.append(pad).append(""</server-hooks>\n"");
        return sb.toString();
    }
}
","// ServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerHooks}.
* It contains ten unit test cases for the {@link ServerHooks#toXML(String)} method.
*/
class ServerHooksTest {","// ServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerHooks}.
* It contains ten unit test cases for the {@link ServerHooks#toXML(String)} method.
*/
class ServerHooksTest {

	@Test
	public void testToXML() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(""package1.Class1"");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class1</class-name>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(""package1.Class1"");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(""\t"");
		assertEquals(""\t<server-hooks>\n\t\t<class-name>package1.Class1</class-name>\n\t\t<class-name>package1.Class2</class-name>\n\t</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyClassName() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName("""");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullClassName() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(null);
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyClassNameAndPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName("""");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(""\t"");
		assertEquals(""\t<server-hooks>\n\t\t<class-name>package1.Class2</class-name>\n\t</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullClassNameAndPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(null);
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(""\t"");
		assertEquals(""\t<server-hooks>\n\t\t<class-name>package1.Class2</class-name>\n\t</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyClassNameAndNullPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName("""");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullClassNameAndNullPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(null);
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyClassNameAndEmptyPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName("""");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML("""");
		assertEquals(""<server-hooks>\n<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullClassNameAndEmptyPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(null);
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML("""");
		assertEquals(""<server-hooks>\n<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithEmptyClassNameAndNullPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName("""");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithNullClassNameAndNullPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(null);
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
}

// ServerHooksTest.java
package org.quickserver.util.xmlreader;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerHooks}.
* It contains ten unit test cases for the {@link ServerHooks#toXML(String)} method.
*/
class ServerHooksTest {
		
	@Test
	public void testToXML() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(""package1.Class1"");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(null);
		assertEquals(""<server-hooks>\n\t<class-name>package1.Class1</class-name>\n\t<class-name>package1.Class2</class-name>\n</server-hooks>\n"", xml);
	}
	
	@Test
	public void testToXMLWithPad() {
		ServerHooks serverHooks = new ServerHooks();
		serverHooks.addClassName(""package1.Class1"");
		serverHooks.addClassName(""package1.Class2"");
		String xml = serverHooks.toXML(""\t"");
		assertEquals(""\t<server-hooks>\n\t\t<class-name>package1.Class1</"
cmpl-6tzst3p2oGqRmy0G7LNv1p4sOn7qG,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ServerMode.java,44.47261333465576,length,"// ServerMode.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the servers mode.
 * The xml is &lt;server-mode&gt;...&lt;/server-mode&gt;
 * @author Akshathkumar Shetty
 * @since 1.4.5
 */
public class ServerMode implements java.io.Serializable {

    private boolean blocking = true;

    /**
     * Returns the blocking mode enable flag. Default is <code>true</code>.
     * @return blocking
     */
    public boolean getBlocking() {
        return blocking;
    }

    /**
     * Sets the blocking mode enable flag.
     * XML Tag: &lt;server-mode&gt;&lt;blocking&gt;true&lt;/blocking&gt;&lt;/server-mode&gt;
     * Allowed values = <code>true</code> | <code>false</code>
     * @param blocking
     */
    public void setBlocking(boolean blocking) {
        this.blocking = blocking;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<server-mode>\n"");
        sb.append(pad).append(""\t<blocking>"").append(getBlocking()).append(""</blocking>\n"");
        sb.append(pad).append(""</server-mode>\n"");
        return sb.toString();
    }

    public String toString() {
        if (getBlocking())
            return ""Blocking"";
        else
            return ""Non-Blocking"";
    }
}
","// ServerModeTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerMode}.
* It contains ten unit test cases for the {@link ServerMode#toXML(String)} method.
*/
class ServerModeTest {","// ServerModeTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerMode}.
* It contains ten unit test cases for the {@link ServerMode#toXML(String)} method.
*/
class ServerModeTest {

	@Test
	void testToXML() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(null);
		assertEquals(""<server-mode>\n\t<blocking>true</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML2() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(null);
		assertEquals(""<server-mode>\n\t<blocking>false</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML3() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t"");
		assertEquals(""\t<server-mode>\n\t\t<blocking>true</blocking>\n\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML4() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(""\t"");
		assertEquals(""\t<server-mode>\n\t\t<blocking>false</blocking>\n\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML5() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML("""");
		assertEquals(""<server-mode>\n\t<blocking>true</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML6() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML("""");
		assertEquals(""<server-mode>\n\t<blocking>false</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML7() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t\t"");
		assertEquals(""\t\t<server-mode>\n\t\t\t<blocking>true</blocking>\n\t\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML8() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(""\t\t"");
		assertEquals(""\t\t<server-mode>\n\t\t\t<blocking>false</blocking>\n\t\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML9() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t\t\t"");
		assertEquals(""\t\t\t<server-mode>\n\t\t\t\t<blocking>true</blocking>\n\t\t\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML10() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(""\t\t\t"");
		assertEquals(""\t\t\t<server-mode>\n\t\t\t\t<blocking>false</blocking>\n\t\t\t</server-mode>\n"", xml);
	}
	
}

// ServerModeTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ServerMode}.
* It contains ten unit test cases for the {@link ServerMode#toXML(String)} method.
*/
class ServerModeTest {
		
	@Test
	void testToXML() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(null);
		assertEquals(""<server-mode>\n\t<blocking>true</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML2() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(null);
		assertEquals(""<server-mode>\n\t<blocking>false</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML3() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t"");
		assertEquals(""\t<server-mode>\n\t\t<blocking>true</blocking>\n\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML4() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(""\t"");
		assertEquals(""\t<server-mode>\n\t\t<blocking>false</blocking>\n\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML5() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML("""");
		assertEquals(""<server-mode>\n\t<blocking>true</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML6() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML("""");
		assertEquals(""<server-mode>\n\t<blocking>false</blocking>\n</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML7() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t\t"");
		assertEquals(""\t\t<server-mode>\n\t\t\t<blocking>true</blocking>\n\t\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML8() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(false);
		String xml = serverMode.toXML(""\t\t"");
		assertEquals(""\t\t<server-mode>\n\t\t\t<blocking>false</blocking>\n\t\t</server-mode>\n"", xml);
	}
	
	@Test
	void testToXML9() {
		ServerMode serverMode = new ServerMode();
		serverMode.setBlocking(true);
		String xml = serverMode.toXML(""\t\t\t"");
		assertEquals(""\t\t\t<server-mode>\n\t\t\t\t<blocking>true</blocking>"
cmpl-6tztwWQiklYyEBvUfLp104sCSrJOv,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/ThreadObjectPoolConfig.java,33.789111375808716,length,"// ThreadObjectPoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the Thread Object pool configuration.
 * The xml is &lt;thread-object-pool&gt;...&lt;/thread-object-pool&gt;
 * @author Akshathkumar Shetty
 */
public class ThreadObjectPoolConfig extends PoolConfig {

    public ThreadObjectPoolConfig() {
        super();
    }

    public ThreadObjectPoolConfig(PoolConfig poolConfig) {
        setMaxActive(poolConfig.getMaxActive());
        setMaxIdle(poolConfig.getMaxIdle());
        setInitSize(poolConfig.getInitSize());
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<thread-object-pool>\n"");
        sb.append(pad).append(""\t<max-active>"").append(getMaxActive()).append(""</max-active>\n"");
        sb.append(pad).append(""\t<max-idle>"").append(getMaxIdle()).append(""</max-idle>\n"");
        sb.append(pad).append(""\t<init-size>"").append(getInitSize()).append(""</init-size>\n"");
        sb.append(pad).append(""</thread-object-pool>\n"");
        return sb.toString();
    }
}
","// ThreadObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ThreadObjectPoolConfig}.
* It contains ten unit test cases for the {@link ThreadObjectPoolConfig#toXML(String)} method.
*/
class ThreadObjectPoolConfigTest {","// ThreadObjectPoolConfigTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ThreadObjectPoolConfig}.
* It contains ten unit test cases for the {@link ThreadObjectPoolConfig#toXML(String)} method.
*/
class ThreadObjectPoolConfigTest {

	@Test
	void testToXML() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(null);
		assertEquals(""<thread-object-pool>\n"" +
				""\t<max-active>10</max-active>\n"" +
				""\t<max-idle>5</max-idle>\n"" +
				""\t<init-size>2</init-size>\n"" +
				""</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPad() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxActive() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxIdle() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxIdle(5);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndInitSize() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdle() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndInitSize() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxIdleAndInitSize() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdleAndInitSize() {
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig();
		config.setMaxActive(10);
		config.setMaxIdle(5);
		config.setInitSize(2);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
	
	@Test
	void testToXMLWithPadAndMaxActiveAndMaxIdleAndInitSizeAndPoolConfig() {
		PoolConfig poolConfig = new PoolConfig();
		poolConfig.setMaxActive(10);
		poolConfig.setMaxIdle(5);
		poolConfig.setInitSize(2);
		ThreadObjectPoolConfig config = new ThreadObjectPoolConfig(poolConfig);
		String xml = config.toXML(""\t"");
		assertEquals(""\t<thread-object-pool>\n"" +
				""\t\t<max-active>10</max-active>\n"" +
				""\t\t<max-idle>5</max-idle>\n"" +
				""\t\t<init-size>2</init-size>\n"" +
				""\t</thread-object-pool>\n"", xml);
	}
}

// PoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 * This class encapsulate the pool configuration.
 * @author Akshathkumar Shetty
 */
public class PoolConfig {
    private int maxActive = -1;
    private int maxIdle = -1;
    private int initSize = -1;

    public PoolConfig() {
    }

    public int getMaxActive() {
        return maxActive;
    }

    public void setMaxActive(int maxActive) {
        this.maxActive"
cmpl-6tzuz0ys5Fy1Rb2FPGHZwtKbZUbZx,/EvoSuiteBenchmark/93_quickserver/src/main/java/org/quickserver/util/xmlreader/TrustStoreInfo.java,41.28050923347473,length,"// TrustStoreInfo.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

/**
 *  This class encapsulate Trust Store.
 *  The example xml is <pre>
 * 	....
 * 	&lt;trust-store-info&gt;
 * 		&lt;store-file&gt;NONE&lt;/store-file&gt;
 * 		&lt;store-password&gt;&lt;/store-password&gt;
 * 	&lt;/trust-store-info&gt;
 * 	....
 *  </pre>
 *  @see KeyStoreInfo
 *  @see SecureStore
 *  @see Secure
 *  @author Akshathkumar Shetty
 *  @since 1.4
 */
public class TrustStoreInfo implements java.io.Serializable {

    private String storeFile = ""NONE"";

    private String storePassword = null;

    private String type = null;

    private String provider = null;

    /**
     * Sets the store file path. This can be either absolute or
     * relative(to config file) path to the store file.
     * XML Tag: &lt;store-file&gt;NONE&lt;/store-file&gt;
     * @param storeFile store file.
     * @see #getStoreFile
     */
    public void setStoreFile(String storeFile) {
        if (storeFile != null && storeFile.trim().length() != 0)
            this.storeFile = storeFile;
    }

    /**
     * Returns the store file path. This can be either absolute or
     * relative(to config file) path to the store file.
     * @see #setStoreFile
     */
    public String getStoreFile() {
        return storeFile;
    }

    /**
     * Sets the store password.
     * XML Tag: &lt;store-password&gt;&lt;/store-password&gt;
     * @param storePassword store password
     * @see #getStorePassword
     */
    public void setStorePassword(String storePassword) {
        if (storePassword != null)
            this.storePassword = storePassword;
    }

    /**
     * Returns store password.
     * @see #setStorePassword
     */
    public String getStorePassword() {
        return storePassword;
    }

    /**
     * Sets the type of trust store.
     * If not set, it will use value from SecureStore<br/>
     * XML Tag: &lt;type&gt;JKS&lt;/type&gt;
     * @param type of keystore.
     * @see #getType
     */
    public void setType(String type) {
        if (type != null && type.trim().length() != 0)
            this.type = type;
    }

    /**
     * Returns the type of truststore.
     * @see #setType
     */
    public String getType() {
        return type;
    }

    /**
     * Sets the provider of trust store. If not set, it will use value from SecureStore<br/>
     * XML Tag: &lt;provider&gt;SUN&lt;/provider&gt;
     * @param provider of keystore.
     * @see #getProvider
     */
    public void setProvider(String provider) {
        if (provider != null && provider.trim().length() != 0)
            this.provider = provider;
    }

    /**
     * Returns the provider of keystore.
     * @see #setProvider
     */
    public String getProvider() {
        return provider;
    }

    /**
     * Returns XML config of this class.
     */
    public String toXML(String pad) {
        if (pad == null)
            pad = """";
        StringBuilder sb = new StringBuilder();
        sb.append(pad).append(""<trust-store-info>\n"");
        sb.append(pad).append(""\t<store-file>"").append(getStoreFile()).append(""</store-file>\n"");
        if (getStorePassword() != null)
            sb.append(pad).append(""\t<store-password>"").append(getStorePassword()).append(""</store-password>\n"");
        else
            sb.append(pad).append(""\t</store-password>\n"");
        if (getType() != null)
            sb.append(pad).append(""\t<type>"").append(getType()).append(""</type>\n"");
        if (getProvider() != null)
            sb.append(pad).append(""\t<provider>"").append(getProvider()).append(""</provider>\n"");
        sb.append(pad).append(""</trust-store-info>\n"");
        return sb.toString();
    }
}
","// TrustStoreInfoTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TrustStoreInfo}.
* It contains ten unit test cases for the {@link TrustStoreInfo#toXML(String)} method.
*/
class TrustStoreInfoTest {","// TrustStoreInfoTest.java
package org.quickserver.util.xmlreader;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TrustStoreInfo}.
* It contains ten unit test cases for the {@link TrustStoreInfo#toXML(String)} method.
*/
class TrustStoreInfoTest {

	@Test
	void testToXML() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""<trust-store-info>\n"" +
				""\t<store-file>NONE</store-file>\n"" +
				""\t<store-password></store-password>\n"" +
				""\t<type>JKS</type>\n"" +
				""\t<provider>SUN</provider>\n"" +
				""</trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""""));
	}
	
	@Test
	void testToXML2() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""    <trust-store-info>\n"" +
				""        <store-file>NONE</store-file>\n"" +
				""        <store-password></store-password>\n"" +
				""        <type>JKS</type>\n"" +
				""        <provider>SUN</provider>\n"" +
				""    </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""    ""));
	}
	
	@Test
	void testToXML3() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""        <trust-store-info>\n"" +
				""            <store-file>NONE</store-file>\n"" +
				""            <store-password></store-password>\n"" +
				""            <type>JKS</type>\n"" +
				""            <provider>SUN</provider>\n"" +
				""        </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""        ""));
	}
	
	@Test
	void testToXML4() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""            <trust-store-info>\n"" +
				""                <store-file>NONE</store-file>\n"" +
				""                <store-password></store-password>\n"" +
				""                <type>JKS</type>\n"" +
				""                <provider>SUN</provider>\n"" +
				""            </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""            ""));
	}
	
	@Test
	void testToXML5() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""                <trust-store-info>\n"" +
				""                    <store-file>NONE</store-file>\n"" +
				""                    <store-password></store-password>\n"" +
				""                    <type>JKS</type>\n"" +
				""                    <provider>SUN</provider>\n"" +
				""                </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""                ""));
	}
	
	@Test
	void testToXML6() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""                    <trust-store-info>\n"" +
				""                        <store-file>NONE</store-file>\n"" +
				""                        <store-password></store-password>\n"" +
				""                        <type>JKS</type>\n"" +
				""                        <provider>SUN</provider>\n"" +
				""                    </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""                    ""));
	}
	
	@Test
	void testToXML7() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""                        <trust-store-info>\n"" +
				""                            <store-file>NONE</store-file>\n"" +
				""                            <store-password></store-password>\n"" +
				""                            <type>JKS</type>\n"" +
				""                            <provider>SUN</provider>\n"" +
				""                        </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""                        ""));
	}
	
	@Test
	void testToXML8() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""                            <trust-store-info>\n"" +
				""                                <store-file>NONE</store-file>\n"" +
				""                                <store-password></store-password>\n"" +
				""                                <type>JKS</type>\n"" +
				""                                <provider>SUN</provider>\n"" +
				""                            </trust-store-info>\n"";
		assertEquals(expected, trustStoreInfo.toXML(""                            ""));
	}
	
	@Test
	void testToXML9() {
		TrustStoreInfo trustStoreInfo = new TrustStoreInfo();
		trustStoreInfo.setStoreFile(""NONE"");
		trustStoreInfo.setStorePassword("""");
		trustStoreInfo.setType(""JKS"");
		trustStoreInfo.setProvider(""SUN"");
		String expected = ""                                <trust-store-info>\n"" +
				""                                    <store-file>NONE</store-file>\n"" +
				""                                    <store-password></store-password>\n"" +
				""                                    <type>JKS</type>\n"" +
				""                                    <provider>SUN</provider>\n"" +
	"
