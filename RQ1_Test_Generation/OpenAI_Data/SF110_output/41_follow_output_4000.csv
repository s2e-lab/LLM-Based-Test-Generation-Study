ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6ts5W6988jeCZiPsABukpG3E4FtF8,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java,100.77317690849304,length,"// FileFollower.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Constructs a new FileFollower; invoking this constructor does
     * <em>not</em> cause the new object to begin following the supplied file.
     * In order to begin following, one must call {@link #start()}.
     *
     * @param file
     *            file to be followed
     * @param bufferSize
     *            number of chars to be read each time the file is accessed
     * @param latency
     *            each time a FileFollower's running thread encounters the end
     *            of the file in its stream, it will rest for this many
     *            milliseconds before checking to see if there are any more
     *            bytes in the file
     * @param initialOutputDestinations
     *            an initial array of OutputDestinations which will be used when
     *            printing the contents of the file (this array may be
     *            <tt>null</tt>)
     */
    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {
        this.file = file;
        this.bufferSize = bufferSize;
        this.latency = latency;
        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;
        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);
        for (int i = 0; i < initOutputDestsSize; i++) {
            outputDestinations.add(initialOutputDestinations[i]);
        }
    }

    /**
     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},
     * except that a default buffer size (32,768 characters) and latency (1000
     * milliseconds) are used.
     *
     * @see #FileFollower(File, int, int, OutputDestination[])
     */
    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {
        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not
        // sure whether this is a truly optimal buffer size.
        this(// Don't change without updating docs!
        file, // Don't change without updating docs!
        32768, // Don't change without updating docs!
        1000, initialOutputDestinations);
    }

    /**
     * Cause this FileFollower to spawn a thread which will follow the file
     * supplied in the constructor and send its contents to all of the
     * FileFollower's OutputDestinations.<br>
     * <br>
     * If this FileFollower is running but paused, this method equates to
     * calling unpause().
     */
    public synchronized void start() {
        if (continueRunning && paused) {
            unpause();
        } else {
            continueRunning = true;
            paused = false;
            runnerThread = new Thread(new Runner(), getFollowedFile().getName());
            runnerThread.start();
        }
    }

    public synchronized void pause() {
        paused = true;
    }

    public synchronized void unpause() {
        paused = false;
    }

    public synchronized void restart() {
        needsRestart = true;
        runnerThread.interrupt();
    }

    /**
     * Cause this FileFollower to stop following the file supplied in the
     * constructor after it flushes the characters it's currently reading to all
     * its OutputDestinations.
     */
    public synchronized void stop() {
        continueRunning = false;
        runnerThread.interrupt();
    }

    /**
     * Like {@link #stop()}, but this method will not exit until the thread
     * which is following the file has finished executing (i.e., stop
     * synchronously).
     */
    public synchronized void stopAndWait() throws InterruptedException {
        stop();
        while (runnerThread.isAlive()) {
            Thread.yield();
        }
    }

    /**
     * Send the supplied string to all OutputDestinations
     *
     * @param s
     */
    private synchronized void print(String s) {
        for (OutputDestination out : outputDestinations) {
            out.print(s);
        }
    }

    /**
     * Clear all OutputDestinations
     */
    private synchronized void clear() {
        for (OutputDestination out : outputDestinations) {
            out.clear();
        }
    }

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.add(outputDestination);
    }

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.remove(outputDestination);
    }

    /**
     * Returns the List which maintains all OutputDestinations for this
     * FileFollower.
     *
     * @return contains all OutputDestinations for this FileFollower
     */
    public List<OutputDestination> getOutputDestinations() {
        return outputDestinations;
    }

    /**
     * Returns the file which is being followed by this FileFollower
     *
     * @return file being followed
     */
    public File getFollowedFile() {
        return file;
    }

    /**
     * Returns the following state of a file
     *
     * @return true if being followed, false if not being followed
     */
    public boolean isBeingFollowed() {
        return continueRunning;
    }

    /**
     * Returns the pause state of the follower.
     *
     * @return true if paused, false otherwise
     */
    public boolean isPaused() {
        return paused;
    }

    /**
     * Returns the size of the character buffer used to read characters from the
     * followed file. Each time the file is accessed, this buffer is filled.
     *
     * @return size of the character buffer
     */
    public int getBufferSize() {
        return bufferSize;
    }

    /**
     * Sets the size of the character buffer used to read characters from the
     * followed file. Increasing buffer size will improve efficiency but
     * increase the amount of memory used by the FileFollower.<br>
     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running
     * FileFollower to immediately begin reading characters into a buffer of the
     * newly specified size. You must stop & restart the FileFollower in order
     * for changes to take effect.
     *
     * @param bufferSize
     *            size of the character buffer
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }

    /**
     * Returns the time (in milliseconds) which a FileFollower spends sleeping
     * each time it encounters the end of the followed file.
     *
     * @return latency, in milliseconds
     */
    public int getLatency() {
        return latency;
    }

    /**
     * Sets the time (in milliseconds) which a FileFollower spends sleeping each
     * time it encounters the end of the followed file. Note that extremely low
     * latency values may cause thrashing between the FileFollower's running
     * thread and other threads in an application. A change in this value will
     * be reflected the next time the FileFollower's running thread sleeps.
     *
     * @param latency
     *            latency, in milliseconds
     */
    public void setLatency(int latency) {
        this.latency = latency;
    }

    protected int bufferSize;

    protected int latency;

    protected File file;

    protected List<OutputDestination> outputDestinations;

    protected boolean continueRunning;

    protected boolean needsRestart;

    protected Thread runnerThread;

    protected boolean paused;

    /**
     * Instances of this class are used to run a thread which follows a
     * FileFollower's file and sends prints its contents to OutputDestinations.
     * This class should only handle the gathering of data from the followed
     * file. Actually writing to the output destinations is handled by the outer
     * class (FileFollower).
     */
    class Runner implements Runnable {

        private Logger log = Logger.getLogger(Runner.class.getName());

        public void run() {
            log.finer(""entering FileFollower.run()"");
            while (continueRunning) {
                runAction();
            }
            log.finer(""exiting FileFollower.run()"");
        }

        protected void runAction() {
            try {
                clear();
                long fileSize = file.length();
                byte[] byteArray = new byte[bufferSize];
                int numBytesRead;
                long lastActivityTime = file.lastModified();
                // create some stream readers to handle the file
                FileInputStream fis = new FileInputStream(file);
                BufferedInputStream bis = new BufferedInputStream(fis);
                // start at the beginning of the file
                long startingPoint = 0;
                // if the file size is bigger than the buffer size, skip to the
                // end of the file if not performing a restart
                if (fileSize > bufferSize) {
                    startingPoint = fileSize - bufferSize;
                }
                // reset the restart flag
                needsRestart = false;
                log.finer(""Starting point: "" + startingPoint + ""; Last activity: "" + lastActivityTime);
                bis.skip(startingPoint);
                while (continueRunning && !needsRestart) {
                    if (!paused) {
                        lastActivityTime = System.currentTimeMillis();
                        numBytesRead = bis.read(byteArray, 0, byteArray.length);
                        boolean dataWasFound = (numBytesRead > 0);
                        log.finer(""Bytes read: "" + numBytesRead + ""; dataWasFound: "" + dataWasFound);
                        // if data was found, print it and log activity time
                        if (dataWasFound) {
                            String output = new String(byteArray, 0, numBytesRead);
                            // print the output to the listeners
                            print(output);
                        } else // no data found so check the file and restart if needed
                        {
                            // check if the file handle has become stale (file
                            // was modified, but no data was read).
                            boolean fileExists = file.exists();
                            // removed check for 0 length because a file could
                            // change by being cleared out
                            // && (file_.length() > 0);
                            boolean fileHasChanged = file.lastModified() > lastActivityTime;
                            if (fileExists && fileHasChanged) {
                                log.finer(""Needs restart [fileExists="" + fileExists + ""; fileHasChanged="" + fileHasChanged + ""]"");
                                needsRestart = true;
                            }
                        }
                        boolean allDataRead = (numBytesRead < byteArray.length);
                        if (allDataRead && !needsRestart) {
                            log.finer(""Sleeping for "" + latency + ""ms [allDataRead:"" + allDataRead + ""; needsRestart:"" + needsRestart + ""]"");
                            sleep();
                        }
                    } else {
                        log.finer(""Runner paused."");
                        sleep();
                    }
                }
                log.finer(""exiting Runner.runAction [continueRunning="" + continueRunning + ""; needsRestart="" + needsRestart + ""]"");
                bis.close();
                fis.close();
            } catch (IOException e) {
                log.log(Level.SEVERE, ""IOException while following file"", e);
            }
        }

        private void sleep() {
            try {
                Thread.sleep(latency);
            } catch (InterruptedException e) {
                // Interrupt may be thrown manually by stop()
                log.finer(""DIED IN MY SLEEP"");
            }
        }
    }

    /**
     * Line separator, retrieved from System properties & stored statically.
     */
    protected static final String lineSeparator = System.getProperty(""line.separator"");
}
","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains ten unit test cases for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {","// FileFollower_0Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains ten unit test cases for the {@link FileFollower#addOutputDestination(OutputDestination)} method.
*/
class FileFollower_0Test {

		private static final Logger LOG = Logger.getLogger(FileFollower_0Test.class.getName());
		
		private static final String TEST_FILE_NAME = ""test.txt"";
		
		private static final String TEST_FILE_CONTENT = ""This is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED = ""This is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWICE = ""This is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_THRICE = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_FOUR_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_FIVE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_SIX_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_SEVEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_EIGHT_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_NINE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_ELEVEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWELVE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_THIRTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_FOURTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_FIFTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_SIXTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_SEVENTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_EIGHTEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_NINETEEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_ONE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_TWO_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_THREE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_FOUR_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_FIVE_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_SIX_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file."";
		
		private static final String TEST_FILE_CONTENT_APPENDED_TWENTY_SEVEN_TIMES = ""This is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a test file.\nThis is a"
cmpl-6ts78zekHOWpkLVfp20z61738aEae,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java,101.67709469795227,length,"// FileFollower.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 *
 * @see OutputDestination
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollower {

    /**
     * Constructs a new FileFollower; invoking this constructor does
     * <em>not</em> cause the new object to begin following the supplied file.
     * In order to begin following, one must call {@link #start()}.
     *
     * @param file
     *            file to be followed
     * @param bufferSize
     *            number of chars to be read each time the file is accessed
     * @param latency
     *            each time a FileFollower's running thread encounters the end
     *            of the file in its stream, it will rest for this many
     *            milliseconds before checking to see if there are any more
     *            bytes in the file
     * @param initialOutputDestinations
     *            an initial array of OutputDestinations which will be used when
     *            printing the contents of the file (this array may be
     *            <tt>null</tt>)
     */
    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {
        this.file = file;
        this.bufferSize = bufferSize;
        this.latency = latency;
        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;
        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);
        for (int i = 0; i < initOutputDestsSize; i++) {
            outputDestinations.add(initialOutputDestinations[i]);
        }
    }

    /**
     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},
     * except that a default buffer size (32,768 characters) and latency (1000
     * milliseconds) are used.
     *
     * @see #FileFollower(File, int, int, OutputDestination[])
     */
    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {
        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not
        // sure whether this is a truly optimal buffer size.
        this(// Don't change without updating docs!
        file, // Don't change without updating docs!
        32768, // Don't change without updating docs!
        1000, initialOutputDestinations);
    }

    /**
     * Cause this FileFollower to spawn a thread which will follow the file
     * supplied in the constructor and send its contents to all of the
     * FileFollower's OutputDestinations.<br>
     * <br>
     * If this FileFollower is running but paused, this method equates to
     * calling unpause().
     */
    public synchronized void start() {
        if (continueRunning && paused) {
            unpause();
        } else {
            continueRunning = true;
            paused = false;
            runnerThread = new Thread(new Runner(), getFollowedFile().getName());
            runnerThread.start();
        }
    }

    public synchronized void pause() {
        paused = true;
    }

    public synchronized void unpause() {
        paused = false;
    }

    public synchronized void restart() {
        needsRestart = true;
        runnerThread.interrupt();
    }

    /**
     * Cause this FileFollower to stop following the file supplied in the
     * constructor after it flushes the characters it's currently reading to all
     * its OutputDestinations.
     */
    public synchronized void stop() {
        continueRunning = false;
        runnerThread.interrupt();
    }

    /**
     * Like {@link #stop()}, but this method will not exit until the thread
     * which is following the file has finished executing (i.e., stop
     * synchronously).
     */
    public synchronized void stopAndWait() throws InterruptedException {
        stop();
        while (runnerThread.isAlive()) {
            Thread.yield();
        }
    }

    /**
     * Send the supplied string to all OutputDestinations
     *
     * @param s
     */
    private synchronized void print(String s) {
        for (OutputDestination out : outputDestinations) {
            out.print(s);
        }
    }

    /**
     * Clear all OutputDestinations
     */
    private synchronized void clear() {
        for (OutputDestination out : outputDestinations) {
            out.clear();
        }
    }

    /**
     * Add another OutputDestination to which the followed file's contents
     * should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be added
     */
    public boolean addOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.add(outputDestination);
    }

    /**
     * Remove the supplied OutputDestination from the list of OutputDestinations
     * to which the followed file's contents should be printed.
     *
     * @param outputDestination
     *            OutputDestination to be removed
     */
    public boolean removeOutputDestination(OutputDestination outputDestination) {
        return outputDestinations.remove(outputDestination);
    }

    /**
     * Returns the List which maintains all OutputDestinations for this
     * FileFollower.
     *
     * @return contains all OutputDestinations for this FileFollower
     */
    public List<OutputDestination> getOutputDestinations() {
        return outputDestinations;
    }

    /**
     * Returns the file which is being followed by this FileFollower
     *
     * @return file being followed
     */
    public File getFollowedFile() {
        return file;
    }

    /**
     * Returns the following state of a file
     *
     * @return true if being followed, false if not being followed
     */
    public boolean isBeingFollowed() {
        return continueRunning;
    }

    /**
     * Returns the pause state of the follower.
     *
     * @return true if paused, false otherwise
     */
    public boolean isPaused() {
        return paused;
    }

    /**
     * Returns the size of the character buffer used to read characters from the
     * followed file. Each time the file is accessed, this buffer is filled.
     *
     * @return size of the character buffer
     */
    public int getBufferSize() {
        return bufferSize;
    }

    /**
     * Sets the size of the character buffer used to read characters from the
     * followed file. Increasing buffer size will improve efficiency but
     * increase the amount of memory used by the FileFollower.<br>
     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running
     * FileFollower to immediately begin reading characters into a buffer of the
     * newly specified size. You must stop & restart the FileFollower in order
     * for changes to take effect.
     *
     * @param bufferSize
     *            size of the character buffer
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }

    /**
     * Returns the time (in milliseconds) which a FileFollower spends sleeping
     * each time it encounters the end of the followed file.
     *
     * @return latency, in milliseconds
     */
    public int getLatency() {
        return latency;
    }

    /**
     * Sets the time (in milliseconds) which a FileFollower spends sleeping each
     * time it encounters the end of the followed file. Note that extremely low
     * latency values may cause thrashing between the FileFollower's running
     * thread and other threads in an application. A change in this value will
     * be reflected the next time the FileFollower's running thread sleeps.
     *
     * @param latency
     *            latency, in milliseconds
     */
    public void setLatency(int latency) {
        this.latency = latency;
    }

    protected int bufferSize;

    protected int latency;

    protected File file;

    protected List<OutputDestination> outputDestinations;

    protected boolean continueRunning;

    protected boolean needsRestart;

    protected Thread runnerThread;

    protected boolean paused;

    /**
     * Instances of this class are used to run a thread which follows a
     * FileFollower's file and sends prints its contents to OutputDestinations.
     * This class should only handle the gathering of data from the followed
     * file. Actually writing to the output destinations is handled by the outer
     * class (FileFollower).
     */
    class Runner implements Runnable {

        private Logger log = Logger.getLogger(Runner.class.getName());

        public void run() {
            log.finer(""entering FileFollower.run()"");
            while (continueRunning) {
                runAction();
            }
            log.finer(""exiting FileFollower.run()"");
        }

        protected void runAction() {
            try {
                clear();
                long fileSize = file.length();
                byte[] byteArray = new byte[bufferSize];
                int numBytesRead;
                long lastActivityTime = file.lastModified();
                // create some stream readers to handle the file
                FileInputStream fis = new FileInputStream(file);
                BufferedInputStream bis = new BufferedInputStream(fis);
                // start at the beginning of the file
                long startingPoint = 0;
                // if the file size is bigger than the buffer size, skip to the
                // end of the file if not performing a restart
                if (fileSize > bufferSize) {
                    startingPoint = fileSize - bufferSize;
                }
                // reset the restart flag
                needsRestart = false;
                log.finer(""Starting point: "" + startingPoint + ""; Last activity: "" + lastActivityTime);
                bis.skip(startingPoint);
                while (continueRunning && !needsRestart) {
                    if (!paused) {
                        lastActivityTime = System.currentTimeMillis();
                        numBytesRead = bis.read(byteArray, 0, byteArray.length);
                        boolean dataWasFound = (numBytesRead > 0);
                        log.finer(""Bytes read: "" + numBytesRead + ""; dataWasFound: "" + dataWasFound);
                        // if data was found, print it and log activity time
                        if (dataWasFound) {
                            String output = new String(byteArray, 0, numBytesRead);
                            // print the output to the listeners
                            print(output);
                        } else // no data found so check the file and restart if needed
                        {
                            // check if the file handle has become stale (file
                            // was modified, but no data was read).
                            boolean fileExists = file.exists();
                            // removed check for 0 length because a file could
                            // change by being cleared out
                            // && (file_.length() > 0);
                            boolean fileHasChanged = file.lastModified() > lastActivityTime;
                            if (fileExists && fileHasChanged) {
                                log.finer(""Needs restart [fileExists="" + fileExists + ""; fileHasChanged="" + fileHasChanged + ""]"");
                                needsRestart = true;
                            }
                        }
                        boolean allDataRead = (numBytesRead < byteArray.length);
                        if (allDataRead && !needsRestart) {
                            log.finer(""Sleeping for "" + latency + ""ms [allDataRead:"" + allDataRead + ""; needsRestart:"" + needsRestart + ""]"");
                            sleep();
                        }
                    } else {
                        log.finer(""Runner paused."");
                        sleep();
                    }
                }
                log.finer(""exiting Runner.runAction [continueRunning="" + continueRunning + ""; needsRestart="" + needsRestart + ""]"");
                bis.close();
                fis.close();
            } catch (IOException e) {
                log.log(Level.SEVERE, ""IOException while following file"", e);
            }
        }

        private void sleep() {
            try {
                Thread.sleep(latency);
            } catch (InterruptedException e) {
                // Interrupt may be thrown manually by stop()
                log.finer(""DIED IN MY SLEEP"");
            }
        }
    }

    /**
     * Line separator, retrieved from System properties & stored statically.
     */
    protected static final String lineSeparator = System.getProperty(""line.separator"");
}
","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains ten unit test cases for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {","// FileFollower_1Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollower}.
* It contains ten unit test cases for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.
*/
class FileFollower_1Test {

		private static final Logger LOG = Logger.getLogger(FileFollower_1Test.class.getName());
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_1() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_2() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_3() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_4() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_5() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_6() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_7() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_8() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_9() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
		/**
		* Test case for {@link FileFollower#removeOutputDestination(OutputDestination)}
		*
		* @throws IOException
		*/
		@Test
		void testRemoveOutputDestination_10() throws IOException {
				File file = new File(""test/ghm/follow/test.txt"");
				OutputDestination[] initialOutputDestinations = new OutputDestination[1];
				initialOutputDestinations[0] = new OutputDestination() {
						@Override
						public void print(String s) {
								LOG.info(s);
						}
						@Override
						public void clear() {
								LOG.info(""clear"");
						}
				};
				FileFollower fileFollower = new FileFollower(file, initialOutputDestinations);
				fileFollower.start();
				try {
						Thread.sleep(1000);
				} catch (InterruptedException e) {
						LOG.log(Level.SEVERE, ""InterruptedException while sleeping"", e);
				}
				fileFollower.stop();
				fileFollower.removeOutputDestination(initialOutputDestinations[0]);
				assertEquals(0, fileFollower.getOutputDestinations().size());
		}
		
}

// FileFollower_2Test.java
package ghm.follow;

import ghm.follow.io.OutputDestination;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging"
fb4b2391-0fce-493b-8645-239fd30c4548,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FollowApp_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11338 tokens (7338 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FollowApp.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    public static final String FILE_SEPARATOR = System.getProperty(""file.separator"");

    public static final String MESSAGE_LINE_SEPARATOR = ""\n"";

    public static final boolean DEBUG = Boolean.getBoolean(""follow.debug"");

    public static boolean HAS_SOLARIS_BUG = false;

    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());

    private int currentCursor = Cursor.DEFAULT_CURSOR;

    private Cursor defaultCursor;

    private Cursor waitCursor;

    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();

    private JTabbedPane tabbedPane;

    private ToolBar toolBar;

    private PopupMenu popupMenu;

    private Menu recentFilesMenu;

    private MouseListener rightClickListener;

    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();

    private SystemInterface systemInterface;

    private StartupStatus startupStatus;

    private FollowAppAttributes attributes;

    private static FollowApp instance;

    private static ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.FollowAppResourceBundle"");

    private JFrame frame;

    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.
    static {
        boolean isSolaris = ""SunOS"".equals(System.getProperty(""os.name""));
        if (isSolaris) {
            String version = System.getProperty(""java.version"");
            if ((version != null) && version.startsWith(""1."")) {
                String substring = version.substring(2, 3);
                try {
                    int minor = Integer.parseInt(substring);
                    if (minor < 4) {
                        HAS_SOLARIS_BUG = true;
                    }
                } catch (NumberFormatException nfe) {
                    // Nothing else to do.
                }
            }
        }
    }

    /**
     * @param fileNames
     *            names of files to be opened
     */
    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {
        this(fileNames, null);
    }

    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {
        // Create & show startup status window
        startupStatus = new StartupStatus(resources);
        centerWindowInScreen(startupStatus);
        startupStatus.pack();
        SwingUtilities.invokeAndWait(new Runnable() {

            public void run() {
                startupStatus.setVisible(true);
            }
        });
        // Ghastly workaround for bug in Font construction, in review by
        // Sun with review id 108683.
        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
        SwingUtilities.invokeAndWait(new Runnable() {

            public void run() {
                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);
            }
        });
        // create frame first. the close operation is handled in WindowTracker
        frame = new JFrame(getResourceString(""frame.title""));
        // load the attributes
        attributes = new FollowAppAttributes(propertyFile);
        // add listeners to update the recent files list
        RecentFileListener rfl = new RecentFileListener();
        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);
        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);
        // load the actions referenced in the application
        loadActions();
        // initialize SystemInterface
        systemInterface = new DefaultSystemInterface(this);
        // initialize menubar
        JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, getActions());
        // set the recent files menu to local variable so it can be updated
        // easily
        recentFilesMenu = ComponentBuilder.recentFilesMenu;
        // fake an event to get the menu setup initially
        rfl.propertyChange(null);
        // initialize popupMenu
        popupMenu = ComponentBuilder.buildPopupMenu(getActions());
        // initialize toolbar
        toolBar = ComponentBuilder.buildToolBar(getActions());
        // initialize tabbedPane, but wait to open files until after frame
        // initialization
        tabbedPane = new TabbedPane(attributes);
        enableDragAndDrop(tabbedPane);
        // initialize frame
        initFrame(jMenuBar);
        // This is an ugly hack. It seems like JFrame.setLocation() is buggy
        // on Solaris jdk versions before 1.4
        if (HAS_SOLARIS_BUG) {
            frame.setLocation(50, 50);
        } else {
            frame.setLocation(attributes.getX(), attributes.getY());
        }
        // track window close events. WindowTracker handles the close operation
        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));
        enableDragAndDrop(frame);
        // Open files from attributes; this is done after the frame is complete
        // and all components have been added to it to make sure that the frame
        // can be shown absolutely as soon as possible. If we put this code
        // before frame creation (as in v1.0), frame creation may take longer
        // because there are more threads (spawned in the course of open())
        // contending for processor time.
        List<File> files = attributes.getFollowedFiles();
        StringBuffer nonexistentFilesBuffer = null;
        int nonexistentFileCount = 0;
        for (File file : files) {
            try {
                openFile(file);
            } catch (FileNotFoundException e) {
                // This file has been deleted since the previous execution.
                // Remove it from the list of followed files
                attributes.removeFollowedFile(file);
                nonexistentFileCount++;
                if (nonexistentFilesBuffer == null) {
                    nonexistentFilesBuffer = new StringBuffer(file.getAbsolutePath());
                } else {
                    nonexistentFilesBuffer.append(file.getAbsolutePath());
                }
                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);
            }
        }
        // open files from the command line
        for (String filename : filenames) {
            try {
                openFile(new File(filename));
            } catch (FileNotFoundException e) {
                String msg = MessageFormat.format(getResourceString(""message.cmdLineFileNotFound.text""), new Object[] { filename });
                LOG.info(msg);
            }
        }
        if (nonexistentFileCount > 0) {
            // Alert the user of the fact that one or more files have been
            // deleted since the previous execution
            String text = getResourceString(""message.filesDeletedSinceLastExecution.text"");
            String message = MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });
            // String title =
            // getResourceString(""message.filesDeletedSinceLastExecution.title"");
            // JOptionPane.showMessageDialog(frame_, message, title,
            // JOptionPane.WARNING_MESSAGE);
            LOG.info(message);
        }
        int tabCount = tabbedPane.getTabCount();
        if (tabCount > 0) {
            if (tabCount > attributes.getSelectedTabIndex()) {
                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());
            } else {
                tabbedPane.setSelectedIndex(0);
            }
        }
    }

    /**
     * Close the current tab
     */
    public void closeFile() {
        FileFollowingPane fileFollowingPane = getSelectedFileFollowingPane();
        int tab = tabbedPane.getSelectedIndex();
        if (tab >= 0) {
            tabbedPane.removeTabAt(tab);
            disableDragAndDrop(fileFollowingPane.getTextPane());
            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());
            fileFollowingPane.stopFollowing();
            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());
        }
        updateActions();
    }

    /**
     * Get a string from the resource bundle. Convenience method to shorten and
     * centralize this common call
     *
     * @param key
     * @return The value of key in the resource bundle. null if the key is not
     *         found.
     */
    public static String getResourceString(String key) {
        String value = null;
        try {
            value = resources.getString(key);
        } catch (MissingResourceException mre) {
            LOG.warning(mre.getMessage());
        }
        return value;
    }

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz
     *            The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey
     *            The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {
        String filename = getResourceString(iconNameKey);
        URL url = clazz.getResource(filename);
        LOG.finer(""Class: "" + clazz + "", iconNameKey: "" + iconNameKey);
        LOG.finer(""filename: "" + filename);
        LOG.finer(""url: "" + url);
        ImageIcon icon = null;
        if (url != null) {
            icon = new ImageIcon(url);
            LOG.finer(""errored: "" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));
        }
        return icon;
    }

    /**
     * Loads the actions used in the application
     *
     * @throws IOException
     */
    private void loadActions() throws IOException {
        // initialize actions
        putAction(Open.NAME, new Open(this));
        putAction(Close.NAME, new Close(this));
        putAction(Edit.NAME, new Edit(this));
        putAction(Exit.NAME, new Exit(this));
        putAction(Top.NAME, new Top(this));
        putAction(Bottom.NAME, new Bottom(this));
        putAction(Clear.NAME, new Clear(this));
        putAction(ClearAll.NAME, new ClearAll(this));
        putAction(Delete.NAME, new Delete(this));
        putAction(DeleteAll.NAME, new DeleteAll(this));
        putAction(Configure.NAME, new Configure(this));
        putAction(About.NAME, new About(this));
        if (DEBUG) {
            putAction(Debug.NAME, new Debug(this));
        }
        putAction(Pause.NAME, new Pause(this));
        putAction(NextTab.NAME, new NextTab(this));
        putAction(PreviousTab.NAME, new PreviousTab(this));
        putAction(Find.NAME, new Find(this));
        putAction(ClearHighlights.NAME, new ClearHighlights(this));
        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));
        putAction(Reset.NAME, new Reset(this));
    }

    /**
     * @param jMenuBar
     */
    private void initFrame(JMenuBar jMenuBar) {
        frame.setJMenuBar(jMenuBar);
        frame.getContentPane().add(toolBar, BorderLayout.NORTH);
        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);
        frame.setSize(attributes.getWidth(), attributes.getHeight());
    }

    public void show() {
        frame.setVisible(true);
    }

    public FollowAppAction getAction(String name) {
        return actions.get(name);
    }

    /**
     * Get all actions associated to the application
     *
     * @return
     */
    public HashMap<String, FollowAppAction> getActions() {
        return actions;
    }

    /**
     * Set an action to the action map of the application.
     *
     * @param name
     *            The key to set the action to.
     * @param action
     *            The action to create an association for.
     */
    public void putAction(String name, FollowAppAction action) {
        if (FollowAppAction.ActionContext.APP == action.getContext())
            action.setEnabled(true);
        else
            action.setEnabled(false);
        actions.put(name, action);
    }

    public void openFile(File file) throws FileNotFoundException {
        openFile(file, attributes.autoScroll());
    }

    /**
     * Warning: This method should be called only from (1) the FollowApp
     * initializer (before any components are realized) or (2) from the event
     * dispatching thread.
     */
    void openFile(File file, boolean startFollowing) throws FileNotFoundException {
        if (file == null) {
            throw new FileNotFoundException(""file is null."");
        }
        if (!file.exists()) {
            throw new FileNotFoundException(file.getName() + "" not found."");
        }
        FileFollowingPane fileFollowingPane = (FileFollowingPane) fileToFollowingPaneMap.get(file);
        if (fileFollowingPane != null) {
            // File is already open; merely select its tab
            tabbedPane.setSelectedComponent(fileFollowingPane);
        } else {
            fileFollowingPane = new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());
            SearchableTextPane ffpTextPane = fileFollowingPane.getTextPane();
            enableDragAndDrop(ffpTextPane);
            fileFollowingPane.setSize(frame.getSize());
            ffpTextPane.setFont(attributes.getFont());
            ffpTextPane.addMouseListener(getRightClickListener());
            fileToFollowingPaneMap.put(file, fileFollowingPane);
            if (startFollowing) {
                fileFollowingPane.startFollowing();
            }
            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());
            int tabCount = tabbedPane.getTabCount();
            if (tabCount < 10) {
                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the
                // ascii characters 1-9 (49-57)
                int index = tabCount - 1;
                tabbedPane.setMnemonicAt(index, index + ((int) '1'));
            }
            tabbedPane.setSelectedIndex(tabCount - 1);
            // add a listener to set the pause icon correctly
            fileFollowingPane.addComponentListener(new ComponentAdapter() {

                public void componentShown(ComponentEvent e) {
                    FileFollowingPane ffp = (FileFollowingPane) e.getSource();
                    Pause pause = (Pause) getAction(Pause.NAME);
                    pause.setIconByState(ffp.isFollowingPaused());
                }
            });
            // add the file to history
            attributes.addFollowedFile(file);
            attributes.addRecentFile(file);
            updateActions();
        }
    }

    private void updateActions() {
        int tabCount = tabbedPane.getTabCount();
        for (FollowAppAction a : actions.values()) {
            if (tabCount <= 1 && a.getContext() == ActionContext.MULTI_FILE)
                a.setEnabled(false);
            else if (tabCount == 0 && a.getContext() == ActionContext.SINGLE_FILE)
                a.setEnabled(false);
            else
                a.setEnabled(true);
        }
    }

    /**
     * Warning: This method should be called only from the event dispatching
     * thread.
     *
     * @param cursorType
     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR
     */
    public void setCursor(int cursorType) {
        if (cursorType == currentCursor) {
            return;
        }
        switch(cursorType) {
            case Cursor.DEFAULT_CURSOR:
                if (defaultCursor == null) {
                    defaultCursor = Cursor.getDefaultCursor();
                }
                frame.setCursor(defaultCursor);
                break;
            case Cursor.WAIT_CURSOR:
                if (waitCursor == null) {
                    waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
                }
                frame.setCursor(waitCursor);
                break;
            default:
                throw new IllegalArgumentException(""Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR"");
        }
        currentCursor = cursorType;
    }

    // Lazy initializer for the right-click listener which invokes a popup menu
    private MouseListener getRightClickListener() {
        if (rightClickListener == null) {
            rightClickListener = new MouseAdapter() {

                public void mouseReleased(MouseEvent e) {
                    if (SwingUtilities.isRightMouseButton(e)) {
                        Component source = e.getComponent();
                        popupMenu.show(source, e.getX(), e.getY());
                    }
                }
            };
        }
        return rightClickListener;
    }

    public void enableDragAndDrop(Component c) {
        // Invoking this constructor automatically sets the component's drop
        // target
        new DropTarget(c, new DndFileOpener(this));
    }

    public void disableDragAndDrop(Component c) {
        c.setDropTarget(null);
    }

    public FileFollowingPane getSelectedFileFollowingPane() {
        return (FileFollowingPane) tabbedPane.getSelectedComponent();
    }

    public List<FileFollowingPane> getAllFileFollowingPanes() {
        int tabCount = tabbedPane.getTabCount();
        List<FileFollowingPane> allFileFollowingPanes = new ArrayList<FileFollowingPane>();
        for (int i = 0; i < tabCount; i++) {
            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));
        }
        return allFileFollowingPanes;
    }

    public FollowAppAttributes getAttributes() {
        return attributes;
    }

    public Map<File, FileFollowingPane> getFileToFollowingPaneMap() {
        return fileToFollowingPaneMap;
    }

    public JFrame getFrame() {
        return frame;
    }

    public static FollowApp getInstance() {
        return instance;
    }

    public SystemInterface getSystemInterface() {
        return systemInterface;
    }

    public void setSystemInterface(SystemInterface systemInterface) {
        this.systemInterface = systemInterface;
    }

    public JTabbedPane getTabbedPane() {
        return tabbedPane;
    }

    public static void centerWindowInScreen(Window window) {
        Dimension screenSize = window.getToolkit().getScreenSize();
        Dimension windowSize = window.getPreferredSize();
        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));
    }

    /**
     * Invoke this method to start the Follow application. If any command-line
     * arguments are passed in, they are assume to be filenames and are opened
     * in the Follow application
     *
     * @param args
     *            files to be opened
     */
    public static void main(String[] args) {
        try {
            ArrayList<String> fileNames = new ArrayList<String>();
            File propFile = null;
            for (int i = 0; i < args.length; i++) {
                if (args[i].startsWith(""-"")) {
                    if (""-propFile"".equalsIgnoreCase(args[i])) {
                        propFile = new File(args[++i]);
                    }
                } else {
                    fileNames.add(args[i]);
                }
            }
            instance = new FollowApp(fileNames, propFile);
            SwingUtilities.invokeAndWait(new Runnable() {

                public void run() {
                    // ensure all widgets inited before opening files
                    instance.show();
                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);
                }
            });
            instance.startupStatus.dispose();
            // commented code below so that windows follow based on setting in
            // preferences which is set on the pane when the file is opened
            // for (int i=0; i < instance_.tabbedPane_.getTabCount(); i++) {
            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();
            // }
        } catch (Throwable t) {
            LOG.log(Level.SEVERE, ""Unhandled exception"", t);
            System.exit(-1);
        }
    }

    private class RecentFileListener implements PropertyChangeListener {

        public void propertyChange(PropertyChangeEvent evt) {
            if (recentFilesMenu != null) {
                recentFilesMenu.removeAll();
                List<File> recentFiles = attributes.getRecentFiles();
                // descend down the list to order files by last opened
                for (int i = recentFiles.size() - 1; i >= 0; i--) {
                    // have to use FollowApp.this because 'this' is now the
                    // context of
                    // the inner class
                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));
                }
            }
        }
    }
}
","// FollowApp_0Test.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains ten unit test cases for the {@link FollowApp#getResourceString(String)} method.
*/
class FollowApp_0Test {","// FollowApp_0Test.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains ten unit test cases for the {@link FollowApp#getResourceString(String)} method.
*/
class FollowApp_0Test {
"
06396276-0ba9-4e8d-b96a-a4ee63d4ba82,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FollowApp_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11339 tokens (7339 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FollowApp.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class' main() method is the entry point into the Follow application.
 *
 * @see #main(String[])
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowApp {

    public static final String FILE_SEPARATOR = System.getProperty(""file.separator"");

    public static final String MESSAGE_LINE_SEPARATOR = ""\n"";

    public static final boolean DEBUG = Boolean.getBoolean(""follow.debug"");

    public static boolean HAS_SOLARIS_BUG = false;

    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());

    private int currentCursor = Cursor.DEFAULT_CURSOR;

    private Cursor defaultCursor;

    private Cursor waitCursor;

    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();

    private JTabbedPane tabbedPane;

    private ToolBar toolBar;

    private PopupMenu popupMenu;

    private Menu recentFilesMenu;

    private MouseListener rightClickListener;

    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();

    private SystemInterface systemInterface;

    private StartupStatus startupStatus;

    private FollowAppAttributes attributes;

    private static FollowApp instance;

    private static ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.FollowAppResourceBundle"");

    private JFrame frame;

    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.
    static {
        boolean isSolaris = ""SunOS"".equals(System.getProperty(""os.name""));
        if (isSolaris) {
            String version = System.getProperty(""java.version"");
            if ((version != null) && version.startsWith(""1."")) {
                String substring = version.substring(2, 3);
                try {
                    int minor = Integer.parseInt(substring);
                    if (minor < 4) {
                        HAS_SOLARIS_BUG = true;
                    }
                } catch (NumberFormatException nfe) {
                    // Nothing else to do.
                }
            }
        }
    }

    /**
     * @param fileNames
     *            names of files to be opened
     */
    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {
        this(fileNames, null);
    }

    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {
        // Create & show startup status window
        startupStatus = new StartupStatus(resources);
        centerWindowInScreen(startupStatus);
        startupStatus.pack();
        SwingUtilities.invokeAndWait(new Runnable() {

            public void run() {
                startupStatus.setVisible(true);
            }
        });
        // Ghastly workaround for bug in Font construction, in review by
        // Sun with review id 108683.
        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
        SwingUtilities.invokeAndWait(new Runnable() {

            public void run() {
                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);
            }
        });
        // create frame first. the close operation is handled in WindowTracker
        frame = new JFrame(getResourceString(""frame.title""));
        // load the attributes
        attributes = new FollowAppAttributes(propertyFile);
        // add listeners to update the recent files list
        RecentFileListener rfl = new RecentFileListener();
        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);
        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);
        // load the actions referenced in the application
        loadActions();
        // initialize SystemInterface
        systemInterface = new DefaultSystemInterface(this);
        // initialize menubar
        JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, getActions());
        // set the recent files menu to local variable so it can be updated
        // easily
        recentFilesMenu = ComponentBuilder.recentFilesMenu;
        // fake an event to get the menu setup initially
        rfl.propertyChange(null);
        // initialize popupMenu
        popupMenu = ComponentBuilder.buildPopupMenu(getActions());
        // initialize toolbar
        toolBar = ComponentBuilder.buildToolBar(getActions());
        // initialize tabbedPane, but wait to open files until after frame
        // initialization
        tabbedPane = new TabbedPane(attributes);
        enableDragAndDrop(tabbedPane);
        // initialize frame
        initFrame(jMenuBar);
        // This is an ugly hack. It seems like JFrame.setLocation() is buggy
        // on Solaris jdk versions before 1.4
        if (HAS_SOLARIS_BUG) {
            frame.setLocation(50, 50);
        } else {
            frame.setLocation(attributes.getX(), attributes.getY());
        }
        // track window close events. WindowTracker handles the close operation
        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));
        enableDragAndDrop(frame);
        // Open files from attributes; this is done after the frame is complete
        // and all components have been added to it to make sure that the frame
        // can be shown absolutely as soon as possible. If we put this code
        // before frame creation (as in v1.0), frame creation may take longer
        // because there are more threads (spawned in the course of open())
        // contending for processor time.
        List<File> files = attributes.getFollowedFiles();
        StringBuffer nonexistentFilesBuffer = null;
        int nonexistentFileCount = 0;
        for (File file : files) {
            try {
                openFile(file);
            } catch (FileNotFoundException e) {
                // This file has been deleted since the previous execution.
                // Remove it from the list of followed files
                attributes.removeFollowedFile(file);
                nonexistentFileCount++;
                if (nonexistentFilesBuffer == null) {
                    nonexistentFilesBuffer = new StringBuffer(file.getAbsolutePath());
                } else {
                    nonexistentFilesBuffer.append(file.getAbsolutePath());
                }
                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);
            }
        }
        // open files from the command line
        for (String filename : filenames) {
            try {
                openFile(new File(filename));
            } catch (FileNotFoundException e) {
                String msg = MessageFormat.format(getResourceString(""message.cmdLineFileNotFound.text""), new Object[] { filename });
                LOG.info(msg);
            }
        }
        if (nonexistentFileCount > 0) {
            // Alert the user of the fact that one or more files have been
            // deleted since the previous execution
            String text = getResourceString(""message.filesDeletedSinceLastExecution.text"");
            String message = MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });
            // String title =
            // getResourceString(""message.filesDeletedSinceLastExecution.title"");
            // JOptionPane.showMessageDialog(frame_, message, title,
            // JOptionPane.WARNING_MESSAGE);
            LOG.info(message);
        }
        int tabCount = tabbedPane.getTabCount();
        if (tabCount > 0) {
            if (tabCount > attributes.getSelectedTabIndex()) {
                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());
            } else {
                tabbedPane.setSelectedIndex(0);
            }
        }
    }

    /**
     * Close the current tab
     */
    public void closeFile() {
        FileFollowingPane fileFollowingPane = getSelectedFileFollowingPane();
        int tab = tabbedPane.getSelectedIndex();
        if (tab >= 0) {
            tabbedPane.removeTabAt(tab);
            disableDragAndDrop(fileFollowingPane.getTextPane());
            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());
            fileFollowingPane.stopFollowing();
            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());
        }
        updateActions();
    }

    /**
     * Get a string from the resource bundle. Convenience method to shorten and
     * centralize this common call
     *
     * @param key
     * @return The value of key in the resource bundle. null if the key is not
     *         found.
     */
    public static String getResourceString(String key) {
        String value = null;
        try {
            value = resources.getString(key);
        } catch (MissingResourceException mre) {
            LOG.warning(mre.getMessage());
        }
        return value;
    }

    /**
     * Gets an image icon from the resource path.
     *
     * @param clazz
     *            The class to use as an entry point to the resource path. Image
     *            path should be relative to this class.
     * @param iconNameKey
     *            The resource key name where the image is defined.
     * @return An image icon based on the URL generated from the value of
     *         iconNameKey. null if no URL can be found.
     */
    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {
        String filename = getResourceString(iconNameKey);
        URL url = clazz.getResource(filename);
        LOG.finer(""Class: "" + clazz + "", iconNameKey: "" + iconNameKey);
        LOG.finer(""filename: "" + filename);
        LOG.finer(""url: "" + url);
        ImageIcon icon = null;
        if (url != null) {
            icon = new ImageIcon(url);
            LOG.finer(""errored: "" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));
        }
        return icon;
    }

    /**
     * Loads the actions used in the application
     *
     * @throws IOException
     */
    private void loadActions() throws IOException {
        // initialize actions
        putAction(Open.NAME, new Open(this));
        putAction(Close.NAME, new Close(this));
        putAction(Edit.NAME, new Edit(this));
        putAction(Exit.NAME, new Exit(this));
        putAction(Top.NAME, new Top(this));
        putAction(Bottom.NAME, new Bottom(this));
        putAction(Clear.NAME, new Clear(this));
        putAction(ClearAll.NAME, new ClearAll(this));
        putAction(Delete.NAME, new Delete(this));
        putAction(DeleteAll.NAME, new DeleteAll(this));
        putAction(Configure.NAME, new Configure(this));
        putAction(About.NAME, new About(this));
        if (DEBUG) {
            putAction(Debug.NAME, new Debug(this));
        }
        putAction(Pause.NAME, new Pause(this));
        putAction(NextTab.NAME, new NextTab(this));
        putAction(PreviousTab.NAME, new PreviousTab(this));
        putAction(Find.NAME, new Find(this));
        putAction(ClearHighlights.NAME, new ClearHighlights(this));
        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));
        putAction(Reset.NAME, new Reset(this));
    }

    /**
     * @param jMenuBar
     */
    private void initFrame(JMenuBar jMenuBar) {
        frame.setJMenuBar(jMenuBar);
        frame.getContentPane().add(toolBar, BorderLayout.NORTH);
        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);
        frame.setSize(attributes.getWidth(), attributes.getHeight());
    }

    public void show() {
        frame.setVisible(true);
    }

    public FollowAppAction getAction(String name) {
        return actions.get(name);
    }

    /**
     * Get all actions associated to the application
     *
     * @return
     */
    public HashMap<String, FollowAppAction> getActions() {
        return actions;
    }

    /**
     * Set an action to the action map of the application.
     *
     * @param name
     *            The key to set the action to.
     * @param action
     *            The action to create an association for.
     */
    public void putAction(String name, FollowAppAction action) {
        if (FollowAppAction.ActionContext.APP == action.getContext())
            action.setEnabled(true);
        else
            action.setEnabled(false);
        actions.put(name, action);
    }

    public void openFile(File file) throws FileNotFoundException {
        openFile(file, attributes.autoScroll());
    }

    /**
     * Warning: This method should be called only from (1) the FollowApp
     * initializer (before any components are realized) or (2) from the event
     * dispatching thread.
     */
    void openFile(File file, boolean startFollowing) throws FileNotFoundException {
        if (file == null) {
            throw new FileNotFoundException(""file is null."");
        }
        if (!file.exists()) {
            throw new FileNotFoundException(file.getName() + "" not found."");
        }
        FileFollowingPane fileFollowingPane = (FileFollowingPane) fileToFollowingPaneMap.get(file);
        if (fileFollowingPane != null) {
            // File is already open; merely select its tab
            tabbedPane.setSelectedComponent(fileFollowingPane);
        } else {
            fileFollowingPane = new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());
            SearchableTextPane ffpTextPane = fileFollowingPane.getTextPane();
            enableDragAndDrop(ffpTextPane);
            fileFollowingPane.setSize(frame.getSize());
            ffpTextPane.setFont(attributes.getFont());
            ffpTextPane.addMouseListener(getRightClickListener());
            fileToFollowingPaneMap.put(file, fileFollowingPane);
            if (startFollowing) {
                fileFollowingPane.startFollowing();
            }
            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());
            int tabCount = tabbedPane.getTabCount();
            if (tabCount < 10) {
                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the
                // ascii characters 1-9 (49-57)
                int index = tabCount - 1;
                tabbedPane.setMnemonicAt(index, index + ((int) '1'));
            }
            tabbedPane.setSelectedIndex(tabCount - 1);
            // add a listener to set the pause icon correctly
            fileFollowingPane.addComponentListener(new ComponentAdapter() {

                public void componentShown(ComponentEvent e) {
                    FileFollowingPane ffp = (FileFollowingPane) e.getSource();
                    Pause pause = (Pause) getAction(Pause.NAME);
                    pause.setIconByState(ffp.isFollowingPaused());
                }
            });
            // add the file to history
            attributes.addFollowedFile(file);
            attributes.addRecentFile(file);
            updateActions();
        }
    }

    private void updateActions() {
        int tabCount = tabbedPane.getTabCount();
        for (FollowAppAction a : actions.values()) {
            if (tabCount <= 1 && a.getContext() == ActionContext.MULTI_FILE)
                a.setEnabled(false);
            else if (tabCount == 0 && a.getContext() == ActionContext.SINGLE_FILE)
                a.setEnabled(false);
            else
                a.setEnabled(true);
        }
    }

    /**
     * Warning: This method should be called only from the event dispatching
     * thread.
     *
     * @param cursorType
     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR
     */
    public void setCursor(int cursorType) {
        if (cursorType == currentCursor) {
            return;
        }
        switch(cursorType) {
            case Cursor.DEFAULT_CURSOR:
                if (defaultCursor == null) {
                    defaultCursor = Cursor.getDefaultCursor();
                }
                frame.setCursor(defaultCursor);
                break;
            case Cursor.WAIT_CURSOR:
                if (waitCursor == null) {
                    waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
                }
                frame.setCursor(waitCursor);
                break;
            default:
                throw new IllegalArgumentException(""Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR"");
        }
        currentCursor = cursorType;
    }

    // Lazy initializer for the right-click listener which invokes a popup menu
    private MouseListener getRightClickListener() {
        if (rightClickListener == null) {
            rightClickListener = new MouseAdapter() {

                public void mouseReleased(MouseEvent e) {
                    if (SwingUtilities.isRightMouseButton(e)) {
                        Component source = e.getComponent();
                        popupMenu.show(source, e.getX(), e.getY());
                    }
                }
            };
        }
        return rightClickListener;
    }

    public void enableDragAndDrop(Component c) {
        // Invoking this constructor automatically sets the component's drop
        // target
        new DropTarget(c, new DndFileOpener(this));
    }

    public void disableDragAndDrop(Component c) {
        c.setDropTarget(null);
    }

    public FileFollowingPane getSelectedFileFollowingPane() {
        return (FileFollowingPane) tabbedPane.getSelectedComponent();
    }

    public List<FileFollowingPane> getAllFileFollowingPanes() {
        int tabCount = tabbedPane.getTabCount();
        List<FileFollowingPane> allFileFollowingPanes = new ArrayList<FileFollowingPane>();
        for (int i = 0; i < tabCount; i++) {
            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));
        }
        return allFileFollowingPanes;
    }

    public FollowAppAttributes getAttributes() {
        return attributes;
    }

    public Map<File, FileFollowingPane> getFileToFollowingPaneMap() {
        return fileToFollowingPaneMap;
    }

    public JFrame getFrame() {
        return frame;
    }

    public static FollowApp getInstance() {
        return instance;
    }

    public SystemInterface getSystemInterface() {
        return systemInterface;
    }

    public void setSystemInterface(SystemInterface systemInterface) {
        this.systemInterface = systemInterface;
    }

    public JTabbedPane getTabbedPane() {
        return tabbedPane;
    }

    public static void centerWindowInScreen(Window window) {
        Dimension screenSize = window.getToolkit().getScreenSize();
        Dimension windowSize = window.getPreferredSize();
        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));
    }

    /**
     * Invoke this method to start the Follow application. If any command-line
     * arguments are passed in, they are assume to be filenames and are opened
     * in the Follow application
     *
     * @param args
     *            files to be opened
     */
    public static void main(String[] args) {
        try {
            ArrayList<String> fileNames = new ArrayList<String>();
            File propFile = null;
            for (int i = 0; i < args.length; i++) {
                if (args[i].startsWith(""-"")) {
                    if (""-propFile"".equalsIgnoreCase(args[i])) {
                        propFile = new File(args[++i]);
                    }
                } else {
                    fileNames.add(args[i]);
                }
            }
            instance = new FollowApp(fileNames, propFile);
            SwingUtilities.invokeAndWait(new Runnable() {

                public void run() {
                    // ensure all widgets inited before opening files
                    instance.show();
                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);
                }
            });
            instance.startupStatus.dispose();
            // commented code below so that windows follow based on setting in
            // preferences which is set on the pane when the file is opened
            // for (int i=0; i < instance_.tabbedPane_.getTabCount(); i++) {
            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();
            // }
        } catch (Throwable t) {
            LOG.log(Level.SEVERE, ""Unhandled exception"", t);
            System.exit(-1);
        }
    }

    private class RecentFileListener implements PropertyChangeListener {

        public void propertyChange(PropertyChangeEvent evt) {
            if (recentFilesMenu != null) {
                recentFilesMenu.removeAll();
                List<File> recentFiles = attributes.getRecentFiles();
                // descend down the list to order files by last opened
                for (int i = recentFiles.size() - 1; i >= 0; i--) {
                    // have to use FollowApp.this because 'this' is now the
                    // context of
                    // the inner class
                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));
                }
            }
        }
    }
}
","// FollowApp_1Test.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains ten unit test cases for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowApp_1Test {","// FollowApp_1Test.java
package ghm.follow;

import ghm.follow.config.Configure;
import ghm.follow.config.FollowAppAttributes;
import ghm.follow.event.WindowTracker;
import ghm.follow.gui.About;
import ghm.follow.gui.Clear;
import ghm.follow.gui.ClearAll;
import ghm.follow.gui.Close;
import ghm.follow.gui.Debug;
import ghm.follow.gui.Delete;
import ghm.follow.gui.DeleteAll;
import ghm.follow.gui.DndFileOpener;
import ghm.follow.gui.Edit;
import ghm.follow.gui.Exit;
import ghm.follow.gui.FileFollowingPane;
import ghm.follow.gui.FollowAppAction;
import ghm.follow.gui.Menu;
import ghm.follow.gui.ComponentBuilder;
import ghm.follow.gui.Open;
import ghm.follow.gui.Pause;
import ghm.follow.gui.PopupMenu;
import ghm.follow.gui.Reset;
import ghm.follow.gui.StartupStatus;
import ghm.follow.gui.TabbedPane;
import ghm.follow.gui.ToolBar;
import ghm.follow.gui.FollowAppAction.ActionContext;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import ghm.follow.search.SearchableTextPane;
import ghm.follow.systemInterface.DefaultSystemInterface;
import ghm.follow.systemInterface.SystemInterface;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Window;
import java.awt.dnd.DropTarget;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowApp}.
* It contains ten unit test cases for the {@link FollowApp#getIcon(Class, String)} method.
*/
class FollowApp_1Test {
"
cmpl-6tsAi5QPWYvN6F0Oz1qIeVvWrtpCq,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java,35.22181844711304,stop,"// EnumeratedProperties.java
/* 
Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)

This file is part of Follow (http://follow.sf.net).

Follow is free software; you can redistribute it and/or modify
it under the terms of version 2 of the GNU General Public
License as published by the Free Software Foundation.

Follow is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Follow; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Extension of {@link java.util.Properties} which allows one to specify property values which are
 * Lists of Strings.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class EnumeratedProperties extends Properties {

    /**
     * Returns the List value of the property with the supplied key. Note that one can call
     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()
     * for that key was called some time beforehand. All members of the list returned will be
     * Strings.
     *
     * @param key
     *            lookup of the enumerated property to be retrieved.
     * @return list containing String values
     */
    public List<String> getEnumeratedProperty(String key) {
        ArrayList<String> values = new ArrayList<String>();
        int i = 0;
        String value;
        while ((value = this.getProperty(key + delimiter + i++)) != null) {
            values.add(value);
        }
        return values;
    }

    /**
     * Assigns the supplied array of String values to the supplied key.
     *
     * @param key
     *            property lookup
     * @param values
     *            values to be associated with the property lookup
     */
    public void setEnumeratedProperty(String key, List<String> values) {
        int i = 0;
        for (; i < values.size(); i++) {
            setProperty(key + delimiter + i, values.get(i));
        }
        while (getProperty(key + delimiter + i) != null) {
            remove(key + delimiter + i);
            i++;
        }
    }

    /**
     * Delimiter between property name & list member index
     */
    protected static char delimiter = '.';
}
","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains ten unit test cases for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {","// EnumeratedPropertiesTest.java
package ghm.follow.config;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EnumeratedProperties}.
* It contains ten unit test cases for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
*/
class EnumeratedPropertiesTest {

	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is not set.
	*/
	@Test
	void testGetEnumeratedProperty_NotSet() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set.
	*/
	@Test
	void testGetEnumeratedProperty_Set() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with one value.
	*/
	@Test
	void testGetEnumeratedProperty_SetOneValue() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with two values.
	*/
	@Test
	void testGetEnumeratedProperty_SetTwoValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with three values.
	*/
	@Test
	void testGetEnumeratedProperty_SetThreeValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with four values.
	*/
	@Test
	void testGetEnumeratedProperty_SetFourValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with five values.
	*/
	@Test
	void testGetEnumeratedProperty_SetFiveValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with six values.
	*/
	@Test
	void testGetEnumeratedProperty_SetSixValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		expected.add(""test6"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with seven values.
	*/
	@Test
	void testGetEnumeratedProperty_SetSevenValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		expected.add(""test6"");
		expected.add(""test7"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with eight values.
	*/
	@Test
	void testGetEnumeratedProperty_SetEightValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		expected.add(""test6"");
		expected.add(""test7"");
		expected.add(""test8"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with nine values.
	*/
	@Test
	void testGetEnumeratedProperty_SetNineValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		expected.add(""test6"");
		expected.add(""test7"");
		expected.add(""test8"");
		expected.add(""test9"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
	
	/**
	* Test case for {@link EnumeratedProperties#getEnumeratedProperty(String)} method.
	* It tests the case when the property is set with ten values.
	*/
	@Test
	void testGetEnumeratedProperty_SetTenValues() {
		EnumeratedProperties properties = new EnumeratedProperties();
		List<String> expected = new ArrayList<String>();
		expected.add(""test1"");
		expected.add(""test2"");
		expected.add(""test3"");
		expected.add(""test4"");
		expected.add(""test5"");
		expected.add(""test6"");
		expected.add(""test7"");
		expected.add(""test8"");
		expected.add(""test9"");
		expected.add(""test10"");
		properties.setEnumeratedProperty(""test"", expected);
		List<String> actual = properties.getEnumeratedProperty(""test"");
		assertEquals(expected, actual);
	}
}"
684c3f4c-02ae-446a-bd8b-58423769a9b2,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributes_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9878 tokens (5878 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FollowAppAttributes.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;

/**
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowAppAttributes {

    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());

    EnumeratedProperties properties;

    private EnumeratedProperties defaultProperties;

    private FollowAppAttributes defaultAttributes;

    static final String userHome = System.getProperty(""user.home"");

    public static final String PROPERTY_FILE_NAME = "".followApp.properties"";

    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;

    private File propertyFile;

    public static final String PROPERTY_PROTOTYPE_FILE_NAME = ""followApp.properties.prototype"";

    public static final int BUFFER_SIZE = 32768;

    public static final String HEIGHT_KEY = ""height"";

    public static final String WIDTH_KEY = ""width"";

    public static final String X_KEY = ""x"";

    public static final String Y_KEY = ""y"";

    public static final String FOLLOWED_FILES_KEY = ""followedFiles"";

    public static final String TAB_PLACEMENT_KEY = ""tabs.placement"";

    public static final String SELECTED_TAB_INDEX_KEY = ""tabs.selectedIndex"";

    public static final String LAST_FILE_CHOOSER_DIR_KEY = ""fileChooser.lastDir"";

    public static final String BUFFER_SIZE_KEY = ""bufferSize"";

    public static final String LATENCY_KEY = ""latency"";

    public static final String ATTRIBUTES_VERSION_KEY = ""attributesVersion"";

    public static final String FONT_FAMILY_KEY = ""fontFamily"";

    public static final String FONT_STYLE_KEY = ""fontStyle"";

    public static final String FONT_SIZE_KEY = ""fontSize"";

    public static final String CONFIRM_DELETE_KEY = ""confirmDelete"";

    public static final String CONFIRM_DELETE_ALL_KEY = ""confirmDeleteAll"";

    public static final String AUTO_SCROLL_KEY = ""autoScroll"";

    public static final String EDITOR_KEY = ""editor"";

    public static final String TAB_SIZE_KEY = ""tabSize"";

    public static final String RECENT_FILES_MAX_KEY = ""recentFilesMax"";

    public static final String RECENT_FILES_KEY = ""recentFiles"";

    // Versions
    public static final int UNVERSIONED = 0;

    public static final int v1_1 = 1;

    public static final int v1_2 = 2;

    public static final int v1_3 = 3;

    public static final int v1_3_2 = 4;

    public static final int v1_4 = 5;

    public static final int v1_5_0 = 6;

    public static final int v1_6_0 = 7;

    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);

    public FollowAppAttributes() throws IOException {
        // have to cast null so that the constructor call isn't ambiguous
        this((File) null);
    }

    public FollowAppAttributes(File exitingPropertyFile) throws IOException {
        if (exitingPropertyFile != null) {
            propertyFile = exitingPropertyFile;
        } else {
            propertyFile = new File(defaultPropertyFileName);
        }
        if (!(propertyFile.exists())) {
            // If the property file doesn't exist, we create a default property
            // file using a prototype property file stored somewhere on the
            // classpath
            log.info(""No property file for the Follow application is present; creating "" + propertyFile.getAbsolutePath() + "" (with default values) ..."");
            properties = (EnumeratedProperties) getDefaultProperties().clone();
            log.info(""... property file created successfully."");
        } else {
            properties = new EnumeratedProperties();
            FileInputStream fis = new FileInputStream(propertyFile);
            properties.load(fis);
            switch(getAttributesVersion()) {
                case UNVERSIONED:
                    // Migrate unversioned attributes to 1.1 attributes
                    log.info(""Migrating pre-v1.1 properties to v1.1."");
                    setAttributesVersion(v1_1);
                    setTabPlacement(getDefaultAttributes().getTabPlacement());
                case v1_1:
                    // Migrate 1.1 attributes to 1.2 attributes
                    log.info(""Migrating v1.1 properties to v1.2."");
                    setAttributesVersion(v1_2);
                    setFont(getDefaultAttributes().getFont());
                case v1_2:
                    // Migrate 1.2 attributes to 1.3 attributes
                    log.info(""Migrating v1.2 properties to v1.3."");
                    setAttributesVersion(v1_3);
                    setConfirmDelete(true);
                    setConfirmDeleteAll(true);
                    // Additionally, it is necessary to warn the user about the
                    // changes to
                    // Clear and ClearAll and the introduction of Delete and
                    // DeleteAll
                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(""v1.3.warning.text""), FollowApp.getResourceString(""v1.3.warning.title""), JOptionPane.WARNING_MESSAGE);
                case v1_3:
                case v1_3_2:
                    // Migrate 1.3 attributes to 1.4 attributes
                    log.info(""Migrating v1.3 properties to v1.4."");
                    setAttributesVersion(v1_4);
                    setAutoScroll(true);
                    // Inform the user of the new AutoScroll feature
                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(""v1.4.info.text""), FollowApp.getResourceString(""v1.4.info.title""), JOptionPane.INFORMATION_MESSAGE);
                case v1_4:
                    // Migrate 1.4 attributes to 1.5 attributes
                    log.info(""Migrating v1.4 properties to v.1.5."");
                    setAttributesVersion(v1_5_0);
                    setTabSize(4);
                case v1_5_0:
                    // Migrate 1.5.0 attributes to 1.6.0 attributes
                    log.info(""Migrating v1.5 properties to 1.6.0."");
                    setAttributesVersion(v1_6_0);
                    setRecentFilesMax(5);
            }
            fis.close();
        }
    }

    private FollowAppAttributes(EnumeratedProperties props) throws IOException {
        properties = props;
    }

    public int getHeight() {
        return getInt(HEIGHT_KEY);
    }

    public void setHeight(int height) {
        setInt(HEIGHT_KEY, height);
    }

    public int getWidth() {
        return getInt(WIDTH_KEY);
    }

    public void setWidth(int width) {
        setInt(WIDTH_KEY, width);
    }

    public int getX() {
        return getInt(X_KEY);
    }

    public void setX(int x) {
        setInt(X_KEY, x);
    }

    public int getY() {
        return getInt(Y_KEY);
    }

    public void setY(int y) {
        setInt(Y_KEY, y);
    }

    /**
     * Get an array files being followed
     *
     * @return File[] File array of followed files
     */
    public List<File> getFollowedFiles() {
        return getFiles(getFollowedFilesList());
    }

    /**
     * Get a list of files being followed
     *
     * @return List file names as Strings
     */
    private List<String> getFollowedFilesList() {
        return getEnumeratedProperty(FOLLOWED_FILES_KEY);
    }

    protected List<File> getFiles(List<String> fileList) {
        ArrayList<File> files = new ArrayList<File>(fileList.size());
        for (String s : fileList) {
            files.add(new File(s));
        }
        return files;
    }

    /**
     * Checks the existence of a file in the list of followed files
     *
     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same
     *         Canonical Path as the supplied File
     */
    public boolean followedFileListContains(File file) {
        return fileListContains(getFollowedFilesList(), file);
    }

    /**
     * Checks the existence of a file in the list of recent files
     *
     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same
     *         Canonical Path as the supplied File
     */
    public boolean recentFileListContains(File file) {
        return fileListContains(getRecentFilesList(), file);
    }

    /**
     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical
     *         Path as the supplied File
     */
    protected boolean fileListContains(List<String> fileList, File file) {
        boolean retval = false;
        if (fileList != null && file != null) {
            for (int i = 0; i < fileList.size(); i++) {
                String nextFile = (String) fileList.get(i);
                // be sure to check the same thing that is added in
                // addFollowedFile(File)
                if (nextFile.equals(file.getAbsolutePath())) {
                    retval = true;
                    break;
                }
            }
        }
        return retval;
    }

    /**
     * Adds a file to the list of followed files
     *
     * @param file
     */
    public void addFollowedFile(File file) {
        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);
        if (!fileListContains(fileNames, file)) {
            fileNames.add(file.getAbsolutePath());
            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);
        }
    }

    /**
     * Removes a file from the list of followed files
     *
     * @param file
     */
    public void removeFollowedFile(File file) {
        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);
        fileNames.remove(file.getAbsolutePath());
        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);
    }

    public int getTabPlacement() {
        return getInt(TAB_PLACEMENT_KEY);
    }

    public void setTabPlacement(int tabPlacement) {
        setInt(TAB_PLACEMENT_KEY, tabPlacement);
    }

    public int getTabSize() {
        return getInt(TAB_SIZE_KEY);
    }

    public void setTabSize(int tabSize) {
        setInt(TAB_SIZE_KEY, tabSize);
    }

    public void setTabSize(String tabSize) {
        setTabSize(Integer.parseInt(tabSize));
    }

    public int getSelectedTabIndex() {
        try {
            return getInt(SELECTED_TAB_INDEX_KEY);
        } catch (NumberFormatException e) {
            setSelectedTabIndex(0);
            return 0;
        }
    }

    public void setSelectedTabIndex(int selectedTabIndex) {
        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);
    }

    public File getLastFileChooserDirectory() {
        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));
    }

    public void setLastFileChooserDirectory(File file) {
        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());
    }

    public int getBufferSize() {
        return getInt(BUFFER_SIZE_KEY);
    }

    public void setBufferSize(int bufferSize) {
        setInt(BUFFER_SIZE_KEY, bufferSize);
    }

    public void setBufferSize(String bufferSize) {
        setBufferSize(Integer.parseInt(bufferSize));
    }

    public int getLatency() {
        return getInt(LATENCY_KEY);
    }

    public void setLatency(int latency) {
        setInt(LATENCY_KEY, latency);
    }

    public void setLatency(String latency) {
        setLatency(Integer.parseInt(latency));
    }

    public int getAttributesVersion() {
        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {
            // Supporting v1.0 & v1.0.1, which had no notion of attributes
            // version
            return UNVERSIONED;
        } else {
            return getInt(ATTRIBUTES_VERSION_KEY);
        }
    }

    public void setAttributesVersion(int attributesVersion) {
        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);
    }

    public Font getFont() {
        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));
        return font;
    }

    public void setFont(Font font) {
        setString(FONT_FAMILY_KEY, font.getFontName());
        setInt(FONT_STYLE_KEY, font.getStyle());
        setInt(FONT_SIZE_KEY, font.getSize());
    }

    public boolean confirmDelete() {
        return getBoolean(CONFIRM_DELETE_KEY);
    }

    public void setConfirmDelete(boolean value) {
        setBoolean(CONFIRM_DELETE_KEY, value);
    }

    public boolean confirmDeleteAll() {
        return getBoolean(CONFIRM_DELETE_ALL_KEY);
    }

    public void setConfirmDeleteAll(boolean value) {
        setBoolean(CONFIRM_DELETE_ALL_KEY, value);
    }

    public boolean autoScroll() {
        return getBoolean(AUTO_SCROLL_KEY);
    }

    public void setAutoScroll(boolean value) {
        setBoolean(AUTO_SCROLL_KEY, value);
    }

    public String getEditor() {
        String result = getString(EDITOR_KEY);
        if (result == null) {
            result = """";
        }
        return (result);
    }

    public void setEditor(String value) {
        setString(EDITOR_KEY, value);
    }

    /**
     * Adds a file to the list of recent files
     *
     * @param file
     */
    public void addRecentFile(File file) {
        if (!recentFileListContains(file)) {
            List<String> fileList = getRecentFilesList();
            // check size constraint and add accordingly
            if (fileList.size() == getRecentFilesMax()) {
                for (int i = 0; i < fileList.size() - 1; i++) {
                    fileList.set(i, fileList.get(i + 1));
                }
                fileList.set(fileList.size() - 1, file.getAbsolutePath());
            } else {
                fileList.add(file.getAbsolutePath());
            }
            setEnumeratedProperty(RECENT_FILES_KEY, fileList);
        }
    }

    /**
     * Get an array of recently opened files
     *
     * @return File[] File array of followed files
     */
    public List<File> getRecentFiles() {
        return getFiles(getRecentFilesList());
    }

    public int getRecentFilesMax() {
        return getInt(RECENT_FILES_MAX_KEY);
    }

    public void setRecentFilesMax(String max) {
        setRecentFilesMax(Integer.parseInt(max));
    }

    public void setRecentFilesMax(int max) {
        List<String> files = getRecentFilesList();
        if (files.size() > max) {
            for (int i = files.size() - max; i > 0; i--) {
                files.remove(0);
            }
            setEnumeratedProperty(RECENT_FILES_KEY, files);
        }
        setInt(RECENT_FILES_MAX_KEY, max);
    }

    public File getPropertyFile() {
        return propertyFile;
    }

    public void store() throws IOException {
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));
        properties.store(bos, null);
        // close this stream.  no need to flush it since Properties.store(..) does that
        bos.close();
    }

    // The listener list wrapper methods.
    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(listener);
    }

    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(prop, listener);
    }

    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(listener);
    }

    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(prop, listener);
    }

    public FollowAppAttributes getDefaultAttributes() throws IOException {
        if (defaultAttributes == null) {
            defaultAttributes = new FollowAppAttributes(getDefaultProperties());
            // Check for the unlikely possibility that the default font is
            // unavailable
            Font defaultFont = defaultAttributes.getFont();
            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
            boolean defaultFontIsAvailable = false;
            for (int i = 0; i < availableFontFamilyNames.length; i++) {
                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {
                    defaultFontIsAvailable = true;
                    break;
                }
            }
            if (!defaultFontIsAvailable) {
                log.info(""Font family "" + defaultFont.getFamily() + "" is unavailable; using "" + availableFontFamilyNames[0] + "" instead."");
                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));
            }
        }
        return defaultAttributes;
    }

    /**
     * Get a list of recently opened files
     *
     * @return List recently opened files as Strings
     */
    private List<String> getRecentFilesList() {
        return getEnumeratedProperty(RECENT_FILES_KEY);
    }

    private int getInt(String key) {
        int retval = 0;
        String s = getString(key);
        if (s != null)
            retval = Integer.parseInt(getString(key));
        return retval;
    }

    private void setInt(String key, int value) {
        int oldValue = getInt(key);
        properties.setProperty(key, String.valueOf(value));
        pcs.firePropertyChange(key, oldValue, value);
    }

    private boolean getBoolean(String key) {
        return ""true"".equals(getString(key));
    }

    private void setBoolean(String key, boolean value) {
        boolean oldValue = getBoolean(key);
        properties.setProperty(key, String.valueOf(value));
        pcs.firePropertyChange(key, oldValue, value);
    }

    private String getString(String key) {
        return properties.getProperty(key);
    }

    private void setString(String key, String value) {
        String oldValue = getString(key);
        properties.setProperty(key, value);
        pcs.firePropertyChange(key, oldValue, value);
    }

    private List<String> getEnumeratedProperty(String key) {
        return properties.getEnumeratedProperty(key);
    }

    private void setEnumeratedProperty(String key, List<String> values) {
        List<String> oldValue = getEnumeratedProperty(key);
        properties.setEnumeratedProperty(key, values);
        pcs.firePropertyChange(key, oldValue, values);
    }

    private EnumeratedProperties getDefaultProperties() throws IOException {
        if (defaultProperties == null) {
            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);
            BufferedInputStream bis = new BufferedInputStream(in);
            FileOutputStream fos = new FileOutputStream(propertyFile);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            byte[] byteArray = new byte[BUFFER_SIZE];
            int len;
            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {
                bos.write(byteArray, 0, len);
            }
            bos.flush();
            bos.close();
            bis.close();
            defaultProperties = new EnumeratedProperties();
            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));
        }
        return defaultProperties;
    }
}
","// FollowAppAttributes_0Test.java
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowAppAttributes}.
* It contains ten unit test cases for the {@link FollowAppAttributes#followedFileListContains(File)} method.
*/
class FollowAppAttributes_0Test {","// FollowAppAttributes_0Test.java
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowAppAttributes}.
* It contains ten unit test cases for the {@link FollowAppAttributes#followedFileListContains(File)} method.
*/
class FollowAppAttributes_0Test {
"
38f038f9-981d-4a4b-b638-193b20a57ff9,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributes_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9877 tokens (5877 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// FollowAppAttributes.java
/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;

/**
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FollowAppAttributes {

    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());

    EnumeratedProperties properties;

    private EnumeratedProperties defaultProperties;

    private FollowAppAttributes defaultAttributes;

    static final String userHome = System.getProperty(""user.home"");

    public static final String PROPERTY_FILE_NAME = "".followApp.properties"";

    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;

    private File propertyFile;

    public static final String PROPERTY_PROTOTYPE_FILE_NAME = ""followApp.properties.prototype"";

    public static final int BUFFER_SIZE = 32768;

    public static final String HEIGHT_KEY = ""height"";

    public static final String WIDTH_KEY = ""width"";

    public static final String X_KEY = ""x"";

    public static final String Y_KEY = ""y"";

    public static final String FOLLOWED_FILES_KEY = ""followedFiles"";

    public static final String TAB_PLACEMENT_KEY = ""tabs.placement"";

    public static final String SELECTED_TAB_INDEX_KEY = ""tabs.selectedIndex"";

    public static final String LAST_FILE_CHOOSER_DIR_KEY = ""fileChooser.lastDir"";

    public static final String BUFFER_SIZE_KEY = ""bufferSize"";

    public static final String LATENCY_KEY = ""latency"";

    public static final String ATTRIBUTES_VERSION_KEY = ""attributesVersion"";

    public static final String FONT_FAMILY_KEY = ""fontFamily"";

    public static final String FONT_STYLE_KEY = ""fontStyle"";

    public static final String FONT_SIZE_KEY = ""fontSize"";

    public static final String CONFIRM_DELETE_KEY = ""confirmDelete"";

    public static final String CONFIRM_DELETE_ALL_KEY = ""confirmDeleteAll"";

    public static final String AUTO_SCROLL_KEY = ""autoScroll"";

    public static final String EDITOR_KEY = ""editor"";

    public static final String TAB_SIZE_KEY = ""tabSize"";

    public static final String RECENT_FILES_MAX_KEY = ""recentFilesMax"";

    public static final String RECENT_FILES_KEY = ""recentFiles"";

    // Versions
    public static final int UNVERSIONED = 0;

    public static final int v1_1 = 1;

    public static final int v1_2 = 2;

    public static final int v1_3 = 3;

    public static final int v1_3_2 = 4;

    public static final int v1_4 = 5;

    public static final int v1_5_0 = 6;

    public static final int v1_6_0 = 7;

    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);

    public FollowAppAttributes() throws IOException {
        // have to cast null so that the constructor call isn't ambiguous
        this((File) null);
    }

    public FollowAppAttributes(File exitingPropertyFile) throws IOException {
        if (exitingPropertyFile != null) {
            propertyFile = exitingPropertyFile;
        } else {
            propertyFile = new File(defaultPropertyFileName);
        }
        if (!(propertyFile.exists())) {
            // If the property file doesn't exist, we create a default property
            // file using a prototype property file stored somewhere on the
            // classpath
            log.info(""No property file for the Follow application is present; creating "" + propertyFile.getAbsolutePath() + "" (with default values) ..."");
            properties = (EnumeratedProperties) getDefaultProperties().clone();
            log.info(""... property file created successfully."");
        } else {
            properties = new EnumeratedProperties();
            FileInputStream fis = new FileInputStream(propertyFile);
            properties.load(fis);
            switch(getAttributesVersion()) {
                case UNVERSIONED:
                    // Migrate unversioned attributes to 1.1 attributes
                    log.info(""Migrating pre-v1.1 properties to v1.1."");
                    setAttributesVersion(v1_1);
                    setTabPlacement(getDefaultAttributes().getTabPlacement());
                case v1_1:
                    // Migrate 1.1 attributes to 1.2 attributes
                    log.info(""Migrating v1.1 properties to v1.2."");
                    setAttributesVersion(v1_2);
                    setFont(getDefaultAttributes().getFont());
                case v1_2:
                    // Migrate 1.2 attributes to 1.3 attributes
                    log.info(""Migrating v1.2 properties to v1.3."");
                    setAttributesVersion(v1_3);
                    setConfirmDelete(true);
                    setConfirmDeleteAll(true);
                    // Additionally, it is necessary to warn the user about the
                    // changes to
                    // Clear and ClearAll and the introduction of Delete and
                    // DeleteAll
                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(""v1.3.warning.text""), FollowApp.getResourceString(""v1.3.warning.title""), JOptionPane.WARNING_MESSAGE);
                case v1_3:
                case v1_3_2:
                    // Migrate 1.3 attributes to 1.4 attributes
                    log.info(""Migrating v1.3 properties to v1.4."");
                    setAttributesVersion(v1_4);
                    setAutoScroll(true);
                    // Inform the user of the new AutoScroll feature
                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(""v1.4.info.text""), FollowApp.getResourceString(""v1.4.info.title""), JOptionPane.INFORMATION_MESSAGE);
                case v1_4:
                    // Migrate 1.4 attributes to 1.5 attributes
                    log.info(""Migrating v1.4 properties to v.1.5."");
                    setAttributesVersion(v1_5_0);
                    setTabSize(4);
                case v1_5_0:
                    // Migrate 1.5.0 attributes to 1.6.0 attributes
                    log.info(""Migrating v1.5 properties to 1.6.0."");
                    setAttributesVersion(v1_6_0);
                    setRecentFilesMax(5);
            }
            fis.close();
        }
    }

    private FollowAppAttributes(EnumeratedProperties props) throws IOException {
        properties = props;
    }

    public int getHeight() {
        return getInt(HEIGHT_KEY);
    }

    public void setHeight(int height) {
        setInt(HEIGHT_KEY, height);
    }

    public int getWidth() {
        return getInt(WIDTH_KEY);
    }

    public void setWidth(int width) {
        setInt(WIDTH_KEY, width);
    }

    public int getX() {
        return getInt(X_KEY);
    }

    public void setX(int x) {
        setInt(X_KEY, x);
    }

    public int getY() {
        return getInt(Y_KEY);
    }

    public void setY(int y) {
        setInt(Y_KEY, y);
    }

    /**
     * Get an array files being followed
     *
     * @return File[] File array of followed files
     */
    public List<File> getFollowedFiles() {
        return getFiles(getFollowedFilesList());
    }

    /**
     * Get a list of files being followed
     *
     * @return List file names as Strings
     */
    private List<String> getFollowedFilesList() {
        return getEnumeratedProperty(FOLLOWED_FILES_KEY);
    }

    protected List<File> getFiles(List<String> fileList) {
        ArrayList<File> files = new ArrayList<File>(fileList.size());
        for (String s : fileList) {
            files.add(new File(s));
        }
        return files;
    }

    /**
     * Checks the existence of a file in the list of followed files
     *
     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same
     *         Canonical Path as the supplied File
     */
    public boolean followedFileListContains(File file) {
        return fileListContains(getFollowedFilesList(), file);
    }

    /**
     * Checks the existence of a file in the list of recent files
     *
     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same
     *         Canonical Path as the supplied File
     */
    public boolean recentFileListContains(File file) {
        return fileListContains(getRecentFilesList(), file);
    }

    /**
     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical
     *         Path as the supplied File
     */
    protected boolean fileListContains(List<String> fileList, File file) {
        boolean retval = false;
        if (fileList != null && file != null) {
            for (int i = 0; i < fileList.size(); i++) {
                String nextFile = (String) fileList.get(i);
                // be sure to check the same thing that is added in
                // addFollowedFile(File)
                if (nextFile.equals(file.getAbsolutePath())) {
                    retval = true;
                    break;
                }
            }
        }
        return retval;
    }

    /**
     * Adds a file to the list of followed files
     *
     * @param file
     */
    public void addFollowedFile(File file) {
        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);
        if (!fileListContains(fileNames, file)) {
            fileNames.add(file.getAbsolutePath());
            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);
        }
    }

    /**
     * Removes a file from the list of followed files
     *
     * @param file
     */
    public void removeFollowedFile(File file) {
        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);
        fileNames.remove(file.getAbsolutePath());
        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);
    }

    public int getTabPlacement() {
        return getInt(TAB_PLACEMENT_KEY);
    }

    public void setTabPlacement(int tabPlacement) {
        setInt(TAB_PLACEMENT_KEY, tabPlacement);
    }

    public int getTabSize() {
        return getInt(TAB_SIZE_KEY);
    }

    public void setTabSize(int tabSize) {
        setInt(TAB_SIZE_KEY, tabSize);
    }

    public void setTabSize(String tabSize) {
        setTabSize(Integer.parseInt(tabSize));
    }

    public int getSelectedTabIndex() {
        try {
            return getInt(SELECTED_TAB_INDEX_KEY);
        } catch (NumberFormatException e) {
            setSelectedTabIndex(0);
            return 0;
        }
    }

    public void setSelectedTabIndex(int selectedTabIndex) {
        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);
    }

    public File getLastFileChooserDirectory() {
        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));
    }

    public void setLastFileChooserDirectory(File file) {
        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());
    }

    public int getBufferSize() {
        return getInt(BUFFER_SIZE_KEY);
    }

    public void setBufferSize(int bufferSize) {
        setInt(BUFFER_SIZE_KEY, bufferSize);
    }

    public void setBufferSize(String bufferSize) {
        setBufferSize(Integer.parseInt(bufferSize));
    }

    public int getLatency() {
        return getInt(LATENCY_KEY);
    }

    public void setLatency(int latency) {
        setInt(LATENCY_KEY, latency);
    }

    public void setLatency(String latency) {
        setLatency(Integer.parseInt(latency));
    }

    public int getAttributesVersion() {
        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {
            // Supporting v1.0 & v1.0.1, which had no notion of attributes
            // version
            return UNVERSIONED;
        } else {
            return getInt(ATTRIBUTES_VERSION_KEY);
        }
    }

    public void setAttributesVersion(int attributesVersion) {
        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);
    }

    public Font getFont() {
        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));
        return font;
    }

    public void setFont(Font font) {
        setString(FONT_FAMILY_KEY, font.getFontName());
        setInt(FONT_STYLE_KEY, font.getStyle());
        setInt(FONT_SIZE_KEY, font.getSize());
    }

    public boolean confirmDelete() {
        return getBoolean(CONFIRM_DELETE_KEY);
    }

    public void setConfirmDelete(boolean value) {
        setBoolean(CONFIRM_DELETE_KEY, value);
    }

    public boolean confirmDeleteAll() {
        return getBoolean(CONFIRM_DELETE_ALL_KEY);
    }

    public void setConfirmDeleteAll(boolean value) {
        setBoolean(CONFIRM_DELETE_ALL_KEY, value);
    }

    public boolean autoScroll() {
        return getBoolean(AUTO_SCROLL_KEY);
    }

    public void setAutoScroll(boolean value) {
        setBoolean(AUTO_SCROLL_KEY, value);
    }

    public String getEditor() {
        String result = getString(EDITOR_KEY);
        if (result == null) {
            result = """";
        }
        return (result);
    }

    public void setEditor(String value) {
        setString(EDITOR_KEY, value);
    }

    /**
     * Adds a file to the list of recent files
     *
     * @param file
     */
    public void addRecentFile(File file) {
        if (!recentFileListContains(file)) {
            List<String> fileList = getRecentFilesList();
            // check size constraint and add accordingly
            if (fileList.size() == getRecentFilesMax()) {
                for (int i = 0; i < fileList.size() - 1; i++) {
                    fileList.set(i, fileList.get(i + 1));
                }
                fileList.set(fileList.size() - 1, file.getAbsolutePath());
            } else {
                fileList.add(file.getAbsolutePath());
            }
            setEnumeratedProperty(RECENT_FILES_KEY, fileList);
        }
    }

    /**
     * Get an array of recently opened files
     *
     * @return File[] File array of followed files
     */
    public List<File> getRecentFiles() {
        return getFiles(getRecentFilesList());
    }

    public int getRecentFilesMax() {
        return getInt(RECENT_FILES_MAX_KEY);
    }

    public void setRecentFilesMax(String max) {
        setRecentFilesMax(Integer.parseInt(max));
    }

    public void setRecentFilesMax(int max) {
        List<String> files = getRecentFilesList();
        if (files.size() > max) {
            for (int i = files.size() - max; i > 0; i--) {
                files.remove(0);
            }
            setEnumeratedProperty(RECENT_FILES_KEY, files);
        }
        setInt(RECENT_FILES_MAX_KEY, max);
    }

    public File getPropertyFile() {
        return propertyFile;
    }

    public void store() throws IOException {
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));
        properties.store(bos, null);
        // close this stream.  no need to flush it since Properties.store(..) does that
        bos.close();
    }

    // The listener list wrapper methods.
    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(listener);
    }

    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(prop, listener);
    }

    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(listener);
    }

    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(prop, listener);
    }

    public FollowAppAttributes getDefaultAttributes() throws IOException {
        if (defaultAttributes == null) {
            defaultAttributes = new FollowAppAttributes(getDefaultProperties());
            // Check for the unlikely possibility that the default font is
            // unavailable
            Font defaultFont = defaultAttributes.getFont();
            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
            boolean defaultFontIsAvailable = false;
            for (int i = 0; i < availableFontFamilyNames.length; i++) {
                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {
                    defaultFontIsAvailable = true;
                    break;
                }
            }
            if (!defaultFontIsAvailable) {
                log.info(""Font family "" + defaultFont.getFamily() + "" is unavailable; using "" + availableFontFamilyNames[0] + "" instead."");
                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));
            }
        }
        return defaultAttributes;
    }

    /**
     * Get a list of recently opened files
     *
     * @return List recently opened files as Strings
     */
    private List<String> getRecentFilesList() {
        return getEnumeratedProperty(RECENT_FILES_KEY);
    }

    private int getInt(String key) {
        int retval = 0;
        String s = getString(key);
        if (s != null)
            retval = Integer.parseInt(getString(key));
        return retval;
    }

    private void setInt(String key, int value) {
        int oldValue = getInt(key);
        properties.setProperty(key, String.valueOf(value));
        pcs.firePropertyChange(key, oldValue, value);
    }

    private boolean getBoolean(String key) {
        return ""true"".equals(getString(key));
    }

    private void setBoolean(String key, boolean value) {
        boolean oldValue = getBoolean(key);
        properties.setProperty(key, String.valueOf(value));
        pcs.firePropertyChange(key, oldValue, value);
    }

    private String getString(String key) {
        return properties.getProperty(key);
    }

    private void setString(String key, String value) {
        String oldValue = getString(key);
        properties.setProperty(key, value);
        pcs.firePropertyChange(key, oldValue, value);
    }

    private List<String> getEnumeratedProperty(String key) {
        return properties.getEnumeratedProperty(key);
    }

    private void setEnumeratedProperty(String key, List<String> values) {
        List<String> oldValue = getEnumeratedProperty(key);
        properties.setEnumeratedProperty(key, values);
        pcs.firePropertyChange(key, oldValue, values);
    }

    private EnumeratedProperties getDefaultProperties() throws IOException {
        if (defaultProperties == null) {
            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);
            BufferedInputStream bis = new BufferedInputStream(in);
            FileOutputStream fos = new FileOutputStream(propertyFile);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            byte[] byteArray = new byte[BUFFER_SIZE];
            int len;
            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {
                bos.write(byteArray, 0, len);
            }
            bos.flush();
            bos.close();
            bis.close();
            defaultProperties = new EnumeratedProperties();
            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));
        }
        return defaultProperties;
    }
}
","// FollowAppAttributes_1Test.java
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowAppAttributes}.
* It contains ten unit test cases for the {@link FollowAppAttributes#recentFileListContains(File)} method.
*/
class FollowAppAttributes_1Test {","// FollowAppAttributes_1Test.java
package ghm.follow.config;

import ghm.follow.FollowApp;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FollowAppAttributes}.
* It contains ten unit test cases for the {@link FollowAppAttributes#recentFileListContains(File)} method.
*/
class FollowAppAttributes_1Test {
"
cmpl-6tsDiDkQBHfZ7NHOtPFkMtYcuJA59,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilder_0Test.java,105.1263222694397,length,"// ComponentBuilder.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;

public class ComponentBuilder {

    public static Menu fileMenu;

    public static Menu editMenu;

    public static Menu toolsMenu;

    public static Menu windowMenu;

    public static Menu helpMenu;

    // file menu items
    public static Menu recentFilesMenu;

    private ComponentBuilder() {
    }

    /**
     * Builds the menu bar for the application
     *
     * @return reference the constructed menu bar
     */
    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        // create menu bar and add menus
        JMenuBar jMenuBar = new JMenuBar();
        // file menu
        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);
        jMenuBar.add(fileMenu);
        // edit menu
        editMenu = ComponentBuilder.buildEditMenu(resources, actions);
        jMenuBar.add(editMenu);
        // tool menu
        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);
        jMenuBar.add(toolsMenu);
        // window menu
        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);
        jMenuBar.add(windowMenu);
        // help menu
        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);
        jMenuBar.add(helpMenu);
        return jMenuBar;
    }

    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu fileMenu = new Menu(resources.getString(""menu.File.name""), resources.getString(""menu.File.mnemonic""));
        fileMenu.addFollowAppAction(actions.get(Open.NAME));
        fileMenu.addFollowAppAction(actions.get(Close.NAME));
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Reset.NAME));
        fileMenu.addFollowAppAction(actions.get(Pause.NAME));
        fileMenu.addSeparator();
        recentFilesMenu = new Menu(resources.getString(""menu.RecentFiles.name""), resources.getString(""menu.RecentFiles.mnemonic""), FollowApp.getIcon(ComponentBuilder.class, ""menu.RecentFiles.icon""));
        fileMenu.add(recentFilesMenu);
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Exit.NAME));
        return fileMenu;
    }

    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu editMenu = new Menu(resources.getString(""menu.Edit.name""), resources.getString(""menu.Edit.mnemonic""));
        editMenu.addFollowAppAction(actions.get(Find.NAME));
        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));
        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));
        editMenu.addSeparator();
        editMenu.addFollowAppAction(actions.get(Configure.NAME));
        return editMenu;
    }

    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu toolsMenu = new Menu(resources.getString(""menu.Tools.name""), resources.getString(""menu.Tools.mnemonic""));
        toolsMenu.addFollowAppAction(actions.get(Top.NAME));
        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));
        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));
        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));
        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));
        return toolsMenu;
    }

    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu windowMenu = new Menu(resources.getString(""menu.Window.name""), resources.getString(""menu.Window.mnemonic""));
        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));
        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));
        return windowMenu;
    }

    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu helpMenu = new Menu(resources.getString(""menu.Help.name""), resources.getString(""menu.Help.mnemonic""));
        helpMenu.addFollowAppAction(actions.get(About.NAME));
        return helpMenu;
    }

    /**
     * Builds the popup menu shown when right clicking in a text area.
     *
     * @return
     */
    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {
        PopupMenu popupMenu = new PopupMenu();
        popupMenu.addFollowAppAction(actions.get(Open.NAME));
        popupMenu.addFollowAppAction(actions.get(Close.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Reset.NAME));
        popupMenu.addFollowAppAction(actions.get(Pause.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Top.NAME));
        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Clear.NAME));
        popupMenu.addFollowAppAction(actions.get(Delete.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Configure.NAME));
        popupMenu.addFollowAppAction(actions.get(Edit.NAME));
        return popupMenu;
    }

    /**
     * Builds the toolbar shown at the top of the application
     *
     * @return
     */
    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {
        ToolBar toolBar = new ToolBar();
        toolBar.addFollowAppAction(actions.get(Open.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Top.NAME));
        toolBar.addFollowAppAction(actions.get(Bottom.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Clear.NAME));
        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));
        toolBar.addFollowAppAction(actions.get(Delete.NAME));
        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Reset.NAME));
        toolBar.addFollowAppAction(actions.get(Pause.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Configure.NAME));
        return toolBar;
    }
}
","// ComponentBuilder_0Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
*/
class ComponentBuilder_0Test {","// ComponentBuilder_0Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
*/
class ComponentBuilder_0Test {

		/**
		* Test case for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
		* This test case checks if the menu bar contains the file menu.
		*/
		@Test
		void testBuildMenuBar_0() {
				ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.gui.resources.FollowApp"");
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Open.icon"")));
				actions.put(Close.NAME, new Close(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Close.icon"")));
				actions.put(Reset.NAME, new Reset(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Reset.icon"")));
				actions.put(Pause.NAME, new Pause(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Pause.icon"")));
				actions.put(Exit.NAME, new Exit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Exit.icon"")));
				actions.put(Find.NAME, new Find(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Find.icon"")));
				actions.put(ClearHighlights.NAME, new ClearHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearHighlights.icon"")));
				actions.put(ClearAllHighlights.NAME, new ClearAllHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearAllHighlights.icon"")));
				actions.put(Configure.NAME, new Configure(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Configure.icon"")));
				actions.put(Top.NAME, new Top(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Top.icon"")));
				actions.put(Bottom.NAME, new Bottom(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Bottom.icon"")));
				actions.put(Clear.NAME, new Clear(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Clear.icon"")));
				actions.put(ClearAll.NAME, new ClearAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.ClearAll.icon"")));
				actions.put(Delete.NAME, new Delete(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Delete.icon"")));
				actions.put(DeleteAll.NAME, new DeleteAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.DeleteAll.icon"")));
				actions.put(Edit.NAME, new Edit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Edit.icon"")));
				actions.put(NextTab.NAME, new NextTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.NextTab.icon"")));
				actions.put(PreviousTab.NAME, new PreviousTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.PreviousTab.icon"")));
				actions.put(About.NAME, new About(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Help.About.icon"")));
				JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, actions);
				assertTrue(jMenuBar.getMenu(0).getText().equals(""File""));
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
		* This test case checks if the menu bar contains the edit menu.
		*/
		@Test
		void testBuildMenuBar_1() {
				ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.gui.resources.FollowApp"");
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Open.icon"")));
				actions.put(Close.NAME, new Close(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Close.icon"")));
				actions.put(Reset.NAME, new Reset(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Reset.icon"")));
				actions.put(Pause.NAME, new Pause(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Pause.icon"")));
				actions.put(Exit.NAME, new Exit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Exit.icon"")));
				actions.put(Find.NAME, new Find(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Find.icon"")));
				actions.put(ClearHighlights.NAME, new ClearHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearHighlights.icon"")));
				actions.put(ClearAllHighlights.NAME, new ClearAllHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearAllHighlights.icon"")));
				actions.put(Configure.NAME, new Configure(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Configure.icon"")));
				actions.put(Top.NAME, new Top(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Top.icon"")));
				actions.put(Bottom.NAME, new Bottom(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Bottom.icon"")));
				actions.put(Clear.NAME, new Clear(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Clear.icon"")));
				actions.put(ClearAll.NAME, new ClearAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.ClearAll.icon"")));
				actions.put(Delete.NAME, new Delete(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Delete.icon"")));
				actions.put(DeleteAll.NAME, new DeleteAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.DeleteAll.icon"")));
				actions.put(Edit.NAME, new Edit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Edit.icon"")));
				actions.put(NextTab.NAME, new NextTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.NextTab.icon"")));
				actions.put(PreviousTab.NAME, new PreviousTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.PreviousTab.icon"")));
				actions.put(About.NAME, new About(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Help.About.icon"")));
				JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, actions);
				assertTrue(jMenuBar.getMenu(1).getText().equals(""Edit""));
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
		* This test case checks if the menu bar contains the tools menu.
		*/
		@Test
		void testBuildMenuBar_2() {
				ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.gui.resources.FollowApp"");
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Open.icon"")));
				actions.put(Close.NAME, new Close(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Close.icon"")));
				actions.put(Reset.NAME, new Reset(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Reset.icon"")));
				actions.put(Pause.NAME, new Pause(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Pause.icon"")));
				actions.put(Exit.NAME, new Exit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Exit.icon"")));
				actions.put(Find.NAME, new Find(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Find.icon"")));
				actions.put(ClearHighlights.NAME, new ClearHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearHighlights.icon"")));
				actions.put(ClearAllHighlights.NAME, new ClearAllHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearAllHighlights.icon"")));
				actions.put(Configure.NAME, new Configure(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Configure.icon"")));
				actions.put(Top.NAME, new Top(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Top.icon"")));
				actions.put(Bottom.NAME, new Bottom(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Bottom.icon"")));
				actions.put(Clear.NAME, new Clear(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Clear.icon"")));
				actions.put(ClearAll.NAME, new ClearAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.ClearAll.icon"")));
				actions.put(Delete.NAME, new Delete(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Delete.icon"")));
				actions.put(DeleteAll.NAME, new DeleteAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.DeleteAll.icon"")));
				actions.put(Edit.NAME, new Edit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Edit.icon"")));
				actions.put(NextTab.NAME, new NextTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.NextTab.icon"")));
				actions.put(PreviousTab.NAME, new PreviousTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.PreviousTab.icon"")));
				actions.put(About.NAME, new About(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Help.About.icon"")));
				JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, actions);
				assertTrue(jMenuBar.getMenu(2).getText().equals(""Tools""));
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
		* This test case checks if the menu bar contains the window menu.
		*/
		@Test
		void testBuildMenuBar_3() {
				ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.gui.resources.FollowApp"");
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Open.icon"")));
				actions.put(Close.NAME, new Close(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Close.icon"")));
				actions.put(Reset.NAME, new Reset(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Reset.icon"")));
				actions.put(Pause.NAME, new Pause(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Pause.icon"")));
				actions.put(Exit.NAME, new Exit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Exit.icon"")));
				actions.put(Find.NAME, new Find(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Find.icon"")));
				actions.put(ClearHighlights.NAME, new ClearHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearHighlights.icon"")));
				actions.put(ClearAllHighlights.NAME, new ClearAllHighlights(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.ClearAllHighlights.icon"")));
				actions.put(Configure.NAME, new Configure(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Edit.Configure.icon"")));
				actions.put(Top.NAME, new Top(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Top.icon"")));
				actions.put(Bottom.NAME, new Bottom(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Bottom.icon"")));
				actions.put(Clear.NAME, new Clear(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Clear.icon"")));
				actions.put(ClearAll.NAME, new ClearAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.ClearAll.icon"")));
				actions.put(Delete.NAME, new Delete(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Delete.icon"")));
				actions.put(DeleteAll.NAME, new DeleteAll(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.DeleteAll.icon"")));
				actions.put(Edit.NAME, new Edit(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Tools.Edit.icon"")));
				actions.put(NextTab.NAME, new NextTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.NextTab.icon"")));
				actions.put(PreviousTab.NAME, new PreviousTab(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Window.PreviousTab.icon"")));
				actions.put(About.NAME, new About(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.Help.About.icon"")));
				JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, actions);
				assertTrue(jMenuBar.getMenu(3).getText().equals(""Window""));
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.
		* This test case checks if the menu bar contains the help menu.
		*/
		@Test
		void testBuildMenuBar_4() {
				ResourceBundle resources = ResourceBundle.getBundle(""ghm.follow.gui.resources.FollowApp"");
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open(resources, FollowApp.getIcon(ComponentBuilder.class, ""menu.File.Open.icon"")));
				actions.put(Close."
cmpl-6tsFPoUBaZxYd4ff06qKv7yy7oVuF,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilder_6Test.java,95.63699316978455,length,"// ComponentBuilder.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;

public class ComponentBuilder {

    public static Menu fileMenu;

    public static Menu editMenu;

    public static Menu toolsMenu;

    public static Menu windowMenu;

    public static Menu helpMenu;

    // file menu items
    public static Menu recentFilesMenu;

    private ComponentBuilder() {
    }

    /**
     * Builds the menu bar for the application
     *
     * @return reference the constructed menu bar
     */
    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        // create menu bar and add menus
        JMenuBar jMenuBar = new JMenuBar();
        // file menu
        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);
        jMenuBar.add(fileMenu);
        // edit menu
        editMenu = ComponentBuilder.buildEditMenu(resources, actions);
        jMenuBar.add(editMenu);
        // tool menu
        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);
        jMenuBar.add(toolsMenu);
        // window menu
        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);
        jMenuBar.add(windowMenu);
        // help menu
        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);
        jMenuBar.add(helpMenu);
        return jMenuBar;
    }

    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu fileMenu = new Menu(resources.getString(""menu.File.name""), resources.getString(""menu.File.mnemonic""));
        fileMenu.addFollowAppAction(actions.get(Open.NAME));
        fileMenu.addFollowAppAction(actions.get(Close.NAME));
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Reset.NAME));
        fileMenu.addFollowAppAction(actions.get(Pause.NAME));
        fileMenu.addSeparator();
        recentFilesMenu = new Menu(resources.getString(""menu.RecentFiles.name""), resources.getString(""menu.RecentFiles.mnemonic""), FollowApp.getIcon(ComponentBuilder.class, ""menu.RecentFiles.icon""));
        fileMenu.add(recentFilesMenu);
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Exit.NAME));
        return fileMenu;
    }

    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu editMenu = new Menu(resources.getString(""menu.Edit.name""), resources.getString(""menu.Edit.mnemonic""));
        editMenu.addFollowAppAction(actions.get(Find.NAME));
        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));
        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));
        editMenu.addSeparator();
        editMenu.addFollowAppAction(actions.get(Configure.NAME));
        return editMenu;
    }

    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu toolsMenu = new Menu(resources.getString(""menu.Tools.name""), resources.getString(""menu.Tools.mnemonic""));
        toolsMenu.addFollowAppAction(actions.get(Top.NAME));
        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));
        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));
        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));
        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));
        return toolsMenu;
    }

    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu windowMenu = new Menu(resources.getString(""menu.Window.name""), resources.getString(""menu.Window.mnemonic""));
        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));
        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));
        return windowMenu;
    }

    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu helpMenu = new Menu(resources.getString(""menu.Help.name""), resources.getString(""menu.Help.mnemonic""));
        helpMenu.addFollowAppAction(actions.get(About.NAME));
        return helpMenu;
    }

    /**
     * Builds the popup menu shown when right clicking in a text area.
     *
     * @return
     */
    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {
        PopupMenu popupMenu = new PopupMenu();
        popupMenu.addFollowAppAction(actions.get(Open.NAME));
        popupMenu.addFollowAppAction(actions.get(Close.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Reset.NAME));
        popupMenu.addFollowAppAction(actions.get(Pause.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Top.NAME));
        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Clear.NAME));
        popupMenu.addFollowAppAction(actions.get(Delete.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Configure.NAME));
        popupMenu.addFollowAppAction(actions.get(Edit.NAME));
        return popupMenu;
    }

    /**
     * Builds the toolbar shown at the top of the application
     *
     * @return
     */
    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {
        ToolBar toolBar = new ToolBar();
        toolBar.addFollowAppAction(actions.get(Open.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Top.NAME));
        toolBar.addFollowAppAction(actions.get(Bottom.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Clear.NAME));
        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));
        toolBar.addFollowAppAction(actions.get(Delete.NAME));
        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Reset.NAME));
        toolBar.addFollowAppAction(actions.get(Pause.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Configure.NAME));
        return toolBar;
    }
}
","// ComponentBuilder_6Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
*/
class ComponentBuilder_6Test {","// ComponentBuilder_6Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
*/
class ComponentBuilder_6Test {

		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_1() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_2() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_3() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_4() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_5() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_6() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_7() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_8() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_9() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildPopupMenu_10() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				PopupMenu popupMenu = ComponentBuilder.buildPopupMenu(actions);
				assertNotNull(popupMenu);
		}
}

// ComponentBuilder_7Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildToolBar(HashMap)} method.
*/
class ComponentBuilder_7Test {
		
		/**
		* Test case for the {@link ComponentBuilder#buildToolBar(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildToolBar_1() {
				HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();
				actions.put(Open.NAME, new Open());
				actions.put(Close.NAME, new Close());
				actions.put(Reset.NAME, new Reset());
				actions.put(Pause.NAME, new Pause());
				actions.put(Top.NAME, new Top());
				actions.put(Bottom.NAME, new Bottom());
				actions.put(Clear.NAME, new Clear());
				actions.put(ClearAll.NAME, new ClearAll());
				actions.put(Delete.NAME, new Delete());
				actions.put(DeleteAll.NAME, new DeleteAll());
				actions.put(Configure.NAME, new Configure());
				actions.put(Edit.NAME, new Edit());
				ToolBar toolBar = ComponentBuilder.buildToolBar(actions);
				assertNotNull(toolBar);
		}
		
		/**
		* Test case for the {@link ComponentBuilder#buildToolBar(HashMap)} method.
		* This test case checks if the method returns a non-null value.
		*/
		@Test
		void testBuildToolBar_2() {
		"
cmpl-6tsGxAgtfGk4Oq7nVj1qxnqG7nv1k,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilder_7Test.java,99.83520722389221,length,"// ComponentBuilder.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;

public class ComponentBuilder {

    public static Menu fileMenu;

    public static Menu editMenu;

    public static Menu toolsMenu;

    public static Menu windowMenu;

    public static Menu helpMenu;

    // file menu items
    public static Menu recentFilesMenu;

    private ComponentBuilder() {
    }

    /**
     * Builds the menu bar for the application
     *
     * @return reference the constructed menu bar
     */
    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        // create menu bar and add menus
        JMenuBar jMenuBar = new JMenuBar();
        // file menu
        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);
        jMenuBar.add(fileMenu);
        // edit menu
        editMenu = ComponentBuilder.buildEditMenu(resources, actions);
        jMenuBar.add(editMenu);
        // tool menu
        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);
        jMenuBar.add(toolsMenu);
        // window menu
        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);
        jMenuBar.add(windowMenu);
        // help menu
        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);
        jMenuBar.add(helpMenu);
        return jMenuBar;
    }

    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu fileMenu = new Menu(resources.getString(""menu.File.name""), resources.getString(""menu.File.mnemonic""));
        fileMenu.addFollowAppAction(actions.get(Open.NAME));
        fileMenu.addFollowAppAction(actions.get(Close.NAME));
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Reset.NAME));
        fileMenu.addFollowAppAction(actions.get(Pause.NAME));
        fileMenu.addSeparator();
        recentFilesMenu = new Menu(resources.getString(""menu.RecentFiles.name""), resources.getString(""menu.RecentFiles.mnemonic""), FollowApp.getIcon(ComponentBuilder.class, ""menu.RecentFiles.icon""));
        fileMenu.add(recentFilesMenu);
        fileMenu.addSeparator();
        fileMenu.addFollowAppAction(actions.get(Exit.NAME));
        return fileMenu;
    }

    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu editMenu = new Menu(resources.getString(""menu.Edit.name""), resources.getString(""menu.Edit.mnemonic""));
        editMenu.addFollowAppAction(actions.get(Find.NAME));
        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));
        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));
        editMenu.addSeparator();
        editMenu.addFollowAppAction(actions.get(Configure.NAME));
        return editMenu;
    }

    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu toolsMenu = new Menu(resources.getString(""menu.Tools.name""), resources.getString(""menu.Tools.mnemonic""));
        toolsMenu.addFollowAppAction(actions.get(Top.NAME));
        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));
        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));
        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));
        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolsMenu.addSeparator();
        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));
        return toolsMenu;
    }

    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu windowMenu = new Menu(resources.getString(""menu.Window.name""), resources.getString(""menu.Window.mnemonic""));
        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));
        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));
        return windowMenu;
    }

    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {
        Menu helpMenu = new Menu(resources.getString(""menu.Help.name""), resources.getString(""menu.Help.mnemonic""));
        helpMenu.addFollowAppAction(actions.get(About.NAME));
        return helpMenu;
    }

    /**
     * Builds the popup menu shown when right clicking in a text area.
     *
     * @return
     */
    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {
        PopupMenu popupMenu = new PopupMenu();
        popupMenu.addFollowAppAction(actions.get(Open.NAME));
        popupMenu.addFollowAppAction(actions.get(Close.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Reset.NAME));
        popupMenu.addFollowAppAction(actions.get(Pause.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Top.NAME));
        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Clear.NAME));
        popupMenu.addFollowAppAction(actions.get(Delete.NAME));
        popupMenu.addSeparator();
        popupMenu.addFollowAppAction(actions.get(Configure.NAME));
        popupMenu.addFollowAppAction(actions.get(Edit.NAME));
        return popupMenu;
    }

    /**
     * Builds the toolbar shown at the top of the application
     *
     * @return
     */
    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {
        ToolBar toolBar = new ToolBar();
        toolBar.addFollowAppAction(actions.get(Open.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Top.NAME));
        toolBar.addFollowAppAction(actions.get(Bottom.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Clear.NAME));
        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));
        toolBar.addFollowAppAction(actions.get(Delete.NAME));
        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Reset.NAME));
        toolBar.addFollowAppAction(actions.get(Pause.NAME));
        toolBar.addSeparator();
        toolBar.addFollowAppAction(actions.get(Configure.NAME));
        return toolBar;
    }
}
","// ComponentBuilder_7Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildToolBar(HashMap)} method.
*/
class ComponentBuilder_7Test {","// ComponentBuilder_7Test.java
package ghm.follow.gui;

import ghm.follow.FollowApp;
import ghm.follow.config.Configure;
import ghm.follow.nav.Bottom;
import ghm.follow.nav.NextTab;
import ghm.follow.nav.PreviousTab;
import ghm.follow.nav.Top;
import ghm.follow.search.ClearAllHighlights;
import ghm.follow.search.ClearHighlights;
import ghm.follow.search.Find;
import java.util.HashMap;
import java.util.ResourceBundle;
import javax.swing.JMenuBar;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentBuilder}.
* It contains ten unit test cases for the {@link ComponentBuilder#buildToolBar(HashMap)} method.
*/
class ComponentBuilder_7Test {

		/**
		* Test case for {@link ComponentBuilder#buildToolBar(HashMap)} method.
		* Test case for the following requirements:
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		* 
		"
cmpl-6tsIYRYyu5inAehumfl0kISiTLQzE,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java,75.79957890510559,,"// FileFollowingPane.java
/* 
 Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)

 This file is part of Follow (http://follow.sf.net).

 Follow is free software; you can redistribute it and/or modify
 it under the terms of version 2 of the GNU General Public
 License as published by the Free Software Foundation.

 Follow is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Follow; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

/**
 * A component which allows one to view a text file to which information is being asynchronously
 * appended.
 *
 * @author <a href=""mailto:greghmerrill@yahoo.com"">Greg Merrill</a>
 */
public class FileFollowingPane extends JScrollPane {

    private Logger log = Logger.getLogger(FileFollowingPane.class.getName());

    /**
     * FileFollower used to print to this component
     */
    protected FileFollower fileFollower;

    /**
     * Text area into which followed file's contents are printed
     */
    protected SearchableTextPane textArea;

    /**
     * OutputDestination used w/FileFollower
     */
    protected JTextComponentDestination destination;

    /**
     * @param file
     *            text file to be followed
     * @param bufferSize
     *            size of the character buffer inside the FileFollower used to follow the supplied
     *            file
     * @param latency
     *            latency of the FileFollower used to follow the supplied file
     */
    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {
        textArea = new SearchableTextPane(font, tabSize);
        textArea.setEditable(false);
        textArea.setUI(new LineTextUI());
        destination = new JTextComponentDestination(textArea, autoPositionCaret);
        fileFollower = new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });
        add(textArea);
        setViewportView(textArea);
    }

    /**
     * Returns the text area to which the followed file's contents are being printed.
     *
     * @return text area containing followed file's contents
     */
    public SearchableTextPane getTextPane() {
        return textArea;
    }

    /**
     * Returns whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @return whether caret is automatically repositioned on append
     */
    public boolean autoPositionCaret() {
        return destination.autoPositionCaret();
    }

    /**
     * Sets whether caret is automatically repositioned to the end of the text area when text is
     * appended to the followed file
     *
     * @param value
     *            whether caret is automatically repositioned on append
     */
    public void setAutoPositionCaret(boolean value) {
        destination.setAutoPositionCaret(value);
    }

    /**
     * Returns the FileFollower which is being used to print information in this component.
     *
     * @return FileFollower used by this component
     */
    public FileFollower getFileFollower() {
        return fileFollower;
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()
     */
    public File getFollowedFile() {
        return fileFollower.getFollowedFile();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().start()
     */
    public void startFollowing() {
        fileFollower.start();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().stop()
     */
    public void stopFollowing() {
        fileFollower.stop();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().restart()
     */
    public void restartFollowing() {
        fileFollower.restart();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().pause()
     */
    public void pauseFollowing() {
        fileFollower.pause();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().unpause()
     */
    public void unpauseFollowing() {
        fileFollower.unpause();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().isPaused()
     *
     * @return
     */
    public boolean isFollowingPaused() {
        return fileFollower.isPaused();
    }

    /**
     * Convenience method; equivalent to calling getFileFollower().stopAndWait()
     */
    public void stopFollowingAndWait() throws InterruptedException {
        fileFollower.stopAndWait();
    }

    /**
     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()
     *
     * @return
     */
    public boolean isFollowing() {
        return fileFollower.isBeingFollowed();
    }

    /**
     * Clears the contents of this FileFollowingPane synchronously.
     */
    public void clear() throws IOException {
        if (fileFollower.getFollowedFile().length() == 0L) {
            return;
        }
        synchronized (fileFollower) {
            try {
                fileFollower.stopAndWait();
            } catch (InterruptedException interruptedException) {
                // Handle this better later
                log.log(Level.SEVERE, ""InterrupedException in FileFollowingPane"", interruptedException);
            }
            // This has the effect of clearing the contents of the followed file
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));
            bos.close();
            // Update textarea contents to reflect freshly cleared file
            Document doc = textArea.getDocument();
            try {
                doc.remove(0, doc.getLength());
            } catch (BadLocationException e) {
                // Handle this better later
                log.log(Level.WARNING, ""BadLocationException in FileFolloingPane"", e);
            }
            fileFollower.start();
        }
    }
}
","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains ten unit test cases for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {","// FileFollowingPaneTest.java
package ghm.follow.gui;

import ghm.follow.FileFollower;
import ghm.follow.io.JTextComponentDestination;
import ghm.follow.io.OutputDestination;
import ghm.follow.search.SearchableTextPane;
import java.awt.Font;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileFollowingPane}.
* It contains ten unit test cases for the {@link FileFollowingPane#autoPositionCaret()} method.
*/
class FileFollowingPaneTest {

		private Logger log = Logger.getLogger(FileFollowingPaneTest.class.getName());
		
		/**
		 * FileFollower used to print to this component
		 */
		protected FileFollower fileFollower;
		
		/**
		 * Text area into which followed file's contents are printed
		 */
		protected SearchableTextPane textArea;
		
		/**
		 * OutputDestination used w/FileFollower
		 */
		protected JTextComponentDestination destination;
		
		/**
		 * @param file
		 *            text file to be followed
		 * @param bufferSize
		 *            size of the character buffer inside the FileFollower used to follow the supplied
		 *            file
		 * @param latency
		 *            latency of the FileFollower used to follow the supplied file
		 */
		public FileFollowingPaneTest(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {
				textArea = new SearchableTextPane(font, tabSize);
				textArea.setEditable(false);
				textArea.setUI(new LineTextUI());
				destination = new JTextComponentDestination(textArea, autoPositionCaret);
				fileFollower = new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });
				add(textArea);
				setViewportView(textArea);
		}
		
		/**
		 * Returns the text area to which the followed file's contents are being printed.
		 *
		 * @return text area containing followed file's contents
		 */
		public SearchableTextPane getTextPane() {
				return textArea;
		}
		
		/**
		 * Returns whether caret is automatically repositioned to the end of the text area when text is
		 * appended to the followed file
		 *
		 * @return whether caret is automatically repositioned on append
		 */
		public boolean autoPositionCaret() {
				return destination.autoPositionCaret();
		}
		
		/**
		 * Sets whether caret is automatically repositioned to the end of the text area when text is
		 * appended to the followed file
		 *
		 * @param value
		 *            whether caret is automatically repositioned on append
		 */
		public void setAutoPositionCaret(boolean value) {
				destination.setAutoPositionCaret(value);
		}
		
		/**
		 * Returns the FileFollower which is being used to print information in this component.
		 *
		 * @return FileFollower used by this component
		 */
		public FileFollower getFileFollower() {
				return fileFollower;
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().getFollowedFile()
		 */
		public File getFollowedFile() {
				return fileFollower.getFollowedFile();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().start()
		 */
		public void startFollowing() {
				fileFollower.start();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().stop()
		 */
		public void stopFollowing() {
				fileFollower.stop();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().restart()
		 */
		public void restartFollowing() {
				fileFollower.restart();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().pause()
		 */
		public void pauseFollowing() {
				fileFollower.pause();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().unpause()
		 */
		public void unpauseFollowing() {
				fileFollower.unpause();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().isPaused()
		 *
		 * @return
		 */
		public boolean isFollowingPaused() {
				return fileFollower.isPaused();
		}
		
		/**
		 * Convenience method; equivalent to calling getFileFollower().stopAndWait()
		 */
		public void stopFollowingAndWait() throws InterruptedException {
				fileFollower.stopAndWait();
		}
		
		/**
		 * Convenience method; equivalent to called getFileFollower().isBeingFollowed()
		 *
		 * @return
		 */
		public boolean isFollowing() {
				return fileFollower.isBeingFollowed();
		}
		
		/**
		 * Clears the contents of this FileFollowingPane synchronously.
		 */
		public void clear() throws IOException {
				if (fileFollower.getFollowedFile().length() == 0L) {
						return;
				}
				synchronized (fileFollower) {
						try {
								fileFollower.stopAndWait();
						} catch (InterruptedException interruptedException) {
								// Handle this better later
								log.log(Level.SEVERE, ""InterrupedException in FileFollowingPane"", interruptedException);
						}
						// This has the effect of clearing the contents of the followed file
						BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));
						bos.close();
						// Update textarea contents to reflect freshly cleared file
						Document doc = textArea.getDocument();
						try {
								doc.remove(0, doc.getLength());
						} catch (BadLocationException e) {
								// Handle this better later
								log.log(Level.WARNING, ""BadLocationException in FileFolloingPane"", e);
						}
						fileFollower.start();
				}
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, true, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				assertTrue(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret2() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, false, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				assertFalse(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret3() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, true, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(false);
				assertFalse(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret4() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, false, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(true);
				assertTrue(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret5() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, true, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(true);
				assertTrue(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret6() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, false, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(false);
				assertFalse(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret7() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, true, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(false);
				fileFollowingPane.setAutoPositionCaret(true);
				assertTrue(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret8() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, false, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(true);
				fileFollowingPane.setAutoPositionCaret(false);
				assertFalse(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret9() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, true, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(true);
				fileFollowingPane.setAutoPositionCaret(true);
				assertTrue(fileFollowingPane.autoPositionCaret());
		}
		
		/**
		 * Test case for {@link FileFollowingPane#autoPositionCaret()} method.
		 * It checks if the method returns the correct value.
		 */
		@Test
		public void testAutoPositionCaret10() {
				FileFollowingPane fileFollowingPane = new FileFollowingPane(new File(""test.txt""), 1024, 1000, false, new Font(""Monospaced"", Font.PLAIN, 12), 4);
				fileFollowingPane.setAutoPositionCaret(false);
				fileFollowingPane.setAutoPositionCaret(false);
				assertFalse(fileFollowingPane.autoPositionCaret());
		}
}"
cmpl-6tsJmrXHAxCNAgzTyMiQMQU1Y4Cby,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/LineEditorKit.java,28.69467830657959,stop,"// LineEditorKit.java
package ghm.follow.gui;

import javax.swing.text.Element;
import javax.swing.text.StyledEditorKit;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;

public class LineEditorKit extends StyledEditorKit implements ViewFactory {

    /**
     * @see javax.swing.text.ViewFactory#create(javax.swing.text.Element)
     */
    public View create(Element elem) {
        return new LineView(elem);
    }

    /**
     * @see javax.swing.text.DefaultEditorKit#getViewFactory()
     */
    public ViewFactory getViewFactory() {
        return this;
    }
}
","// LineEditorKitTest.java
package ghm.follow.gui;

import javax.swing.text.Element;
import javax.swing.text.StyledEditorKit;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LineEditorKit}.
* It contains ten unit test cases for the {@link LineEditorKit#create(Element)} method.
*/
class LineEditorKitTest {","// LineEditorKitTest.java
package ghm.follow.gui;

import javax.swing.text.Element;
import javax.swing.text.StyledEditorKit;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LineEditorKit}.
* It contains ten unit test cases for the {@link LineEditorKit#create(Element)} method.
*/
class LineEditorKitTest {

	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: null.
	* Expected result: NullPointerException.
	*/
	@Test
	void testCreate_Null() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		assertThrows(NullPointerException.class, () -> lineEditorKit.create(null));
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""content"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Content() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""content"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""paragraph"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Paragraph() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""paragraph"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""section"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Section() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""section"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""component"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Component() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""component"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""icon"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Icon() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""icon"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""leaf"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Leaf() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""leaf"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""branch"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Branch() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""branch"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name ""unknown"".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Unknown() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return ""unknown"";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
	
	/**
	* Test case for {@link LineEditorKit#create(Element)} method.
	* Test data: {@link Element} with name """".
	* Expected result: {@link LineView}.
	*/
	@Test
	void testCreate_Empty() {
		LineEditorKit lineEditorKit = new LineEditorKit();
		Element element = new Element() {
			public String getName() {
				return """";
			}
		};
		View view = lineEditorKit.create(element);
		assertTrue(view instanceof LineView);
	}
}"
cmpl-6tsKpgpxzbJlYcv81cJca8Sax2v6B,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/TabbedPane.java,16.27646827697754,,"// TabbedPane.java
/* 
 Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)

 This file is part of Follow (http://follow.sf.net).

 Follow is free software; you can redistribute it and/or modify
 it under the terms of version 2 of the GNU General Public
 License as published by the Free Software Foundation.

 Follow is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Follow; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package ghm.follow.gui;

import ghm.follow.config.FollowAppAttributes;
import java.awt.Component;
import java.awt.Container;
import java.io.File;
import javax.swing.JTabbedPane;

/**
 * Derived from a workaround proposed by sqrrrl for bug <a
 * href=""http://developer.java.sun.com/developer/bugParade/bugs/4193463.html"" >4193463</a>. This
 * bug was causing drag-and-drop to behave incorrectly for all but the first tab.
 */
public class TabbedPane extends JTabbedPane {

    private FollowAppAttributes attributes = null;

    public TabbedPane(FollowAppAttributes attributes) {
        super(attributes.getTabPlacement());
        this.attributes = attributes;
    }

    /**
     * sqrrrl's fix
     */
    public Component findComponentAt(int x, int y) {
        if (!contains(x, y)) {
            return null;
        }
        int ncomponents = getComponentCount();
        for (int i = 0; i < ncomponents; i++) {
            Component comp = getComponentAt(i);
            if (comp != null) {
                if (comp instanceof Container) {
                    if (comp.isVisible()) {
                        comp = ((Container) comp).findComponentAt(x - comp.getX(), y - comp.getY());
                    }
                } else {
                    comp = comp.getComponentAt(x - comp.getX(), y - comp.getY());
                }
                if (comp != null && comp.isVisible()) {
                    return comp;
                }
            }
        }
        return this;
    }

    public void setSelectedIndex(int index) {
        super.setSelectedIndex(index);
        handleSelectedFile();
    }

    public void setSelectedComponent(FileFollowingPane pane) {
        super.setSelectedComponent(pane);
        handleSelectedFile();
    }

    public void removeTabAt(int index) {
        super.removeTabAt(index);
        handleSelectedFile();
    }

    private void handleSelectedFile() {
        FileFollowingPane pane = (FileFollowingPane) getSelectedComponent();
        if (pane != null) {
            File parent = pane.getFollowedFile().getParentFile();
            attributes.setLastFileChooserDirectory(parent);
        }
    }
}
","// TabbedPaneTest.java
package ghm.follow.gui;

import ghm.follow.config.FollowAppAttributes;
import java.awt.Component;
import java.awt.Container;
import java.io.File;
import javax.swing.JTabbedPane;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TabbedPane}.
* It contains ten unit test cases for the {@link TabbedPane#findComponentAt(int, int)} method.
*/
class TabbedPaneTest {","// TabbedPaneTest.java
package ghm.follow.gui;

import ghm.follow.config.FollowAppAttributes;
import java.awt.Component;
import java.awt.Container;
import java.io.File;
import javax.swing.JTabbedPane;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TabbedPane}.
* It contains ten unit test cases for the {@link TabbedPane#findComponentAt(int, int)} method.
*/
class TabbedPaneTest {

		private FollowAppAttributes attributes = null;
		private TabbedPane tabbedPane = null;
		
		public TabbedPaneTest() {
				attributes = new FollowAppAttributes();
				tabbedPane = new TabbedPane(attributes);
		}
		
		/**
		* Test of findComponentAt method, of class TabbedPane.
		*/
		@Test
		public void testFindComponentAt() {
				System.out.println(""findComponentAt"");
				
				// Test case 1
				int x = 0;
				int y = 0;
				Component expResult = tabbedPane;
				Component result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 2
				x = -1;
				y = -1;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 3
				x = 1;
				y = 1;
				expResult = tabbedPane;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 4
				x = -1;
				y = 1;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 5
				x = 1;
				y = -1;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 6
				x = 0;
				y = 1;
				expResult = tabbedPane;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 7
				x = 1;
				y = 0;
				expResult = tabbedPane;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 8
				x = 0;
				y = -1;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 9
				x = -1;
				y = 0;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
				
				// Test case 10
				x = -1;
				y = 1;
				expResult = null;
				result = tabbedPane.findComponentAt(x, y);
				assertEquals(expResult, result);
		}
}"
cmpl-6tsLseKjPse85fPjiYi4xXKBdl3tC,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java,92.59246277809143,length,"// JTextComponentDestination.java
/* 
 Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)

 This file is part of Follow (http://follow.sf.net).

 Follow is free software; you can redistribute it and/or modify
 it under the terms of version 2 of the GNU General Public
 License as published by the Free Software Foundation.

 Follow is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Follow; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.
 *
 * @see OutputDestination
 * @see JTextCompnent
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextComponentDestination extends FilterableOutputDestination {

    private static final Logger LOG = Logger.getLogger(JTextComponentDestination.class.getName());

    protected JTextComponent comp;

    protected boolean autoPositionCaret;

    /**
     * Construct a new JTextCompnentDestination.
     *
     * @param jTextPane
     *            text will be appended to this text area
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public JTextComponentDestination(JTextComponent comp, boolean autoPositionCaret) {
        this.comp = comp;
        this.autoPositionCaret = autoPositionCaret;
    }

    public JTextComponent getJTextComponent() {
        return comp;
    }

    public void setJTextComponent(JTextComponent comp) {
        this.comp = comp;
    }

    /**
     * Add a filtered view to this destination. Filtered views show only a subset of the total
     * output based on filter conditions.
     *
     * @since 1.8.0
     */
    public void addFilteredView() {
    }

    /**
     * Remove a filtered view
     *
     * @since 1.8.0
     */
    public void removeFilteredView() {
    }

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret() {
        return autoPositionCaret;
    }

    /**
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public void setAutoPositionCaret(boolean autoPositionCaret) {
        this.autoPositionCaret = autoPositionCaret;
    }

    public void handlePrint(String s) {
        try {
            comp.getDocument().insertString(comp.getDocument().getLength(), s, null);
            if (autoPositionCaret) {
                comp.setCaretPosition(comp.getDocument().getLength());
            }
        } catch (BadLocationException e) {
            // just ignore, nothing we can do
            LOG.log(Level.SEVERE, ""BadLocationException in JTextComponentDestination"", e);
        }
    }

    public void clear() {
        comp.setText("""");
        if (autoPositionCaret) {
            comp.setCaretPosition(0);
        }
    }
}
","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains ten unit test cases for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {","// JTextComponentDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextComponentDestination}.
* It contains ten unit test cases for the {@link JTextComponentDestination#autoPositionCaret()} method.
*/
class JTextComponentDestinationTest {

		private static final Logger LOG = Logger.getLogger(JTextComponentDestinationTest.class.getName());
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns true when the caret is automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, true);
				assertTrue(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns false when the caret is not automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret2() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, false);
				assertFalse(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns true when the caret is automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret3() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, true);
				assertTrue(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns false when the caret is not automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret4() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, false);
				assertFalse(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns true when the caret is automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret5() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, true);
				assertTrue(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns false when the caret is not automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret6() {
				JTextComponentDestination jTextComponentDestination = new JTextComponentDestination(new JTextComponent() {
						@Override
						public void setCaretPosition(int position) {
								assertEquals(0, position);
						}
						
						@Override
						public int getCaretPosition() {
								return 0;
						}
						
						@Override
						public void setText(String t) {
								assertEquals("""", t);
						}
						
						@Override
						public String getText() {
								return """";
						}
						
						@Override
						public void replaceSelection(String content) {
								assertEquals("""", content);
						}
						
						@Override
						public void insert(String str, int pos) {
								assertEquals("""", str);
								assertEquals(0, pos);
						}
						
						@Override
						public int getDocument().getLength() {
								return 0;
						}
						
						@Override
						public void getDocument().insertString(int offs, String str, AttributeSet a) throws BadLocationException {
								assertEquals(0, offs);
								assertEquals("""", str);
								assertEquals(null, a);
						}
				}, false);
				assertFalse(jTextComponentDestination.autoPositionCaret());
		}
		
		/**
		* Test case for {@link JTextComponentDestination#autoPositionCaret()} method.
		* This test case checks if the method returns true when the caret is automatically moved to the bottom of the text area when text is appended.
		*/
		@Test
		public void testAutoPositionCaret7() {
				JTextComponentDestination jTextComponent"
cmpl-6tsNN8v7P1GkH6f6zvg77MbTYvRJx,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java,99.18200731277466,length,"// JTextPaneDestination.java
/* 
 Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)

 This file is part of Follow (http://follow.sf.net).

 Follow is free software; you can redistribute it and/or modify
 it under the terms of version 2 of the GNU General Public
 License as published by the Free Software Foundation.

 Follow is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Follow; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;

/**
 * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.
 *
 * @see OutputDestination
 * @see JTextPane
 * @author <a href=""mailto:carl.hall@gmail.com"">Carl Hall</a>
 */
public class JTextPaneDestination implements OutputDestination {

    private Logger log = Logger.getLogger(JTextPaneDestination.class.getName());

    protected JTextPane jTextPane;

    protected boolean autoPositionCaret;

    /**
     * Construct a new JTextPaneDestination.
     *
     * @param jTextPane
     *            text will be appended to this text area
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public JTextPaneDestination(JTextPane jTextPane, boolean autoPositionCaret) {
        this.jTextPane = jTextPane;
        this.autoPositionCaret = autoPositionCaret;
    }

    public JTextPane getJTextPane() {
        return jTextPane;
    }

    public void setJTextArea(JTextPane jTextPane) {
        this.jTextPane = jTextPane;
    }

    /**
     * Add a filtered view to this destination. Filtered views show only a subset of the total
     * output based on filter conditions.
     *
     * @since 1.8.0
     */
    public void addFilteredView() {
    }

    /**
     * Remove a filtered view
     *
     * @since 1.8.0
     */
    public void removeFilteredView() {
    }

    /**
     * @return whether caret will be automatically moved to the bottom of the text area when text is
     *         appended
     */
    public boolean autoPositionCaret() {
        return autoPositionCaret;
    }

    /**
     * @param autoPositionCaret
     *            if true, caret will be automatically moved to the bottom of the text area when
     *            text is appended
     */
    public void setAutoPositionCaret(boolean autoPositionCaret) {
        this.autoPositionCaret = autoPositionCaret;
    }

    public void print(String s) {
        try {
            jTextPane.getDocument().insertString(jTextPane.getDocument().getLength(), s, null);
            if (autoPositionCaret) {
                jTextPane.setCaretPosition(jTextPane.getDocument().getLength());
            }
        } catch (BadLocationException e) {
            // just ignore, nothing we can do
            log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestination"", e);
        }
    }

    public void clear() {
        jTextPane.setText("""");
        if (autoPositionCaret) {
            jTextPane.setCaretPosition(0);
        }
    }
}
","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains ten unit test cases for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {","// JTextPaneDestinationTest.java
package ghm.follow.io;

import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JTextPaneDestination}.
* It contains ten unit test cases for the {@link JTextPaneDestination#autoPositionCaret()} method.
*/
class JTextPaneDestinationTest {

	private static final Logger log = Logger.getLogger(JTextPaneDestinationTest.class.getName());
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret2() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret2() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret3() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret3() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret4() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret4() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret5() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret5() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret6() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret6() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret7() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret7() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret8() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is not automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testNotAutoPositionCaret8() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, false);
		jTextPaneDestination.print(""test"");
		try {
			assertNotEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#autoPositionCaret()} method.
	* It tests the case when the caret is automatically moved to the bottom of the text area when text is appended.
	*/
	@Test
	void testAutoPositionCaret9() {
		JTextPane jTextPane = new JTextPane();
		JTextPaneDestination jTextPaneDestination = new JTextPaneDestination(jTextPane, true);
		jTextPaneDestination.print(""test"");
		try {
			assertEquals(jTextPane.getDocument().getLength(), jTextPane.getCaretPosition());
		} catch (BadLocationException e) {
			// just ignore, nothing we can do
			log.log(Level.SEVERE, ""BadLocationException in JTextPaneDestinationTest"", e);
		}
	}
	
	/**
	* Test case for {@link JTextPaneDestination#auto"
cmpl-6tsOyW7AOJYNulzwxUGjJKAKDIVu6,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/LineResult.java,122.78457808494568,length,"// LineResult.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Keeps results information about a line in the searchable text.
 *
 * @author Carl Hall (carl.hall@gmail.com)
 */
public class LineResult {

    // line position of the found term
    public int lineNumber;

    // starting caret position
    public int start;

    // ending caret position
    public int end;

    // word results found on this line
    private List<WordResult> wordResults;

    // keeps track of lower caret position for display scrolling
    private int firstPosition;

    /**
     * Constructor
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param lineNumber
     */
    public LineResult(int lineNumber, int start, int end) {
        wordResults = new ArrayList<WordResult>();
        this.lineNumber = lineNumber;
        this.start = start;
        this.end = end;
        firstPosition = Integer.MAX_VALUE;
    }

    /**
     * Get the word results associated with this line.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @return
     */
    public List<WordResult> getWordResults() {
        return wordResults;
    }

    /**
     * Get a specific word result associated with this line.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param index
     * @return
     */
    public WordResult getWordResult(int index) {
        return (WordResult) wordResults.get(index);
    }

    /**
     * Get the caret position of the first occurring word result on this line.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @return
     */
    public int getFirstWordPosition() {
        return firstPosition;
    }

    /**
     * Add a <code>WordResult</code> to this line
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param wordResult
     */
    public void addWord(WordResult wordResult) {
        wordResult.parent = this;
        if (wordResult.start < firstPosition) {
            firstPosition = wordResult.start;
        }
        wordResults.add(wordResult);
    }

    /**
     * Builds a string that is conducive for showing as a result list entry
     *
     * @author Carl Hall (carl.hall@gmail.com)
     */
    public String toString() {
        StringBuffer retval = new StringBuffer(""Line "" + lineNumber);
        if (wordResults.size() > 0) {
            retval.append("" ("");
            Iterator<WordResult> words = wordResults.iterator();
            while (words.hasNext()) {
                WordResult word = words.next();
                String wordString = word.toString();
                if (wordString.length() > 0) {
                    retval.append(wordString);
                    if (words.hasNext()) {
                        retval.append("","");
                    }
                }
            }
            retval.append("")"");
        }
        return retval.toString();
    }
}
","// LineResultTest.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LineResult}.
* It contains ten unit test cases for the {@link LineResult#getWordResult(int)} method.
*/
class LineResultTest {","// LineResultTest.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LineResult}.
* It contains ten unit test cases for the {@link LineResult#getWordResult(int)} method.
*/
class LineResultTest {

		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is negative.
		*/
		@Test
		public void testGetWordResult_NegativeIndex() {
				LineResult lineResult = new LineResult(1, 1, 1);
				WordResult wordResult = new WordResult(1, 1, 1);
				lineResult.addWord(wordResult);
				assertNull(lineResult.getWordResult(-1));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is zero.
		*/
		@Test
		public void testGetWordResult_ZeroIndex() {
				LineResult lineResult = new LineResult(1, 1, 1);
				WordResult wordResult = new WordResult(1, 1, 1);
				lineResult.addWord(wordResult);
				assertEquals(wordResult, lineResult.getWordResult(0));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is positive.
		*/
		@Test
		public void testGetWordResult_PositiveIndex() {
				LineResult lineResult = new LineResult(1, 1, 1);
				WordResult wordResult = new WordResult(1, 1, 1);
				lineResult.addWord(wordResult);
				assertNull(lineResult.getWordResult(1));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is equal to the size of the list.
		*/
		@Test
		public void testGetWordResult_IndexEqualToSize() {
				LineResult lineResult = new LineResult(1, 1, 1);
				WordResult wordResult = new WordResult(1, 1, 1);
				lineResult.addWord(wordResult);
				assertNull(lineResult.getWordResult(1));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is greater than the size of the list.
		*/
		@Test
		public void testGetWordResult_IndexGreaterThanSize() {
				LineResult lineResult = new LineResult(1, 1, 1);
				WordResult wordResult = new WordResult(1, 1, 1);
				lineResult.addWord(wordResult);
				assertNull(lineResult.getWordResult(2));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is negative and the list is empty.
		*/
		@Test
		public void testGetWordResult_NegativeIndexEmptyList() {
				LineResult lineResult = new LineResult(1, 1, 1);
				assertNull(lineResult.getWordResult(-1));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is zero and the list is empty.
		*/
		@Test
		public void testGetWordResult_ZeroIndexEmptyList() {
				LineResult lineResult = new LineResult(1, 1, 1);
				assertNull(lineResult.getWordResult(0));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is positive and the list is empty.
		*/
		@Test
		public void testGetWordResult_PositiveIndexEmptyList() {
				LineResult lineResult = new LineResult(1, 1, 1);
				assertNull(lineResult.getWordResult(1));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is equal to the size of the list and the list is empty.
		*/
		@Test
		public void testGetWordResult_IndexEqualToSizeEmptyList() {
				LineResult lineResult = new LineResult(1, 1, 1);
				assertNull(lineResult.getWordResult(0));
		}
		
		/**
		* Test case for {@link LineResult#getWordResult(int)} method.
		* It tests the case when the index is greater than the size of the list and the list is empty.
		*/
		@Test
		public void testGetWordResult_IndexGreaterThanSizeEmptyList() {
				LineResult lineResult = new LineResult(1, 1, 1);
				assertNull(lineResult.getWordResult(1));
		}
}

// WordResult.java
package ghm.follow.search;

/**
 * Keeps results information about a word in the searchable text.
 *
 * @author Carl Hall (carl.hall@gmail.com)
 */
public class WordResult {

    // word position of the found term
    public int wordNumber;

    // starting caret position
    public int start;

    // ending caret position
    public int end;

    // parent line result
    public LineResult parent;

    /**
     * Constructor
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param wordNumber
     * @param start
     * @param end
     */
    public WordResult(int wordNumber, int start, int end) {
        this.wordNumber = wordNumber;
        this.start = start;
        this.end = end;
    }

    /**
     * Builds a string that is conducive for showing as a result list entry
     *
     * @author Carl Hall (carl.hall@gmail.com)
     */
    public String toString() {
        return ""Word "" + wordNumber;
    }
}

// WordResultTest.java
package ghm.follow.search;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link WordResult}.
* It contains ten unit test cases for the {@link WordResult#toString()} method.
*/
class WordResultTest {
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is negative.
		*/
		@Test
		public void testToString_NegativeWordNumber() {
				WordResult wordResult = new WordResult(-1, 1, 1);
				assertEquals(""Word -1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is zero.
		*/
		@Test
		public void testToString_ZeroWordNumber() {
				WordResult wordResult = new WordResult(0, 1, 1);
				assertEquals(""Word 0"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is positive.
		*/
		@Test
		public void testToString_PositiveWordNumber() {
				WordResult wordResult = new WordResult(1, 1, 1);
				assertEquals(""Word 1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is negative and the start and end are negative.
		*/
		@Test
		public void testToString_NegativeWordNumberNegativeStartEnd() {
				WordResult wordResult = new WordResult(-1, -1, -1);
				assertEquals(""Word -1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is zero and the start and end are zero.
		*/
		@Test
		public void testToString_ZeroWordNumberZeroStartEnd() {
				WordResult wordResult = new WordResult(0, 0, 0);
				assertEquals(""Word 0"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is positive and the start and end are positive.
		*/
		@Test
		public void testToString_PositiveWordNumberPositiveStartEnd() {
				WordResult wordResult = new WordResult(1, 1, 1);
				assertEquals(""Word 1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is negative and the start and end are zero.
		*/
		@Test
		public void testToString_NegativeWordNumberZeroStartEnd() {
				WordResult wordResult = new WordResult(-1, 0, 0);
				assertEquals(""Word -1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is zero and the start and end are negative.
		*/
		@Test
		public void testToString_ZeroWordNumberNegativeStartEnd() {
				WordResult wordResult = new WordResult(0, -1, -1);
				assertEquals(""Word 0"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is positive and the start and end are zero.
		*/
		@Test
		public void testToString_PositiveWordNumberZeroStartEnd() {
				WordResult wordResult = new WordResult(1, 0, 0);
				assertEquals(""Word 1"", wordResult.toString());
		}
		
		/**
		* Test case for {@link WordResult#toString()} method.
		* It tests the case when the word number is zero and the start and end are positive.
		*/
		@Test
		public void testToString_ZeroWordNumberPositiveStartEnd() {
				WordResult wordResult = new WordResult(0, 1, 1);
				assertEquals(""Word 0"", wordResult.toString());
		}
}

// SearchResult.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Keeps results information about a search.
 *
 * @author Carl Hall (carl.hall@gmail.com)
 */
public class SearchResult {

    // search term
    public String term;

    // line results found
    private List<LineResult> lineResults;

    // keeps track of lower caret position for display scrolling
    private int firstPosition;

    /**
     * Constructor
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param term
     */
    public SearchResult(String term) {
        lineResults = new ArrayList<LineResult>();
        this.term = term;
        firstPosition = Integer.MAX_VALUE;
    }

    /**
     * Get the line results associated with this search.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @return
     */
    public List<LineResult> getLineResults() {
        return lineResults;
    }

    /**
     * Get a specific line result associated with this search.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param index
     * @return
     */
    public LineResult getLineResult(int index) {
        return (LineResult) lineResults.get(index);
    }

    /**
     * Get the caret position of the first occurring line result in this search.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @return
     */
    public int getFirstLinePosition() {
        return firstPosition;
    }

    /**
     * Add a <code>LineResult</code> to this search
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param lineResult
     */
    public void addLine(LineResult lineResult) {
        if (lineResult.start < firstPosition) {
            firstPosition = lineResult.start;
        }
        lineResults.add(lineResult);
    }

    /**
     * Builds a string that is conducive for showing as a result list entry
     *
     * @author Carl Hall (carl.hall@gmail.com)
     */
    public String toString() {
        StringBuffer retval = new StringBuffer(""Search for \"""" + term + ""\"""");
        if (lineResults.size() > 0) {
            retval.append("" ("");
            Iterator<LineResult> lines = lineResults.iterator();
            while (lines.hasNext()) {
                LineResult line = lines.next();
                String lineString = line.toString();
                if (lineString.length() > 0) {
                    retval.append(lineString);
                    if (lines.hasNext()) {
                        retval.append("","");
                    }
                }
            }
            retval.append("")"");
        }
        return retval.toString();
    }
}

// SearchResultTest.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchResult}.
* It contains ten unit test cases for the {@link SearchResult#getLineResult(int)} method.
*/
class SearchResultTest {
		
		/**
		* Test case for {@link SearchResult#getLineResult(int)} method.
		* It tests the case when the index is negative.
		*/
		@Test
		public void testGetLineResult_NegativeIndex() {
				SearchResult searchResult = new SearchResult(""test"");
				LineResult lineResult = new LineResult(1, 1, 1);
				searchResult.addLine(lineResult);
				assertNull(searchResult.getLineResult(-1));
		}
		
		/**
		* Test case for {@link SearchResult#getLineResult(int)} method.
		* It tests the case when the index is zero.
		*/
		@Test
		public void testGetLineResult_ZeroIndex() {
				SearchResult searchResult = new SearchResult(""test"");
				LineResult lineResult = new LineResult(1, 1, 1);
				searchResult.addLine(lineResult);
				assertEquals(lineResult, searchResult.getLineResult(0));
		}
		
		/**
		* Test case for {@link SearchResult#getLineResult(int)} method.
	"
cmpl-6tsQxGtb4Ob9a6JRuQnL4s7i4dNmb,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchEngine.java,35.762561082839966,stop,"// SearchEngine.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Searches through text based on flags passed at time of search.
 *
 * @author Carl Hall (carl.hall@gmail.com)
 */
public class SearchEngine {

    public static final int CASE_SENSITIVE = 1;

    public static final int REGEX = 2;

    private int flags;

    /**
     * Constructor for search text and tracking display elements for results list
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param textPane
     */
    public SearchEngine(int flags) {
        this.flags = flags;
    }

    /**
     * Search for <code>term</code>. Use the constants of this class for flags.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param term
     * @return An array of found positions of term
     */
    public List<WordResult> search(String term, String text) {
        List<WordResult> retval = null;
        // search using a case sensitive regular expression
        if (((flags & CASE_SENSITIVE) != 0) && ((flags & REGEX) != 0)) {
            Pattern p = Pattern.compile(term, Pattern.MULTILINE);
            retval = regexSearch(p, text);
        } else // search using a case insensitive regular expression
        if ((flags & REGEX) != 0) {
            Pattern p = Pattern.compile(term, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
            retval = regexSearch(p, text);
        } else // search by case sensitive text
        if ((flags & CASE_SENSITIVE) != 0) {
            retval = textSearch(term, text);
        } else // search by case insensitive text
        if (flags == 0) {
            retval = textSearch(term.toLowerCase(), text.toLowerCase());
        } else // fail due to unknown flags
        {
            throw new IllegalArgumentException(""Unknown search strategy requested [flags="" + flags);
        }
        return retval;
    }

    /**
     * Searches <code>text</code> for <code>term</code> by performing a simple text search.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param term
     * @param text
     * @return
     */
    protected List<WordResult> textSearch(String term, String text) {
        ArrayList<WordResult> results = new ArrayList<WordResult>();
        if (term != null && term.length() > 0 && text != null && text.length() > 0) {
            int pos = 0;
            while ((pos = text.indexOf(term, pos)) > -1) {
                results.add(new WordResult(pos, pos + term.length(), term));
                pos += term.length();
                // allow other things to happen in case the search takes a while
                Thread.yield();
            }
        }
        return results;
    }

    /**
     * Searches <code>text</code> using the provided <code>Pattern</code><br>
     * <br>
     * Thanks to prec in #regex for correcting the use of Matcher.
     *
     * @author Carl Hall (carl.hall@gmail.com)
     * @param p
     * @param text
     * @return
     */
    protected List<WordResult> regexSearch(Pattern p, String text) {
        Matcher m = p.matcher(text);
        ArrayList<WordResult> results = new ArrayList<WordResult>();
        while (m.find()) {
            results.add(new WordResult(m.start(), m.end(), m.group()));
            Thread.yield();
        }
        return results;
    }
}
","// SearchEngineTest.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchEngine}.
* It contains ten unit test cases for the {@link SearchEngine#search(String, String)} method.
*/
class SearchEngineTest {","// SearchEngineTest.java
package ghm.follow.search;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchEngine}.
* It contains ten unit test cases for the {@link SearchEngine#search(String, String)} method.
*/
class SearchEngineTest {

		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is null.
		*/
		@Test
		void testSearch_NullTerm() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(null, ""Hello World"");
				assertEquals(0, results.size());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is empty.
		*/
		@Test
		void testSearch_EmptyTerm() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search("""", ""Hello World"");
				assertEquals(0, results.size());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the text is null.
		*/
		@Test
		void testSearch_NullText() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(""Hello"", null);
				assertEquals(0, results.size());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the text is empty.
		*/
		@Test
		void testSearch_EmptyText() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(""Hello"", """");
				assertEquals(0, results.size());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is not found in the text.
		*/
		@Test
		void testSearch_TermNotFound() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(""Hello"", ""World"");
				assertEquals(0, results.size());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found in the text.
		*/
		@Test
		void testSearch_TermFound() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(""Hello"", ""Hello World"");
				assertEquals(1, results.size());
				assertEquals(0, results.get(0).getStart());
				assertEquals(5, results.get(0).getEnd());
				assertEquals(""Hello"", results.get(0).getWord());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found multiple times in the text.
		*/
		@Test
		void testSearch_TermFoundMultipleTimes() {
				SearchEngine searchEngine = new SearchEngine(0);
				List<WordResult> results = searchEngine.search(""Hello"", ""Hello World Hello World"");
				assertEquals(2, results.size());
				assertEquals(0, results.get(0).getStart());
				assertEquals(5, results.get(0).getEnd());
				assertEquals(""Hello"", results.get(0).getWord());
				assertEquals(11, results.get(1).getStart());
				assertEquals(16, results.get(1).getEnd());
				assertEquals(""Hello"", results.get(1).getWord());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found multiple times in the text.
		*/
		@Test
		void testSearch_TermFoundMultipleTimesWithCaseSensitive() {
				SearchEngine searchEngine = new SearchEngine(SearchEngine.CASE_SENSITIVE);
				List<WordResult> results = searchEngine.search(""Hello"", ""Hello World hello World"");
				assertEquals(1, results.size());
				assertEquals(0, results.get(0).getStart());
				assertEquals(5, results.get(0).getEnd());
				assertEquals(""Hello"", results.get(0).getWord());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found multiple times in the text.
		*/
		@Test
		void testSearch_TermFoundMultipleTimesWithRegex() {
				SearchEngine searchEngine = new SearchEngine(SearchEngine.REGEX);
				List<WordResult> results = searchEngine.search(""Hello"", ""Hello World hello World"");
				assertEquals(2, results.size());
				assertEquals(0, results.get(0).getStart());
				assertEquals(5, results.get(0).getEnd());
				assertEquals(""Hello"", results.get(0).getWord());
				assertEquals(11, results.get(1).getStart());
				assertEquals(16, results.get(1).getEnd());
				assertEquals(""hello"", results.get(1).getWord());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found multiple times in the text.
		*/
		@Test
		void testSearch_TermFoundMultipleTimesWithRegexAndCaseSensitive() {
				SearchEngine searchEngine = new SearchEngine(SearchEngine.REGEX | SearchEngine.CASE_SENSITIVE);
				List<WordResult> results = searchEngine.search(""Hello"", ""Hello World hello World"");
				assertEquals(1, results.size());
				assertEquals(0, results.get(0).getStart());
				assertEquals(5, results.get(0).getEnd());
				assertEquals(""Hello"", results.get(0).getWord());
		}
		
		/**
		* Test case for {@link SearchEngine#search(String, String)} method.
		* It tests the case when the search term is found multiple times in the text.
		*/
		@Test
		void testSearch_TermFoundMultipleTimesWithRegexAndCaseSensitiveAndUnknownFlags() {
				SearchEngine searchEngine = new SearchEngine(SearchEngine.REGEX | SearchEngine.CASE_SENSITIVE | 4);
				assertThrows(IllegalArgumentException.class, () -&gt; searchEngine.search(""Hello"", ""Hello World hello World""));
		}
}</code>



"
cmpl-6tsS00yJAZlpqUSxGH7cvJ936yfWb,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_0Test.java,139.81279253959656,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());

    private int lastSearchPos = -1;

    private String lastSearchTerm;

    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);

    public SearchableTextPane(Font font, int tabSize) {
        // set the display font
        setFont(font);
        setTabSize(tabSize);
    }

    /**
     * Override this to keep the text from wrapping and to make the viewable area as wide as the
     * tabbed pane
     */
    public boolean getScrollableTracksViewportWidth() {
        Component parent = getParent();
        ComponentUI ui = getUI();
        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;
    }

    /**
     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
     * line on which the term is found.
     *
     * @param term
     * @param caseSensitive
     * @param useRegularExpression
     * @return
     */
    public List<LineResult> highlight(String term, int flags) {
        List<LineResult> lineResults = new ArrayList<LineResult>();
        // Remove all old highlights
        removeHighlights();
        // Search for pattern
        if ((term != null) && (term.length() > 0)) {
            // look for instances of the term in the text
            try {
                Document doc = getDocument();
                String text = doc.getText(0, doc.getLength());
                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);
                lineResults = convertWords2Lines(searchResults);
                for (LineResult lineResult : lineResults) {
                    List<WordResult> wordResults = lineResult.getWordResults();
                    for (WordResult wordResult : wordResults) {
                        // highlight the searched term
                        int wordStart = wordResult.start;
                        int wordEnd = wordResult.end;
                        addHighlight(wordStart, wordEnd - wordStart);
                        Thread.yield();
                    }
                }
            } catch (BadLocationException e) {
                log.log(Level.SEVERE, ""BadLocationException in SearchableTextPane"", e);
                lineResults = new ArrayList<LineResult>();
            }
        }
        return lineResults;
    }

    /**
     * Highlight a piece of text in the document
     *
     * @param start
     * @param wordEnd
     * @param highlighter
     */
    private void addHighlight(int start, int length) throws BadLocationException {
        getHighlighter().addHighlight(start, start + length, wordPainter);
    }

    /**
     * Removes highlights from text area
     */
    public void removeHighlights() {
        getHighlighter().removeAllHighlights();
    }

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term) {
        if (term != null && term.length() > 0) {
            if (term.equals(lastSearchTerm)) {
                // assume to start at the beginning
                int pos = 0;
                // if there is a previous search position, start there plus the
                // length
                // of the last term so that last term again isn't found again
                if (lastSearchPos != -1) {
                    pos = lastSearchPos + lastSearchTerm.length();
                }
                lastSearchPos = search(lastSearchTerm, pos);
            } else {
                lastSearchPos = search(term, 0);
            }
        }
        // remember the term if it was found
        if (lastSearchPos == -1) {
            lastSearchTerm = null;
        } else {
            lastSearchTerm = term;
        }
        return lastSearchPos;
    }

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @param startPos
     *            Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos) {
        int pos = 0;
        try {
            Document doc = getDocument();
            String text = doc.getText(0, doc.getLength());
            // Search for pattern
            pos = text.indexOf(term, startPos);
        } catch (BadLocationException e) {
            // just return -1;
            log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
            pos = -1;
        }
        return pos;
    }

    /**
     * Converts word results from search into line results
     *
     * @param words
     * @return
     */
    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {
        ArrayList<LineResult> lines = new ArrayList<LineResult>();
        LineResult tempLine = null;
        int lastLine = -1;
        for (WordResult word : words) {
            int line = getLineOfOffset(word.start);
            if (line != lastLine) {
                if (tempLine != null) {
                    lines.add(tempLine);
                }
                Element elem = Utilities.getParagraphElement(this, word.start);
                int lineStart = elem.getStartOffset();
                int lineEnd = elem.getEndOffset();
                tempLine = new LineResult(line, lineStart, lineEnd);
            }
            updateWordResult(word, tempLine);
            lastLine = line;
            // allow other things to happen in case the search takes a while
            Thread.yield();
        }
        if (tempLine != null) {
            lines.add(tempLine);
        }
        return lines;
    }

    /**
     * Adds word result to line result and updates line information
     *
     * @param wordResult
     * @param lineResult
     */
    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {
        lineResult.addWord(wordResult);
        // increase by 1 because offset starts at 0.
        // 1 is clearer to the user since most people don't start counting
        // at 0
        int line = getLineOfOffset(wordResult.start);
        wordResult.parent.lineNumber = line + 1;
        int lineOffset = getLineStartOffset(line);
        wordResult.setLineOffset(lineOffset);
    }
}
","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#highlight(String, int)} method.
*/
class SearchableTextPane_0Test {","// SearchableTextPane_0Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#highlight(String, int)} method.
*/
class SearchableTextPane_0Test {

		/**
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}.
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int)}
		* </p>
		* <p>
		* Test case for the method {@link SearchableTextPane#highlight(String, int"
cmpl-6tsUGr05q04skYNeddvN0Noz63vtn,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java,111.88633441925049,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());

    private int lastSearchPos = -1;

    private String lastSearchTerm;

    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);

    public SearchableTextPane(Font font, int tabSize) {
        // set the display font
        setFont(font);
        setTabSize(tabSize);
    }

    /**
     * Override this to keep the text from wrapping and to make the viewable area as wide as the
     * tabbed pane
     */
    public boolean getScrollableTracksViewportWidth() {
        Component parent = getParent();
        ComponentUI ui = getUI();
        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;
    }

    /**
     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
     * line on which the term is found.
     *
     * @param term
     * @param caseSensitive
     * @param useRegularExpression
     * @return
     */
    public List<LineResult> highlight(String term, int flags) {
        List<LineResult> lineResults = new ArrayList<LineResult>();
        // Remove all old highlights
        removeHighlights();
        // Search for pattern
        if ((term != null) && (term.length() > 0)) {
            // look for instances of the term in the text
            try {
                Document doc = getDocument();
                String text = doc.getText(0, doc.getLength());
                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);
                lineResults = convertWords2Lines(searchResults);
                for (LineResult lineResult : lineResults) {
                    List<WordResult> wordResults = lineResult.getWordResults();
                    for (WordResult wordResult : wordResults) {
                        // highlight the searched term
                        int wordStart = wordResult.start;
                        int wordEnd = wordResult.end;
                        addHighlight(wordStart, wordEnd - wordStart);
                        Thread.yield();
                    }
                }
            } catch (BadLocationException e) {
                log.log(Level.SEVERE, ""BadLocationException in SearchableTextPane"", e);
                lineResults = new ArrayList<LineResult>();
            }
        }
        return lineResults;
    }

    /**
     * Highlight a piece of text in the document
     *
     * @param start
     * @param wordEnd
     * @param highlighter
     */
    private void addHighlight(int start, int length) throws BadLocationException {
        getHighlighter().addHighlight(start, start + length, wordPainter);
    }

    /**
     * Removes highlights from text area
     */
    public void removeHighlights() {
        getHighlighter().removeAllHighlights();
    }

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term) {
        if (term != null && term.length() > 0) {
            if (term.equals(lastSearchTerm)) {
                // assume to start at the beginning
                int pos = 0;
                // if there is a previous search position, start there plus the
                // length
                // of the last term so that last term again isn't found again
                if (lastSearchPos != -1) {
                    pos = lastSearchPos + lastSearchTerm.length();
                }
                lastSearchPos = search(lastSearchTerm, pos);
            } else {
                lastSearchPos = search(term, 0);
            }
        }
        // remember the term if it was found
        if (lastSearchPos == -1) {
            lastSearchTerm = null;
        } else {
            lastSearchTerm = term;
        }
        return lastSearchPos;
    }

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @param startPos
     *            Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos) {
        int pos = 0;
        try {
            Document doc = getDocument();
            String text = doc.getText(0, doc.getLength());
            // Search for pattern
            pos = text.indexOf(term, startPos);
        } catch (BadLocationException e) {
            // just return -1;
            log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
            pos = -1;
        }
        return pos;
    }

    /**
     * Converts word results from search into line results
     *
     * @param words
     * @return
     */
    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {
        ArrayList<LineResult> lines = new ArrayList<LineResult>();
        LineResult tempLine = null;
        int lastLine = -1;
        for (WordResult word : words) {
            int line = getLineOfOffset(word.start);
            if (line != lastLine) {
                if (tempLine != null) {
                    lines.add(tempLine);
                }
                Element elem = Utilities.getParagraphElement(this, word.start);
                int lineStart = elem.getStartOffset();
                int lineEnd = elem.getEndOffset();
                tempLine = new LineResult(line, lineStart, lineEnd);
            }
            updateWordResult(word, tempLine);
            lastLine = line;
            // allow other things to happen in case the search takes a while
            Thread.yield();
        }
        if (tempLine != null) {
            lines.add(tempLine);
        }
        return lines;
    }

    /**
     * Adds word result to line result and updates line information
     *
     * @param wordResult
     * @param lineResult
     */
    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {
        lineResult.addWord(wordResult);
        // increase by 1 because offset starts at 0.
        // 1 is clearer to the user since most people don't start counting
        // at 0
        int line = getLineOfOffset(wordResult.start);
        wordResult.parent.lineNumber = line + 1;
        int lineOffset = getLineStartOffset(line);
        wordResult.setLineOffset(lineOffset);
    }
}
","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_1Test {","// SearchableTextPane_1Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#search(String)} method.
*/
class SearchableTextPane_1Test {

		private Logger log = Logger.getLogger(SearchableTextPane_1Test.class.getName());
		
		private int lastSearchPos = -1;
		
		private String lastSearchTerm;
		
		private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);
		
		public SearchableTextPane_1Test(Font font, int tabSize) {
				// set the display font
				setFont(font);
				setTabSize(tabSize);
		}
		
		/**
		* Override this to keep the text from wrapping and to make the viewable area as wide as the
		* tabbed pane
		*/
		public boolean getScrollableTracksViewportWidth() {
				Component parent = getParent();
				ComponentUI ui = getUI();
				return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;
		}
		
		/**
		* Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
		* line on which the term is found.
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		public List<LineResult> highlight(String term, int flags) {
				List<LineResult> lineResults = new ArrayList<LineResult>();
				// Remove all old highlights
				removeHighlights();
				// Search for pattern
				if ((term != null) && (term.length() > 0)) {
						// look for instances of the term in the text
						try {
								Document doc = getDocument();
								String text = doc.getText(0, doc.getLength());
								List<WordResult> searchResults = new SearchEngine(flags).search(term, text);
								lineResults = convertWords2Lines(searchResults);
								for (LineResult lineResult : lineResults) {
										List<WordResult> wordResults = lineResult.getWordResults();
										for (WordResult wordResult : wordResults) {
												// highlight the searched term
												int wordStart = wordResult.start;
												int wordEnd = wordResult.end;
												addHighlight(wordStart, wordEnd - wordStart);
												Thread.yield();
										}
								}
						} catch (BadLocationException e) {
								log.log(Level.SEVERE, ""BadLocationException in SearchableTextPane"", e);
								lineResults = new ArrayList<LineResult>();
						}
				}
				return lineResults;
		}
		
		/**
		* Highlight a piece of text in the document
		*
		* @param start
		* @param wordEnd
		* @param highlighter
		*/
		private void addHighlight(int start, int length) throws BadLocationException {
				getHighlighter().addHighlight(start, start + length, wordPainter);
		}
		
		/**
		* Removes highlights from text area
		*/
		public void removeHighlights() {
				getHighlighter().removeAllHighlights();
		}
		
		/**
		* Searches for a term. If the term provided matches the last searched term, the last found
		* position is used as a starting point.<br>
		* <br>
		* Developer note: this method isn't currently used.
		*
		* @param term
		*            The string for which to search.
		* @return The position where the term was found.<br>
		*         If the term is null, empty or not found, -1 is returned.
		*/
		public int search(String term) {
				if (term != null && term.length() > 0) {
						if (term.equals(lastSearchTerm)) {
								// assume to start at the beginning
								int pos = 0;
								// if there is a previous search position, start there plus the
								// length
								// of the last term so that last term again isn't found again
								if (lastSearchPos != -1) {
										pos = lastSearchPos + lastSearchTerm.length();
								}
								lastSearchPos = search(lastSearchTerm, pos);
						} else {
								lastSearchPos = search(term, 0);
						}
				}
				// remember the term if it was found
				if (lastSearchPos == -1) {
						lastSearchTerm = null;
				} else {
						lastSearchTerm = term;
				}
				return lastSearchPos;
		}
		
		/**
		* Searches for a term at the given starting position.<br>
		* <br>
		* Developer note: this method isn't currently used.
		*
		* @param term
		*            The string for which to search.
		* @param startPos
		*            Where to start.
		* @return The position where the term was found.<br>
		*         If the term is null, empty or not found, -1 is returned.
		*/
		public int search(String term, int startPos) {
				int pos = 0;
				try {
						Document doc = getDocument();
						String text = doc.getText(0, doc.getLength());
						// Search for pattern
						pos = text.indexOf(term, startPos);
				} catch (BadLocationException e) {
						// just return -1;
						log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
						pos = -1;
				}
				return pos;
		}
		
		/**
		* Converts word results from search into line results
		*
		* @param words
		* @return
		*/
		private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {
				ArrayList<LineResult> lines = new ArrayList<LineResult>();
				LineResult tempLine = null;
				int lastLine = -1;
				for (WordResult word : words) {
						int line = getLineOfOffset(word.start);
						if (line != lastLine) {
								if (tempLine != null) {
										lines.add(tempLine);
								}
								Element elem = Utilities.getParagraphElement(this, word.start);
								int lineStart = elem.getStartOffset();
								int lineEnd = elem.getEndOffset();
								tempLine = new LineResult(line, lineStart, lineEnd);
						}
						updateWordResult(word, tempLine);
						lastLine = line;
						// allow other things to happen in case the search takes a while
						Thread.yield();
				}
				if (tempLine != null) {
						lines.add(tempLine);
				}
				return lines;
		}
		
		/**
		* Adds word result to line result and updates line information
		*
		* @param wordResult
		* @param lineResult
		*/
		private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {
				lineResult.addWord(wordResult);
				// increase by 1 because offset starts at 0.
				// 1 is clearer to the user since most people don't start counting
				// at 0
				int line = getLineOfOffset(wordResult.start);
				wordResult.parent.lineNumber = line + 1;
				int lineOffset = getLineStartOffset(line);
				wordResult.setLineOffset(lineOffset);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_1() {
				// Test case 1
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_2() {
				// Test case 2
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_3() {
				// Test case 3
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_4() {
				// Test case 4
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_5() {
				// Test case 5
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_6() {
				// Test case 6
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_7() {
				// Test case 7
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_8() {
				// Test case 8
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_9() {
				// Test case 9
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link SearchableTextPane#search(String)}
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		@Test
		public void testSearch_10() {
				// Test case 10
				String term = """";
				int expected = -1;
				int actual = search(term);
				assertEquals(expected, actual);
		}
}

// SearchableTextPane_2Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org."
cmpl-6tsW4ItzH5594dQGAyeYOz2hS0jZT,/EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_2Test.java,102.55695796012878,length,"// SearchableTextPane.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea {

    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());

    private int lastSearchPos = -1;

    private String lastSearchTerm;

    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);

    public SearchableTextPane(Font font, int tabSize) {
        // set the display font
        setFont(font);
        setTabSize(tabSize);
    }

    /**
     * Override this to keep the text from wrapping and to make the viewable area as wide as the
     * tabbed pane
     */
    public boolean getScrollableTracksViewportWidth() {
        Component parent = getParent();
        ComponentUI ui = getUI();
        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;
    }

    /**
     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
     * line on which the term is found.
     *
     * @param term
     * @param caseSensitive
     * @param useRegularExpression
     * @return
     */
    public List<LineResult> highlight(String term, int flags) {
        List<LineResult> lineResults = new ArrayList<LineResult>();
        // Remove all old highlights
        removeHighlights();
        // Search for pattern
        if ((term != null) && (term.length() > 0)) {
            // look for instances of the term in the text
            try {
                Document doc = getDocument();
                String text = doc.getText(0, doc.getLength());
                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);
                lineResults = convertWords2Lines(searchResults);
                for (LineResult lineResult : lineResults) {
                    List<WordResult> wordResults = lineResult.getWordResults();
                    for (WordResult wordResult : wordResults) {
                        // highlight the searched term
                        int wordStart = wordResult.start;
                        int wordEnd = wordResult.end;
                        addHighlight(wordStart, wordEnd - wordStart);
                        Thread.yield();
                    }
                }
            } catch (BadLocationException e) {
                log.log(Level.SEVERE, ""BadLocationException in SearchableTextPane"", e);
                lineResults = new ArrayList<LineResult>();
            }
        }
        return lineResults;
    }

    /**
     * Highlight a piece of text in the document
     *
     * @param start
     * @param wordEnd
     * @param highlighter
     */
    private void addHighlight(int start, int length) throws BadLocationException {
        getHighlighter().addHighlight(start, start + length, wordPainter);
    }

    /**
     * Removes highlights from text area
     */
    public void removeHighlights() {
        getHighlighter().removeAllHighlights();
    }

    /**
     * Searches for a term. If the term provided matches the last searched term, the last found
     * position is used as a starting point.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term) {
        if (term != null && term.length() > 0) {
            if (term.equals(lastSearchTerm)) {
                // assume to start at the beginning
                int pos = 0;
                // if there is a previous search position, start there plus the
                // length
                // of the last term so that last term again isn't found again
                if (lastSearchPos != -1) {
                    pos = lastSearchPos + lastSearchTerm.length();
                }
                lastSearchPos = search(lastSearchTerm, pos);
            } else {
                lastSearchPos = search(term, 0);
            }
        }
        // remember the term if it was found
        if (lastSearchPos == -1) {
            lastSearchTerm = null;
        } else {
            lastSearchTerm = term;
        }
        return lastSearchPos;
    }

    /**
     * Searches for a term at the given starting position.<br>
     * <br>
     * Developer note: this method isn't currently used.
     *
     * @param term
     *            The string for which to search.
     * @param startPos
     *            Where to start.
     * @return The position where the term was found.<br>
     *         If the term is null, empty or not found, -1 is returned.
     */
    public int search(String term, int startPos) {
        int pos = 0;
        try {
            Document doc = getDocument();
            String text = doc.getText(0, doc.getLength());
            // Search for pattern
            pos = text.indexOf(term, startPos);
        } catch (BadLocationException e) {
            // just return -1;
            log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
            pos = -1;
        }
        return pos;
    }

    /**
     * Converts word results from search into line results
     *
     * @param words
     * @return
     */
    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {
        ArrayList<LineResult> lines = new ArrayList<LineResult>();
        LineResult tempLine = null;
        int lastLine = -1;
        for (WordResult word : words) {
            int line = getLineOfOffset(word.start);
            if (line != lastLine) {
                if (tempLine != null) {
                    lines.add(tempLine);
                }
                Element elem = Utilities.getParagraphElement(this, word.start);
                int lineStart = elem.getStartOffset();
                int lineEnd = elem.getEndOffset();
                tempLine = new LineResult(line, lineStart, lineEnd);
            }
            updateWordResult(word, tempLine);
            lastLine = line;
            // allow other things to happen in case the search takes a while
            Thread.yield();
        }
        if (tempLine != null) {
            lines.add(tempLine);
        }
        return lines;
    }

    /**
     * Adds word result to line result and updates line information
     *
     * @param wordResult
     * @param lineResult
     */
    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {
        lineResult.addWord(wordResult);
        // increase by 1 because offset starts at 0.
        // 1 is clearer to the user since most people don't start counting
        // at 0
        int line = getLineOfOffset(wordResult.start);
        wordResult.parent.lineNumber = line + 1;
        int lineOffset = getLineStartOffset(line);
        wordResult.setLineOffset(lineOffset);
    }
}
","// SearchableTextPane_2Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_2Test {","// SearchableTextPane_2Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SearchableTextPane}.
* It contains ten unit test cases for the {@link SearchableTextPane#search(String, int)} method.
*/
class SearchableTextPane_2Test {

		private Logger log = Logger.getLogger(SearchableTextPane_2Test.class.getName());
		
		private int lastSearchPos = -1;
		
		private String lastSearchTerm;
		
		private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);
		
		public SearchableTextPane_2Test(Font font, int tabSize) {
				// set the display font
				setFont(font);
				setTabSize(tabSize);
		}
		
		/**
		* Override this to keep the text from wrapping and to make the viewable area as wide as the
		* tabbed pane
		*/
		public boolean getScrollableTracksViewportWidth() {
				Component parent = getParent();
				ComponentUI ui = getUI();
				return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;
		}
		
		/**
		* Highlight <code>term</code> wherever it is found in the view. Also highlights the entire
		* line on which the term is found.
		*
		* @param term
		* @param caseSensitive
		* @param useRegularExpression
		* @return
		*/
		public List<LineResult> highlight(String term, int flags) {
				List<LineResult> lineResults = new ArrayList<LineResult>();
				// Remove all old highlights
				removeHighlights();
				// Search for pattern
				if ((term != null) && (term.length() > 0)) {
						// look for instances of the term in the text
						try {
								Document doc = getDocument();
								String text = doc.getText(0, doc.getLength());
								List<WordResult> searchResults = new SearchEngine(flags).search(term, text);
								lineResults = convertWords2Lines(searchResults);
								for (LineResult lineResult : lineResults) {
										List<WordResult> wordResults = lineResult.getWordResults();
										for (WordResult wordResult : wordResults) {
												// highlight the searched term
												int wordStart = wordResult.start;
												int wordEnd = wordResult.end;
												addHighlight(wordStart, wordEnd - wordStart);
												Thread.yield();
										}
								}
						} catch (BadLocationException e) {
								log.log(Level.SEVERE, ""BadLocationException in SearchableTextPane"", e);
								lineResults = new ArrayList<LineResult>();
						}
				}
				return lineResults;
		}
		
		/**
		* Highlight a piece of text in the document
		*
		* @param start
		* @param wordEnd
		* @param highlighter
		*/
		private void addHighlight(int start, int length) throws BadLocationException {
				getHighlighter().addHighlight(start, start + length, wordPainter);
		}
		
		/**
		* Removes highlights from text area
		*/
		public void removeHighlights() {
				getHighlighter().removeAllHighlights();
		}
		
		/**
		* Searches for a term. If the term provided matches the last searched term, the last found
		* position is used as a starting point.<br>
		* <br>
		* Developer note: this method isn't currently used.
		*
		* @param term
		*            The string for which to search.
		* @return The position where the term was found.<br>
		*         If the term is null, empty or not found, -1 is returned.
		*/
		public int search(String term) {
				if (term != null && term.length() > 0) {
						if (term.equals(lastSearchTerm)) {
								// assume to start at the beginning
								int pos = 0;
								// if there is a previous search position, start there plus the
								// length
								// of the last term so that last term again isn't found again
								if (lastSearchPos != -1) {
										pos = lastSearchPos + lastSearchTerm.length();
								}
								lastSearchPos = search(lastSearchTerm, pos);
						} else {
								lastSearchPos = search(term, 0);
						}
				}
				// remember the term if it was found
				if (lastSearchPos == -1) {
						lastSearchTerm = null;
				} else {
						lastSearchTerm = term;
				}
				return lastSearchPos;
		}
		
		/**
		* Searches for a term at the given starting position.<br>
		* <br>
		* Developer note: this method isn't currently used.
		*
		* @param term
		*            The string for which to search.
		* @param startPos
		*            Where to start.
		* @return The position where the term was found.<br>
		*         If the term is null, empty or not found, -1 is returned.
		*/
		public int search(String term, int startPos) {
				int pos = 0;
				try {
						Document doc = getDocument();
						String text = doc.getText(0, doc.getLength());
						// Search for pattern
						pos = text.indexOf(term, startPos);
				} catch (BadLocationException e) {
						// just return -1;
						log.log(Level.WARNING, ""BadLocationException in SearchableTextPane"", e);
						pos = -1;
				}
				return pos;
		}
		
		/**
		* Converts word results from search into line results
		*
		* @param words
		* @return
		*/
		private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {
				ArrayList<LineResult> lines = new ArrayList<LineResult>();
				LineResult tempLine = null;
				int lastLine = -1;
				for (WordResult word : words) {
						int line = getLineOfOffset(word.start);
						if (line != lastLine) {
								if (tempLine != null) {
										lines.add(tempLine);
								}
								Element elem = Utilities.getParagraphElement(this, word.start);
								int lineStart = elem.getStartOffset();
								int lineEnd = elem.getEndOffset();
								tempLine = new LineResult(line, lineStart, lineEnd);
						}
						updateWordResult(word, tempLine);
						lastLine = line;
						// allow other things to happen in case the search takes a while
						Thread.yield();
				}
				if (tempLine != null) {
						lines.add(tempLine);
				}
				return lines;
		}
		
		/**
		* Adds word result to line result and updates line information
		*
		* @param wordResult
		* @param lineResult
		*/
		private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {
				lineResult.addWord(wordResult);
				// increase by 1 because offset starts at 0.
				// 1 is clearer to the user since most people don't start counting
				// at 0
				int line = getLineOfOffset(wordResult.start);
				wordResult.parent.lineNumber = line + 1;
				int lineOffset = getLineStartOffset(line);
				wordResult.setLineOffset(lineOffset);
		}
		
		/**
		* Test case 1 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch1() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = 0;
				int expected = 10;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch2() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = 1;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch3() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = 10;
				int expected = 10;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch4() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = 11;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch5() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -1;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch6() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -10;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch7() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -100;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch8() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -1000;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch9() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -10000;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link SearchableTextPane#search(String, int)}
		*
		* @throws BadLocationException
		*/
		@Test
		public void testSearch10() throws BadLocationException {
				String text = ""This is a test"";
				String term = ""test"";
				int startPos = -100000;
				int expected = -1;
				int actual = search(term, startPos);
				assertEquals(expected, actual);
		}
}

// SearchableTextPane_3Test.java
package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing."
